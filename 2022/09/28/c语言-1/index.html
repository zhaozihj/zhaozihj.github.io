<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>c语言 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="变量访问： 直接访问就是直接利用变量的地址直接进行访问 按照C的方式，如果定义一个变量，系统会给这个变量分配一块内存，变量有两个属性，变量值和变量地址。变量地址指示了该变量在内存中的存储位置，变量值是这块内存中的内容。要访问这块内存空间上的内容，可以直接使用变量名。 间接访问：间接访问的含义是先从其它内存空间获得要访问的内存地址，根据得到的地址访问目的地址。****：间接访问的含义是先从其它内存空">
<meta property="og:type" content="article">
<meta property="og:title" content="c语言">
<meta property="og:url" content="http://example.com/2022/09/28/c%E8%AF%AD%E8%A8%80-1/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="变量访问： 直接访问就是直接利用变量的地址直接进行访问 按照C的方式，如果定义一个变量，系统会给这个变量分配一块内存，变量有两个属性，变量值和变量地址。变量地址指示了该变量在内存中的存储位置，变量值是这块内存中的内容。要访问这块内存空间上的内容，可以直接使用变量名。 间接访问：间接访问的含义是先从其它内存空间获得要访问的内存地址，根据得到的地址访问目的地址。****：间接访问的含义是先从其它内存空">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-09-28T05:18:34.000Z">
<meta property="article:modified_time" content="2022-09-28T05:19:24.886Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-c语言-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/09/28/c%E8%AF%AD%E8%A8%80-1/" class="article-date">
  <time class="dt-published" datetime="2022-09-28T05:18:34.000Z" itemprop="datePublished">2022-09-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      c语言
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>变量访问：</p>
<p><strong>直接访问</strong>就是直接利用变量的地址直接进行访问</p>
<p>按照C的方式，如果定义一个变量，系统会给这个变量分配一块内存，变量有两个属性，变量值和变量地址。变量地址指示了该变量在内存中的存储位置，变量值是这块内存中的内容。要访问这块内存空间上的内容，可以直接使用变量名。</p>
<p><strong>间接访问</strong>：间接访问的含义是先从其它内存空间获得要访问的内存地址，根据得到的地址访问目的地址。****：间接访问的含义是先从其它内存空间获得要访问的内存地址，根据得到的地址访问目的地址。</p>
<p><strong>函数指针</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line">   <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line">    <span class="type">int</span> (*p)(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line">   <span class="type">int</span> a,b,c;</span><br><span class="line">    p = max;</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">   c = (*p)(a,b);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d,max=%d\n&quot;</span>,a,b,c);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line"> &#123;</span><br><span class="line">   <span class="type">int</span> z;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;y) z = x;</span><br><span class="line">   <span class="keyword">else</span> z = y;</span><br><span class="line">   <span class="keyword">return</span>(z);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>int （*p）( int,int );：</p>
<p>用来定义 p 是一个指向函数的指针变量，该函数有两个整形参数，函数值为整形。注意 *p 两侧的括号不可省略，表示 p 先与 * 结合，是指针变量，然后再与后面的 ( ) 结合，表示此指针变量指向函数，这个函数值 (即函数的返回值) 是整形的。如果写成 int *p ( int,int ) ,由于( )的优先级高于 *，它就成了声明一个函数P( 这个函数的返回值是指向整形变量的指针)。</p>
<p>int(*p)[4]表示p是一个指针变量，它指向包含4个整型元素的一维数组</p>
<p>int *p[4]，由于方括号[]运算级别高，因此p先与[4]结合，此时p[4]定义成数组形式，再与前面的 * 结合，这样一来就是一个存放指针的数组了。</p>
<p>char *s&#x3D;”C Language”;可以这样表示字符串，也可以用字符数组表示字符串</p>
<p>int a[10], *p&#x3D;a;      p指针指向数组a首地址 p[5]就是a的第六个元素,**p++是数组第一个元素加一</p>
<p>数组名本来就表示一个地址所以加不加&amp;都可以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scanf(&quot;%s&quot;, pup[0].name);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scanf(&quot;%d&quot;, &amp;pup[0].age);</span><br></pre></td></tr></table></figure>



<p>int c[]&#x3D;{1, 3, 5};</p>
<p> int *k&#x3D;c+1; &#x2F;&#x2F;k指针指向数组的第二元素的地址</p>
<p>printf(“%d”, *++k);&#x2F;&#x2F;让k地址向后移一位  *++k就是当前k地址指向的内容</p>
<p>int a[] &#x3D; {0,1,2,3,4,5,6,7,8,9}, *p &#x3D; a,i;</p>
<ul>
<li>&#96;&#96;&#96;<br>a[p-a+i]<br>p-a变成一个空指针就是零，所以是可以的<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">数组与指针之间的关系介绍</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int c[]=&#123;1, 3, 5&#125;;</span><br><span class="line">int *p=c;</span><br><span class="line">printf(&quot;%d\n&quot;,*p);//1</span><br><span class="line">printf(&quot;%d&quot;,p);//地址</span><br><span class="line">printf(&quot;%d\n&quot;,p[0]);//1</span><br><span class="line">p++;</span><br><span class="line">printf(&quot;%d&quot;,*p);3</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>如果是让指针指向数组中某一个元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> c[]=&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p=&amp;c[<span class="number">1</span>];<span class="comment">//指针指向数组的第二个元素</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p[<span class="number">0</span>]);<span class="comment">//所以p[0]为3，p[1]为5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>p是一个指针的数组，每一个p中元素都是一个指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int *p[3], a[3];</span><br><span class="line"></span><br><span class="line">p[0] = &amp;a[0];</span><br><span class="line">printf(&quot;%d&quot;,*p[0]);//0</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>typedef四种用法</strong></p>
<ol>
<li>为基本数据类型定义新的类型名</li>
</ol>
<ol>
<li><strong>typedef</strong> unsigned int COUNT;</li>
</ol>
<p>2.为自定义数据类型（结构体、共用体和枚举类型）定义简洁的类型名称</p>
<ol>
<li>&#96;&#96;&#96;<br>typedef struct tagPoint<br>{<br> double x;<br>double y;<br>double z;<br> } Point;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   使用 typedef 为这个新的结构起了一个别名，叫 Point，即</span><br><span class="line"></span><br><span class="line">因此，现在你就可以像 int 和 double 那样直接使用 Point 定义变量，如下面的代码所示</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">Point oPoint1=&#123;100，100，0&#125;;</span><br><span class="line"></span><br><span class="line">Point oPoint2;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>用 typedef 给一个还未完全声明的类型 tagNode 起了一个新别名。</p>
<p>struct tagNode</p>
<p>{   char *pItem;</p>
<p>  struct tagNode *pNext;};</p>
<p>typedef struct tagNode *pNode;&#x2F;&#x2F;给tagNode起了一个别名</p>
<p>3.为数组定义简洁的类型名称</p>
<p>typedef int INT_ARRAY_100[100];</p>
<p>INT_ARRAY_100 arr;</p>
<p>4.为指针定义简洁的名称</p>
<ol>
<li><strong>typedef</strong> char* PCHAR;</li>
<li>PCHAR pa;</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef int ElementType;//将int重命名为ElementType</span><br><span class="line">typedef struct LNode *PtrToLNode;</span><br><span class="line">//这个地方是typedef这个方式 来重命名 struct Node* 这个结构体类型，所以 ptrToNode 这个变量名就可以直接使用来代表 struct Node* 这个结构体类型</span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToLNode Next;</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToLNode List;</span><br><span class="line"></span><br><span class="line">List Read(); /* 细节在此不表 */</span><br><span class="line"></span><br><span class="line">int Length( List L );</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    List L = Read();</span><br><span class="line">    printf(&quot;%d\n&quot;, Length(L));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 你的代码将被嵌在这里 */</span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2）通过结构指针间接访问成员值</span><br><span class="line"></span><br><span class="line">访问的一般形式：</span><br><span class="line">（*结构指针变量）. 成员名 或 结构指针变量 -&gt; 成员名</span><br><span class="line">如：</span><br><span class="line"></span><br><span class="line">(*pstu).name  </span><br><span class="line">pstu-&gt;name</span><br><span class="line">注意(pstu)的小括号不能省略，因为成员符“.”优先级为1，取地址符“”优先级为2，去掉括号就相当于*(pstu.name)了。</span><br></pre></td></tr></table></figure>



<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">//库函数头文件包含</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;malloc.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//函数状态码定义</span><br><span class="line">#define TRUE        1</span><br><span class="line">#define FALSE       0</span><br><span class="line">#define OK          1</span><br><span class="line">#define ERROR       0</span><br><span class="line">#define INFEASIBLE -1</span><br><span class="line">#define OVERFLOW   -2</span><br><span class="line"></span><br><span class="line">typedef int  Status;</span><br><span class="line"></span><br><span class="line">//顺序表的存储结构定义</span><br><span class="line">#define LIST_INIT_SIZE  100</span><br><span class="line">#define LISTINCREMENT   10</span><br><span class="line">typedef int ElemType;  //假设线性表中的元素均为整型</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    ElemType* elem;   //存储空间基地址</span><br><span class="line">    int length;       //表中元素的个数</span><br><span class="line">    int listsize;     //表容量大小</span><br><span class="line">&#125;SqList;    //顺序表类型定义</span><br><span class="line">//初始化</span><br><span class="line">Status ListInsert_Sq(SqList &amp;L, int pos, ElemType e)&#123;</span><br><span class="line">    if(pos&gt;L.listsize)&#123;</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=L.length;i&gt;=pos;i--)&#123;</span><br><span class="line">        L.elem[i]=L.elem[i-1];</span><br><span class="line">    &#125;</span><br><span class="line">    L.elem[pos-1]=e;</span><br><span class="line">    L.length++;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status ListDelete_Sq(SqList &amp;L, int pos, ElemType &amp;e)&#123;</span><br><span class="line">    if(pos&gt;L.length)&#123;</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    e=L.elem[pos-1];</span><br><span class="line">    for(int i=pos;i&lt;L.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L.elem[i-1]=L.elem[i];</span><br><span class="line">    &#125;  </span><br><span class="line">    L.length--;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int ListLocate_Sq(SqList L, ElemType e)&#123;</span><br><span class="line">    for(int i=0;i&lt;L.length;i++)&#123;</span><br><span class="line">        if(L.elem[i]==e)&#123;</span><br><span class="line">            return i+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ERROR;</span><br><span class="line">&#125;</span><br><span class="line">void ListPrint_Sq(SqList L)&#123;</span><br><span class="line">    int flag=1;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;L.length;i++)&#123;</span><br><span class="line">            if(flag)&#123;</span><br><span class="line">        printf(&quot;%d&quot;,L.elem[i]);</span><br><span class="line">                flag=0;</span><br><span class="line">    &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">        printf(&quot; %d&quot;,L.elem[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//结构初始化与销毁操作</span><br><span class="line">Status InitList_Sq(SqList &amp;L)&#123;</span><br><span class="line">  //初始化L为一个空的有序顺序表</span><br><span class="line">    L.elem=(ElemType *)malloc(LIST_INIT_SIZE*sizeof(ElemType));</span><br><span class="line">    if(!L.elem)exit(OVERFLOW);</span><br><span class="line">    L.listsize=LIST_INIT_SIZE;</span><br><span class="line">    L.length=0;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    SqList L;</span><br><span class="line"></span><br><span class="line">    if(InitList_Sq(L)!= OK) &#123;</span><br><span class="line">        printf(&quot;InitList_Sq: 初始化失败！！！\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int i = 1; i &lt;= 10; ++ i)</span><br><span class="line">        ListInsert_Sq(L, i, i);</span><br><span class="line">    </span><br><span class="line">    int operationNumber;  //操作次数</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;operationNumber);</span><br><span class="line">    </span><br><span class="line">    while(operationNumber != 0) &#123;</span><br><span class="line">        int operationType;  //操作种类</span><br><span class="line">        scanf(&quot;%d&quot;, &amp; operationType);</span><br><span class="line">    </span><br><span class="line">        if(operationType == 1) &#123;  //增加操作</span><br><span class="line">            int pos, elem;</span><br><span class="line">            scanf(&quot;%d%d&quot;, &amp;pos, &amp;elem);</span><br><span class="line">            ListInsert_Sq(L, pos, elem);</span><br><span class="line">        &#125; else if(operationType == 2) &#123;  //删除操作</span><br><span class="line">             int pos; ElemType elem;</span><br><span class="line">             scanf(&quot;%d&quot;, &amp;pos);</span><br><span class="line">             ListDelete_Sq(L, pos, elem);</span><br><span class="line">             printf(&quot;%d\n&quot;, elem);</span><br><span class="line">        &#125; else if(operationType == 3) &#123;  //查找定位操作</span><br><span class="line">            ElemType elem;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;elem);</span><br><span class="line">            int pos = ListLocate_Sq(L, elem);</span><br><span class="line">            if(pos &gt;= 1 &amp;&amp; pos &lt;= L.length)</span><br><span class="line">                printf(&quot;%d\n&quot;, pos);</span><br><span class="line">            else</span><br><span class="line">                printf(&quot;NOT FIND!\n&quot;);</span><br><span class="line">        &#125; else if(operationType == 4) &#123;  //输出操作</span><br><span class="line">            ListPrint_Sq(L);</span><br><span class="line">        &#125;</span><br><span class="line">       operationNumber--;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>顺序表的创建和逆序</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">ListCreate_Sq</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count ;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;count);</span><br><span class="line">        L.elem=(ElemType *)<span class="built_in">malloc</span>(count*<span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">    L.listsize=count;</span><br><span class="line">    <span class="keyword">if</span>(!L.elem) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">        L.elem[i]=num;</span><br><span class="line">        L.length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ListReverse_Sq</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">        t=L.elem[i];</span><br><span class="line">        L.elem[i]=L.elem[L.length<span class="number">-1</span>-i];</span><br><span class="line">        L.elem[L.length<span class="number">-1</span>-i]=t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>无论是初始化还是怎么处理链表时，不要直接用那个参数链表，而是定义一个指针来操作</p>
<p>要删除最后一个元素，必须要找到最后一个元素的前一个元素，然后再用这个元素的下一个释放最后一个元素</p>
<p>尾节点是指向最后一个元素的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">链表</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define Ok 1;</span><br><span class="line">#define ERROR 0;</span><br><span class="line">typedef int ElemType;</span><br><span class="line">typedef int Status;</span><br><span class="line">typedef struct LNode&#123;</span><br><span class="line">ElemType data;</span><br><span class="line">struct LNode *next;</span><br><span class="line">&#125;LNode,*LinkList//这个意思是LinkList是结构体指针类型的关键字，LNode是结构体变量关键字</span><br><span class="line"></span><br><span class="line">//初始化</span><br><span class="line">Status InitList_L(LinkList &amp;L)&#123;</span><br><span class="line">L=(LinkList)malloc(sizeof(LNode));</span><br><span class="line">L-&gt;next=null;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//清空算法</span><br><span class="line">Status ClearList_L(LinkList &amp;L)&#123;</span><br><span class="line">LinkList p,q;</span><br><span class="line">p=L-&gt;next;</span><br><span class="line">while(p)&#123;</span><br><span class="line">q=p-&gt;next;</span><br><span class="line">delete p;</span><br><span class="line">p=q;</span><br><span class="line">&#125;</span><br><span class="line">L-&gt;next=null;//头结点的指针域为空</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//求表长</span><br><span class="line">Status ListLength_L(LinkList L)&#123;</span><br><span class="line">LinkList p;</span><br><span class="line">p=L-&gt;next;</span><br><span class="line">i=0;</span><br><span class="line">while(p)&#123;</span><br><span class="line">    i++;</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//判断表是否为空</span><br><span class="line">int ListEmpty(LinkList L)&#123;</span><br><span class="line">if(L-&gt;next)&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取线性表L中的某个数据元素的全部内容</span><br><span class="line">Status GetElem_L(LinkList L,int i,ElemType &amp;e)&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">p=L-&gt;next;j=1;//初始化</span><br><span class="line">while(p&amp;&amp;j&lt;i)&#123;</span><br><span class="line">    p=p-&gt;next;++j;</span><br><span class="line">&#125;</span><br><span class="line">if(!p||j&gt;i)return ERROR;</span><br><span class="line">e=p-&gt;data;</span><br><span class="line">return OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//在线性表中查找值为e的数据元素</span><br><span class="line">LNode *LocateELem_L(LinkList L,ElemType e)&#123;</span><br><span class="line">    //返回L中值为e的数据元素</span><br><span class="line">p=L-&gt;next;</span><br><span class="line">while(p&amp;&amp;p-&gt;data!=e)&#123;</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在线性表L中查找值为e的元素</span><br><span class="line">int LocateElem_L(LinkList L,ElemType e)&#123;</span><br><span class="line">p=L-&gt;next;j=1;</span><br><span class="line">while(p&amp;&amp;p-&gt;data!=e)&#123;</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">    j++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">if(p) return j;</span><br><span class="line">else return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在L第i个元素之前插入元素e</span><br><span class="line">Status ListInsert_L(LinkList &amp;L,int i,ElemType e)&#123;</span><br><span class="line">LinkList p;</span><br><span class="line">p=L;j=0;</span><br><span class="line">while(p&amp;&amp;j&lt;i-1)&#123;</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">    ++j;</span><br><span class="line">&#125;</span><br><span class="line">if(!p) return ERROR;</span><br><span class="line">s=(LinkList)malloc(sizeof(LNode));</span><br><span class="line">s-&gt;data=e;</span><br><span class="line">s-&gt;next=p-&gt;next;</span><br><span class="line">p-&gt;next=s;</span><br><span class="line">return OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将线性表L中第i个数据元素删除</span><br><span class="line">Status ListDelete_L(LinkList &amp;L,int i,ElemType &amp;e)&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    LinkList q;</span><br><span class="line">p=L-&gt;next;j=1;</span><br><span class="line">while(p&amp;&amp;j&lt;i-1)&#123;</span><br><span class="line">    p=p-&gt;next;++j;</span><br><span class="line">&#125;</span><br><span class="line">if(!p)return ERROR;</span><br><span class="line">q=p-&gt;next;//临时保存删除结点的地址，准备释放</span><br><span class="line">p-&gt;next=q-&gt;next;//改变删除结点前驱结点的指针</span><br><span class="line">e=q-&gt;data;//保存删除结点的数据域</span><br><span class="line">delete q;//释放删除节点的空间</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> LinkList c;</span><br><span class="line"> LinkList a;</span><br><span class="line"> LinkList b;</span><br><span class="line">  InitList_L(c);</span><br><span class="line"> InitList_L(a);</span><br><span class="line">  InitList_L(b);</span><br><span class="line">  c-&gt;next=a;</span><br><span class="line"> a-&gt;data=1;</span><br><span class="line"> a-&gt;next=b;</span><br><span class="line"> b-&gt;data =2;</span><br><span class="line"> ListInsert_L(c,1,6);</span><br><span class="line"> int m=LocateElem_L(c,6);</span><br><span class="line"> printf(&quot;%d&quot;,&amp;m);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>链表</p>
<p><strong>循环单链表</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">//库函数头文件包含</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;malloc.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">//函数状态码定义</span><br><span class="line">#define TRUE        1</span><br><span class="line">#define FALSE       0</span><br><span class="line">#define OK          1</span><br><span class="line">#define ERROR       0</span><br><span class="line">#define INFEASIBLE -1</span><br><span class="line">#define OVERFLOW   -2</span><br><span class="line"></span><br><span class="line">typedef int  Status;</span><br><span class="line">typedef int  ElemType; //假设线性表中的元素均为整型  </span><br><span class="line"></span><br><span class="line">typedef struct LNode</span><br><span class="line">&#123;  </span><br><span class="line">    ElemType data;  </span><br><span class="line">    struct LNode *next; </span><br><span class="line">&#125;LNode,*LinkList; //循环单链表类型定义与单链表定义相同，区别在尾节点next取值</span><br><span class="line"></span><br><span class="line">//创建一个单循环链表</span><br><span class="line">Status ListCreate_CL(LinkList &amp;CL)&#123;</span><br><span class="line">    LinkList q;</span><br><span class="line">    CL=(LinkList)malloc(sizeof(LNode));</span><br><span class="line">    CL-&gt;next=NULL;</span><br><span class="line">    q=CL;</span><br><span class="line">    int count;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;count);</span><br><span class="line">    for(int i=0;i&lt;count;i++)&#123;</span><br><span class="line">        int sum;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;sum);</span><br><span class="line">        LinkList p=(LinkList)malloc(sizeof(LNode));</span><br><span class="line">        p-&gt;data=sum;</span><br><span class="line">        q-&gt;next=p;</span><br><span class="line">        q=p;</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;next=CL;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//删除单循环链表中在min和max之间的元素</span><br><span class="line">void ListDelete_CL(LinkList &amp;CL,ElemType min,ElemType max)&#123;</span><br><span class="line">    LNode *p=CL;</span><br><span class="line">    LinkList q;</span><br><span class="line">    while(p-&gt;next!=CL)&#123;</span><br><span class="line">                    q=p-&gt;next;</span><br><span class="line">        if(q-&gt;data&gt;min&amp;&amp;q-&gt;data&lt;max)&#123;</span><br><span class="line">            p-&gt;next=q-&gt;next;</span><br><span class="line">            free(q);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void ListPrint_CL(LinkList &amp;CL) </span><br><span class="line">&#123;   //输出单链表,空表时输出Empty List。 </span><br><span class="line">    LNode *p=CL-&gt;next;  //p指向第一个元素结点</span><br><span class="line">    if(p==CL)&#123;</span><br><span class="line">      printf(&quot;Empty List&quot;);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    while(p!=CL)  </span><br><span class="line">    &#123;   </span><br><span class="line">        if(p-&gt;next!=CL)</span><br><span class="line">            printf(&quot;%d &quot;,p-&gt;data);   </span><br><span class="line">        else</span><br><span class="line">            printf(&quot;%d&quot;,p-&gt;data);      </span><br><span class="line">        p=p-&gt;next; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;    </span><br><span class="line">int main() </span><br><span class="line">&#123;  </span><br><span class="line">    LinkList CL;</span><br><span class="line">    ElemType min,max;</span><br><span class="line">    if(ListCreate_CL(CL)!= OK) </span><br><span class="line">    &#123;</span><br><span class="line">       printf(&quot;循环链表创建失败！！！\n&quot;);</span><br><span class="line">       return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;min,&amp;max);    </span><br><span class="line">    ListDelete_CL(CL,min,max);   </span><br><span class="line">    ListPrint_CL(CL);      </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 请在这里填写答案 */</span><br></pre></td></tr></table></figure>



<p>链表</p>
<p><strong>最正规的链表的创建</strong></p>
<p>c++;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">//库函数头文件包含</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;malloc.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">//函数状态码定义</span><br><span class="line">#define TRUE        1</span><br><span class="line">#define FALSE       0</span><br><span class="line">#define OK          1</span><br><span class="line">#define ERROR       0</span><br><span class="line">#define INFEASIBLE -1</span><br><span class="line">#define OVERFLOW   -2</span><br><span class="line"></span><br><span class="line">typedef int  Status;</span><br><span class="line">typedef int  ElemType; //假设线性表中的元素均为整型</span><br><span class="line"></span><br><span class="line">typedef struct LNode</span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct LNode *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line">//单链表的创建</span><br><span class="line">Status ListCreate_L(LinkList &amp;L,int n)</span><br><span class="line">&#123;</span><br><span class="line">    LNode *rearPtr,*curPtr;   //一个尾指针，一个指向新节点的指针</span><br><span class="line">    L=(LNode*)malloc(sizeof (LNode));</span><br><span class="line">    if(!L)exit(OVERFLOW);</span><br><span class="line">    L-&gt;next=NULL;               //先建立一个带头结点的单链表</span><br><span class="line">    rearPtr=L;  //初始时头结点为尾节点,rearPtr指向尾巴节点</span><br><span class="line">    for (int i=1;i&lt;=n;i++)&#123;  //每次循环都开辟一个新节点，并把新节点拼到尾节点后</span><br><span class="line">        curPtr=(LNode*)malloc(sizeof(LNode));//生成新结点</span><br><span class="line">        if(!curPtr)exit(OVERFLOW);</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;curPtr-&gt;data);//输入元素值</span><br><span class="line">        curPtr-&gt;next=NULL;  //最后一个节点的next赋空</span><br><span class="line">        rearPtr-&gt;next=curPtr;</span><br><span class="line">        rearPtr=curPtr;</span><br><span class="line">    &#125;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//下面是需要实现的函数的声明</span><br><span class="line">int ListLocate_L(LinkList L, ElemType x)&#123;</span><br><span class="line">LinkList p=L;</span><br><span class="line">    int m=0;</span><br><span class="line">    while(p-&gt;next)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        m++;</span><br><span class="line">        if(p-&gt;data==x)&#123;</span><br><span class="line">            return m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    int n;</span><br><span class="line">    int x,k;   </span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);  //输入链表中元素个数</span><br><span class="line">    if(ListCreate_L(L,n)!= OK) &#123;</span><br><span class="line">          printf(&quot;表创建失败！！！\n&quot;);</span><br><span class="line">          return -1;</span><br><span class="line">    &#125;</span><br><span class="line">   scanf(&quot;%d&quot;,&amp;x); //输入待查找元素</span><br><span class="line">   k=ListLocate_L(L,x);</span><br><span class="line">   printf(&quot;%d\n&quot;,k);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 请在这里填写答案 */</span><br></pre></td></tr></table></figure>



<p><strong>单链表的头插法和尾插法</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateList_L</span><span class="params">(LinkList&amp;L,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//先创建一个带头结点的单链表</span></span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="comment">//前插法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line"></span><br><span class="line">    p=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;count);</span><br><span class="line">    p-&gt;data=count;</span><br><span class="line">    p-&gt;next=L-&gt;next;</span><br><span class="line">    L-&gt;next=p;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line">    <span class="comment">//一开始就设定两个指针r和L都指向同一个，但用r来操作,这样L始终在第一个</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateList_L</span><span class="params">(LinkList &amp;L,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>;<span class="comment">//创建带头节点单链表L</span></span><br><span class="line">r=L;  <span class="comment">//尾指针指向头节点</span></span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    p=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;count);</span><br><span class="line">    p-&gt;data=count;</span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    r-&gt;next=p;</span><br><span class="line">    r=p;<span class="comment">//r指向新的尾节点</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>单链表的逆序</strong></p>
<p>p&#x3D;q就相当于两个指针指向同一个地址，后面对一个的操作其实就是对他俩都做了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">//库函数头文件包含</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;malloc.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">//函数状态码定义</span><br><span class="line">#define TRUE        1</span><br><span class="line">#define FALSE       0</span><br><span class="line">#define OK          1</span><br><span class="line">#define ERROR       0</span><br><span class="line">#define INFEASIBLE -1</span><br><span class="line">#define OVERFLOW   -2</span><br><span class="line"></span><br><span class="line">typedef int  Status;</span><br><span class="line">typedef int  ElemType; //假设线性表中的元素均为整型</span><br><span class="line"></span><br><span class="line">typedef struct LNode</span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct LNode *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line">Status ListCreate_L(LinkList &amp;L,int n)</span><br><span class="line">&#123;</span><br><span class="line">    LNode *rearPtr,*curPtr;   //一个尾指针，一个指向新节点的指针</span><br><span class="line">    L=(LNode*)malloc(sizeof (LNode));</span><br><span class="line">    if(!L)exit(OVERFLOW);</span><br><span class="line">    L-&gt;next=NULL;               //先建立一个带头结点的单链表</span><br><span class="line">    rearPtr=L;  //初始时头结点为尾节点,rearPtr指向尾巴节点</span><br><span class="line">    for (int i=1;i&lt;=n;i++)&#123;  //每次循环都开辟一个新节点，并把新节点拼到尾节点后</span><br><span class="line">        curPtr=(LNode*)malloc(sizeof(LNode));//生成新结点</span><br><span class="line">        if(!curPtr)exit(OVERFLOW);</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;curPtr-&gt;data);//输入元素值</span><br><span class="line">        curPtr-&gt;next=NULL;  //最后一个节点的next赋空</span><br><span class="line">        rearPtr-&gt;next=curPtr;</span><br><span class="line">        rearPtr=curPtr;</span><br><span class="line">    &#125;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line">void ListReverse_L(LinkList &amp;L)&#123;</span><br><span class="line"> LinkList p=L-&gt;next;//让p成为L这个链表</span><br><span class="line">    L-&gt;next=NULL;//将L变为一个空链表</span><br><span class="line">    while(p)&#123;</span><br><span class="line">        LinkList q=p;</span><br><span class="line">        p=p-&gt;next;//必须在这个地方p=p-&gt;next，因为现在p，q指向同一个结点，后面q让下一个结点为null变成空链表，所以p也会变成空链表，所以p必须在这之前指向下一个，所以当两个指针指向一个的时候，后面一个指针改变链表结构，另一个指针也会变化</span><br><span class="line">        q-&gt;next=L-&gt;next;</span><br><span class="line">        L-&gt;next=q;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ListPrint_L(LinkList &amp;L)&#123;</span><br><span class="line">//输出单链表</span><br><span class="line">    LNode *p=L-&gt;next;  //p指向第一个元素结点</span><br><span class="line">    while(p!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">          if(p-&gt;next!=NULL)</span><br><span class="line">               printf(&quot;%d &quot;,p-&gt;data);</span><br><span class="line">          else</span><br><span class="line">               printf(&quot;%d&quot;,p-&gt;data);</span><br><span class="line">          p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    if(ListCreate_L(L,n)!= OK) &#123;</span><br><span class="line">          printf(&quot;表创建失败！！！\n&quot;);</span><br><span class="line">          return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    ListReverse_L(L);</span><br><span class="line">    ListPrint_L(L);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/* 请在这里填写答案 */</span><br></pre></td></tr></table></figure>



<p><strong>合并两个有序链表的具体操作</strong></p>
<p>这个地方的初始化，输入的时候是到-1停止</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;malloc.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define TRUE        1</span><br><span class="line">#define FALSE       0</span><br><span class="line">#define OK          1</span><br><span class="line">#define ERROR       0</span><br><span class="line">#define INFEASIBLE -1</span><br><span class="line">#define OVERFLOW   -2</span><br><span class="line"></span><br><span class="line">typedef int  Status;</span><br><span class="line">typedef int  ElemType;</span><br><span class="line"></span><br><span class="line">typedef struct LNode</span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct LNode *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line">Status ListCreate_CL(LinkList &amp;CL)&#123;</span><br><span class="line">    LinkList q;</span><br><span class="line">    CL=(LinkList)malloc(sizeof(LNode));</span><br><span class="line">    CL-&gt;next=NULL;//这个一定要有</span><br><span class="line">    q=CL;</span><br><span class="line">    while(1)&#123;//用1不用true</span><br><span class="line">        int sum;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;sum);</span><br><span class="line">               if(sum==-1)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkList p=(LinkList)malloc(sizeof(LNode));</span><br><span class="line">        p-&gt;next=NULL;//这个一定要有</span><br><span class="line">        p-&gt;data=sum;</span><br><span class="line">        q-&gt;next=p;</span><br><span class="line">        q=p;</span><br><span class="line">    &#125;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void uon(LinkList &amp;a,LinkList &amp;b,LinkList &amp;c)&#123;</span><br><span class="line">     LinkList pa=a-&gt;next;</span><br><span class="line">     LinkList pb=b-&gt;next;</span><br><span class="line">     LinkList pc=c=a;</span><br><span class="line">while(pa&amp;&amp;pb)&#123;</span><br><span class="line">    if(pa-&gt;data&gt;=pb-&gt;data)&#123;</span><br><span class="line">        pc-&gt;next=pb;pc=pb;pb=pb-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        pc-&gt;next=pa;pc=pa;pa=pa-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        pc-&gt;next=pa?pa:pb;</span><br><span class="line">        delete b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">LinkList a;</span><br><span class="line">ListCreate_CL(a);</span><br><span class="line">LinkList b;</span><br><span class="line">ListCreate_CL(b);</span><br><span class="line">LinkList c;</span><br><span class="line">    uon(a,b,c);</span><br><span class="line">    c=c-&gt;next;//遍历元素的时候一定要从首元结点开始而不是从头节点</span><br><span class="line">    int flag=1;</span><br><span class="line">    if(c==NULL)&#123;</span><br><span class="line">        printf(&quot;NULL&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">while(c)&#123;</span><br><span class="line">    if(flag)&#123;</span><br><span class="line">    printf(&quot;%d&quot;,c-&gt;data);</span><br><span class="line">    flag=0;</span><br><span class="line">        c=c-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        printf(&quot; %d&quot;,c-&gt;data);</span><br><span class="line">    c=c-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>求两个链表交集的具体操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;malloc.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"># define OK 1;</span><br><span class="line"></span><br><span class="line"># define ERROR 0;</span><br><span class="line"></span><br><span class="line">typedef int Status;</span><br><span class="line">typedef int Elementype;</span><br><span class="line">typedef struct LNode&#123;</span><br><span class="line"> Elementype data;</span><br><span class="line">struct LNode* next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line">Status ListCreate_CL(LinkList &amp;CL)&#123;</span><br><span class="line">    LinkList q;</span><br><span class="line">    CL=(LinkList)malloc(sizeof(LNode));</span><br><span class="line">    CL-&gt;next=NULL;</span><br><span class="line">    q=CL;</span><br><span class="line">    while(1)&#123;//用1不用true</span><br><span class="line">        int sum;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;sum);</span><br><span class="line">               if(sum==-1)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkList p=(LinkList)malloc(sizeof(LNode));</span><br><span class="line">        p-&gt;next=NULL;</span><br><span class="line">        p-&gt;data=sum;</span><br><span class="line">        q-&gt;next=p;</span><br><span class="line">        q=p;</span><br><span class="line">    &#125;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line">void uni(LinkList &amp;a,LinkList &amp;b,LinkList &amp;c)&#123;</span><br><span class="line">    int count=0;</span><br><span class="line">LinkList pa=a-&gt;next;</span><br><span class="line">LinkList pb=b-&gt;next;</span><br><span class="line">LinkList pc=c=a;</span><br><span class="line">while(pa&amp;&amp;pb)&#123;</span><br><span class="line">    if(pa-&gt;data==pb-&gt;data)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        pc-&gt;next=pa;</span><br><span class="line">        pc=pa;</span><br><span class="line">         pa=pa-&gt;next;</span><br><span class="line">        pb=pb-&gt;next;</span><br><span class="line">        pc-&gt;next=NULL;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if(pb-&gt;data&lt;pa-&gt;data)</span><br><span class="line">        pb=pb-&gt;next;</span><br><span class="line">        else</span><br><span class="line">            pa=pa-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(count==0)&#123;</span><br><span class="line">        pc-&gt;next=NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    delete b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">LinkList b;</span><br><span class="line">LinkList a;</span><br><span class="line">LinkList c;</span><br><span class="line"> ListCreate_CL(a);</span><br><span class="line"> ListCreate_CL(b);</span><br><span class="line"> uni(a,b,c);</span><br><span class="line"> c=c-&gt;next;</span><br><span class="line"> if(!c)&#123;</span><br><span class="line">    printf(&quot;NULL&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"> int flag=1;</span><br><span class="line"> while(c)&#123;</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">    printf(&quot;%d&quot;,c-&gt;data);</span><br><span class="line">    c=c-&gt;next;</span><br><span class="line">    flag=0;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">    printf(&quot; %d&quot;,c-&gt;data);</span><br><span class="line">    c=c-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><strong>双向链表</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双向链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">prior</span>;</span><span class="comment">//指向前驱的指针域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">next</span>;</span><span class="comment">//指向后继的指针域</span></span><br><span class="line"></span><br><span class="line">&#125;DuLNode,*DuLinkList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双向链表的删除</span></span><br><span class="line">Status <span class="title function_">ListDelete_DuL</span><span class="params">(DuLinkList &amp;L,<span class="type">int</span> i,ElemType &amp;e)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!(p=GetElemP_DuL(L,i))) <span class="keyword">return</span> ERROR;</span><br><span class="line">e=p-&gt;data;</span><br><span class="line">p-&gt;prior-&gt;next=p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior=p-&gt;prior;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双向链表的插入</span></span><br><span class="line">Status <span class="title function_">ListInsert_DuL</span><span class="params">(DuLinkList&amp;L,<span class="type">int</span> i,ElemType e)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!(p=DetElemP_DuL(L,i)))</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">if</span>(!(s=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DuLNode))))<span class="keyword">return</span> ERROR;</span><br><span class="line">s-&gt;data=e;</span><br><span class="line">s-&gt;prior=p-&gt;prior;</span><br><span class="line">p-&gt;prior-&gt;next=s;</span><br><span class="line">s-&gt;next=p;</span><br><span class="line">p-&gt;prior=s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="线性表应用："><a href="#线性表应用：" class="headerlink" title="线性表应用："></a>线性表应用：</h2><p>1将AB两个集合取并集得到新集合</p>
<p>依次取出b中每个元素，在a中查找，如果找不到就插入到a最后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void union (List &amp;La,List Lb)&#123;</span><br><span class="line">La_len=ListLength(La);</span><br><span class="line">Lb_len=ListLength(Lb);</span><br><span class="line">for(int i=1;i&lt;=Lb_len;i++)&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    GetElem(Lb,i,e);</span><br><span class="line">    if(!LocateElem(La,e))&#123;</span><br><span class="line">        ListInsert(&amp;La,++La_len,e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>有序顺序表合并</p>
<p>两个按大小排列的顺序表，组合成一个按大小排列的顺序表</p>
<p>创建一个空表，依次从两个表中摘取元素值小的结点插入到Lc表的最后，直至其中一个表变空为止，再将剩下的插入最后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//库函数头文件包含</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;malloc.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void MergeList_Sq(SqList LA,SqList LB,SqList &amp;LC)&#123;</span><br><span class="line">pa=LA.elem;</span><br><span class="line">pb=LB.elem;//指针pa和pb分别指向两个表的第一个元素</span><br><span class="line">LC.length=LB.length+LA.length;</span><br><span class="line">LC.elem=new Elementype[LC.length];</span><br><span class="line">pc=LC.elem;</span><br><span class="line">pa_last=pa+LA.length-1;//pa_last指向LA表中最后一个元素</span><br><span class="line">pb_last=pb+LB.length-1;</span><br><span class="line">while(pa&lt;=pa_last&amp;&amp;pb&lt;=pb_last)&#123;</span><br><span class="line">    if(*pa&gt;*pb)&#123;</span><br><span class="line">        *pc++=*pb++;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        *pc++=*pa++//先赋值然后再把pa++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">    while(pb&lt;=pb_last)&#123;</span><br><span class="line">    *pc++=*pb++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(pa&lt;=pa_last)&#123;</span><br><span class="line">    *pc++=*pa++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>有序链表合并，就是两个从小到大的链表合并</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//库函数头文件包含</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;malloc.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void MergeList_L(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc)&#123;</span><br><span class="line"></span><br><span class="line">pa=La-&gt;next;</span><br><span class="line">pb=Lb-&gt;next;</span><br><span class="line">pc=Lc=La;</span><br><span class="line">while(pa&amp;&amp;pb)&#123;</span><br><span class="line">    if(pa-&gt;data&gt;=pb-&gt;data)&#123;</span><br><span class="line">        pc-&gt;next=pa;pc=pa;pa=pa-&gt;next;//这里要让pc和pa指向同一个是因为要让pc指向新链表的最后一个</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        pc-&gt;next=pb;pc=pb;pb=pb-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pc-&gt;next=pa?pa:pb;</span><br><span class="line">    delete Lb;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多项式相加</p>
<p>两个属性一个存参数一个存指数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">void merge(LinkList &amp;a,LinkList &amp;b,LinkList &amp;c)&#123;</span><br><span class="line">LinkList pa=a-&gt;next;</span><br><span class="line">LinkList pb=b-&gt;next;</span><br><span class="line">LinkList pc=c=a;</span><br><span class="line">while(pa&amp;&amp;pb)&#123;</span><br><span class="line">    if(pa-&gt;index==pb-&gt;index)&#123;</span><br><span class="line">        pa-&gt;data=pa-&gt;data+pb-&gt;data;</span><br><span class="line">        pc-&gt;next=pa;</span><br><span class="line">        pc=pa;</span><br><span class="line">        pa=pa-&gt;next;</span><br><span class="line">        pb=pb-&gt;next;;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if(pa-&gt;index&gt;pb-&gt;index)&#123;</span><br><span class="line">            pc-&gt;next=pa;</span><br><span class="line">            pc=pa;</span><br><span class="line">            pa=pa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">           pc-&gt;next=pb;</span><br><span class="line">           pc=pb;</span><br><span class="line">           pb=pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    if(pa==NULL)&#123;</span><br><span class="line">        pc-&gt;next=pb;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(pb==NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        pc-&gt;next=pa;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define OK 1</span><br><span class="line">typedef int Status;</span><br><span class="line">typedef struct LNode</span><br><span class="line">&#123;</span><br><span class="line"> 	int data;</span><br><span class="line"> 	int index;</span><br><span class="line"> 	struct LNode *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line">Status ListCreate_CL(LinkList &amp;CL)&#123;</span><br><span class="line">    LinkList q;</span><br><span class="line">    CL=(LinkList)malloc(sizeof(LNode));</span><br><span class="line">    CL-&gt;next=NULL;</span><br><span class="line">    q=CL;</span><br><span class="line">    int count;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;count);</span><br><span class="line">    for(int i=0;i&lt;count;i++)&#123;</span><br><span class="line">        int data1;</span><br><span class="line">        int index1;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;data1);</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;index1);</span><br><span class="line">        LinkList p=(LinkList)malloc(sizeof(LNode));</span><br><span class="line">        p-&gt;next=NULL;</span><br><span class="line">        p-&gt;data=data1;</span><br><span class="line">        p-&gt;index=index1;</span><br><span class="line">        q-&gt;next=p;</span><br><span class="line">        q=p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void merge(LinkList &amp;a,LinkList &amp;b,LinkList &amp;c)&#123;</span><br><span class="line">LinkList pa=a-&gt;next;</span><br><span class="line">LinkList pb=b-&gt;next;</span><br><span class="line">LinkList pc=c=a;</span><br><span class="line">while(pa&amp;&amp;pb)&#123;</span><br><span class="line">    if(pa-&gt;index==pb-&gt;index)&#123;</span><br><span class="line">        pa-&gt;data=pa-&gt;data+pb-&gt;data;</span><br><span class="line">        pc-&gt;next=pa;</span><br><span class="line">        pc=pa;</span><br><span class="line">        pa=pa-&gt;next;</span><br><span class="line">        pb=pb-&gt;next;;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if(pa-&gt;index&gt;pb-&gt;index)&#123;</span><br><span class="line">            pc-&gt;next=pa;</span><br><span class="line">            pc=pa;</span><br><span class="line">            pa=pa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">           pc-&gt;next=pb;</span><br><span class="line">           pc=pb;</span><br><span class="line">           pb=pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    if(pa==NULL)&#123;</span><br><span class="line">        pc-&gt;next=pb;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(pb==NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        pc-&gt;next=pa;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">void multy(LinkList &amp;a,LinkList &amp;b,LinkList &amp;c)&#123;</span><br><span class="line">    LinkList pa=a-&gt;next;</span><br><span class="line">    LinkList pb=b-&gt;next;</span><br><span class="line">    c=(LinkList)malloc(sizeof(LNode));</span><br><span class="line">    c-&gt;next=NULL;</span><br><span class="line">    LinkList pc=c;</span><br><span class="line">    while(pb)&#123;</span><br><span class="line">    while(pa)&#123;</span><br><span class="line">            if(pa-&gt;index+pb-&gt;index==pc-&gt;index)&#123;</span><br><span class="line">        LinkList p=(LinkList)malloc(sizeof(LNode));</span><br><span class="line">        p-&gt;data=pa-&gt;data*pb-&gt;data;</span><br><span class="line">        p-&gt;index=pa-&gt;index+pb-&gt;index;</span><br><span class="line">        p-&gt;next=NULL;</span><br><span class="line">        pa=pa-&gt;next;</span><br><span class="line">        pc-&gt;next=p;</span><br><span class="line">        pc=p;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        pa=a;</span><br><span class="line">        pb=pb-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void print(LinkList c)&#123;</span><br><span class="line">    int flag=1;</span><br><span class="line">    c=c-&gt;next;</span><br><span class="line">    while(c)</span><br><span class="line">    &#123;</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            if(c-&gt;data!=0)&#123;</span><br><span class="line">        printf(&quot;%d %d&quot;,c-&gt;data,c-&gt;index);</span><br><span class="line">        c=c-&gt;next;</span><br><span class="line">        flag=0;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                c=c-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            if(c-&gt;data!=0)&#123;</span><br><span class="line">            printf(&quot; %d %d&quot;,c-&gt;data,c-&gt;index);</span><br><span class="line">        c=c-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                c=c-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    int main()&#123;</span><br><span class="line">    LinkList a;</span><br><span class="line"></span><br><span class="line">    LinkList b;</span><br><span class="line">    LinkList c;</span><br><span class="line">        LinkList d;</span><br><span class="line">    ListCreate_CL(a);</span><br><span class="line">    ListCreate_CL(b);</span><br><span class="line">        multy(a,b,d);</span><br><span class="line">        merge(a,b,c);</span><br><span class="line">        print(c);</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">        print(d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    </span><br><span class="line">​    </span><br></pre></td></tr></table></figure>




<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p><strong>顺序栈的基本操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">//库函数头文件包含</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;malloc.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAXSIZE 100</span><br><span class="line">typedef struct&#123;</span><br><span class="line">SElemType *base;</span><br><span class="line">SElemType *top;</span><br><span class="line">int stacksize;</span><br><span class="line"></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line">//初始化</span><br><span class="line">Status InitStack(SqStack &amp;S)&#123;</span><br><span class="line">S.base=new SElemType[MAXSIZE];</span><br><span class="line">if(!S.base) return OVERFLOW;</span><br><span class="line">S.top=S.base;</span><br><span class="line">S.stacksize=MAXSIZE;</span><br><span class="line">return OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//判断顺序栈是否为空</span><br><span class="line">bool StackEmpty(SqStack S)&#123;</span><br><span class="line"></span><br><span class="line">if(S.base==S.top)return OK;</span><br><span class="line">else return ERROR;</span><br><span class="line">&#125;</span><br><span class="line">//求顺序栈的长度</span><br><span class="line">int StackLength(SqStack S)&#123;</span><br><span class="line">return S.top-S.base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//清空顺序栈</span><br><span class="line">Status ClearStack(SqStack S)&#123;</span><br><span class="line">if(S.base)&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    S.top=S.base;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line">//销毁顺序栈</span><br><span class="line">Status DestroyStack(SqStack &amp;S)&#123;</span><br><span class="line">if(S.base)&#123;</span><br><span class="line">    free(S.base);</span><br><span class="line">    S.stacksize=0;</span><br><span class="line">    S.top=S.base=NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//顺序栈进展</span><br><span class="line">Status Push(SqStack &amp;S,SElemType e)&#123;</span><br><span class="line">if(S.top-S.base==MAXSIZE)&#123;</span><br><span class="line">    return ERROR;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">*s.top++=e;//先赋值然后再加一</span><br><span class="line">return OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//顺序栈出栈</span><br><span class="line">Status Pop(SqStack &amp;S,SElemType &amp;e)&#123;</span><br><span class="line">if(S.base==S.top)&#123;</span><br><span class="line">    return ERROR;</span><br><span class="line">&#125;</span><br><span class="line">e=*--S.top;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//取顺序栈的栈顶元素</span><br><span class="line">Status GetTop(SqStack S,SElemType &amp;e)&#123;</span><br><span class="line">if(S.base==S.top)&#123;</span><br><span class="line">    return ERROR;</span><br><span class="line">&#125;</span><br><span class="line">e=*(S.top-1);</span><br><span class="line">return OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>链栈的基本操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">typedef struct StruckNode&#123;</span><br><span class="line"></span><br><span class="line">struct StruckNode* next;</span><br><span class="line">SElemType data;</span><br><span class="line">&#125;StruckNode,*LinkStack;</span><br><span class="line"></span><br><span class="line">//初始化链表栈</span><br><span class="line">void InitStack(LinkStack &amp;S)&#123;</span><br><span class="line">S=NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//判断链栈是否为空</span><br><span class="line">Status StackEmpty(LinkStack &amp;S)&#123;</span><br><span class="line"></span><br><span class="line">if(S==NULL) return TRUE;</span><br><span class="line">else return FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//链栈进栈</span><br><span class="line">Status Push(LinkStack &amp;S,SElemType e)&#123;</span><br><span class="line"></span><br><span class="line">LinkStack p=new StackNode;</span><br><span class="line">if(!p) exit(OVERFLOW);</span><br><span class="line">p-&gt;data=e;</span><br><span class="line">p-&gt;next=S;</span><br><span class="line">p=S;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//链栈出栈</span><br><span class="line">Status Pop(LinkStack &amp;S,SElemType &amp;e)&#123;</span><br><span class="line">if(S==NULL) return ERROR;</span><br><span class="line">e=S-&gt;data;p=S;S=S-&gt;next;</span><br><span class="line">free(p);</span><br><span class="line"></span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//取链栈栈顶元素</span><br><span class="line">SElemType GetTop(LinkStack S)&#123;</span><br><span class="line"></span><br><span class="line">if(S==NULL) exit(1);</span><br><span class="line">else return S-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>数组实现的队列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">define MAXQSIZE <span class="number">100</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">QElemType *base;</span><br><span class="line"><span class="type">int</span> front;</span><br><span class="line"><span class="type">int</span> rear;</span><br><span class="line"><span class="type">int</span> emptyflag;<span class="comment">//队列空的标志,空为1</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化循环队列</span></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">Q.base=(QElemType)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QElemType));</span><br><span class="line"><span class="keyword">if</span>(!Q.base) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">Q.front=Q.rear=<span class="number">0</span>;</span><br><span class="line">Q.emptyflag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空循环队列</span></span><br><span class="line"><span class="function">Status <span class="title">ClearQueue</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">Q.rear=Q.front;</span><br><span class="line">Q.empty=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断循环队列队列是否为空</span></span><br><span class="line"><span class="function">Status <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Q.empty) <span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环队列长度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Q.emptyflag)&#123;</span><br><span class="line">     <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Q.rear==Q.front)&#123;</span><br><span class="line">        <span class="keyword">return</span> MAXQSIZE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (Q.rear-Q.front+MAXQSIZE)%MAXQSIZE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取队头元素</span></span><br><span class="line"><span class="function">Status <span class="title">GetHead</span><span class="params">(SqQueue Q,QElemType &amp;e)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Q.emptyflag) <span class="keyword">return</span> ERROR;</span><br><span class="line">*e=Q.base[Q.front];</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入元素e为Q的队尾元素</span></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,ElemType e)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Q.emptyflag) Q.emptyflag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Q.rear==Q.front) <span class="keyword">return</span> ERROR;</span><br><span class="line">Q.base[Q.rear]=e;</span><br><span class="line">Q.rear=(Q.rear+<span class="number">1</span>)%MAXQSIZE;<span class="comment">//让Q.rear为MAX-1的时候变成0</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//出队列一个</span></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q,ElemType &amp;e)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Q.emptyflag) <span class="keyword">return</span> ERROR;</span><br><span class="line">*e=Q.base[Q.front];</span><br><span class="line">Q.front=(Q.front<span class="number">-1</span>)%MAXQSIZE;</span><br><span class="line"><span class="keyword">if</span>(Q.rear==Q.front) Q.emptyflag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链表实现的不循环队列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">typedef struct QNode&#123;</span><br><span class="line">QElemType data;</span><br><span class="line">struct Qnode *next;</span><br><span class="line">&#125;Qnode,*QueuePtr;</span><br><span class="line">typedef struct&#123;</span><br><span class="line"></span><br><span class="line">QueuePtr front;</span><br><span class="line">QueuePtr rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line">//初始化</span><br><span class="line">Status InitQueue(LinkQueue &amp;Q)&#123;</span><br><span class="line">Q.front=Q.rear=(QueuePtr)malloc(sizeof(Qnode));</span><br><span class="line">if(!Q.front)exit(OVERFLOW);</span><br><span class="line">Q.front-&gt;next=NULL;</span><br><span class="line">return OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//判断队列是否为空</span><br><span class="line">Status QueueEmpty(LinkQueue &amp;Q)&#123;</span><br><span class="line"></span><br><span class="line">return Q.front==Q.rear;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//求链队列的队头元素</span><br><span class="line">Status GetHead(LinkQueue Q,QElemType &amp;e)&#123;</span><br><span class="line"></span><br><span class="line">if(Q.front==Q.rear) return ERROR;</span><br><span class="line">e=Q.front-&gt;next-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//链队列入队</span><br><span class="line">Status EnQueue(LinkQueue &amp;Q,QElemType e)&#123;</span><br><span class="line">p=(QueuePtr)malloc(sizeof(Qnode));</span><br><span class="line">p-&gt;data=e;</span><br><span class="line">p-&gt;next=NULL;</span><br><span class="line">Q.rear-&gt;next=p;</span><br><span class="line">Q.rear=p;</span><br><span class="line">return OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//链队列出队</span><br><span class="line">Status EnQueue(LinkQueue &amp;Q,QElemType e)&#123;</span><br><span class="line">if(Q.front==Q.rear) return ERROR;</span><br><span class="line">p=Q.front-&gt;next;</span><br><span class="line">e=p-&gt;data;</span><br><span class="line">Q.front-&gt;next=p-&gt;next;</span><br><span class="line">if(Q.rear==p) Q.rear=Q.front;</span><br><span class="line">free(p);</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用：</p>
<p>假设以<code>S</code>和<code>X</code>分别表示入栈和出栈操作。如果根据一个仅由<code>S</code>和<code>X</code>构成的序列，对一个空堆栈进行操作，相应操作均可行（如没有出现删除时栈空）且最后状态也是栈空，则称该序列是合法的堆栈操作序列。请编写程序，输入<code>S</code>和<code>X</code>序列，判断该序列是否合法。</p>
<p>输入格式:</p>
<p>输入第一行给出两个正整数N和M，其中N是待测序列的个数，M（≤50）是堆栈的最大容量。随后N行，每行中给出一个仅由<code>S</code>和<code>X</code>构成的序列。序列保证不为空，且长度不超过100。</p>
<p>输出格式:</p>
<p>对每个序列，在一行中输出<code>YES</code>如果该序列是合法的堆栈操作序列，或<code>NO</code>如果不是。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span><span class="comment">//有这个才能用strlen方法</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span>* top;</span><br><span class="line">    <span class="type">char</span>* base;</span><br><span class="line">    <span class="type">int</span> stackSize;</span><br><span class="line">&#125;LNode;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW -2;</span></span><br><span class="line"> <span class="type">int</span> status=<span class="number">1</span>;</span><br><span class="line">Status <span class="title function_">InitStack</span><span class="params">(LNode &amp;s,<span class="type">int</span> MAXSIZE)</span>&#123;</span><br><span class="line">    s.base=new <span class="type">char</span>[MAXSIZE];</span><br><span class="line">    <span class="keyword">if</span>(!s.base) <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">    s.top=s.base;</span><br><span class="line">    s.stackSize=MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(LNode &amp;s,<span class="type">char</span> a)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top-s.base==s.stackSize) <span class="keyword">return</span> ERROR;</span><br><span class="line">    *s.top++=a;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(LNode &amp;s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top==s.base)&#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    s.top--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status <span class="title function_">matching</span><span class="params">(LNode &amp;s,<span class="type">char</span> <span class="built_in">exp</span>[])</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(<span class="built_in">exp</span>);i++)&#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">exp</span>[i])&#123;<span class="comment">//这里必须有括号</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">                  Push(s,<span class="built_in">exp</span>[i]);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">                  <span class="keyword">if</span>(s.base==s.top)</span><br><span class="line">                         status=<span class="number">0</span>;</span><br><span class="line">                  <span class="keyword">else</span>&#123;</span><br><span class="line">                      Pop(s);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Status <span class="title function_">StackEmpty</span><span class="params">(LNode &amp;s)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s.base==s.top)&#123;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> num;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">    <span class="type">int</span> MAXSIZE;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;MAXSIZE);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">     LNode s;</span><br><span class="line">     InitStack(s,MAXSIZE);</span><br><span class="line">     <span class="type">char</span> <span class="built_in">exp</span>[<span class="number">100</span>];</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,<span class="built_in">exp</span>);</span><br><span class="line">     matching(s,<span class="built_in">exp</span>);</span><br><span class="line">        <span class="keyword">if</span>(StackEmpty(s)&amp;&amp;status)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/09/28/c%E8%AF%AD%E8%A8%80-1/" data-id="cl8l6i03q0000ksui32fuhn2s" data-title="c语言" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/09/28/java/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2022/09/28/%E6%B5%8B%E8%AF%95/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">测试</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/09/28/java/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/09/28/c%E8%AF%AD%E8%A8%80-1/">c语言</a>
          </li>
        
          <li>
            <a href="/2022/09/28/%E6%B5%8B%E8%AF%95/">测试</a>
          </li>
        
          <li>
            <a href="/2022/09/28/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>