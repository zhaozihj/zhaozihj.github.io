

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="数据结构和算法的概述数据结构：数据结构就是把数据元素按照一定的关系组织起来的集合，用来组织和存储数据 数据结构分类： 1.逻辑结构：集合结构，线性结构，树形结构，图形结构 2.物理结构：顺序存储结构，链式存储结构 顺序存储结构和链式存储结构的区别 链表存储结构的内存地址不一定是连续的，但顺序存储结构的内存地址一定是连续的； 链式存储适用于在较频繁地插入、删除、更新元素时，而顺序存储结构适用于频繁查">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法">
<meta property="og:url" content="http://example.com/2022/09/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="数据结构和算法的概述数据结构：数据结构就是把数据元素按照一定的关系组织起来的集合，用来组织和存储数据 数据结构分类： 1.逻辑结构：集合结构，线性结构，树形结构，图形结构 2.物理结构：顺序存储结构，链式存储结构 顺序存储结构和链式存储结构的区别 链表存储结构的内存地址不一定是连续的，但顺序存储结构的内存地址一定是连续的； 链式存储适用于在较频繁地插入、删除、更新元素时，而顺序存储结构适用于频繁查">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/jienigui.webp">
<meta property="article:published_time" content="2022-09-29T15:31:35.000Z">
<meta property="article:modified_time" content="2023-04-10T13:15:48.893Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/jienigui.webp">
  
  
  
  <title>数据结构与算法 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg","onlypost":true,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>java宝库</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="数据结构与算法"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-09-29 23:31" pubdate>
          September 29, 2022 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          157k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          1311 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">数据结构与算法</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="数据结构和算法的概述"><a href="#数据结构和算法的概述" class="headerlink" title="数据结构和算法的概述"></a><strong>数据结构和算法的概述</strong></h1><p>数据结构：数据结构就是把数据元素按照一定的关系组织起来的集合，用来组织和存储数据</p>
<p>数据结构分类：</p>
<p>1.逻辑结构：集合结构，线性结构，树形结构，图形结构</p>
<p>2.物理结构：顺序存储结构，链式存储结构</p>
<h3 id="顺序存储结构和链式存储结构的区别"><a href="#顺序存储结构和链式存储结构的区别" class="headerlink" title="顺序存储结构和链式存储结构的区别"></a>顺序存储结构和链式存储结构的区别</h3><ol>
<li>链表存储结构的内存地址不一定是连续的，但顺序存储结构的内存地址一定是连续的；</li>
<li>链式存储适用于在较频繁地插入、删除、更新元素时，而顺序存储结构适用于频繁查询时使用。</li>
</ol>
<h3 id="顺序存储结构和链式存储结构的优缺点："><a href="#顺序存储结构和链式存储结构的优缺点：" class="headerlink" title="顺序存储结构和链式存储结构的优缺点："></a>顺序存储结构和链式<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">存储结构</a>的优缺点：</h3><ul>
<li>空间上<br>顺序比链式节约空间。是因为链式结构每一个节点都有一个指针存储域。</li>
<li>存储操作上：<br>顺序支持随机存取，方便操作</li>
<li>插入和删除上：<br>链式的要比顺序的方便（因为插入的话顺序表也很方便，问题是顺序表的插入要执行更大的空间复杂度，包括一个从表头索引以及索引后的元素后移，而链表是索引后，插入就完成了）</li>
</ul>
<p>例如：当你在字典中查询一个字母j的时候，你可以选择两种方式，第一，顺序查询，从第一页依次查找直到查询到j。第二，索引查询，从字典的索引中，直接查出j的页数，直接找页数，或许是比顺序查询最快的。</p>
<h3 id="算法的概述"><a href="#算法的概述" class="headerlink" title="算法的概述"></a>算法的概述</h3><p>根据一定的条件，得到需要的结果</p>
<p>标准：1.花最少的时间完成需求</p>
<p>​            2.占用最少的内存空间完成需求</p>
<p>比如求1到100的和         1.可以用for循环来进行叠加1到100</p>
<p>​                                          2.也可以用高斯公式从(n+1)*n&#x2F;2</p>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><p>如何花更少的时间，如何占用更少的内存去完成相同的需求</p>
<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p><strong>事后分析估算方法</strong></p>
<p>并不是很好，浪费时间</p>
<p>在程序前后加上    long start &#x3D;System.currentTimeMillis();&#x2F;&#x2F;程序开始的时间</p>
<p>​                               long end&#x3D;System.currentTimeMillis();&#x2F;&#x2F;程序结束的时间</p>
<p>​                                System.out.println(start-end);&#x2F;&#x2F;程序执行的时间</p>
<p>程序运行在不同的电脑上会对运行时间产生一定影响</p>
<p><strong>事前分析估算方法</strong></p>
<p>1.算法采用的策略和方案</p>
<p>2.问题的输入规模（所谓的问题输入规模就是输入量的多少）</p>
<p>3.编译产生的代码质量</p>
<p>4.机器执行指令的速度</p>
<p>分析一个算法的运行时间，最重要的就是把核心操作的次数和输入规模关联起来</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202303131442533.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220730081116862"></p>
<p> <strong>函数渐近增长</strong></p>
<p>n为输入规模，fn为核心操作次数（运算）明显是橙色优于红色优于紫色</p>
<p><strong>算法函数规则</strong></p>
<p><strong>1.随着输入规模的增大，算法的常数操作可以忽略不计</strong></p>
<p><strong>2.随着输入规模的增大，与最高次数相乘的常数可以忽略</strong></p>
<p><strong>3.最高次项的指数大的，随着n的增长，结果也会变得增长特别快</strong></p>
<p><strong>4.算法函数中n的最高次幂越小，算法效率越高</strong></p>
<p><strong>大o记法</strong></p>
<p>定义：用大写O来体现算法时间复杂度记法，称之为大O记法，执行次数等于执行时间</p>
<p>算法一：运行次数为3次</p>
<p>算法二：运行次数为n+3次</p>
<p>算法三：运行次数为n*n+2次</p>
<p>大o记法规则：1.用常数1取代运行时间中的所有加法常数</p>
<p>​                          2.在修改后的运行次数中，只保留高阶项</p>
<p>​                          3.如果最高阶项存在，且常数因子不是1，则出去与这个项相乘的常数</p>
<p>算法1：O(1)</p>
<p>算法2：O(n)</p>
<p>算法3:O(n^2)</p>
<p><strong>对数阶</strong></p>
<p>int i&#x3D;1,n&#x3D;100;</p>
<p>while(i&lt;n){</p>
<p>i&#x3D;i*2;</p>
<p>}</p>
<p>执行次数为log(2)100</p>
<p>时间复杂度为O(logn)      把底数忽略掉的原因是随着n的增大底数可以忽略不计</p>
<p>常见的大O阶的复杂程度排序</p>
<p>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)</p>
<p><strong>最坏情况</strong></p>
<p>public int search(int num){</p>
<p>int []arr&#x3D;[11,10,8,9,7,5];</p>
<p>for(int i&#x3D;0;i&lt;arr.length;i++){</p>
<p>if(num&#x3D;&#x3D;arr[i]){</p>
<p>return i;</p>
<p>}</p>
<p>}</p>
<p>return -1;</p>
<p>}</p>
<p>在一个数组中存储了n个数查找指定一个数的下标</p>
<p>最好情况：查找的第一个数字就是期望数字，时间复杂度为O(1)</p>
<p>最坏情况：查找的最后一个数字才是期望数字，时间复杂度为O(n)</p>
<p>平均情况:任何数字查找的平均成本为O(n&#x2F;2)</p>
<p>以后做算法分析的时候：更多情况下是要看在最坏情况下的算法复杂度</p>
<p>经典计算时间复杂度</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202212102043402.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt=" "></p>
<h2 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><p>1.java中常见的基本数据类型的占用</p>
<p>byte    1字节    一字节是八位</p>
<p>short        2字节</p>
<p>int             4字节</p>
<p>long           8字节</p>
<p>float       4字节</p>
<p>double      8字节</p>
<p> boolean     1字节</p>
<p>char          2字节</p>
<p>2.计算机访问内存的方式都是一次一个字节</p>
<p>3.一个引用需要八个字节表示</p>
<p>​     例如：Date date &#x3D;new Date(),则这个变量需要占用8个字节来表示</p>
<p>4.创建一个对象new Date()，除了Date对象内部存储的数据(年月日)占用的内存，该对象本身也有内存的开销，每个对象的自身开销是16个字节，用来保存对象头信息</p>
<p>5.一般内存的使用，如果不够八个字节，都会被自动填充为8个字节</p>
<p>例子：public class A{</p>
<p>public int a&#x3D;1;</p>
<p>}</p>
<p>通过new A()创建一个对象的内存占用如下：1.整形成员变量a占用四个字节2.对象本身占用16个字节</p>
<p>那么创建对象总共需要20个字节，但由于不是以8位为单位，会自动填充为24个字节</p>
<p>6.java中数组被限定为对象，他们一般会因为记录长度而需要额外的内存，一个原始数据类型的数字一般需要24个字节的头信息（16个自己的对象开销，四字节用于保存长度，以及四个填充字节）再加上保存至所需的内存</p>
<h1 id="简单排序"><a href="#简单排序" class="headerlink" title="简单排序"></a>简单排序</h1><p>这些排序写的例子都是从小到大排序的</p>
<h2 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h2><p>对实现了Comparable接口的对象进行排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过Comparable接口提供比较规则</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Student&gt;&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>	<span class="hljs-keyword">private</span> String username;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> age;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>		<span class="hljs-built_in">this</span>.age = age;<br>	&#125;<br>	<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUsername</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> username;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUsername</span><span class="hljs-params">(String username)</span> &#123;<br>		<span class="hljs-built_in">this</span>.username = username;<br>	&#125;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Student o)</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getAge()-o.getAge();<span class="hljs-comment">//这种是按照年龄的从小到大对学生对象进行排序</span><br>	&#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>测试使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span> &#123;<br>		Student s1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>		s1.setAge(<span class="hljs-number">10</span>);<br>		s1.setUsername(<span class="hljs-string">&quot;找&quot;</span>);<br>		Student s2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>		s2.setAge(<span class="hljs-number">13</span>);<br>		s2.setUsername(<span class="hljs-string">&quot;我&quot;</span>);<br>		Comparable max=getMax(s1,s2);<br>		System.out.println(max);<br>		<br><br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Comparable <span class="hljs-title function_">getMax</span><span class="hljs-params">(Comparable c1,Comparable c2)</span> &#123;<br>		<span class="hljs-type">int</span> result=c1.compareTo(c2);<br>		<span class="hljs-keyword">if</span>(result&gt;=<span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-keyword">return</span> c1;<br>		&#125;<br>		<span class="hljs-keyword">else</span><br>		&#123;<br>			<span class="hljs-keyword">return</span> c2;<br>		&#125;<br>		<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序的API设计</p>
<p>1.构造方法：创建Bubble对象</p>
<p>2.成员方法：public static void sort(Comparable[] a):对数组内的元素进行排序</p>
<p> private static boolean greater(Comparable v,Comparable w):判断v是否大于w</p>
<p>  private static void (Comparable[] a,int i,int j):交换数组中，索引i和索引j处的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bubble</span>&#123;<br>	<span class="hljs-comment">//对数组a中元素进行冒泡排序</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(Comparable[] a)</span> &#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.length-<span class="hljs-number">1</span>;i&gt;<span class="hljs-number">0</span>;i--) &#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++) &#123;<br>			<span class="hljs-keyword">if</span>(greater(a[j],a[j+<span class="hljs-number">1</span>]))<br>			&#123;<br>				exch(a,j,j+<span class="hljs-number">1</span>);<br>			&#125;<br>		&#125;<br>	&#125;<br>		<br><br>	&#125;<br>	<span class="hljs-comment">//比较v元素是否大于w元素</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">greater</span><span class="hljs-params">(Comparable v,Comparable w)</span> &#123;<br>		<span class="hljs-keyword">return</span> v.compareTo(w)&gt;<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//数组元素i和j交换位置</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exch</span><span class="hljs-params">(Comparable[] a,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> &#123;<br>		Comparable temp;<br>		temp=a[i];<br>		a[i]=a[j];<br>		a[j]=temp;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span> &#123;<br>Integer []arr= &#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<span class="hljs-comment">//这里必须是用Integer而不是基本数据类型，因为Integer实现了Comparable类</span><br>Bubble.sort(arr);<br>System.out.println(Arrays.toString(arr));<span class="hljs-comment">//[1, 2, 3, 4, 5, 6]</span><br>		<br><br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>最坏情况下也就是数组里的数完全逆序</p>
<p>元素的比较次数：(n-1)+(n-2)+(n-3)+(n-4)+..+2+1&#x3D;n^2&#x2F;2-n&#x2F;2;</p>
<p>元素的交换次数：(n-1)+(n-2)+(n-3)+(n-4)+..+2+1&#x3D;n^2&#x2F;2-n&#x2F;2;</p>
<p>总执行次数为：n^2-n;</p>
<p>时间复杂度为O(n^2)</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>排序原理：每一次遍历过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较，如果第一个索引处的值大于a索引处的值，则交换这个a索引处的值和第一个索引处的值，这样一直遍历到最后一个元素，就会得到这些数中的最小值，同时它是放在第一个索引处的，接下来再对剩下的数进行相同的操作</p>
<p><strong>选择排序的API设计</strong></p>
<p>Selection</p>
<p>构造方法：Selection()用来创建对象</p>
<p>1.public static void sort(Comparable[] a):对数组内的元素排序</p>
<p>2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w</p>
<ol start="3">
<li>private static void (Comparable[] a,int i,int j):交换数组中，索引i和索引j处的值</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Selection</span>&#123;<br>	<span class="hljs-comment">//对数组a中元素进行选择排序</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(Comparable[] a)</span> &#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.length-<span class="hljs-number">1</span>;i++) &#123;<br>		<span class="hljs-comment">//定义一个变量，记录最小元素所在的索引，默认为参与选择排序的第一个元素所在的位置</span><br>		<span class="hljs-type">int</span> minIndex=i;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;a.length;j++) &#123;<br>			<span class="hljs-comment">//需要比较最小索引minIndex处的值和j索引处的值</span><br>			<span class="hljs-keyword">if</span>(greater(a[minIndex],a[j])) &#123;<br>				<span class="hljs-comment">//交换最小元素所在的索引minIndex处的值和索引处的值</span><br>				exch(a,minIndex,j);<br>			&#125;<br>		&#125;<br>	&#125;<br>	&#125;<br>	<span class="hljs-comment">//比较v元素是否大于w元素</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">greater</span><span class="hljs-params">(Comparable v,Comparable w)</span> &#123;<br>		<span class="hljs-keyword">return</span> v.compareTo(w)&gt;<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//数组元素i和j交换位置</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exch</span><span class="hljs-params">(Comparable[] a,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> &#123;<br>		Comparable temp;<br>		temp=a[i];<br>		a[i]=a[j];<br>		a[j]=temp;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span> &#123;<br>Integer []arr= &#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<br>Selection.sort(arr);<br>System.out.println(Arrays.toString(arr));<span class="hljs-comment">//[1, 2, 3, 4, 5, 6]</span><br>		<br><br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>最坏情况：</p>
<p>1.元素比较次数(n-1)+(n-2)+(n-3)+(n-4)+..+2+1&#x3D;n^2&#x2F;2-n&#x2F;2;</p>
<p>2.元素的交换次数是n-1</p>
<p>时间复杂度为n^2&#x2F;2+n&#x2F;2-1；</p>
<p>时间复杂度为O(n^2)</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>1.把所有的元素分为两组，已经排序的和未排序的</p>
<p>2.找到未排序的组中的第一个元素，向已经排序的组中进行插入</p>
<p>3.用排好序的最后一个元素a和未排序的第一个元素b比较，如果a&gt;b，那么他俩交换位置，然后b再和前面的比较，直到找到比他小的或相等的就不用交换了，如果a&lt;b，a和b就不用交换了</p>
<p><strong>插入排序的API设计</strong></p>
<p>1.public static void sort(Comparable[] a):对数组内的元素排序</p>
<p>2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w</p>
<ol start="3">
<li>private static void (Comparable[] a,int i,int j):交换数组中，索引i和索引j处的值</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Insertion</span>&#123;<br>	<span class="hljs-comment">//对数组a中元素进行插入排序</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(Comparable[] a)</span> &#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;a.length;i++) &#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&gt;<span class="hljs-number">0</span>;j--) &#123;<br>			<span class="hljs-comment">//比较索引处的值和索引-1处的值，如果索引j-1处的值比索引处的值大，则交换数据，如果不大，那么就找到合适的位置了，退出循环即可</span><br>			<span class="hljs-keyword">if</span>(greater(a[j-<span class="hljs-number">1</span>],a[j])) &#123;<br>				exch(a,j-<span class="hljs-number">1</span>,j);<br>			&#125;<br>			<span class="hljs-keyword">else</span><br>			&#123;<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>		&#125;<br>	&#125;<br>	&#125;<br>	<span class="hljs-comment">//比较v元素是否大于w元素</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">greater</span><span class="hljs-params">(Comparable v,Comparable w)</span> &#123;<br>		<span class="hljs-keyword">return</span> v.compareTo(w)&gt;<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//数组元素i和j交换位置</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exch</span><span class="hljs-params">(Comparable[] a,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> &#123;<br>		Comparable temp;<br>		temp=a[i];<br>		a[i]=a[j];<br>		a[j]=temp;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span> &#123;<br>Integer []arr= &#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<br>Insertion.sort(arr);<br>System.out.println(Arrays.toString(arr));<br>		<br><br>	&#125;<br><br>&#125;<br>结果：[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure>

<p>最坏情况：</p>
<p>元素的比较次数：(n-1)+(n-2)+(n-3)+(n-4)+..+2+1&#x3D;n^2&#x2F;2-n&#x2F;2;</p>
<p>元素的交换次数：(n-1)+(n-2)+(n-3)+(n-4)+..+2+1&#x3D;n^2&#x2F;2-n&#x2F;2;</p>
<p>总执行次数为：n^2-n;</p>
<p>时间复杂度为O(n^2)</p>
<h1 id="高级排序"><a href="#高级排序" class="headerlink" title="高级排序"></a>高级排序</h1><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>插入排序的高效版</p>
<p>1.选定一个增长量n，按照增长量n所谓数据分组的依据，对数据进行分组</p>
<p>2.比如n为7的时候就比较下标为0和下标为7，下标为1和下标为8，以此类推直到下标大于最大下标，然后n&#x3D;n&#x2F;2,保持n&gt;&#x3D;1即可</p>
<p>3.减小增长量，最小减为1，重复第二步操作</p>
<p>增长量h的确定，假设数组的元素个数为10</p>
<p>int h&#x3D;1;</p>
<p>while(h&lt;5){</p>
<p>h&#x3D;2h+1;&#x2F;&#x2F;3,7</p>
<p>}</p>
<p>循环结束后就可以确定增长量的最大值</p>
<p>每次增长量减少之后h为h&#x2F;2,按照这个规则来减少 7变为3，3变为1</p>
<p><strong>希尔排序API</strong>（Shell）</p>
<p>1.public static void sort(Comparable[] a):对数组内的元素排序</p>
<p>2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w</p>
<ol start="3">
<li>private static void exch(Comparable[] a,int i,int j):交换数组中，索引i和索引j处的值</li>
<li></li>
</ol>
<p>最早的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shell</span>&#123;<br>	<span class="hljs-comment">//对数组a中元素进行希尔排序</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(Comparable[] a)</span> &#123;<br>		<span class="hljs-type">int</span> h=<span class="hljs-number">1</span>;<br>         <span class="hljs-keyword">while</span>(h&lt;a.length/<span class="hljs-number">2</span>) &#123;<br>        	 h=<span class="hljs-number">2</span>*h+<span class="hljs-number">1</span>;<br>         &#125;<br>         <span class="hljs-keyword">while</span>(h&gt;=<span class="hljs-number">1</span>) &#123;<br>        	 <span class="hljs-comment">//找到待插入的元素</span><br>        	 <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h;i&lt;a.length;i++) &#123;<br>        		 <span class="hljs-comment">//把待插入的元素插入到有序数列中</span><br>        		 <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&gt;=h;j-=h) &#123;<br>        			 <span class="hljs-comment">//待插入的元素是a[j]，比较a[j]和a[j-h]</span><br>        			 <span class="hljs-keyword">if</span>(greater(a[j-h],a[j])) &#123;<br>        				 exch(a,j-h,j);<br>        			 &#125;<br>        			 <span class="hljs-keyword">else</span><br>        			 &#123;<br>        				 <span class="hljs-keyword">break</span>;<br>        			 &#125;<br>        		 &#125;<br>        	 &#125;<br>        	 <span class="hljs-comment">//减小h的值</span><br>        	 h=h/<span class="hljs-number">2</span>;<br>         &#125;<br>	<br><br>	&#125;<br>	<span class="hljs-comment">//比较v元素是否大于w元素</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">greater</span><span class="hljs-params">(Comparable v,Comparable w)</span> &#123;<br>		<span class="hljs-keyword">return</span> v.compareTo(w)&gt;<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//数组元素i和j交换位置</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exch</span><span class="hljs-params">(Comparable[] a,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> &#123;<br>		Comparable temp;<br>		temp=a[i];<br>		a[i]=a[j];<br>		a[j]=temp;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<p>自己又写的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 排序算法;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shell</span> &#123;<br><br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(Comparable a[])</span> &#123;<br>		<br>	  <span class="hljs-type">int</span> h=<span class="hljs-number">1</span>;<br>	  <span class="hljs-keyword">while</span>(h&lt;a.length) &#123;<br>		  h=<span class="hljs-number">2</span>*h+<span class="hljs-number">1</span>;<br>	  &#125;<br>	  <br>	  <span class="hljs-keyword">while</span>(h&gt;=<span class="hljs-number">1</span>) &#123;	<br>		  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h;i&lt;a.length;i++) &#123;<br>			  <br>			  <span class="hljs-keyword">if</span>(greater(a[i-h],a[i])) &#123;<br>				  exch(a,i-h,i);<br>			  &#125;<br>			  <br>		  &#125;<br>		  <br>		  h=h/<span class="hljs-number">2</span>;<br>		  <br>	  &#125;	<br><br>	&#125;<br><br>	<span class="hljs-comment">//判断a是否比b大</span><br>			<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">greater</span><span class="hljs-params">(Comparable a,Comparable b)</span> &#123;<br><br>				<span class="hljs-keyword">return</span> a.compareTo(b)&gt;<span class="hljs-number">0</span>;<br>			&#125;<br>						<br><br>			<span class="hljs-comment">//进行数值交换</span><br>			<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">exch</span><span class="hljs-params">(Comparable[] a,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> &#123;<br>				<br>				Comparable mid=a[i];<br>				a[i]=a[j];<br>				a[j]=mid;<br>				<br>			&#125;<br><br><br>​	<br>&#125;<br><br><br><br><br></code></pre></td></tr></table></figure>



<p>测试：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Main&#123;<br>	public static void main(String <span class="hljs-literal">[]</span>args) &#123;<br>Integer <span class="hljs-literal">[]</span>arr= &#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Shell</span>.</span></span>sort(arr);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">String(<span class="hljs-params">arr</span>)</span>);<br>		<br><br>	&#125;<br><br><br>&#125;<br>结果：<span class="hljs-literal">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]</span><br></code></pre></td></tr></table></figure>

<p><strong>希尔排序和插入排序的时间复杂度分析</strong></p>
<p>一个例子：就是一个完全倒叙的数组用两种排序进行一个时间的比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedInputStream;<br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileNotFoundException;<br><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Insertion</span>&#123;<br>	<span class="hljs-comment">//对数组a中元素进行插入排序</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(Comparable[] a)</span> &#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;a.length;i++) &#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&gt;<span class="hljs-number">0</span>;j--) &#123;<br>			<span class="hljs-comment">//比较索引处的值和索引-1处的值，如果索引j-1处的值比索引处的值大，则交换数据，如果不大，那么就找到合适的位置了，退出循环即可</span><br>			<span class="hljs-keyword">if</span>(greater(a[j-<span class="hljs-number">1</span>],a[j])) &#123;<br>				exch(a,j-<span class="hljs-number">1</span>,j);<br>			&#125;<br>			<span class="hljs-keyword">else</span><br>			&#123;<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>		&#125;<br>	&#125;<br>	&#125;<br>	<span class="hljs-comment">//比较v元素是否大于w元素</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">greater</span><span class="hljs-params">(Comparable v,Comparable w)</span> &#123;<br>		<span class="hljs-keyword">return</span> v.compareTo(w)&gt;<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//数组元素i和j交换位置</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exch</span><span class="hljs-params">(Comparable[] a,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> &#123;<br>		Comparable temp;<br>		temp=a[i];<br>		a[i]=a[j];<br>		a[j]=temp;<br>	&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shell</span>&#123;<br>	<span class="hljs-comment">//对数组a中元素进行希尔排序</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(Comparable[] a)</span> &#123;<br>		<span class="hljs-type">int</span> h=<span class="hljs-number">1</span>;<br>         <span class="hljs-keyword">while</span>(h&lt;a.length/<span class="hljs-number">2</span>) &#123;<br>        	 h=<span class="hljs-number">2</span>*h+<span class="hljs-number">1</span>;<br>         &#125;<br>         <span class="hljs-keyword">while</span>(h&gt;=<span class="hljs-number">1</span>) &#123;<br>        	 <span class="hljs-comment">//找到待插入的元素</span><br>        	 <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h;i&lt;a.length;i++) &#123;<br>        		 <span class="hljs-comment">//把待插入的元素插入到有序数列中</span><br>        		 <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&gt;=h;j-=h) &#123;<br>        			 <span class="hljs-comment">//待插入的元素是a[j]，比较a[j]和a[j-h]</span><br>        			 <span class="hljs-keyword">if</span>(greater(a[j-h],a[j])) &#123;<br>        				 exch(a,j-h,j);<br>        			 &#125;<br>        			 <span class="hljs-keyword">else</span><br>        			 &#123;<br>        				 <span class="hljs-keyword">break</span>;<br>        			 &#125;<br>        		 &#125;<br>        	 &#125;<br>        	 <span class="hljs-comment">//减小h的值</span><br>        	 h=h/<span class="hljs-number">2</span>;<br>         &#125;<br>	<br><br>	&#125;<br>	<span class="hljs-comment">//比较v元素是否大于w元素</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">greater</span><span class="hljs-params">(Comparable v,Comparable w)</span> &#123;<br>		<span class="hljs-keyword">return</span> v.compareTo(w)&gt;<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//数组元素i和j交换位置</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exch</span><span class="hljs-params">(Comparable[] a,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> &#123;<br>		Comparable temp;<br>		temp=a[i];<br>		a[i]=a[j];<br>		a[j]=temp;<br>	&#125;<br><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testShell</span><span class="hljs-params">(Integer []a)</span> &#123;<br>		<span class="hljs-comment">//获取执行之前的时间</span><br>		<span class="hljs-type">long</span> start=System.currentTimeMillis();<br>		Shell.sort(a);<br>		<span class="hljs-comment">//获取执行之后的时间</span><br>		<span class="hljs-type">long</span> end=System.currentTimeMillis();<br>		System.out.println(end-start);<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testInsertion</span><span class="hljs-params">(Integer []a)</span> &#123;<br>		<span class="hljs-type">long</span> start=System.currentTimeMillis();<br>		Insertion.sort(a);<br>		<span class="hljs-type">long</span> end=System.currentTimeMillis();<br>		System.out.println(end-start);<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span> <span class="hljs-keyword">throws</span> NumberFormatException, IOException &#123;<br>		<span class="hljs-comment">//创建一个ArrayList集合，读取数据，并存储在ArrayList中</span><br>ArrayList&lt;Integer&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>BufferedReader reader=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;D:\\放乱七八糟\\File.txt&quot;</span>));<br>String line=<span class="hljs-literal">null</span>;<br><span class="hljs-keyword">while</span>((line=reader.readLine())!=<span class="hljs-literal">null</span>) &#123;<br>	<span class="hljs-comment">//line是字符串把line转换成Integer，存储到集合中</span><br>	<span class="hljs-type">int</span> i=Integer.parseInt(line);<br>	list.add(i);<br>&#125;<br>reader.close();<br><span class="hljs-comment">//将ArrayList转换为数组</span><br>Integer a[]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[list.size()];<br>list.toArray(a);<br><span class="hljs-comment">//调用调试代码完成测试</span><br><br><span class="hljs-comment">//testInsertion(a);1毫秒</span><br><span class="hljs-comment">//testShell(a);0毫秒</span><br>	<br>&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>定义方法时，调用方法本身称之为递归</p>
<p>注意事项：在递归中，不能无限制的调用自己，必须要有边界条件，能够让递归结束，因为每一次递归调用都会在栈内存开辟新的空间，重新执行方法，如果递归的层级太深，很容易造成栈内存溢出</p>
<p>递归地实现：求阶乘</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span> &#123;<br>		<span class="hljs-type">int</span> result=factorial(<span class="hljs-number">5</span>);<br>		System.out.println(result);<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">factorial</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>		<span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>		&#125;<br>		<span class="hljs-keyword">return</span> n*factorial(n-<span class="hljs-number">1</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>归并排序的原理</strong></p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656802.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220731080847464"></p>
<p>如果是奇数个数比如9就分为4和5，然后再分到不能分为止</p>
<p><strong>归并排序的API设计</strong></p>
<p>1.public static void sort(Comparable[] a):对数组内的元素排序</p>
<p>2.private static boolean less(Comparable v,Comparable w):判断v是否小于w</p>
<ol start="3">
<li>private static void (Comparable[] a,int i,int j):交换数组中，索引i和索引j处的值</li>
</ol>
<p>4.private static void sort(Comparable[]a,int lo,int hi):对数组a中索引o到索引h之间的元素进行排序</p>
<p>5.private static void merge(Comparable[] a,int lo,int mid,int hi)从索引lo到mid为一个子组，从索引mid+1到索引hi为另一个子组，把数组a中的这两个子组的数据合并成一个有序的大组(从索引lo到索引hi)</p>
<p>成员变量：private static Comparable[] assist   完成归并操作需要的辅助数组</p>
<p>merge归并的原理</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656804.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220731084418827"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Merge</span>&#123;<br>	<span class="hljs-comment">//归并所需要的辅助数据</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Comparable[] assist;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * 比较v元素是否小于w元素</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">less</span><span class="hljs-params">(Comparable v,Comparable w)</span> &#123;<br>		<span class="hljs-keyword">return</span> v.compareTo(w)&lt;<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * 将数组中的元素交换位置</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exch</span><span class="hljs-params">(Comparable[] a,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> &#123;<br>		Comparable t=a[i];<br>		a[i]=a[j];<br>		a[j]=t;<br>	&#125;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * 对数组中a中的元素从lo到hi进行排序</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(Comparable []a,<span class="hljs-type">int</span> lo,<span class="hljs-type">int</span> hi)</span> &#123;<br>        <span class="hljs-comment">//做一个安全性的校验</span><br>		<span class="hljs-keyword">if</span>(hi&lt;=lo) &#123;<br>			<span class="hljs-keyword">return</span> ;<br>		&#125;<br><span class="hljs-comment">//对lo到high之间的数据分为两个组</span><br>		<span class="hljs-type">int</span> mid=lo+(hi-lo)/<span class="hljs-number">2</span>;<br>		<br><br>		<span class="hljs-comment">//分别对每一组数据进行排序</span><br>		sort(a,lo,mid);<br>		sort(a,mid+<span class="hljs-number">1</span>,hi);<br>		<span class="hljs-comment">//再把两个组中的数据进行归并</span><br>		merge(a,lo,mid,hi);<br>	&#125;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * 对数组中a中的元素进行排序</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(Comparable []a)</span> &#123;<br>		<span class="hljs-comment">//1.初始化辅助数组assist</span><br>		assist =<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparable</span>[a.length];<br>		<span class="hljs-comment">//2.定义一个lo变量，和hi变量，分别记录数组中最小的索引和最大的索引</span><br>		<span class="hljs-type">int</span> lo=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//这个地方同时可以指定，你要给哪些元素排序</span><br>		<span class="hljs-type">int</span> hi=a.length-<span class="hljs-number">1</span>;<br>		<span class="hljs-comment">//3.调用sort重载方法完成数组a中，从索引lo到索引hi的元素排序</span><br>		sort(a,lo,hi);<br>	&#125;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * 对数组中，从lo到mid为一组，从mid+1到hi为一组，对比两组数据进行归并</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(Comparable[] a,<span class="hljs-type">int</span> lo,<span class="hljs-type">int</span> mid,<span class="hljs-type">int</span> hi)</span> &#123;<br>		<span class="hljs-comment">//定义三个指针</span><br>		<span class="hljs-type">int</span> i=lo;<span class="hljs-comment">//辅助数组的第一个数</span><br>		<span class="hljs-type">int</span> p1=lo;<span class="hljs-comment">//左子组的第一个数</span><br>		<span class="hljs-type">int</span> p2=mid+<span class="hljs-number">1</span>;<span class="hljs-comment">//右子组的第一个数</span><br>		<br>		<span class="hljs-comment">//遍历：移动p1指针和p2至真1，比较对应索引处的值，找出小的那个，放到辅助数组的对应索引处</span><br>		<span class="hljs-keyword">while</span>(p1&lt;=mid&amp;&amp;p2&lt;=hi) &#123;<br>			<span class="hljs-keyword">if</span>(less(a[p1],a[p2])) &#123;<br>				assist[i++]=a[p1++];<br>			&#125;<br>			<span class="hljs-keyword">else</span><br>			&#123;<br>				assist[i++]=a[p2++];<br>			&#125;<br>		&#125;<br>		<span class="hljs-comment">//遍历，如果p2走完了p1的指针没有走完，那么顺序移动p1指针，把对应的元素放到辅助数据的对应索引处</span><br>		<span class="hljs-keyword">while</span>(p1&lt;=mid) &#123;<br>			assist[i++]=a[p1++];<br>		&#125;<br>		<span class="hljs-comment">//遍历，如果p1走完了p2的指针没有走完，那么顺序移动p1指针，把对应的元素放到辅助数据的对应索引处</span><br>		<span class="hljs-keyword">while</span>(p2&lt;=hi) &#123;<br>			assist[i++]=a[p2++];<br>		&#125;<br>		<span class="hljs-comment">//把辅助数组中的元素拷贝到原数组中</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> m=lo;m&lt;=hi;m++) &#123;<br>			a[m]=assist[m];<br>		&#125;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>归并排序的时间复杂度分析</strong></p>
<p>log2(n)为总层数</p>
<p>第k层的数组个数为2^k       每个数组的长度为2^(log2(n)-k)  所以这一层比较次数为2^log2(n)      总共有log2(n)层</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">所以总的比较次数为log2(<span class="hljs-built_in">n</span>)*<span class="hljs-number">2</span>^log2(<span class="hljs-built_in">n</span>)=log2(<span class="hljs-built_in">n</span>)*<span class="hljs-built_in">n</span>      最终归并排序的时间复杂度为O(nlogn);忽略底数<br></code></pre></td></tr></table></figure>

<p>归并排序缺点：需要申请额外的数组空间，倒置空间复杂度提升，是典型的以空间换时间的操作</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><strong>快速排序</strong></h2><p><strong>当进行从小到大排序的时候，你选的这个临界值默认为第一个元素在左边，所以指针找比标准值小的数的右指针要先开始找，这样右指针也是先停，然后停在一个比标准值小的值上这样第一个元素和右指针所在的元素交换位置，才能保证交换后标准值左边的值都比它小</strong></p>
<p>快速排序原理：</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656805.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220731095311939"></p>
<p>找到数组当中的第一个数，以他为分界线，比这个数大的一组(右边)比这个数小的一组(左边)，然后再进行重复的操作，然后再将他们合并起来</p>
<p><strong>快速排序的API设计</strong></p>
<p>1.public static void sort(Comparable[] a):对数组内的元素排序</p>
<p>2.private static boolean less(Comparable v,Comparable w):判断v是否小于w</p>
<p>3.private static int partition(Comparable[] a,int lo,int hi):对数组a中，从索引lo到索引hi之间的元素进行分组，并返回分组界限对应的索引</p>
<p>4.private static void sort(Comparable[]a,int lo,int hi):对数组a中索引o到索引h之间的元素进行排序</p>
<p>5.private static void exch(Comparable[] a,int i,int j):交换数组中，索引i和索引j处的值</p>
<p>切分原理：两个指针一个从左到右一个从右到左，当右指针遇到比标准值小的数停下，左指针遇到比标准值大的数停下，然后两者交换</p>
<p>直到左右指针相遇将第一个数也就是标准值与相遇的那个数交换位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Quick</span>&#123;<br>	<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * 比较v元素是否小于w元素</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">less</span><span class="hljs-params">(Comparable v,Comparable w)</span><br>	&#123;<br>		<span class="hljs-keyword">return</span> v.compareTo(w)&lt;<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * 数组元素i和j交换位置</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exch</span><span class="hljs-params">(Comparable[] a,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> &#123;<br>		Comparable t=a[i];<br>		a[i]=a[j];<br>		a[j]=t;<br>	&#125;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * 对数组中的元素进行排序</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(Comparable []a)</span> &#123;<br>		<span class="hljs-type">int</span> lo=<span class="hljs-number">0</span>;<br>		<span class="hljs-type">int</span> hi=a.length-<span class="hljs-number">1</span>;<br>		sort(a,lo,hi);<br>	&#125;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * 对数组a中从索引lo到索引hi之间的元素进行排序</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(Comparable []a,<span class="hljs-type">int</span> lo,<span class="hljs-type">int</span> hi)</span> &#123;<br>	<span class="hljs-comment">//安全性校验</span><br>		<span class="hljs-keyword">if</span>(hi&lt;=lo) &#123;<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		<span class="hljs-comment">//现需要对数组中lo索引到hi索引处的元素进行分组  左子组，右子组</span><br>		<span class="hljs-type">int</span> partition=partition(a,lo,hi);<span class="hljs-comment">//返回的是分组的分界值所在的索引，分界值位置变换后的索引</span><br>		<br>		<span class="hljs-comment">//让左子组有序，让右子组有序</span><br>		sort(a,lo,partition-<span class="hljs-number">1</span>);<br>		sort(a,partition+<span class="hljs-number">1</span>,hi);<br>	&#125;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * 对数组a中，从索引lo到hi之间的元素进行分组，并返回分组界限所应的索引</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(Comparable[]a,<span class="hljs-type">int</span> lo,<span class="hljs-type">int</span> hi)</span> &#123;<br>		<span class="hljs-comment">//确定分界值</span><br>		Comparable key=a[lo];<br>		<span class="hljs-comment">//定义两个分界值，分别指向待切分元素的最小索引处和最大索引处的下一个位置</span><br>		<span class="hljs-type">int</span> left=lo;<br>		<span class="hljs-type">int</span> right=hi+<span class="hljs-number">1</span>;<br>		<br>		<span class="hljs-comment">//切分</span><br>		<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>			<span class="hljs-comment">//先从右往左扫描，移动right指针，找到一个比分界值小的元素，停止</span><br>			<span class="hljs-keyword">while</span>(less(key,a[--right])) &#123;<br>				<span class="hljs-keyword">if</span>(right==lo) &#123;<br>					<span class="hljs-keyword">break</span>;<br>				&#125;<br>			&#125;<br>			<span class="hljs-comment">//再从左往右扫描，移动left指针，找到一个比分界值大的元素,停止</span><br>			<span class="hljs-keyword">while</span>(less(a[++left],key)) &#123;<br>				<span class="hljs-keyword">if</span>(left==hi) &#123;<br>					<span class="hljs-keyword">break</span>;<br>				&#125;<br>			&#125;<br>			<span class="hljs-comment">//判断left&gt;=right,如果是则证明元素扫描完毕，结束循环，如果不是，则交换元素即可</span><br>		<span class="hljs-keyword">if</span>(left&gt;=right) &#123;<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>		<span class="hljs-keyword">else</span><br>		&#123;<br>			exch(a,left,right);<br>		&#125;<br>		&#125;<br>		exch(a,lo,right);<br>		<br>		<span class="hljs-keyword">return</span> right;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Main&#123;<br>	public static void main(String <span class="hljs-literal">[]</span>args) &#123;<br>		Integer<span class="hljs-literal">[]</span> a= &#123;<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>&#125;;<br>		<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Quick</span>.</span></span>sort(a);<br>		<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">String(<span class="hljs-params">a</span>)</span>);<br>	&#125;<br>&#125;<br>结果：<span class="hljs-literal">[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]</span><br></code></pre></td></tr></table></figure>

<p><strong>快速排序和归并排序的区别</strong></p>
<p>1.归并排序是数组分成两个子数组分别排序，并将有序的子数组归并从而将整个数组排序，而快速排序的方式则是当两个数组有序时，整个数组自然就有序了。</p>
<p><strong>快速排序最坏情况</strong></p>
<p>每一次切分选择的基准数字是当前序列中最大数或者最小数，这使得每次切分都会有一个子组，那么总共就得切分n次，所以，最坏情况下，快速排序的时间复杂度为O(n^2)</p>
<p><strong>快速排序最优，平均情况</strong></p>
<p>复杂度为O(nlogn)</p>
<h2 id="排序稳定性"><a href="#排序稳定性" class="headerlink" title="排序稳定性"></a>排序稳定性</h2><p>数组arr中有若干元素，其中A元素和B元素相等，并且A元素再B元素前面，如果使用某种排序算法排序后，能保证A元素依然在B元素的前面，可以说这个算法是稳定的</p>
<p>稳定性的意义：如果一组数据只需要一次排序，那么稳定性没有任何意义</p>
<p>冒泡排序：稳定的</p>
<p>选择排序：不稳定的</p>
<p>插入排序：稳定的</p>
<p>希尔排序：不稳定的</p>
<p>归并排序：稳定的</p>
<p>快速排序：不稳定的</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性表是最基本最简单也是最常用的一种数据结构，一个线性表是n个具有相同特性的数据元素的有限序列</p>
<p>前驱元素： 若A元素在B元素的前面，则称A为B的前驱元素 </p>
<p>后继元素： 若B元素在A元素的后面，则称B为A的后继元素 </p>
<p>线性表的特征：数据元素之间具有一种“一对一”的逻辑关系。 1. 第一个数据元素没有前驱，这个数据元素被称为头结点； </p>
<ol start="2">
<li>最后一个数据元素没有后继，这个数据元素被称为尾结点； </li>
<li>除了第一个和最后一个数据元素外，其他数据元素有且仅有一个前驱和一个后继。</li>
<li>如果把线性表用数学语言来定义，则可以表示为(a1,…ai-1,ai,ai+1,…an)，ai-1领先于ai,ai领先于ai+1，称ai-1是ai的 前驱元素，ai+1是ai的后继元素</li>
</ol>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656806.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220731142917512"></p>
<p>线性表的分类： 线性表中数据存储的方式可以是顺序存储，也可以是链式存储，按照数据的存储方式不同，可以把线性表分为顺序 表和链表。</p>
<p>构造方法:</p>
<p>SequenceList(int capacity)：创建容量为capacity的SequenceList对象</p>
<p>成员方法：<br>1.public void clear()：空置线性表 </p>
<p> 2.publicboolean isEmpty()：判断线性表是否为空，是返回true，否返回false </p>
<p>3.public int length():获取线性表中元素的个数 </p>
<p>4.public T get(int i):读取并返回线性表中的第i个元素的值 </p>
<p>5.public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。 </p>
<p>6.public void insert(T t):向线性表中添加一个元素t </p>
<p>7.public T remove(int i):删除并返回线性表中第i个数据元素。 </p>
<p>8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返 回-1。</p>
<p>成员变量：1.private T[] eles：存储元素的数组</p>
<p>​                   2.private int N:当前线性表的长度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SequenceList</span>&lt;T&gt;&#123;<br><span class="hljs-comment">//存储元素的数组</span><br>	<span class="hljs-keyword">private</span> T[] eles;<br>	<span class="hljs-comment">//记录当前顺序表中元素的个数</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br>	<br>	<span class="hljs-comment">//构造方法</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">SequenceList</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span><br>	&#123;<br>		<span class="hljs-comment">//初始化数据</span><br>		<span class="hljs-built_in">this</span>.eles=(T[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];<br>		<span class="hljs-built_in">this</span>.N=<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//将一个线性表置为空表</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-built_in">this</span>.N=<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//判断当前线性表是否为空表</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> N==<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//获取线性表的长度</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> N;<br>	&#125;<br>	<span class="hljs-comment">//获取指定位置的元素</span><br>	<span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>		<span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>||i&gt;=N) &#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;当前元素不存在&quot;</span>);<br>		&#125;<br>		<span class="hljs-keyword">return</span> eles[i];<br>	&#125;<br>	<span class="hljs-comment">//向线性表中添加元素t</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(T t)</span> &#123;<br>		<span class="hljs-keyword">if</span>(N==eles.length) &#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;当前表已满&quot;</span>);<br>		&#125;<br>		eles[N++]=t;<br>	&#125;<br>	<span class="hljs-comment">//向线性表的指定位置添加元素</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i,T t)</span> &#123;<br>		<span class="hljs-keyword">if</span>(N==eles.length) &#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;当前表已满&quot;</span>);<br>			<br>		&#125;<br>		<span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>||i&gt;N) &#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;插入的位置不合法&quot;</span>);<br>		&#125;<br>		<span class="hljs-comment">//记录最后一位的值</span><br>		T last=eles[N-<span class="hljs-number">1</span>];<br>		<span class="hljs-comment">//先把i索引处的元素及其后面的元素依次向后移一位</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> index=N;index&gt;i;index--) &#123;<br>			eles[index]=eles[index-<span class="hljs-number">1</span>];<br>		&#125;<br>		<span class="hljs-comment">//再把t元素放到i索引处即可</span><br>		eles[i]=t;<br>		N++;<br>	&#125;<br>	<span class="hljs-comment">//删除指定索引处的元素，并返回该元素</span><br>	<span class="hljs-keyword">public</span> T <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>		<span class="hljs-comment">//记录索引处的值</span><br>		T current=eles[i];<br>		<span class="hljs-comment">//索引i后面元素依次向前移动一位即可</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> m=i;m&lt;N-<span class="hljs-number">1</span>;m++) &#123;<br>		eles[m]=eles[m+<span class="hljs-number">1</span>];<br>		&#125;<br>		<span class="hljs-comment">//元素个数减一</span><br>		N--;<br>		<span class="hljs-keyword">return</span> current;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(T t)</span> &#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++) &#123;<br>			<span class="hljs-keyword">if</span>(eles[i].equals(t)) &#123;<br>				<span class="hljs-keyword">return</span> i;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span> &#123;<br>		<span class="hljs-comment">//创建顺序表对象</span><br>		<br><br>		SequenceList&lt;String&gt; s1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SequenceList</span>&lt;&gt;(<span class="hljs-number">10</span>); <br>		<span class="hljs-comment">//测试插入</span><br>		s1.insert(<span class="hljs-string">&quot;姚明&quot;</span>);<br>		s1.insert(<span class="hljs-string">&quot;科比&quot;</span>);<br>		s1.insert(<span class="hljs-string">&quot;麦迪&quot;</span>);<br>		s1.insert(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;艾弗森&quot;</span>);<br>		<br>		<span class="hljs-comment">//测试获取</span><br>		String getResult1=s1.get(<span class="hljs-number">1</span>);<br>		System.out.println(getResult1);<br>		<span class="hljs-comment">//测试删除</span><br>		String removeResult=s1.remove(<span class="hljs-number">0</span>);<br>		System.out.println(removeResult);<br>		<span class="hljs-comment">//测试清空</span><br>		s1.clear();<br>		System.out.println(<span class="hljs-string">&quot;清空后的线性表中的元素个数&quot;</span>+s1.length());<br>		System.out.println(s1.get(<span class="hljs-number">1</span>));<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>这里对这个clear有个疑问</strong></p>
<p><strong>顺序表的遍历</strong></p>
<p>在java中，遍历集合的方式一般都是用的是foreach循环，如果想让我们的SequenceList也能支持foreach循环，则 需要做如下操作：</p>
<p> 1.让SequenceList实现Iterable接口，重写iterator方法； </p>
<p>2.在SequenceList内部提供一个内部类SIterator,实现Iterator接口，重写hasNext方法和next方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SequenceList</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt;&#123;<br><span class="hljs-comment">//存储元素的数组</span><br>	<span class="hljs-keyword">private</span> T[] eles;<br>	<span class="hljs-comment">//记录当前顺序表中元素的个数</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br>	<br><br>	<span class="hljs-comment">//构造方法</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">SequenceList</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span><br>	&#123;<br>		<span class="hljs-comment">//初始化数据</span><br>		<span class="hljs-built_in">this</span>.eles=(T[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];<br>		<span class="hljs-built_in">this</span>.N=<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//将一个线性表置为空表</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-built_in">this</span>.N=<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//判断当前线性表是否为空表</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> N==<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//获取线性表的长度</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> N;<br>	&#125;<br>	<span class="hljs-comment">//获取指定位置的元素</span><br>	<span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>		<span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>||i&gt;=N) &#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;当前元素不存在&quot;</span>);<br>		&#125;<br>		<span class="hljs-keyword">return</span> eles[i];<br>	&#125;<br>	<span class="hljs-comment">//向线性表中添加元素t</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(T t)</span> &#123;<br>		<span class="hljs-keyword">if</span>(N==eles.length) &#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;当前表已满&quot;</span>);<br>		&#125;<br>		eles[N++]=t;<br>	&#125;<br>	<span class="hljs-comment">//向线性表的指定位置添加元素</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i,T t)</span> &#123;<br>		<span class="hljs-keyword">if</span>(i==eles.length) &#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;当前表已满&quot;</span>);<br>			<br>		&#125;<br>		<span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>||i&gt;N) &#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;插入的位置不合法&quot;</span>);<br>		&#125;<br>		<span class="hljs-comment">//记录最后一位的值</span><br>		T last=eles[N-<span class="hljs-number">1</span>];<br>		<span class="hljs-comment">//先把i索引处的元素及其后面的元素依次向后移一位</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> index=N;index&gt;i;index--) &#123;<br>			eles[index]=eles[index-<span class="hljs-number">1</span>];<br>		&#125;<br>		<span class="hljs-comment">//再把t元素放到i索引处即可</span><br>		eles[i]=t;<br>		N++;<br>	&#125;<br>	<span class="hljs-comment">//删除指定索引处的元素，并返回该元素</span><br>	<span class="hljs-keyword">public</span> T <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>		<span class="hljs-comment">//记录索引处的值</span><br>		T current=eles[i];<br>		<span class="hljs-comment">//索引i后面元素依次向前移动一位即可</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> m=i;m&lt;N-<span class="hljs-number">1</span>;m++) &#123;<br>		eles[m]=eles[m+<span class="hljs-number">1</span>];<br>		&#125;<br>		<span class="hljs-comment">//元素个数减一</span><br>		N--;<br>		<span class="hljs-keyword">return</span> current;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(T t)</span> &#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++) &#123;<br>			<span class="hljs-keyword">if</span>(eles[i].equals(t)) &#123;<br>				<span class="hljs-keyword">return</span> i;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">// TODO Auto-generated method stub</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SIterator</span>();<br>	&#125;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cusor;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">SIterator</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-built_in">this</span>.cusor=<span class="hljs-number">0</span>;<br>&#125;<br>		<span class="hljs-meta">@Override</span><br>		<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-comment">// TODO Auto-generated method stub</span><br>			<span class="hljs-keyword">return</span> cusor&lt;N;<br>		&#125;<br><br>		<span class="hljs-meta">@Override</span><br>		<span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-comment">// TODO Auto-generated method stub</span><br>			<span class="hljs-keyword">return</span> eles[cusor++];<br>		&#125;<br>		<br>	&#125;<br><br><br>​	<br>&#125;<br></code></pre></td></tr></table></figure>


<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span> &#123;<br>		<span class="hljs-comment">//创建顺序表对象</span><br>		<br><br>		SequenceList&lt;String&gt; s1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SequenceList</span>&lt;&gt;(<span class="hljs-number">10</span>); <br>		<span class="hljs-comment">//测试插入</span><br>		s1.insert(<span class="hljs-string">&quot;姚明&quot;</span>);<br>		s1.insert(<span class="hljs-string">&quot;科比&quot;</span>);<br>		s1.insert(<span class="hljs-string">&quot;麦迪&quot;</span>);<br>		s1.insert(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;艾弗森&quot;</span>);<br>		<br>		<span class="hljs-comment">//测试循环</span><br>		<span class="hljs-keyword">for</span>(String s3:s1) &#123;<br>			System.out.println(s3);<br>		&#125;<br>		System.out.println(<span class="hljs-string">&quot;-----------------------------------------&quot;</span>);<br>		Iterator it=s1.iterator();<br>		<span class="hljs-keyword">while</span>(it.hasNext()) &#123;<br>			System.out.println(it.next());<br>		&#125;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>顺序表的容量可变</strong></p>
<p>添加元素时，应该检查当前数组的大小是否能容纳新的元素，如果不能容纳，则需要创建新的容量更大的数组，我 们这里创建一个是原数组两倍容量的新数组存储元素。</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656807.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220731154207090"></p>
<p>移除元素时，应该检查当前数组的大小是否太大，比如正在用100个容量的数组存储10个元素，这样就会造成内存 空间的浪费，应该创建一个容量更小的数组存储元素。如果我们发现数据元素的数量不足数组容量的1&#x2F;4，则创建 一个是原数组容量的1&#x2F;2的新数组存储元素。</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656808.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220731154308585"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SequenceList</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt;&#123;<br><span class="hljs-comment">//存储元素的数组</span><br>	<span class="hljs-keyword">private</span> T[] eles;<br>	<span class="hljs-comment">//记录当前顺序表中元素的个数</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br>	<br><br>	<span class="hljs-comment">//构造方法</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">SequenceList</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span><br>	&#123;<br>		<span class="hljs-comment">//初始化数据</span><br>		<span class="hljs-built_in">this</span>.eles=(T[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];<br>		<span class="hljs-built_in">this</span>.N=<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//将一个线性表置为空表</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-built_in">this</span>.N=<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//判断当前线性表是否为空表</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> N==<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//获取线性表的长度</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> N;<br>	&#125;<br>	<span class="hljs-comment">//获取指定位置的元素</span><br>	<span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>		<span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>||i&gt;=N) &#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;当前元素不存在&quot;</span>);<br>		&#125;<br>		<span class="hljs-keyword">return</span> eles[i];<br>	&#125;<br>	<span class="hljs-comment">//向线性表中添加元素t</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(T t)</span> &#123;<br>		<span class="hljs-keyword">if</span>(N==eles.length) &#123;<br>			resize(<span class="hljs-number">2</span>*eles.length);<br>		&#125;<br>		eles[N++]=t;<br>	&#125;<br>	<span class="hljs-comment">//向线性表的指定位置添加元素</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i,T t)</span> &#123;<br>		<span class="hljs-keyword">if</span>(N==eles.length) &#123;<br>			resize(<span class="hljs-number">2</span>*eles.length);<br>		&#125;<br>		<span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>||i&gt;N) &#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;插入的位置不合法&quot;</span>);<br>		&#125;<br>		<span class="hljs-comment">//记录最后一位的值</span><br>		T last=eles[N-<span class="hljs-number">1</span>];<br>		<span class="hljs-comment">//先把i索引处的元素及其后面的元素依次向后移一位</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> index=N;index&gt;i;index--) &#123;<br>			eles[index]=eles[index-<span class="hljs-number">1</span>];<br>		&#125;<br>		<span class="hljs-comment">//再把t元素放到i索引处即可</span><br>		eles[i]=t;<br>		N++;<br>	&#125;<br>	<span class="hljs-comment">//删除指定索引处的元素，并返回该元素</span><br>	<span class="hljs-keyword">public</span> T <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>		<span class="hljs-comment">//记录索引处的值</span><br>		T current=eles[i];<br>		<span class="hljs-comment">//索引i后面元素依次向前移动一位即可</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> m=i;m&lt;N-<span class="hljs-number">1</span>;m++) &#123;<br>		eles[m]=eles[m+<span class="hljs-number">1</span>];<br>		&#125;<br>		<span class="hljs-comment">//元素个数减一</span><br>		N--;<br>		<span class="hljs-keyword">if</span>(N&lt;eles.length/<span class="hljs-number">4</span>) &#123;<br>			resize(eles.length/<span class="hljs-number">2</span>);<br>		&#125;<br>		<span class="hljs-keyword">return</span> current;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(T t)</span> &#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++) &#123;<br>			<span class="hljs-keyword">if</span>(eles[i].equals(t)) &#123;<br>				<span class="hljs-keyword">return</span> i;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>	&#125;<br>	<br>	<span class="hljs-comment">//根据参数newSize，重置eles的大小</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">(<span class="hljs-type">int</span> newSize)</span> &#123;<br>		<span class="hljs-comment">//定义一个临时数组，指向原数组</span><br>		T[] temp=eles;<br>		<span class="hljs-comment">//创建新数组</span><br>		eles=(T[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[newSize];<br>		<span class="hljs-comment">//吧原数组中的内容拷贝到新数组中</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++) &#123;<br>			eles[i]=temp[i];<br>		&#125;<br>	&#125;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">// TODO Auto-generated method stub</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SIterator</span>();<br>	&#125;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cusor;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">SIterator</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-built_in">this</span>.cusor=<span class="hljs-number">0</span>;<br>&#125;<br>		<span class="hljs-meta">@Override</span><br>		<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-comment">// TODO Auto-generated method stub</span><br>			<span class="hljs-keyword">return</span> cusor&lt;N;<br>		&#125;<br><br>		<span class="hljs-meta">@Override</span><br>		<span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-comment">// TODO Auto-generated method stub</span><br>			<span class="hljs-keyword">return</span> eles[cusor++];<br>		&#125;<br>		<br>	&#125;<br><br><br>​	<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> []args</span>) &#123;<br>		<span class="hljs-title class_">SequenceList</span>&lt;<span class="hljs-title class_">String</span>&gt; s1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SequenceList</span>&lt;<span class="hljs-title class_">String</span>&gt;(<span class="hljs-number">1</span>);<br>		s1.<span class="hljs-title function_">insert</span>(<span class="hljs-string">&quot;张三&quot;</span>);<br>		s1.<span class="hljs-title function_">insert</span>(<span class="hljs-string">&quot;李四&quot;</span>);<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(s1.<span class="hljs-title function_">length</span>());<br>	&#125;<br>&#125;<br>结果为<span class="hljs-number">2</span><br><br></code></pre></td></tr></table></figure>

<p><strong>顺序表的时间复杂度</strong></p>
<p>get(i):不难看出，不论数据元素量N有多大，只需要一次eles[i]就可以获取到对应的元素，所以时间复杂度为O(1);</p>
<p> insert(int i,T t):每一次插入，都需要把i位置后面的元素移动一次，随着元素数量N的增大，移动的元素也越多，时 间复杂为O(n); </p>
<p>remove(int i):每一次删除，都需要把i位置后面的元素移动一次，随着数据量N的增大,移动的元素也越多，时间复 杂度为O(n); </p>
<p>由于顺序表的底层由数组实现，数组的长度是固定的，所以在操作的过程中涉及到了容器扩容操作。这样会导致顺 序表在使用过程中的时间复杂度不是线性的，在某些需要扩容的结点处，耗时会突增，尤其是元素越多，这个问题 越明显</p>
<p><strong>java中ArrayList的实现</strong></p>
<p>java中ArrayList集合的底层也是一种顺序表，使用数组实现，同样提供了增删改查以及扩容等功能。</p>
<p> 1.是否用数组实现； </p>
<p>2.有没有扩容操作；</p>
<p> 3.有没有提供遍历方式；</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>之前，顺序表的查询很快，但是增删的效率是比较低的，每次修改伴随大量数据元素移动，这些都是因为他们元素的内存地址是连续的</p>
<p>链表：物理存储单元不是连续的，链表由一系列的结点组成，节点可以在运行时动态生成</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656809.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220731162517790"></p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656810.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220731162527466"></p>
<p>插入数据就是把11和13之间的链断开，将11和22连接再将22和13连接</p>
<p>删除数据就是把11直接指向12</p>
<p>结点API设计</p>
<p>构造方法：Node(T t,Node next)：创建Node对象</p>
<p>成员变量：T item:存储数据 </p>
<p>​                   Node next：指向下一个结点</p>
<p>基本链表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;T&gt;&#123;<br>	<span class="hljs-comment">//存储元素</span><br>	<span class="hljs-keyword">public</span> T item;<br>	<span class="hljs-comment">//指向下一个节点</span><br>	<span class="hljs-keyword">public</span> Node next;<br>	<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(T item,Node next)</span> &#123;<br>		<span class="hljs-built_in">this</span>.item=item;<br>		<span class="hljs-built_in">this</span>.next=next;<br>	&#125;<br><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span> &#123;<br>		<span class="hljs-comment">//构建结点</span><br>		Node&lt;Integer&gt; first=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;Integer&gt;(<span class="hljs-number">11</span>,<span class="hljs-literal">null</span>);<br>		Node&lt;Integer&gt; second=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;Integer&gt;(<span class="hljs-number">13</span>,<span class="hljs-literal">null</span>);<br>		Node&lt;Integer&gt; third=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;Integer&gt;(<span class="hljs-number">12</span>,<span class="hljs-literal">null</span>);<br>		Node&lt;Integer&gt; fourth=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;Integer&gt;(<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>);<br>		Node&lt;Integer&gt; fifth=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;Integer&gt;(<span class="hljs-number">9</span>,<span class="hljs-literal">null</span>);<br>		<br><br>		<span class="hljs-comment">//生成链表</span><br>		first.next=second;<br>		second.next=third;<br>		third.next=fourth;<br>		fourth.next=fifth;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><p>单向链表是链表的一种，它由多个结点组成，每个结点都是由一个数据域和一个指针域组成，数据域用来存储数据，指针域用来指向其后结点，链表的头节点数据与不存储数据，指针域指向第一个真正存储数据的结点</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656811.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220731171744874"></p>
<p>构造方法：LinkList()：创建LinkList对象</p>
<p><strong>单向链表的API设计</strong></p>
<p>下面这些i都是指索引的意思，就是第一个有data的结点索引是0</p>
<p>1.public void clear()：空置线性表 </p>
<p> 2.publicboolean isEmpty()：判断线性表是否为空，是返回true，否返回false </p>
<p>3.public int length():获取线性表中元素的个数 </p>
<p>4.public T get(int i):读取并返回线性表中的第i个元素的值 </p>
<p>5.public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。 </p>
<p>6.public void insert(T t):向线性表中添加一个元素t </p>
<p>7.public T remove(int i):删除并返回线性表中第i个数据元素。 </p>
<p>8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返 回-1。</p>
<p>成员内部类：private class Node<T>  结点类</p>
<p>成员变量：1.private Node head 记录首结点</p>
<p>​                     2.private int N 记录链表的长度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkList</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt;&#123;<br>	<br>	<span class="hljs-comment">//记录头节点</span><br>	<span class="hljs-keyword">private</span> Node head;<br>	<span class="hljs-comment">//记录链表的长度</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br>	<span class="hljs-comment">//结点类</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;T&gt;&#123;<br>		<span class="hljs-comment">//存储数据</span><br>		T item;<br>		<span class="hljs-comment">//下一个结点</span><br>		Node next;<br>		<br>		<span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(T item,Node next)</span> &#123;<br>			<span class="hljs-built_in">this</span>.item=item;<br>			<span class="hljs-built_in">this</span>.next=next;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkList</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">//创建头结点</span><br>		<span class="hljs-built_in">this</span>.head=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>);<br>		<span class="hljs-comment">//初始化元素个数</span><br>		<span class="hljs-built_in">this</span>.N=<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//清空链表</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>		head.next=<span class="hljs-literal">null</span>;<br>		<span class="hljs-built_in">this</span>.N=<span class="hljs-number">0</span>;<br>	&#125;<br>	<br>	<span class="hljs-comment">//获取链表的长度</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> N;<br>&#125;<br>	<span class="hljs-comment">//判断链表是否为空</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> N==<span class="hljs-number">0</span>;<br>	&#125;<br>	<br>	<span class="hljs-comment">//获取指定位置i处的元素</span><br>	<span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>		Node&lt;T&gt; m=head.next;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;n&lt;i;n++) &#123;<br>			<span class="hljs-comment">//通过循环，从头结点开始往后找，依次找i次，就可以找到对应的元素</span><br>			m=m.next;<br>		&#125;<br>		<span class="hljs-keyword">return</span>  m.item;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(T item)</span> &#123;<br>		<span class="hljs-comment">//找到当前最后一个结点</span><br>		Node n=head;<br>		<span class="hljs-keyword">while</span>(n.next!=<span class="hljs-literal">null</span>) &#123;<br>			n=n.next;<br>		&#125;<br>		<span class="hljs-comment">//创建新结点，保存元素t</span><br>		Node&lt;T&gt; newNode=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(item,<span class="hljs-literal">null</span>);<br>		<span class="hljs-comment">//让当前最后一个结点指向新结点</span><br>		n.next=newNode;<br>		<span class="hljs-comment">//元素的个数+1</span><br>		N++;<br>	&#125;<br>	<span class="hljs-comment">//向指定的位置i处添加新元素</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(T item,<span class="hljs-type">int</span> i)</span> &#123;<br>	<span class="hljs-comment">//找到i位置前一个结点</span><br>		Node n=head;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> index=<span class="hljs-number">0</span>;index&lt;=i-<span class="hljs-number">1</span>;index++) &#123;<br>			n=n.next;<br>		&#125;<br>		<br>		<span class="hljs-comment">//找到i位置的结点</span><br>		Node curr=n.next;<br>		<span class="hljs-comment">//创建新结点，并且·新结点需要指向原来i位置的结点</span><br>		Node newNode=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(item,curr);<br>		<span class="hljs-comment">//原来i位置的前一个结点指向新结点即可</span><br>		n.next=newNode;<br>		<span class="hljs-comment">//元素的个数加一</span><br>		N++;<br>		&#125;<br>	<span class="hljs-comment">//删除指定位置i的元素，并返回被删除的元素</span><br>	<span class="hljs-keyword">public</span> T <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br><span class="hljs-comment">//找到i前一个位置的结点</span><br>		Node&lt;T&gt; n=head;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> index=<span class="hljs-number">0</span>;index&lt;=i-<span class="hljs-number">1</span>;index++) &#123;<br>			n=n.next;<br>		&#125;<br>		<span class="hljs-comment">//找到i位置这个节点</span><br>		Node curr=n.next;<br>		<span class="hljs-comment">//找到i位置之后这个结点</span><br>		Node last=curr.next;<br>		<span class="hljs-comment">//将i位置之前的这个结点指向i位置之后这个结点</span><br>		n.next=last;<br>		<span class="hljs-comment">//元素数目-1</span><br>		N--;<br>		<span class="hljs-keyword">return</span> get(i);<br>		<br>	&#125;<br>	<span class="hljs-comment">//查找元素t在链表中第一次出现的位置</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(T t)</span> &#123;<br>		Node&lt;T&gt; n=head;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;n.next!=<span class="hljs-literal">null</span>;i++) &#123;<br>			<span class="hljs-keyword">if</span>(n.next.item.equals(t)) &#123;<br>				<span class="hljs-keyword">return</span> i;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>		<br>	&#125;<br>	<span class="hljs-comment">//实现遍历</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&#123;<br><br>    	<span class="hljs-keyword">private</span> Node n;<br>    	<span class="hljs-keyword">public</span> <span class="hljs-title function_">SIterator</span><span class="hljs-params">()</span> &#123;<br>    		<span class="hljs-built_in">this</span>.n=head;<br>    	&#125;<br>		<span class="hljs-meta">@Override</span><br>		<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">return</span> n.next!=<span class="hljs-literal">null</span>;<br>		&#125;<br><br>		<span class="hljs-meta">@Override</span><br>		<span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>			n=n.next;<br>			<span class="hljs-keyword">return</span> n.item;<br>		&#125;<br>    	<br>    &#125;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">// TODO Auto-generated method stub</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SIterator</span>();<span class="hljs-comment">//有点不理解应该是&lt;T&gt;泛型的Iterator对象，但这个不是也行啊</span><br>	&#125;<br><br><br>	&#125;<br><span class="hljs-comment">//有了Itreable的实现才能用遍历for(String s:s1)这个</span><br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span> []args) &#123;<br>		<span class="hljs-comment">//创建顺序表对象</span><br>		<br><br>		LinkList&lt;<span class="hljs-keyword">String</span>&gt; s1=<span class="hljs-keyword">new</span> <span class="hljs-type">LinkList</span>&lt;<span class="hljs-keyword">String</span>&gt;(); <br>		<span class="hljs-comment">//测试插入</span><br>		s1.insert(<span class="hljs-string">&quot;姚明&quot;</span>);<br>		s1.insert(<span class="hljs-string">&quot;科比&quot;</span>);<br>		s1.insert(<span class="hljs-string">&quot;麦迪&quot;</span>);<br>		s1.insert(<span class="hljs-string">&quot;艾弗森&quot;</span>,<span class="hljs-number">1</span>);<br>		<br>		<span class="hljs-comment">//测试获取</span><br>		<span class="hljs-keyword">String</span> getResult1=s1.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);<br>		System.out.println(getResult1);<br>		<span class="hljs-comment">//测试删除</span><br>		<span class="hljs-keyword">String</span> removeResult=s1.remove(<span class="hljs-number">0</span>);<br>		System.out.println(removeResult);<br>		<span class="hljs-comment">//测试清空</span><br>		s1.clear();<br>		System.out.println(<span class="hljs-string">&quot;清空后的线性表中的元素个数&quot;</span>+s1.length());<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>每个结点都由一个数据域和两个指针域组成，数据域用来存放数据，其中一个指针域用来指向其后继结点，另一个指针域用来指向前驱结点。</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656812.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220731195546388"></p>
<p><strong>结点API设计</strong></p>
<p>构造方法：Node(T t,Node pre,Node next)：创建Node对象</p>
<p>成员变量：T item:存储数据 </p>
<p>​                   Node next：指向下一个结点 </p>
<p>​                   Node pre:指向上一个结点</p>
<p><strong>双向链表API设计</strong></p>
<p>成员变量：1.private Node first:记录首结点 </p>
<p>2.private Node last:记录尾结点 </p>
<p>3.private int N:记录链表的长度</p>
<p>成员内部类：private class Node<T></p>
<p>1.public void clear()：空置线性表 </p>
<p> 2.publicboolean isEmpty()：判断线性表是否为空，是返回true，否返回false </p>
<p>3.public int length():获取线性表中元素的个数 </p>
<p>4.public T get(int i):读取并返回线性表中的第i个元素的值 </p>
<p>5.public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。 </p>
<p>6.public void insert(T t):向线性表中添加一个元素t </p>
<p>7.public T remove(int i):删除并返回线性表中第i个数据元素。 </p>
<p>8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返 回-1。</p>
<p>9.public T getFirst():获取第一个元素</p>
<p>10.public T getLast():获取最后一个元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TowWayLinkList</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt; &#123;<br>	<span class="hljs-comment">//首结点</span><br>	<span class="hljs-keyword">private</span> Node head;<br>	<span class="hljs-comment">//最后一个结点</span><br>	<span class="hljs-keyword">private</span> Node last;<br>	<br>	<span class="hljs-comment">//链表的长度</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br>	<br>	<span class="hljs-comment">//结点类</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>		<span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(T item,Node pre,Node next)</span> &#123;<br>			<span class="hljs-built_in">this</span>.item=item;<br>			<span class="hljs-built_in">this</span>.pre=pre;<br>			<span class="hljs-built_in">this</span>.next=next;<br>		&#125;<br>		<span class="hljs-comment">//存储数据</span><br>		<span class="hljs-keyword">public</span> T item;<br>		<span class="hljs-comment">//指向上一个结点</span><br>		<span class="hljs-keyword">public</span> Node pre;<br>		<span class="hljs-comment">//指向下一个结点</span><br>		<span class="hljs-keyword">public</span> Node next;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">TowWayLinkList</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-built_in">this</span>.head=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>);<br>		<span class="hljs-built_in">this</span>.last=<span class="hljs-literal">null</span>;<span class="hljs-comment">//刚开始是没有尾节点的</span><br>		<span class="hljs-comment">//初始化元素个数</span><br>		<span class="hljs-built_in">this</span>.N=<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//清空列表</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-built_in">this</span>.head.next=<span class="hljs-literal">null</span>;<br>		<span class="hljs-built_in">this</span>.head.pre=<span class="hljs-literal">null</span>;<br>		<span class="hljs-built_in">this</span>.N=<span class="hljs-number">0</span>;<br>	&#125; <br>	<span class="hljs-comment">//获取链表的长度</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> N;<br>	&#125;<br>	<span class="hljs-comment">//判断链表是否为空</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> N==<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//获取第一个元素</span><br>	<span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">if</span>(isEmpty()) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>		&#125;<br>		<span class="hljs-keyword">return</span> head.next.item;<br>	&#125;<br>	<span class="hljs-comment">//获取最后一个元素</span><br>	<span class="hljs-keyword">public</span> T <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">if</span>(isEmpty()) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>		&#125;<br>		<span class="hljs-keyword">return</span> last.item;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(T item)</span> &#123;<br>		<span class="hljs-keyword">if</span>(isEmpty()) &#123;<br>		<span class="hljs-comment">//如果我们的链表为空</span><br>		Node n=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(item,head,<span class="hljs-literal">null</span>);<span class="hljs-comment">//因为是第一个插入的没有尾节点自己就是，所以第三个参数为null</span><br>		<span class="hljs-comment">//我们需要让新结点为尾节点</span><br>		last=n;<br>		<span class="hljs-comment">//让头结点指向尾节点</span><br>		head.next=last;<br>		&#125;<br>		<span class="hljs-keyword">else</span><br>		&#123;		<span class="hljs-comment">//如果我们的链表不为空3</span><br>			Node oldlast=last;<br>			<span class="hljs-comment">//创建新的节点</span><br>			Node n=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(item,oldlast,<span class="hljs-literal">null</span>);<br>			<span class="hljs-comment">//让老尾节点指向新结点</span><br>		    oldlast.next=n;<br>		    <span class="hljs-comment">//让新结点成为尾结点</span><br>		    last=n;<br>		&#125;<br>		<span class="hljs-comment">//元素个数加一</span><br>		N++;<br><br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i,T t)</span> &#123;<br>		<span class="hljs-comment">//找到i位置前的一个结点</span><br>		Node pre=head;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> index=<span class="hljs-number">0</span>;index&lt;=i-<span class="hljs-number">1</span>;index++) &#123;<br>			pre=pre.next;<br>		&#125;<br>		<span class="hljs-comment">//找到i位置的一个结点</span><br>		Node curr=pre.next;<br>		<span class="hljs-comment">//创建新结点</span><br>		Node newNode=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(t,pre,curr);<br>		<span class="hljs-comment">//让i位置的前一个结点的下一个结点为新结点</span><br>		pre.next=newNode;<br>		<span class="hljs-comment">//让i位置的前一个结点为新结点</span><br>		curr.pre=newNode;<br>		<span class="hljs-comment">//元素的个数加一</span><br>		N++;<br>	&#125;<br>	<span class="hljs-comment">//获取指定位置i处的元素</span><br>	<span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>		Node n=head;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> index=<span class="hljs-number">0</span>;index&lt;=i;index++) &#123;<br>			n=n.next;<br>		&#125;<br>		<span class="hljs-keyword">return</span> n.item;<br>	&#125;<br>		<span class="hljs-comment">//找到元素t在链表中第一次出现的位置</span><br>		<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(T t)</span> &#123;<br>			Node n=head;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;n.next!=<span class="hljs-literal">null</span>;i++) &#123;<br>				n=n.next;<br>				<span class="hljs-keyword">if</span>(n.item.equals(t)) &#123;<br>					<span class="hljs-keyword">return</span> i;<br>				&#125;<br>				<br>			&#125;<br>			<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>		&#125;<br>		<span class="hljs-keyword">public</span> T <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>			<span class="hljs-comment">//找到i位置的前一个结点</span><br>			Node n=head;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> index=<span class="hljs-number">0</span>;index&lt;=i-<span class="hljs-number">1</span>;index++) &#123;<br>			n=n.next;<br>			&#125;<br>			<span class="hljs-comment">//找到i位置结点</span><br>			Node curr=n.next;<br>			<span class="hljs-comment">//找到i位置后一个结点</span><br>			Node last=curr.next;<br>			<span class="hljs-comment">//让i位置后一个结点的上一个结点是i位置的前一个结点</span><br>			last.pre=n;<br>			<span class="hljs-comment">//然i位置前一个结点的下一个结点是i位置的后一个结点</span><br>			n.next=last;<br>			<span class="hljs-comment">//减少一个元素</span><br>			N--;<br>			<span class="hljs-keyword">return</span> curr.item;<br>		&#125;<br>		<span class="hljs-meta">@Override</span><br>		<span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-comment">// TODO Auto-generated method stub</span><br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>		&#125;<br>		<span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SIterator</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;T&gt;&#123;<br>                     <span class="hljs-keyword">private</span> Node n=head;<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>				<span class="hljs-comment">// TODO Auto-generated method stub</span><br>				<span class="hljs-keyword">return</span> n.next!=<span class="hljs-literal">null</span>;<br>			&#125;<br><br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-keyword">public</span> T <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>				n=n.next;<br>                 <span class="hljs-keyword">return</span> (T)n.item;<br>			&#125;<br>			<br>		&#125;<br>	&#125;<br><br>注意点：上面添加元素时之所以只有一个方向的指向是因为在创建那个元素的时候就已经规定了另外一个方向了<br><br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Main&#123;<br>	<span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String []args) &#123;<br>		//创建顺序表对象<br>		<br><br>		TowWayLinkList&lt;String&gt; s1=<span class="hljs-built_in">new</span> TowWayLinkList&lt;String&gt;(); <br>		//测试插入<br>		s1.<span class="hljs-keyword">insert</span>(&quot;姚明&quot;);<br>		s1.<span class="hljs-keyword">insert</span>(&quot;科比&quot;);<br>		s1.<span class="hljs-keyword">insert</span>(&quot;麦迪&quot;);<br>		s1.<span class="hljs-keyword">insert</span>(<span class="hljs-number">1</span>,&quot;艾弗森&quot;);<br>		//测试获取<br>		String getResult1=s1.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);<br>		<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(getResult1);<br>		//测试删除<br>		String removeResult=s1.remove(<span class="hljs-number">0</span>);<br>		<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(removeResult);<br>		<br>		//测试方法<br>		<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;第一个元素是&quot;+s1.getFirst());<br>		<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;最后一个元素是&quot;+s1.getLast());<br>		//测试清空<br>		s1.clear();<br>		<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;清空后的线性表中的元素个数&quot;+s1.length());<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>1.2.2.4 java中LinkedList实现</strong> </p>
<p>java中LinkedList集合也是使用双向链表实现，并提供了增删改查等相关方法 </p>
<p>1.底层是否用双向链表实现； </p>
<p>2.结点类是否有三个域</p>
<p><strong>链表的复杂度分析</strong></p>
<p>最坏情况</p>
<p>get(int i):可能会找N次           复杂度为O(n)</p>
<p>insert(int i,T t):要找到位置的前一个元素，所以复杂度也为O(n)</p>
<p>remove(int i):找到i位置的结点，所以复杂度也为O(n)</p>
<p>相比较顺序表，链表插入和删除的时间复杂度和他一样，但链表有优势，不需要提前指定存储空间大小，并且没有涉及元素的交换</p>
<p>相比较顺序表，链表的查询操作性能会比较低，所以查询操作多使用顺序表，增删操作多，使用链表</p>
<h3 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h3><p>单链表的反转</p>
<p>添加两个方法：</p>
<p>反转API： public void reverse()：对整个链表反转</p>
<p> public Node reverse(Node curr)：反转链表中的某个结点curr,并把反转后的curr结点返回</p>
<p>原链表：</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656813.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220801090443066"></p>
<p>反转之后是head指向4指向3指向2指向1</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656814.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220801090717283"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Main;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkList</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt;&#123;<br>	<br>	<span class="hljs-comment">//记录头节点</span><br>	<span class="hljs-keyword">private</span> Node head;<br>	<span class="hljs-comment">//记录链表的长度</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br>	<span class="hljs-comment">//结点类</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;T&gt;&#123;<br>		<span class="hljs-comment">//存储数据</span><br>		T item;<br>		<span class="hljs-comment">//下一个结点</span><br>		Node next;<br>		<br>		<span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(T item,Node next)</span> &#123;<br>			<span class="hljs-built_in">this</span>.item=item;<br>			<span class="hljs-built_in">this</span>.next=next;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkList</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">//创建头结点</span><br>		<span class="hljs-built_in">this</span>.head=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>);<br>		<span class="hljs-comment">//初始化元素个数</span><br>		<span class="hljs-built_in">this</span>.N=<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//清空链表</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>		head.next=<span class="hljs-literal">null</span>;<br>		<span class="hljs-built_in">this</span>.N=<span class="hljs-number">0</span>;<br>	&#125;<br>	<br>	<span class="hljs-comment">//获取链表的长度</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> N;<br>&#125;<br>	<span class="hljs-comment">//判断链表是否为空</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> N==<span class="hljs-number">0</span>;<br>	&#125;<br>	<br>	<span class="hljs-comment">//获取指定位置i处的元素</span><br>	<span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>		Node&lt;T&gt; m=head.next;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;n&lt;i;n++) &#123;<br>			<span class="hljs-comment">//通过循环，从头结点开始往后找，依次找i次，就可以找到对应的元素</span><br>			m=m.next;<br>		&#125;<br>		<span class="hljs-keyword">return</span>  m.item;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(T item)</span> &#123;<br>		<span class="hljs-comment">//找到当前最后一个结点</span><br>		Node n=head;<br>		<span class="hljs-keyword">while</span>(n.next!=<span class="hljs-literal">null</span>) &#123;<br>			n=n.next;<br>		&#125;<br>		<span class="hljs-comment">//创建新结点，保存元素t</span><br>		Node&lt;T&gt; newNode=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(item,<span class="hljs-literal">null</span>);<br>		<span class="hljs-comment">//让当前最后一个结点指向新结点</span><br>		n.next=newNode;<br>		<span class="hljs-comment">//元素的个数+1</span><br>		N++;<br>	&#125;<br>	<span class="hljs-comment">//向指定的位置i处添加新元素</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(T item,<span class="hljs-type">int</span> i)</span> &#123;<br>	<span class="hljs-comment">//找到i位置前一个结点</span><br>		Node n=head;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> index=<span class="hljs-number">0</span>;index&lt;=i-<span class="hljs-number">1</span>;index++) &#123;<br>			n=n.next;<br>		&#125;<br>		<br>		<span class="hljs-comment">//找到i位置的结点</span><br>		Node curr=n.next;<br>		<span class="hljs-comment">//创建新结点，并且·新结点需要指向原来i位置的结点</span><br>		Node newNode=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(item,curr);<br>		<span class="hljs-comment">//原来i位置的前一个结点指向新结点即可</span><br>		n.next=newNode;<br>		<span class="hljs-comment">//元素的个数加一</span><br>		N++;<br>		&#125;<br>	<span class="hljs-comment">//删除指定位置i的元素，并返回被删除的元素</span><br>	<span class="hljs-keyword">public</span> T <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br><span class="hljs-comment">//找到i前一个位置的结点</span><br>		Node&lt;T&gt; n=head;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> index=<span class="hljs-number">0</span>;index&lt;=i-<span class="hljs-number">1</span>;index++) &#123;<br>			n=n.next;<br>		&#125;<br>		<span class="hljs-comment">//找到i位置这个节点</span><br>		Node curr=n.next;<br>		<span class="hljs-comment">//找到i位置之后这个结点</span><br>		Node last=curr.next;<br>		<span class="hljs-comment">//将i位置之前的这个结点指向i位置之后这个结点</span><br>		n.next=last;<br>		<span class="hljs-comment">//元素数目-1</span><br>		N--;<br>		<span class="hljs-keyword">return</span> get(i);<br>		<br>	&#125;<br>	<span class="hljs-comment">//查找元素t在链表中第一次出现的位置</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(T t)</span> &#123;<br>		Node&lt;T&gt; n=head;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;n.next!=<span class="hljs-literal">null</span>;i++) &#123;<br>			<span class="hljs-keyword">if</span>(n.next.item.equals(t)) &#123;<br>				<span class="hljs-keyword">return</span> i;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>		<br>	&#125;<br>	<span class="hljs-comment">//实现遍历</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&#123;<br><br>    	<span class="hljs-keyword">private</span> Node n;<br>    	<span class="hljs-keyword">public</span> <span class="hljs-title function_">SIterator</span><span class="hljs-params">()</span> &#123;<br>    		<span class="hljs-built_in">this</span>.n=head;<br>    	&#125;<br>		<span class="hljs-meta">@Override</span><br>		<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">return</span> n.next!=<span class="hljs-literal">null</span>;<br>		&#125;<br><br>		<span class="hljs-meta">@Override</span><br>		<span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>			n=n.next;<br>			<span class="hljs-keyword">return</span> n.item;<br>		&#125;<br>    	<br>    &#125;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">// TODO Auto-generated method stub</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SIterator</span>();<span class="hljs-comment">//有点不理解应该是&lt;T&gt;泛型的Iterator对象，但这个不是也行啊</span><br>	&#125;<br>	<span class="hljs-comment">//用来反转整个链表</span><br>		<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">//判断当前链表是否为空链表,如果是空链表，则结束运行，如果不是，则调用重载reverse方法完成反转</span><br>			<span class="hljs-keyword">if</span>(isEmpty()) &#123;<br>				<span class="hljs-keyword">return</span> ;<br>			&#125;<br>			reverse(head.next);<br>		<br>		&#125;<br>		<span class="hljs-keyword">public</span> Node <span class="hljs-title function_">reverse</span><span class="hljs-params">(Node curr)</span> &#123;<br>			<span class="hljs-comment">//一个出口，如果反转到最后一个元素就用head指向它</span><br>			<span class="hljs-keyword">if</span>(curr.next==<span class="hljs-literal">null</span>) &#123;<br>			head.next=curr;<br>			<span class="hljs-keyword">return</span> curr;<br>			&#125;<br>			<span class="hljs-keyword">else</span> &#123;<br>				<span class="hljs-comment">//递归地去反转当前节点curr的下一个结点</span><br>				Node pre=reverse(curr.next);<br>				<span class="hljs-comment">//让返回的结点的下一个结点变为curr</span><br>				pre.next=curr;<br>				<span class="hljs-comment">//把当前结点的下一个结点变为null</span><br>				curr.next=<span class="hljs-literal">null</span>;<br>				<span class="hljs-comment">//返回值就是当前结点的下一个结点，也是反转后的上一个结点</span><br>				<span class="hljs-keyword">return</span> curr;<br>			&#125;<br>		&#125;<br><br><br>	&#125;<br><br></code></pre></td></tr></table></figure>

<p>链表反转的代码</p>
<p>测试：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> []args</span>) &#123;<br>		<span class="hljs-comment">//创建顺序表对象</span><br>		<br><br>		<span class="hljs-title class_">LinkList</span>&lt;<span class="hljs-title class_">String</span>&gt; s1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkList</span>&lt;<span class="hljs-title class_">String</span>&gt;(); <br>		<span class="hljs-comment">//测试插入</span><br>		s1.<span class="hljs-title function_">insert</span>(<span class="hljs-string">&quot;姚明&quot;</span>);<br>		s1.<span class="hljs-title function_">insert</span>(<span class="hljs-string">&quot;科比&quot;</span>);<br>		s1.<span class="hljs-title function_">insert</span>(<span class="hljs-string">&quot;麦迪&quot;</span>);<br>		s1.<span class="hljs-title function_">insert</span>(<span class="hljs-string">&quot;艾弗森&quot;</span>,<span class="hljs-number">1</span>);<br>		<br>s1.<span class="hljs-title function_">reverse</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-title class_">String</span> <span class="hljs-attr">s</span>:s1) &#123;<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(s);<br>&#125;<br>&#125;<br>	&#125;<br>结果：<br></code></pre></td></tr></table></figure>

<p>麦迪<br>科比<br>艾弗森<br>姚明</p>
<h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>快慢指针指的是定义两个指针，这两个指针的移动速度一块一慢，以此来制造出自己想要的差值，这个差值可以然 我们找到链表上相应的结点。一般情况下，快指针的移动步长为慢指针的两倍</p>
<p><strong>中间值问题：主要是那个getMid方法</strong></p>
<ul>
<li><p>&#96;&#96;&#96;<br>&#x2F;&#x2F;测试类<br>public class Main {<br>public static void main(String[] args) throws Exception {<br>Node<String> first &#x3D; new Node<String>(“aa”, null);<br>Node<String> second &#x3D; new Node<String>(“bb”, null);<br>Node<String> third &#x3D; new Node<String>(“cc”, null);<br>Node<String> fourth &#x3D; new Node<String>(“dd”, null);<br>Node<String> fifth &#x3D; new Node<String>(“ee”, null);<br>Node<String> six &#x3D; new Node<String>(“ff”, null);<br>Node<String> seven &#x3D; new Node<String>(“gg”, null);<br>&#x2F;&#x2F;完成结点之间的指向<br>first.next &#x3D; second;<br>second.next &#x3D; third;<br>third.next &#x3D; fourth;<br>fourth.next &#x3D; fifth;<br>fifth.next &#x3D; six;<br>six.next &#x3D; seven;<br>&#x2F;&#x2F;查找中间值<br>String mid &#x3D; getMid(first);<br>System.out.println(“中间值为：”+mid);<br>}<br>&#x2F;**</p>
<ul>
<li>@param first 链表的首结点</li>
<li>@return 链表的中间结点的值<br>*&#x2F;<br>public static String getMid(Node<String> first) {<br>&#x2F;&#x2F;定义两个指针<br>Node<String> fast&#x3D;first;<br>Node<String> slow&#x3D;first;<br>&#x2F;&#x2F;使用两个指针遍历链表，当快指针指向的结点没有下一个结点了，就可以结束了，结束之后，慢指针指向的结点就是中间值<br>while(fast!&#x3D;null&amp;&amp;fast.next!&#x3D;null) {<br>&#x2F;&#x2F;变换fast值和slow的值<br>fast&#x3D;fast.next.next;<br>slow&#x3D;slow.next;<br>}<br>return slow.item;<br>}<br>&#x2F;&#x2F;结点类<br>private static class Node<T> {<br>&#x2F;&#x2F;存储数据<br>T item;<br>&#x2F;&#x2F;下一个结点<br>Node next;<br>public Node(T item, Node next) {<br>this.item &#x3D; item;<br>this.next &#x3D; next;<br>}<br>}<br>}<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>  **单项链表是否有环的问题**<br><br>![image-<span class="hljs-number">20220801103447923</span>](https:<span class="hljs-regexp">//</span>zhao1129.oss-cn-qingdao.aliyuncs.com<span class="hljs-regexp">/img/</span><span class="hljs-number">202209291656815</span>.png)<br><br>在有环链表中快慢指针迟早会相遇，指向同一个元素，因为快指针比慢指针走得快<br><br>代码：<br><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>public class Main {<br>public static void main(String[] args) throws Exception {<br>Node<String> first &#x3D; new Node<String>(“aa”, null);<br>Node<String> second &#x3D; new Node<String>(“bb”, null);<br>Node<String> third &#x3D; new Node<String>(“cc”, null);<br>Node<String> fourth &#x3D; new Node<String>(“dd”, null);<br>Node<String> fifth &#x3D; new Node<String>(“ee”, null);<br>Node<String> six &#x3D; new Node<String>(“ff”, null);<br>Node<String> seven &#x3D; new Node<String>(“gg”, null);<br>&#x2F;&#x2F;完成结点之间的指向<br>first.next &#x3D; second;<br>second.next &#x3D; third;<br>third.next &#x3D; fourth;<br>fourth.next &#x3D; fifth;<br>fifth.next &#x3D; six;<br>six.next &#x3D; seven;<br>seven.next&#x3D;second;<br>&#x2F;&#x2F;判断是否为环<br>boolean circle&#x3D;isCircle(first);<br>System.out.println(“first链表中是否有环”+circle);<br>}</p>
<p>  public static boolean isCircle(Node<String> first) {<br>    &#x2F;&#x2F;定义快慢指针<br>      Node<String> fast&#x3D;first;<br>      Node<String> slow&#x3D;first;<br>     &#x2F;&#x2F;遍历链表，如果快慢指针指向同一个结点，那么证明有环<br>      while(fast!&#x3D;null&amp;&amp;fast.next!&#x3D;null) {<br>          &#x2F;&#x2F;变换fast和slow<br>          fast&#x3D;fast.next.next;<br>          slow&#x3D;slow.next;<br>          if(fast.equals(slow)) {<br>              return true;<br>          }<br>      }<br>      return false;<br>  }<br>  &#x2F;&#x2F;结点类<br>  private static class Node<T> {<br>  &#x2F;&#x2F;存储数据<br>  T item;<br>  &#x2F;&#x2F;下一个结点<br>  Node next;<br>  public Node(T item, Node next) {<br>  this.item &#x3D; item;<br>  this.next &#x3D; next;<br>  }<br>  }<br>  }<br>结果：first链表中是否有环true</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><br>**检测链表中有环如何找到环的入口**<br><br>当快慢指针相遇时，我们可以判断到链表中有环，这时重新设定一个新指针指向链表的起点，且步长与慢指针一样 为<span class="hljs-number">1</span>，则慢指针与“新”指针相遇的地方就是环的入口。<br><br>代码<br><br>```java<br>public class Main &#123;<br>public static void main(<span class="hljs-keyword">String</span>[] args) throws Exception &#123;<br><span class="hljs-keyword">Node</span><span class="hljs-title">&lt;String</span>&gt; first = new <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;String</span>&gt;(<span class="hljs-string">&quot;aa&quot;</span>, null);<br><span class="hljs-keyword">Node</span><span class="hljs-title">&lt;String</span>&gt; second = new <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;String</span>&gt;(<span class="hljs-string">&quot;bb&quot;</span>, null);<br><span class="hljs-keyword">Node</span><span class="hljs-title">&lt;String</span>&gt; third = new <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;String</span>&gt;(<span class="hljs-string">&quot;cc&quot;</span>, null);<br><span class="hljs-keyword">Node</span><span class="hljs-title">&lt;String</span>&gt; fourth = new <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;String</span>&gt;(<span class="hljs-string">&quot;dd&quot;</span>, null);<br><span class="hljs-keyword">Node</span><span class="hljs-title">&lt;String</span>&gt; fifth = new <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;String</span>&gt;(<span class="hljs-string">&quot;ee&quot;</span>, null);<br><span class="hljs-keyword">Node</span><span class="hljs-title">&lt;String</span>&gt; six = new <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;String</span>&gt;(<span class="hljs-string">&quot;ff&quot;</span>, null);<br><span class="hljs-keyword">Node</span><span class="hljs-title">&lt;String</span>&gt; seven = new <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;String</span>&gt;(<span class="hljs-string">&quot;gg&quot;</span>, null);<br>//完成结点之间的指向<br>first.next = second;<br>second.next = third;<br>third.next = fourth;<br>fourth.next = fifth;<br>fifth.next = six;<br>six.next = seven;<br>seven.<span class="hljs-attr">next=</span>third;<br>//找到环的入口结点<br><span class="hljs-keyword">Node</span><span class="hljs-title">&lt;String</span>&gt; <span class="hljs-attr">entrance=</span>getEntrance(first);<br>System.out.println(<span class="hljs-string">&quot;first链表中环的入口结点元素为&quot;</span>+entrance.item);<br>&#125;<br>public static <span class="hljs-keyword">Node</span> <span class="hljs-title">getEntrance</span>(<span class="hljs-keyword">Node</span><span class="hljs-title">&lt;String</span>&gt; first) &#123;<br>	//定义快慢指针<br>	  <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;String</span>&gt; <span class="hljs-attr">fast=</span>first;<br>	  <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;String</span>&gt; <span class="hljs-attr">slow=</span>first;<br>	  <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;String</span>&gt; <span class="hljs-attr">temp=</span>null;<br>	 //遍历链表，如果快慢指针指向同一个结点，找到换，准备一个临时指针，指向表的首结点，继续遍历，直到慢指针和临时指针相遇，那么相遇时指向的结点就是环的入口<br>	  while(fast!=null&amp;&amp;fast.next!=null) &#123;<br>		  //变换fast和slow<br>		  <span class="hljs-attr">fast=</span>fast.next.next;<br>		  <span class="hljs-attr">slow=</span>slow.next;<br>		  if(fast.equals(slow)) &#123;<br>			  <span class="hljs-attr">temp=</span>first;<br>			  continue;<br>		  &#125;<br>		  //让临时结点不是null的时候变换<br>		  if(temp!=null) &#123;<br>			  <span class="hljs-attr">temp=</span>temp.next;<br>			  <br><br>			  //判断临时指针是否和慢指针相遇<br>			  if(temp.equals(slow)) &#123;<br>				  break;<br>			  &#125;<br>		  &#125;<br>	  &#125;<br>	  return temp;<br><br>&#125;<br><br>  //结点类<br>  private static class <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;T</span>&gt; &#123;<br>  //存储数据<br>  T item;<br>  //下一个结点<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">next</span>;<br>  public <span class="hljs-keyword">Node</span><span class="hljs-title">(T</span> item, <span class="hljs-keyword">Node</span> <span class="hljs-title">next</span>) &#123;<br>  this.item = item;<br>  this.next = next;<br>  &#125;<br>  &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>结果为：cc</p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表，顾名思义，链表整体要形成一个圆环状。在单向链表中，最后一个节点的指针为null，不指向任何结 点，因为没有下一个元素了。要实现循环链表，我们只需要让单向链表的最后一个节点的指针指向头结点即可。</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656816.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220801113827874"></p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">public class Main &#123;<br>public static void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>//构建结点<br><span class="hljs-keyword">Node</span><span class="hljs-title">&lt;Integer</span>&gt; first = new <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;Integer</span>&gt;(<span class="hljs-number">1</span>, null);<br><span class="hljs-keyword">Node</span><span class="hljs-title">&lt;Integer</span>&gt; second = new <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;Integer</span>&gt;(<span class="hljs-number">2</span>, null);<br><span class="hljs-keyword">Node</span><span class="hljs-title">&lt;Integer</span>&gt; third = new <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;Integer</span>&gt;(<span class="hljs-number">3</span>, null);<br><span class="hljs-keyword">Node</span><span class="hljs-title">&lt;Integer</span>&gt; fourth = new <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;Integer</span>&gt;(<span class="hljs-number">4</span>, null);<br><span class="hljs-keyword">Node</span><span class="hljs-title">&lt;Integer</span>&gt; fifth = new <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;Integer</span>&gt;(<span class="hljs-number">5</span>, null);<br><span class="hljs-keyword">Node</span><span class="hljs-title">&lt;Integer</span>&gt; six = new <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;Integer</span>&gt;(<span class="hljs-number">6</span>, null);<br><span class="hljs-keyword">Node</span><span class="hljs-title">&lt;Integer</span>&gt; seven = new <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;Integer</span>&gt;(<span class="hljs-number">7</span>, null);<br>//构建单链表<br>first.next = second;<br>second.next = third;<br>third.next = fourth;<br>fourth.next = fifth;<br>fifth.next = six;<br>six.next = seven;<br>//构建循环链表,让最后一个结点指向第一个结点<br>seven.next = first;<br>&#125;<br>private static class <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;T</span>&gt; &#123;<br>	public T i;<br>	public <span class="hljs-keyword">Node</span> <span class="hljs-title">next</span>;<br>	public <span class="hljs-keyword">Node</span><span class="hljs-title">(T</span> i,<span class="hljs-keyword">Node</span> <span class="hljs-title">next</span>) &#123;<br>		this.i=i;<br>		this.<span class="hljs-attr">next=</span>next;<br>	&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>报错但不知道为什么，报错的原因是内部类要在main函数中使用必须是static</p>
<h3 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h3><p>41个人坐一圈，第一个人编号为1，第二个人编号为2，第n个人编号为n。</p>
<p> 1.编号为1的人开始从1报数，依次向后，报数为3的那个人退出圈；</p>
<p> 2.自退出那个人开始的下一个人再次从1开始报数，以此类推；</p>
<p> 3.求出最后退出的那个人的编号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;T&gt; &#123;<br>		<span class="hljs-keyword">public</span> T item;<br>		<span class="hljs-keyword">public</span> Node next;<br>		<span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(T item,Node next)</span> &#123;<br>			<span class="hljs-built_in">this</span>.item=item;<br>			<span class="hljs-built_in">this</span>.next=next;<br>		&#125;<br>	&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//构建循环链表具有41个结点。分别存储1-41之间的值</span><br>	Node&lt;Integer&gt; first=<span class="hljs-literal">null</span>;<span class="hljs-comment">//记录首结点</span><br>	Node&lt;Integer&gt; pre=<span class="hljs-literal">null</span>;<span class="hljs-comment">//记录前一个结点</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">41</span>;i++) &#123;<br>		<span class="hljs-comment">//1.如果是第一个结点</span><br>		<span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>) &#123;<br>			first=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(i,<span class="hljs-literal">null</span>);<span class="hljs-comment">//下一个节点暂时不知道</span><br>			pre=first;<br>			<span class="hljs-keyword">continue</span>;<br>		&#125;<br>		<span class="hljs-comment">//如果不是第一个结点</span><br>		Node newNode=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(i,<span class="hljs-literal">null</span>);<br>		pre.next=newNode;<br>		pre=newNode;<br>		<span class="hljs-comment">//如果是最后一个结点，让下一个结点为first</span><br>		<span class="hljs-keyword">if</span>(i==<span class="hljs-number">41</span>) &#123;<br>			pre.next=first;<br>		&#125;<br>	&#125;<br><span class="hljs-comment">//1.需要count计数器，模拟报数</span><br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>	<br><span class="hljs-comment">//遍历循环链表</span><br><span class="hljs-comment">//记录每次遍历拿到的结点，默认从首节点开始</span><br>Node&lt;Integer&gt; n=first;<br><span class="hljs-comment">//记录当前节点的上一个节点</span><br>Node&lt;Integer&gt; before=<span class="hljs-literal">null</span>;<br><span class="hljs-keyword">while</span>(n!=n.next) &#123;<br><span class="hljs-comment">//模拟报数</span><br>	count++;<br>	<span class="hljs-comment">//判断当前报数是不是3</span><br>	<span class="hljs-keyword">if</span>(count==<span class="hljs-number">3</span>) &#123;<br>		<span class="hljs-comment">//如果是3，则把当前结点删除调用，打印当前结点，重置count为0，让我当前节点n后移</span><br>		before.next=n.next;<br>		System.out.print(n.item+<span class="hljs-string">&quot;,&quot;</span>);<br>		count=<span class="hljs-number">0</span>;<br>		n=n.next;<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-comment">//如果不是3，让before变为当前结点，让当前结点后移</span><br>		before=n;<br>		n=n.next;<br>	&#125;<br>	<br><br>&#125;<br><span class="hljs-comment">//打印最后一个元素</span><br>System.out.print(<span class="hljs-string">&quot;\n&quot;</span>);<br>System.out.println(n.item);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种基于先进后出(FILO)的数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出 的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一 个数据被第一个读出来）。</p>
<p>称数据进入到栈的动作为压栈，数据从栈中出去的动作为弹栈。</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656817.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220801144820623"></p>
<p><strong>栈的API设计</strong></p>
<p>构造方法：Stack()创建Stack对象</p>
<p>成员方法:1.public boolean isEmpty()：判断栈是否为空，是返回true，否返回false </p>
<p>​               2.public int size():获取栈中元素的个数 </p>
<p>​               3.public T pop():弹出栈顶元素 </p>
<p>​               4.public void push(T t)：向栈中压入元素t</p>
<p>成员变量:1.private Node head:记录首结点 </p>
<p>​                 2.private int N:当前栈的元素个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br>```<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt;&#123;<br>	<span class="hljs-comment">//记录首节点</span><br>	<span class="hljs-keyword">private</span> Node head;<br>	<span class="hljs-comment">//栈中元素个数</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>	<span class="hljs-keyword">public</span> T item;<br>	<span class="hljs-keyword">public</span> Node next;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(T item,Node next)</span> &#123;<br>		<span class="hljs-built_in">this</span>.item=item;<br>		<span class="hljs-built_in">this</span>.next=next;<br>	&#125;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Stack</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">//初始化首节点</span><br>		<span class="hljs-built_in">this</span>.head=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>);<br>		<span class="hljs-comment">//初始化栈元素个数</span><br>		<span class="hljs-built_in">this</span>.N=<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//判断当前栈中的元素个数是否为零</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> N==<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//获取栈中元素的个数</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> N;<br>	&#125;<br>	<span class="hljs-comment">//将t元素压入栈</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(T t)</span> &#123;<br>		<span class="hljs-comment">//创建一个新结点，将新结点插入到首节点和下一个结点之间</span><br>	Node newNode=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(t,head.next);<br>	head.next=newNode;<br>	N++;<br>	&#125;<br>	<span class="hljs-comment">//弹栈</span><br>	<span class="hljs-keyword">public</span> T <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">//找到首节点指向第一个结点</span><br>		Node old=head.next;<br>		<span class="hljs-comment">//如果栈中没有元素</span><br>		<span class="hljs-keyword">if</span>(old==<span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>		&#125;<br>		<span class="hljs-comment">//让首节点直接连要删除结点后面一个节点</span><br>		head.next=head.next.next;<br>		<span class="hljs-comment">//元素个数减一</span><br>		N--;<br>		<span class="hljs-comment">//返回那个被弹出的结点</span><br>		<span class="hljs-keyword">return</span> old.item;<br>	&#125;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SIterator</span>();<br>	&#125;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&#123;<br>             <span class="hljs-keyword">private</span> Node n;<br>             <span class="hljs-keyword">public</span> <span class="hljs-title function_">SIterator</span><span class="hljs-params">()</span> &#123;<br>            	 <span class="hljs-built_in">this</span>.n=head;<br>             &#125;<br>		<span class="hljs-meta">@Override</span><br>		<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">return</span> n.next!=<span class="hljs-literal">null</span>;<br>		&#125;<br>```<br><br><br><br>		<span class="hljs-meta">@Override</span><br>		<span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>			n=n.next;<br>			<span class="hljs-keyword">return</span> n.item;<br>		&#125;<br>	&#125;<br>	&#125;<br><br><br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span> &#123;<br>		Stack&lt;String&gt; stack=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>		stack.push(<span class="hljs-string">&quot;a&quot;</span>);<br>		stack.push(<span class="hljs-string">&quot;b&quot;</span>);<br>		stack.push(<span class="hljs-string">&quot;c&quot;</span>);<br>		stack.push(<span class="hljs-string">&quot;d&quot;</span>);<br>		<span class="hljs-keyword">for</span>(String a:stack) &#123;<br>			System.out.println(a);<br>		&#125;<br>		String result=stack.pop();<br>		System.out.println(result);<br>		System.out.println(<span class="hljs-string">&quot;剩余元素个数&quot;</span>+stack.size());<br>	&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h3 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h3><p>给定一个字符串，里边可能包含”()”小括号和其他字符，请编写程序检查该字符串的中的小括号是否成对出现。 </p>
<p>例如:                “(上海)(长安)”：正确匹配 </p>
<p>​                        “上海((长安))”：正确匹配 </p>
<p>​                        “上海(长安(北京)(深圳)南京)”:正确匹配 </p>
<p>​                        “上海(长安))”：错误匹配 </p>
<p>​                        “((上海)长安”：错误匹配</p>
<p>下面主要是isMatch方法的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt;&#123;<br>	<span class="hljs-comment">//记录首节点</span><br>	<span class="hljs-keyword">private</span> Node head;<br>	<span class="hljs-comment">//栈中元素个数</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>	<span class="hljs-keyword">public</span> T item;<br>	<span class="hljs-keyword">public</span> Node next;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(T item,Node next)</span> &#123;<br>		<span class="hljs-built_in">this</span>.item=item;<br>		<span class="hljs-built_in">this</span>.next=next;<br>	&#125;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Stack</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">//初始化首节点</span><br>		<span class="hljs-built_in">this</span>.head=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>);<br>		<span class="hljs-comment">//初始化栈元素个数</span><br>		<span class="hljs-built_in">this</span>.N=<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//判断当前栈中的元素个数是否为零</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> N==<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//获取栈中元素的个数</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> N;<br>	&#125;<br>	<span class="hljs-comment">//将t元素压入栈</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(T t)</span> &#123;<br>		<span class="hljs-comment">//创建一个新结点，将新结点插入到首节点和下一个结点之间</span><br>	Node newNode=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(t,head.next);<br>	head.next=newNode;<br>	N++;<br>	&#125;<br>	<span class="hljs-comment">//弹栈</span><br>	<span class="hljs-keyword">public</span> T <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">//找到首节点指向第一个结点</span><br>		Node old=head.next;<br>		<span class="hljs-comment">//如果栈中没有元素</span><br>		<span class="hljs-keyword">if</span>(old==<span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>		&#125;<br>		<span class="hljs-comment">//让首节点直接连要删除结点后面一个节点</span><br>		head.next=head.next.next;<br>		<span class="hljs-comment">//元素个数减一</span><br>		N--;<br>		<span class="hljs-comment">//返回那个被弹出的结点</span><br>		<span class="hljs-keyword">return</span> old.item;<br>	&#125;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SIterator</span>();<br>	&#125;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&#123;<br>             <span class="hljs-keyword">private</span> Node n;<br>             <span class="hljs-keyword">public</span> <span class="hljs-title function_">SIterator</span><span class="hljs-params">()</span> &#123;<br>            	 <span class="hljs-built_in">this</span>.n=head;<br>             &#125;<br>		<span class="hljs-meta">@Override</span><br>		<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">return</span> n.next!=<span class="hljs-literal">null</span>;<br>		&#125;<br><br><br><br>		<span class="hljs-meta">@Override</span><br>		<span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>			n=n.next;<br>			<span class="hljs-keyword">return</span> n.item;<br>		&#125;<br>	&#125;<br>	&#125;<br><br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>		<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(上海(长安)())&quot;</span>;<br>		<span class="hljs-type">boolean</span> <span class="hljs-variable">match</span> <span class="hljs-operator">=</span> isMatch(str);<br>		System.out.println(str+<span class="hljs-string">&quot;中的括号是否匹配：&quot;</span>+match);<br>		&#125;<br>	<br>		<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMatch</span><span class="hljs-params">(String str)</span>&#123;<br>		<span class="hljs-comment">//创建栈对象用来存储左阔</span><br>			Stack&lt;String&gt; stack=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;String&gt;();<br>		<span class="hljs-comment">//从左往右遍历字符串</span><br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;str.length();i++) &#123;<br>				String currchar=str.charAt(i)+<span class="hljs-string">&quot;&quot;</span>;<br>	    <span class="hljs-comment">//判断当前字符是否为左括号，如果是，则压入栈中</span><br>			<span class="hljs-keyword">if</span>(currchar.equals(<span class="hljs-string">&quot;(&quot;</span>)) &#123;<br>				stack.push(currchar);<br>				&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(currchar.equals(<span class="hljs-string">&quot;)&quot;</span>))<br>			&#123;<br>				<span class="hljs-comment">//继续判断当前字符是否是右括号，如果是，则弹出一个左括号，并判断弹出结果是否为null，是null则证明没有匹配的左括号，不是null则证明右匹配的左括号</span><br>				String pop=stack.pop();<br>				<span class="hljs-keyword">if</span>(pop==<span class="hljs-literal">null</span>) &#123;<br>					<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>				&#125;<br>			&#125;<br>			&#125;<br>		<span class="hljs-comment">//判断是否有剩余的左括号</span><br>			<span class="hljs-keyword">if</span>(stack.size()!=<span class="hljs-number">0</span>) &#123;<br>				<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	<br>			&#125;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>		&#125;<br>		<br>		&#125;<br><br><br></code></pre></td></tr></table></figure>



<h3 id="逆波兰表达式求值问题"><a href="#逆波兰表达式求值问题" class="headerlink" title="逆波兰表达式求值问题"></a>逆波兰表达式求值问题</h3><p>逆波兰表达式简介：</p>
<p>也就是后缀表达式，运算符总是放在跟他相关的操作数之后</p>
<p>中缀表达式简介：</p>
<p>二元运算符总是置于两个操作数之间</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656818.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220801155152334"></p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656819.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220801161635574"></p>
<p>代码：</p>
<p>主要是caculate方法的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt;&#123;<br>	<span class="hljs-comment">//记录首节点</span><br>	<span class="hljs-keyword">private</span> Node head;<br>	<span class="hljs-comment">//栈中元素个数</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>	<span class="hljs-keyword">public</span> T item;<br>	<span class="hljs-keyword">public</span> Node next;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(T item,Node next)</span> &#123;<br>		<span class="hljs-built_in">this</span>.item=item;<br>		<span class="hljs-built_in">this</span>.next=next;<br>	&#125;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Stack</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">//初始化首节点</span><br>		<span class="hljs-built_in">this</span>.head=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>);<br>		<span class="hljs-comment">//初始化栈元素个数</span><br>		<span class="hljs-built_in">this</span>.N=<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//判断当前栈中的元素个数是否为零</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> N==<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//获取栈中元素的个数</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> N;<br>	&#125;<br>	<span class="hljs-comment">//将t元素压入栈</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(T t)</span> &#123;<br>		<span class="hljs-comment">//创建一个新结点，将新结点插入到首节点和下一个结点之间</span><br>	Node newNode=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(t,head.next);<br>	head.next=newNode;<br>	N++;<br>	&#125;<br>	<span class="hljs-comment">//弹栈</span><br>	<span class="hljs-keyword">public</span> T <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">//找到首节点指向第一个结点</span><br>		Node old=head.next;<br>		<span class="hljs-comment">//如果栈中没有元素</span><br>		<span class="hljs-keyword">if</span>(old==<span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>		&#125;<br>		<span class="hljs-comment">//让首节点直接连要删除结点后面一个节点</span><br>		head.next=head.next.next;<br>		<span class="hljs-comment">//元素个数减一</span><br>		N--;<br>		<span class="hljs-comment">//返回那个被弹出的结点</span><br>		<span class="hljs-keyword">return</span> old.item;<br>	&#125;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SIterator</span>();<br>	&#125;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&#123;<br>             <span class="hljs-keyword">private</span> Node n;<br>             <span class="hljs-keyword">public</span> <span class="hljs-title function_">SIterator</span><span class="hljs-params">()</span> &#123;<br>            	 <span class="hljs-built_in">this</span>.n=head;<br>             &#125;<br>		<span class="hljs-meta">@Override</span><br>		<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">return</span> n.next!=<span class="hljs-literal">null</span>;<br>		&#125;<br><br><br><br>		<span class="hljs-meta">@Override</span><br>		<span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>			n=n.next;<br>			<span class="hljs-keyword">return</span> n.item;<br>		&#125;<br>	&#125;<br>	&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//中缀表达式3*（17-15）+18/6的逆波兰表达式如下</span><br>String[] notation = &#123;<span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;17&quot;</span>, <span class="hljs-string">&quot;15&quot;</span>, <span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>,<span class="hljs-string">&quot;18&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-string">&quot;+&quot;</span>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> caculate(notation);<br>System.out.println(<span class="hljs-string">&quot;逆波兰表达式的结果为：&quot;</span>+result);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">caculate</span><span class="hljs-params">(String[] notaion)</span>&#123;<br><span class="hljs-comment">//定义一个栈，用来存储操作数</span><br>Stack&lt;Integer&gt; stack=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br><span class="hljs-comment">//从左往右遍历逆波兰表达式，得到每一个元素</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;notaion.length;i++) &#123;<br>		String curr=notaion[i];<br>		<span class="hljs-comment">//3.判断该字符串是不是运算符，如果不是，把该该操作数压入oprands栈中</span><br>		Integer o1;<br>		Integer o2;<br>		Integer result;<br>		<span class="hljs-keyword">switch</span> (curr) &#123;<br>		<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>		<span class="hljs-comment">//4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2</span><br>		o1 =stack.pop();<br>		o2 = stack.pop();<br>		<span class="hljs-comment">//5.使用该运算符计算o1和o2，得到结果result</span><br>		result = o2 + o1;<br>		<span class="hljs-comment">//6.把该结果压入oprands栈中</span><br>		stack.push(result);<br>		<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>		<span class="hljs-comment">//4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2</span><br>		o1 = stack.pop();<br>		o2 = stack.pop();<br>		<span class="hljs-comment">//5.使用该运算符计算o1和o2，得到结果result</span><br>		result = o2 - o1;<br>		<span class="hljs-comment">//6.把该结果压入oprands栈中</span><br>		stack.push(result);<br>		<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>		<span class="hljs-comment">//4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2</span><br>		o1 = stack.pop();<br>		o2 = stack.pop();<br>		<span class="hljs-comment">//5.使用该运算符计算o1和o2，得到结果result</span><br>		result = o2 * o1;<br>		<span class="hljs-comment">//6.把该结果压入oprands栈中</span><br>		stack.push(result);<br>		<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>		<span class="hljs-comment">//4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2</span><br>		o1 = stack.pop();<br>		o2 = stack.pop();<br>		<span class="hljs-comment">//5.使用该运算符计算o1和o2，得到结果result</span><br>		result = o2 / o1;<br>		<span class="hljs-comment">//6.把该结果压入oprands栈中</span><br>		stack.push(result);<br>		<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">default</span>:<br>			<span class="hljs-comment">//如果是操作数，直接压入栈中就可以</span><br>		stack.push(Integer.parseInt(curr));<br>		<span class="hljs-keyword">break</span>;<br>	&#125;<br><br>&#125;<br>	<span class="hljs-comment">//得到栈中最后一个元素就是逆波兰表达式的结果</span><br>		<span class="hljs-type">int</span> result=stack.pop();<br>		<span class="hljs-keyword">return</span> result;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是一种基于先进先出(FIFO)的数据结构，是一种只能在一端进行插入,在另一端进行删除操作的特殊线性表，它 按照先进先出的原则存储数据，先进入的数据，在读取数据时先读被读出来。</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656820.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220802080508929"></p>
<p>构造方法 ：Queue()：创建Queue对象</p>
<p>成员变量：1.private Node head:记录首结点 </p>
<p>​                    2.private int N:当前栈的元素个数 </p>
<p>​                   3.private Node last:记录最后一个结点</p>
<p>成员方法：1.public boolean isEmpty()：判断队列是否为空，是返回true，否返回false </p>
<p>​                    2.public int size():获取队列中元素的个数 </p>
<p>​                    3.public T dequeue():从队列中拿出一个元素 </p>
<p>​                    4.public void enqueue(T t)：往队列中插入一个元素</p>
<p>成员内部类：private class Node</p>
<p>队列的API</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt;&#123;<br>	<span class="hljs-comment">//记录首节点</span><br>	<span class="hljs-keyword">private</span> Node head;<br>	<span class="hljs-comment">//记录最后一个结点</span><br>	<span class="hljs-keyword">private</span> Node last;<br>	<span class="hljs-comment">//记录队列中元素的个数</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br>	<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>		<span class="hljs-keyword">public</span> T item;<br>		<span class="hljs-keyword">public</span> Node next;<br>		<span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(T item,Node next)</span> &#123;<br>			<span class="hljs-built_in">this</span>.item=item;<br>			<span class="hljs-built_in">this</span>.next=next;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Queue</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-built_in">this</span>.head=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>);<br>		<span class="hljs-built_in">this</span>.last=<span class="hljs-literal">null</span>;<br>		<span class="hljs-built_in">this</span>.N=<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//判断当前队列是否为空</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> N==<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//返回队列中元素的个数</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> N;<br>	&#125;<br>	<span class="hljs-comment">//像队列中插入元素t</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(T t)</span> &#123;<br>		<span class="hljs-comment">//当前尾节点为null</span><br>		<span class="hljs-keyword">if</span>(last==<span class="hljs-literal">null</span>) &#123;<br>			last=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(t,<span class="hljs-literal">null</span>);<br>			head.next=last;<br>		&#125;<br>		<span class="hljs-keyword">else</span><br>		&#123;<br>			<span class="hljs-comment">//当前尾节点不为null</span><br>		<span class="hljs-comment">//创建新结点</span><br>			Node oldlast=last;<br>		<span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(t,<span class="hljs-literal">null</span>);<br>		<span class="hljs-comment">//将新结点设置为尾节点</span><br>		last=newNode;<br>		<span class="hljs-comment">//将原本的尾节点指向新结点</span><br>		oldlast.next=last;<br>		&#125;<br>		<span class="hljs-comment">//元素个数加一</span><br>		N++;<br>		<br>	&#125;<br>	<span class="hljs-comment">//从队列中拿出一个元素</span><br>	<span class="hljs-keyword">public</span> T <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">if</span>(isEmpty()) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>		&#125;<br>		<span class="hljs-comment">//保留原本第一个</span><br>		Node oldfirst=head.next;<br>		<span class="hljs-comment">//头节点直接指向原本第二个</span><br>		head.next=oldfirst.next;<br>		N--;<br>		<br>		<span class="hljs-comment">//如果队列中的元素删除完了，需要重置last=null</span><br>		<span class="hljs-keyword">if</span>(isEmpty()) &#123;<br>			last=<span class="hljs-literal">null</span>;<br>		&#125;<br>		<br>		<span class="hljs-comment">//返回原本第一个</span><br>		<span class="hljs-keyword">return</span> oldfirst.item;<br>		&#125;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SIterator</span>();<br>	&#125;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&#123;<br>             <span class="hljs-keyword">private</span> Node n;<br>             <span class="hljs-keyword">public</span> <span class="hljs-title function_">SIterator</span><span class="hljs-params">()</span> &#123;<br>            	 <span class="hljs-built_in">this</span>.n=head;<br>             &#125;<br>		<span class="hljs-meta">@Override</span><br>		<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">return</span> n.next!=<span class="hljs-literal">null</span>;<br>		&#125;<br><br>		<span class="hljs-meta">@Override</span><br>		<span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>			n=n.next;<br>			<span class="hljs-keyword">return</span> n.item;<br>		&#125;<br>		<br>	&#125;<br>	&#125;<br>	<br><br><br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span> &#123;<br>   <span class="hljs-comment">//创建队列对象</span><br>	Queue&lt;String&gt; queue=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>&lt;String&gt;();<br>	<span class="hljs-comment">//测试队列中的enqueue方法</span><br>	queue.enqueue(<span class="hljs-string">&quot;a&quot;</span>);<br>	queue.enqueue(<span class="hljs-string">&quot;b&quot;</span>);<br>	queue.enqueue(<span class="hljs-string">&quot;c&quot;</span>);<br>	queue.enqueue(<span class="hljs-string">&quot;d&quot;</span>);<br>	<span class="hljs-keyword">for</span>(String s:queue) &#123;<br>		System.out.println(s);<br>	&#125;<br>	System.out.println(<span class="hljs-string">&quot;--------------------------------------------------&quot;</span>);<br>	<span class="hljs-comment">//调试队列的dequeue方法</span><br>	String result=queue.dequeue();<br>	System.out.println(result);<br>    System.out.println(queue.size());<br>&#125;<br>&#125;<br><br>​	<br></code></pre></td></tr></table></figure>

<h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h2><p>符号表最主要的目的就是将一个键和一个值联系起来，符号表能够存储的数据元素是一个键和一个值共同组成的键值对数据，我们可以根据键来查找对应的值</p>
<p>符号表中，键要有唯一性</p>
<p><strong>符号表的API设计</strong></p>
<p><strong>结点类：</strong></p>
<p>构造方法 Node(Key key,Value value,Node next)：创建Node对象</p>
<p> 成员变量 1.public Key key:存储键</p>
<p>​                  2.public Value value:存储值 </p>
<p>​                  3.public Node next:存储下一个结点</p>
<p><strong>符号表的API</strong> </p>
<p>SymbolTable()</p>
<p>构造方法 SymbolTable()：创建SymbolTable对象</p>
<p> 成员方法 1.public Value get(Key key)：根据键key，找对应的值 </p>
<p>​                 2.public void put(Key key,Value val):向符号表中插入一个键值对 </p>
<p>​                 3.public void delete(Key key):删除键为key的键值对 </p>
<p>​                 4.public int size()：获取符号表的大小 </p>
<p>成员变量 </p>
<p>1.private Node head:记录首结点 </p>
<p>2.private int N:记录符号表中键值对的个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Symboltable</span>&lt;Key,Value&gt;&#123;<br>	<span class="hljs-comment">//记录首结点</span><br>	<span class="hljs-keyword">private</span> Node head;<br>	<span class="hljs-comment">//记录符号表中元素的个数</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br>	<br><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>		<span class="hljs-comment">//键</span><br>		<span class="hljs-keyword">public</span> Key key;<br>		<span class="hljs-comment">//值</span><br>		<span class="hljs-keyword">public</span> Value value;<br>		<span class="hljs-comment">//下一个结点</span><br>		<span class="hljs-keyword">public</span> Node next;<br>		<br>		<span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(Key key,Value value,Node next)</span> &#123;<br>			<span class="hljs-built_in">this</span>.key=key;<br>			<span class="hljs-built_in">this</span>.value=value;<br>			<span class="hljs-built_in">this</span>.next=next;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Symboltable</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">//初始化</span><br>		<span class="hljs-built_in">this</span>.head=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>);<br>		<span class="hljs-built_in">this</span>.N=<span class="hljs-number">0</span>;<br>		<br>	&#125;<br>	<span class="hljs-comment">//获取符号表中键值对的个数</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> N;<br>	&#125;<br>	<span class="hljs-comment">//往符号表中插入键值对</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Key key,Value value)</span> &#123;<br>	<span class="hljs-comment">//符号表中已经存在键为key的键值对，那么只需要找到该结点，替换值value</span><br>	    Node n=head;<br>	    <span class="hljs-keyword">while</span>(n.next!=<span class="hljs-literal">null</span>) &#123;<br>	    	n=n.next;<br>	    	<span class="hljs-keyword">if</span>(n.key.equals(key)) &#123;<br>	    		n.value=value;<br>	    		<span class="hljs-keyword">return</span>;<br>	    	&#125;<br>	    &#125;<br>		<br>	<span class="hljs-comment">//如果符号表中不存在键为key的键值对，只需要创建新的结点，保存要插入的键值对，把新结点插入到链表的头部  head.next=新结点即可</span><br>	Node newNode=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key,value,<span class="hljs-literal">null</span>);<br>	Node oldfirst=head.next;<br>	newNode.next=oldfirst;<br>	head.next=newNode;<br>	<span class="hljs-comment">//数据元素加一</span><br>	N++;<br>	<br>	&#125;<br>	<span class="hljs-comment">//删除符号表中键为key的键值对</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(Key key)</span> &#123;<br>		Node n=head;<br>		<span class="hljs-keyword">while</span>(n.next!=<span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-comment">//判断一下n的下一个结点的key是否符合,这样可以更好的获得符合条件的结点的上一个结点</span><br>			<span class="hljs-keyword">if</span>(n.next.key.equals(key)) &#123;<br>				n.next=n.next.next;<br>				N--;<br>				<span class="hljs-keyword">return</span>;<br>			&#125;<br>			n=n.next;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">public</span> Value <span class="hljs-title function_">get</span><span class="hljs-params">(Key key)</span> &#123;<br>		Node n=head;<br>		<span class="hljs-comment">//找到符合条件的结点返回它的value值</span><br>		<span class="hljs-keyword">while</span>(n.next!=<span class="hljs-literal">null</span>) &#123;<br>			n=n.next;<br>			<span class="hljs-keyword">if</span>(n.key.equals(key)) &#123;<br>				<span class="hljs-keyword">return</span> n.value;<br>			&#125;<br>	<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>	 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		 <span class="hljs-comment">//创建符号表对象</span><br>		 Symboltable&lt;Integer,String&gt; symboltable=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Symboltable</span>&lt;Integer,String&gt;();<br>		 <span class="hljs-comment">//测试put方法（插入，替换）</span><br>		symboltable.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;乔峰&quot;</span>);<br>		symboltable.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;虚竹&quot;</span>);<br>		symboltable.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;段餐&quot;</span>);<br>		<br><br>		System.out.println(<span class="hljs-string">&quot;插入完毕以后，元素的个数为&quot;</span>+symboltable.size());<br>		<br>		symboltable.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;慕容夫&quot;</span>);<br>		System.out.println(<span class="hljs-string">&quot;替换之后元素个数&quot;</span>+symboltable.size());<br>		 <span class="hljs-comment">//测试get方法</span><br>		 System.out.println(symboltable.get(<span class="hljs-number">2</span>));<br>		 <span class="hljs-comment">//测试删除方法</span><br>		 symboltable.delete(<span class="hljs-number">2</span>);<br>		System.out.println(<span class="hljs-string">&quot;删除完毕之后元素个数&quot;</span>+symboltable.size());<br>	 &#125;<br><br> &#125;<br></code></pre></td></tr></table></figure>

<h2 id="有序符号表"><a href="#有序符号表" class="headerlink" title="有序符号表"></a>有序符号表</h2><p>主要是put方法的改变</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderSymboltable</span>&lt;Key <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;Key&gt;,Value&gt;&#123;<br>	<span class="hljs-comment">//记录首结点</span><br>	<span class="hljs-keyword">private</span> Node head;<br>	<span class="hljs-comment">//记录符号表中元素的个数</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br>	<br><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>		<span class="hljs-comment">//键</span><br>		<span class="hljs-keyword">public</span> Key key;<br>		<span class="hljs-comment">//值</span><br>		<span class="hljs-keyword">public</span> Value value;<br>		<span class="hljs-comment">//下一个结点</span><br>		<span class="hljs-keyword">public</span> Node next;<br>		<br>		<span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(Key key,Value value,Node next)</span> &#123;<br>			<span class="hljs-built_in">this</span>.key=key;<br>			<span class="hljs-built_in">this</span>.value=value;<br>			<span class="hljs-built_in">this</span>.next=next;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">OrderSymboltable</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">//初始化</span><br>		<span class="hljs-built_in">this</span>.head=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>);<br>		<span class="hljs-built_in">this</span>.N=<span class="hljs-number">0</span>;<br>		<br>	&#125;<br>	<span class="hljs-comment">//获取符号表中键值对的个数</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> N;<br>	&#125;<br>	<span class="hljs-comment">//往符号表中插入键值对,并根据key排序</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Key key,Value value)</span> &#123;<br><br><span class="hljs-comment">//定义两个Node变量，分别记录当前结点和当前结点的上一个结点</span><br>		Node curr=head.next;<br>		Node pre=head;<br>		<span class="hljs-comment">//如果节点不为空且要插入key大于当前结点的key就往后走</span><br>		<span class="hljs-keyword">while</span>(curr!=<span class="hljs-literal">null</span>&amp;&amp;key.compareTo(curr.key)&gt;=<span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-comment">//都向后移一位，方便之后插入的时候连接</span><br>			pre=curr;<br>			curr=curr.next;<br>		&#125;<br>		<span class="hljs-comment">//如果当前结点curr的键和要插入的Key一样，替换</span><br>		<span class="hljs-keyword">if</span>(curr!=<span class="hljs-literal">null</span>&amp;&amp;key.compareTo(curr.key)==<span class="hljs-number">0</span>) &#123;<br>			curr.value=value;<br>			<span class="hljs-keyword">return</span> ;<br>		&#125;<br>		<span class="hljs-comment">//如果当前结点curr键和要插入的key不一样，把新的结点插入到curr之前</span><br>		Node newNode=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key,value,curr);<br>		pre.next=newNode;<br>       <span class="hljs-comment">//元素的个数加一</span><br>		N++;<br>	<br><br>	&#125;<br>	<span class="hljs-comment">//删除符号表中键为key的键值对</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(Key key)</span> &#123;<br>		Node n=head;<br>		<span class="hljs-keyword">while</span>(n.next!=<span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-comment">//判断一下n的下一个结点的key是否符合,这样可以更好的获得符合条件的结点的上一个结点</span><br>			<span class="hljs-keyword">if</span>(n.next.key.equals(key)) &#123;<br>				n.next=n.next.next;<br>				N--;<br>				<span class="hljs-keyword">return</span>;<br>			&#125;<br>			n=n.next;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">public</span> Value <span class="hljs-title function_">get</span><span class="hljs-params">(Key key)</span> &#123;<br>		Node n=head;<br>		<span class="hljs-comment">//找到符合条件的结点返回它的value值</span><br>		<span class="hljs-keyword">while</span>(n.next!=<span class="hljs-literal">null</span>) &#123;<br>			n=n.next;<br>			<span class="hljs-keyword">if</span>(n.key.equals(key)) &#123;<br>				<span class="hljs-keyword">return</span> n.value;<br>			&#125;<br>	<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>	 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		 <span class="hljs-comment">//创建符号表对象</span><br>		 OrderSymboltable&lt;Integer,String&gt; table=<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderSymboltable</span>&lt;Integer,String&gt;();<br>		 <span class="hljs-comment">//测试put方法（插入，替换）</span><br>	    table.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;张三&quot;</span>);<br>	    table.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;李四&quot;</span>);<br>	    table.put(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;赵六&quot;</span>);<br>	    table.put(<span class="hljs-number">7</span>, <span class="hljs-string">&quot;七&quot;</span>);<br>	    table.put(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;王五&quot;</span>);<br>	    <br><br>	 &#125;<br><br> &#125;<br></code></pre></td></tr></table></figure>

<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>之前我们实现的符号表中，不难看出，符号表的增删查操作，随着元素个数N的增多，其耗时也是线性增多的，时 间复杂度都是O(n),为了提高运算效率，接下来我们学习树这种数据结构。</p>
<p>树由有限结点组成的具有层次关系的集合</p>
<p>用数组来实现树天生查询快，可以改善增删慢</p>
<p>用链表来实现树天生增删快，可以改善查询慢</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656821.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220802100829224"></p>
<p>树具有以下特点： 1.每个结点有零个或多个子结点； </p>
<p>​                                2.没有父结点的结点为根结点； </p>
<p>​                                3.每一个非根结点只有一个父结点； </p>
<p>​                                4.每个结点及其后代结点整体上可以看做是一棵树，称为当前结点的父结点的一个子树；（一个结点也可以称之为子树，就是E有两个子树两个度）</p>
<p><strong>结点的度</strong>： 一个结点含有的子树的个数称为该结点的度； </p>
<p><strong>叶结点</strong>： 度为0的结点称为叶结点，也可以叫做终端结点 </p>
<p><strong>分支结点</strong>： 度不为0的结点称为分支结点，也可以叫做非终端结点 </p>
<p><strong>结点的层次</strong>： 从根结点开始，根结点的层次为1，根的直接后继层次为2，以此类推 </p>
<p><strong>结点的层序编号</strong>：将树中的结点，按照<strong>从上层到下层，同层从左到右的次序</strong>排成一个线性序列，把他们编成连续的自然数</p>
<p><strong>树的度</strong>： 树中所有结点的度的最大值</p>
<p> **树的高度(深度)**： 树中结点的最大层次 </p>
<p><strong>森林</strong>： m（m&gt;&#x3D;0）个互不相交的树的集合，将一颗非空树的根结点删去，树就变成一个森林；给森林增加一个统一的根 结点，森林就变成一棵树</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656822.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220802102149874"></p>
<p><strong>孩子结点</strong>： 一个结点的直接后继结点称为该结点的孩子结点</p>
<p> **双亲结点(父结点)**： 一个结点的直接前驱称为该结点的双亲结点 </p>
<p><strong>兄弟结点</strong>： 同一双亲结点的孩子结点间互称兄弟结点</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树就是度不超过2的树(每个结点最多有两个子结点)</p>
<p><strong>满二叉树</strong></p>
<p>一个二叉树，如果每一个层的结点树都达到最大值，则这个二叉树就是满二叉树。</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656823.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220802102501935"></p>
<p><strong>完全二叉树</strong>：</p>
<p>叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656824.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220802102636416"></p>
<p>完全二叉树就是先把该层从左到右都放满才会放下一层</p>
<h3 id="二叉查找树的创建"><a href="#二叉查找树的创建" class="headerlink" title="二叉查找树的创建"></a>二叉查找树的创建</h3><p>用链表设计一个二叉查找树</p>
<p>二叉查找树是左子节点大于根节点小于右子节点</p>
<p><strong>结点类：类名Node&lt;Key,Value&gt;</strong></p>
<p>构造方法 Node(Key key, Value value, Node left, Node right)：创建Node对象</p>
<p>成员变量：1.public Node left:记录左子结点</p>
<p>​                    2.public Node right:记录右子结点 （因为度最大为二所以只有左右子节点即可）</p>
<p>​                    3.public Key key:存储键 </p>
<p>​                    4.public Value value:存储值</p>
<p><strong>二叉查找树的API设计</strong></p>
<p>类名:BinaryTree&lt;Key extends Comparable<key>,Value value&gt;</p>
<p>key继承Comparable是为了排序</p>
<p>构造方法 BinaryTree()：创建BinaryTree对象</p>
<p>成员变量 1.private Node root:记录根结点 </p>
<p>​                2.private int N:记录树中元素的个数</p>
<p>成员方法</p>
<p>1.public void put(Key key,Value value):向树中插入一个键值对 </p>
<p>2.private Node put(Node x, Key key, Value val)：给指定树x上，添加键一个键值对，并返回添 加后的新树 </p>
<p>3.public Value get(Key key):根据key，从树中找出对应的值 </p>
<p>4.private Value get(Node x, Key key):从指定的树x中，找出key对应的值 </p>
<p>5.public void delete(Key key):根据key，删除树中对应的键值对 </p>
<p>6.private Node delete(Node x, Key key):删除指定树x上的键为key的键值对，并返回删除后的 新树 </p>
<p>7.public int size():获取树中元素的个数</p>
<p><strong>插入方法put实现思想：</strong> 1.如果当前树中没有任何一个结点，则直接把新结点当做根结点使用 </p>
<p>2.如果当前树不为空，则从根结点开始： </p>
<p>2.1如果新结点的key小于当前结点的key，则继续找当前结点的左子结点； </p>
<p>2.2如果新结点的key大于当前结点的key，则继续找当前结点的右子结点； </p>
<p>2.3如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656825.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220802115038763"></p>
<p>查询方法的get实现思想：</p>
<p>从根节点开始： 1.如果要查询的key小于当前结点的key，则继续找当前结点的左子结点； </p>
<p>​                            2.如果要查询的key大于当前结点的key，则继续找当前结点的右子结点； </p>
<p>​                            3.如果要查询的key等于当前结点的key，则树中返回当前结点的value。</p>
<p>删除方法delete的实现思想</p>
<p> 1.找到被删除结点； </p>
<p>2.找到被删除结点右子树中的最小结点minNode （右子树中最左最下的）</p>
<p>3.删除右子树中的最小结点 </p>
<p>4.让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子树 </p>
<p>5.让被删除结点的父节点指向最小结点minNode</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656826.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220802140919901"></p>
<p>代码API实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTree</span>&lt;Key <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;Key&gt;,Value&gt; &#123;<br><span class="hljs-comment">//记录根结点</span><br><span class="hljs-keyword">private</span> Node root;<br><span class="hljs-comment">//记录树中元素个数</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>	<span class="hljs-comment">//存储键</span><br>	<span class="hljs-keyword">public</span> Key key;<br>	<span class="hljs-comment">//存储值</span><br>	<span class="hljs-keyword">public</span> Value value;<br>	<span class="hljs-comment">//记录左子节点</span><br>	<span class="hljs-keyword">public</span> Node left;<br>	<span class="hljs-comment">//记录右子节点</span><br>	<span class="hljs-keyword">public</span> Node right;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(Key key,Value value,Node left,Node right)</span> &#123;<br>		<span class="hljs-built_in">this</span>.key=key;<br>		<span class="hljs-built_in">this</span>.value=value;<br>		<span class="hljs-built_in">this</span>.right=right;<br>        <span class="hljs-built_in">this</span>.left=left;<br>	&#125;<br>&#125;<br><span class="hljs-comment">//获取树中元素的个数</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">return</span> N;<br>&#125;<br><br><span class="hljs-comment">//向树中添加元素key-value</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Key key,Value value)</span> &#123;<br>	root=put(root,key,value);<br>&#125;<br><span class="hljs-comment">//向指定的树中添加key-value，并返回添加元素后的新树</span><br><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">put</span><span class="hljs-params">(Node x,Key key,Value value)</span> &#123;<br>	<span class="hljs-comment">//x子树为空</span><br>	<span class="hljs-keyword">if</span>(x==<span class="hljs-literal">null</span>) &#123;<br>		N++;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key,value,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>);<br>	&#125;<br>	<span class="hljs-comment">//如果x子树不为空</span><br>		<span class="hljs-comment">//比较x结点的键和key的大小</span><br>		<span class="hljs-type">int</span> cmp=key.compareTo(x.key);<br>		<span class="hljs-keyword">if</span>(cmp&gt;<span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-comment">//如果key大于x结点的键，则继续找x结点右子树</span><br>			x.right=put(x.right,key,value);<br>		&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmp&lt;<span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-comment">//如果key小于x节点的键，则继续找x结点的左子树</span><br>			x.left=put(x.left,key,value);<br>		&#125;<br>		<span class="hljs-keyword">else</span><br>		&#123;<br>			<span class="hljs-comment">//如果key等于x结点的键，则替换value</span><br>			x.value=value;<br>		&#125;<br>		<span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-comment">//查询树中指定key对应的value</span><br><span class="hljs-keyword">public</span> Value <span class="hljs-title function_">get</span><span class="hljs-params">(Key key)</span> &#123;<br>	<span class="hljs-keyword">return</span> get(root,key);<br>&#125;<br><span class="hljs-comment">//从指定的树x中，查找key对应的值</span><br><span class="hljs-keyword">public</span> Value <span class="hljs-title function_">get</span><span class="hljs-params">(Node x,Key key)</span> &#123;<br>	<span class="hljs-comment">//x树为null</span><br>	<span class="hljs-keyword">if</span>(x==<span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>	&#125;<br>	<span class="hljs-comment">//x树不为null</span><br>	<span class="hljs-comment">//比较key和x结点键的大小</span><br>	<span class="hljs-type">int</span> cmp=key.compareTo(x.key);<br>	<span class="hljs-keyword">if</span>(cmp&gt;<span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-comment">//如果key大于x结点的键，则继续找x结点右子树</span><br>		<span class="hljs-keyword">return</span> get(x.right,key);<br>	&#125;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmp&lt;<span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-comment">//如果key小于x节点的键，则继续找x结点的左子树</span><br>		<span class="hljs-keyword">return</span> get(x.left,key);<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-comment">//如果key等于x结点的键，就找到了key的结点，只需要返回x结点的值即可</span><br>		<span class="hljs-keyword">return</span> x.value;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">//删除树中key对应的value值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(Key key)</span> &#123;<br>	delete(root,key);<br>&#125;<br><span class="hljs-comment">//删除指定树x中的key所对应的value，并返回删除后的新树</span><br><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">delete</span><span class="hljs-params">(Node x,Key key)</span> &#123;<br>	<span class="hljs-comment">//x树为null</span><br>	<br>	<span class="hljs-keyword">if</span>(x==<span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>	&#125;<br>	<span class="hljs-comment">//x树不为null</span><br>	<span class="hljs-comment">//比较key和x结点键的大小</span><br>			<span class="hljs-type">int</span> cmp=key.compareTo(x.key);<br>	<span class="hljs-keyword">if</span>(cmp&gt;<span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-comment">//如果key大于x结点的键，则继续找x结点右子树</span><br>		x.right=delete(x.right,key);<br>	&#125;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmp&lt;<span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-comment">//如果key小于x节点的键，则继续找x结点的左子树</span><br>		x.left=delete(x.left,key);<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-comment">//得找到x结点右子树中最小的结点</span><br>		<span class="hljs-keyword">if</span>(x.right==<span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">return</span> x.left;<span class="hljs-comment">//因为是递归所以这个返回值之后在上面会自动给那个被删除结点的父节点</span><br>		&#125;<br>		<span class="hljs-keyword">if</span>(x.left==<span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> x.right;<span class="hljs-comment">//因为是递归所以这个返回值之后在上面会自动给那个被删除结点的父节点</span><br>		&#125;<br>		Node minNode=x.right;<br>		<span class="hljs-keyword">while</span>(minNode.left!=<span class="hljs-literal">null</span>) &#123;<br>		minNode=minNode.left;<br>		<br>		&#125;<br>		<span class="hljs-comment">//删除右子树中的最小结点</span><br>		Node n=x.right;<br>		<span class="hljs-keyword">while</span>(n.left!=<span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-comment">//如果n结点的下一个的下一个是空，就将n结点的下一个设为null</span><br>		<span class="hljs-keyword">if</span>(n.left.left==<span class="hljs-literal">null</span>) &#123;<br>			n.left=<span class="hljs-literal">null</span>;<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-comment">//变换n结点即可</span><br>			n=n.left;<br>		&#125;<br>		&#125;<br>	<span class="hljs-comment">//让最小结点为被删结点左右结点的父结点</span><br>			minNode.right=x.right;<br>		<br>			minNode.left=x.left;<br>		<br>		<span class="hljs-comment">//被删结点的父结点为minNode的父节点</span><br>		x=minNode;<br>	<span class="hljs-comment">//让元素个数减一</span><br>		N--;<br>	&#125;<br>	<span class="hljs-keyword">return</span> x;<span class="hljs-comment">//因为是递归所以这个返回值为x也就是minNode之后在上面会自动给那个被删除结点的父节点，到最后返回的就是删除后的新树</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">testTree</span> &#123;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-comment">//创建二叉查找对象</span><br>		BinaryTree&lt;Integer,String&gt; tree=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BinaryTree</span>&lt;&gt;();<br>		<span class="hljs-comment">//测试插入</span><br>		tree.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;张三&quot;</span>);<br>		tree.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;李四&quot;</span>);<br>		tree.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;王五&quot;</span>);<br>		System.out.println(<span class="hljs-string">&quot;插入完毕后元素个数&quot;</span>+tree.size());<br>		<span class="hljs-comment">//测试获取</span><br>		System.out.println(<span class="hljs-string">&quot;键对应的元素是&quot;</span>+tree.get(<span class="hljs-number">2</span>));<br>		<span class="hljs-comment">//测试删除</span><br>		tree.delete(<span class="hljs-number">3</span>);<br>		System.out.println(<span class="hljs-string">&quot;删除后元素的个数&quot;</span>+tree.size());<br>		System.out.println(<span class="hljs-string">&quot;删除后键3对应的元素&quot;</span>+tree.get(<span class="hljs-number">3</span>));<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>查找二叉树中的最小键和最大键</strong></p>
<p>重点是两个min()方法和两个max()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTree</span>&lt;Key <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;Key&gt;,Value&gt; &#123;<br><span class="hljs-comment">//记录根结点</span><br><span class="hljs-keyword">private</span> Node root;<br><span class="hljs-comment">//记录树中元素个数</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>	<span class="hljs-comment">//存储键</span><br>	<span class="hljs-keyword">public</span> Key key;<br>	<span class="hljs-comment">//存储值</span><br>	<span class="hljs-keyword">public</span> Value value;<br>	<span class="hljs-comment">//记录左子节点</span><br>	<span class="hljs-keyword">public</span> Node left;<br>	<span class="hljs-comment">//记录右子节点</span><br>	<span class="hljs-keyword">public</span> Node right;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(Key key,Value value,Node left,Node right)</span> &#123;<br>		<span class="hljs-built_in">this</span>.key=key;<br>		<span class="hljs-built_in">this</span>.value=value;<br>		<span class="hljs-built_in">this</span>.right=right;<br>	&#125;<br>&#125;<br><span class="hljs-comment">//获取树中元素的个数</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">return</span> N;<br>&#125;<br><br><span class="hljs-comment">//向树中添加元素key-value</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Key key,Value value)</span> &#123;<br>	root=put(root,key,value);<br>&#125;<br><span class="hljs-comment">//向指定的树中添加key-value，并返回添加元素后的新树</span><br><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">put</span><span class="hljs-params">(Node x,Key key,Value value)</span> &#123;<br>	<span class="hljs-comment">//x子树为空</span><br>	<span class="hljs-keyword">if</span>(x==<span class="hljs-literal">null</span>) &#123;<br>		N++;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key,value,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>);<br>	&#125;<br>	<span class="hljs-comment">//如果x子树不为空</span><br>		<span class="hljs-comment">//比较x结点的键和key的大小</span><br>		<span class="hljs-type">int</span> cmp=key.compareTo(x.key);<br>		<span class="hljs-keyword">if</span>(cmp&gt;<span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-comment">//如果key大于x结点的键，则继续找x结点右子树</span><br>			x.right=put(x.right,key,value);<br>		&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmp&lt;<span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-comment">//如果key小于x节点的键，则继续找x结点的左子树</span><br>			x.left=put(x.left,key,value);<br>		&#125;<br>		<span class="hljs-keyword">else</span><br>		&#123;<br>			<span class="hljs-comment">//如果key等于x结点的键，则替换value</span><br>			x.value=value;<br>		&#125;<br>		<span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-comment">//查询树中指定key对应的value</span><br><span class="hljs-keyword">public</span> Value <span class="hljs-title function_">get</span><span class="hljs-params">(Key key)</span> &#123;<br>	<span class="hljs-keyword">return</span> get(root,key);<br>&#125;<br><span class="hljs-comment">//从指定的树x中，查找key对应的值</span><br><span class="hljs-keyword">public</span> Value <span class="hljs-title function_">get</span><span class="hljs-params">(Node x,Key key)</span> &#123;<br>	<span class="hljs-comment">//x树为null</span><br>	<span class="hljs-keyword">if</span>(x==<span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>	&#125;<br>	<span class="hljs-comment">//x树不为null</span><br>	<span class="hljs-comment">//比较key和x结点键的大小</span><br>	<span class="hljs-type">int</span> cmp=key.compareTo(x.key);<br>	<span class="hljs-keyword">if</span>(cmp&gt;<span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-comment">//如果key大于x结点的键，则继续找x结点右子树</span><br>		<span class="hljs-keyword">return</span> get(x.right,key);<br>	&#125;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmp&lt;<span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-comment">//如果key小于x节点的键，则继续找x结点的左子树</span><br>		<span class="hljs-keyword">return</span> get(x.left,key);<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-comment">//如果key等于x结点的键，就找到了key的结点，只需要返回x结点的值即可</span><br>		<span class="hljs-keyword">return</span> x.value;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">//删除树中key对应的value值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(Key key)</span> &#123;<br>	delete(root,key);<br>&#125;<br><span class="hljs-comment">//删除指定树x中的key所对应的value，并返回删除后的新树</span><br><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">delete</span><span class="hljs-params">(Node x,Key key)</span> &#123;<br>	<span class="hljs-comment">//x树为null</span><br>	<br>	<span class="hljs-keyword">if</span>(x==<span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>	&#125;<br>	<span class="hljs-comment">//x树不为null</span><br>	<span class="hljs-comment">//比较key和x结点键的大小</span><br>			<span class="hljs-type">int</span> cmp=key.compareTo(x.key);<br>	<span class="hljs-keyword">if</span>(cmp&gt;<span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-comment">//如果key大于x结点的键，则继续找x结点右子树</span><br>		x.right=delete(x.right,key);<br>	&#125;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmp&lt;<span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-comment">//如果key小于x节点的键，则继续找x结点的左子树</span><br>		x.left=delete(x.left,key);<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-comment">//让元素个数减一</span><br>		N--;<br>		<span class="hljs-comment">//得找到x结点右子树中最小的结点</span><br>		<span class="hljs-keyword">if</span>(x.right==<span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">return</span> x.left;<span class="hljs-comment">//因为是递归所以这个返回值之后在上面会自动给那个被删除结点的父节点</span><br>		&#125;<br>		<span class="hljs-keyword">if</span>(x.left==<span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> x.right;<span class="hljs-comment">//因为是递归所以这个返回值之后在上面会自动给那个被删除结点的父节点</span><br>		&#125;<br>		Node minNode=x.right;<br>		<span class="hljs-keyword">while</span>(minNode.left!=<span class="hljs-literal">null</span>) &#123;<br>		minNode=minNode.left;<br>		<br>		&#125;<br>		<span class="hljs-comment">//删除右子树中的最小结点</span><br>		Node n=x.right;<br>		<span class="hljs-keyword">while</span>(n.left!=<span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-comment">//如果n结点的下一个的下一个是空，就将n结点的下一个设为null</span><br>		<span class="hljs-keyword">if</span>(n.left.left==<span class="hljs-literal">null</span>) &#123;<br>			n.left=<span class="hljs-literal">null</span>;<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-comment">//变换n结点即可</span><br>			n=n.left;<br>		&#125;<br>		&#125;<br>	<span class="hljs-comment">//让最小结点为被删结点左右结点的父结点</span><br>			minNode.right=x.right;<br>		<br>			minNode.left=x.left;<br>		<br>		<span class="hljs-comment">//被删结点的父结点为minNode的父节点</span><br>		x=minNode;<br><br>	&#125;<br>	<span class="hljs-keyword">return</span> x;<span class="hljs-comment">//因为是递归所以这个返回值为x也就是minNode之后在上面会自动给那个被删除结点的父节点，到最后返回的就是删除后的新树</span><br>&#125;<br><br><span class="hljs-comment">//找出整个树中找出最小的键</span><br><span class="hljs-keyword">public</span> Key <span class="hljs-title function_">min</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">return</span> min(root).key;<br>&#125;<br><span class="hljs-comment">//查找指定树x中找出最小键所在的结点</span><br><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">min</span><span class="hljs-params">(Node x)</span> &#123;<br>	<span class="hljs-keyword">if</span>(x.left!=<span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> min(x.left);<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-keyword">return</span> x;<br>	&#125;<br>&#125;<br><span class="hljs-comment">//找出整个树中最大的键</span><br><span class="hljs-keyword">public</span> Key <span class="hljs-title function_">max</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">return</span> max(root).key;<br>&#125;<br><span class="hljs-comment">//查找指定树中的最大键</span><br><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">max</span><span class="hljs-params">(Node x)</span> &#123;<br>	<span class="hljs-keyword">if</span>(x.right!=<span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> min(x.right);<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-keyword">return</span> x;<br>	&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>










<p>测试：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> testTree &#123;<br><br>	<span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>		//创建二叉查找对象<br>		BinaryTree&lt;<span class="hljs-type">Integer</span>,String&gt; tree=<span class="hljs-built_in">new</span> BinaryTree&lt;&gt;();<br>		//测试插入<br>		tree.put(<span class="hljs-number">1</span>,&quot;张三&quot;);<br>		tree.put(<span class="hljs-number">2</span>, &quot;李四&quot;);<br>		tree.put(<span class="hljs-number">3</span>, &quot;王五&quot;);<br><br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(tree.min());<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(tree.max());<br>	&#125;<br><br>&#125;<br>结果：<span class="hljs-number">1</span>，<span class="hljs-number">2</span>         不知道为什么最大值弄不出来<br></code></pre></td></tr></table></figure>

<h3 id="二叉树的基础遍历"><a href="#二叉树的基础遍历" class="headerlink" title="二叉树的基础遍历"></a>二叉树的基础遍历</h3><p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656827.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220802162803486"></p>
<p>1.前序遍历； 先访问根结点，然后再访问左子树，最后访问右子树 </p>
<p><strong>前序遍历</strong></p>
<p>public Queue preErgodic()：使用前序遍历，获取整个树中的所有键</p>
<p>private void preErgodic(Node x,Queue keys)：使用前序遍历，把指定树x中的所有键放入到keys队列中 实现过程中，我们通过前序遍历，把,把每个结点的键取出，放入到队列中返回即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取整个树中的所有键</span><br><span class="hljs-keyword">public</span> Queue&lt;Key&gt; <span class="hljs-title function_">preErgodic</span><span class="hljs-params">()</span>&#123;<br>	Queue&lt;Key&gt; keys=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>&lt;Key&gt;();<br>	preErgodic(root,keys);<br>	<span class="hljs-keyword">return</span> keys;<br>&#125;<br><span class="hljs-comment">//获取指定树所有的键放到keys</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preErgodic</span><span class="hljs-params">(Node x,Queue&lt;Key&gt; keys)</span> &#123;<br>	<span class="hljs-keyword">if</span>(x==<span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-comment">//把x结点的key放入到keys中</span><br>	keys.enqueue(x.key);<br>	<span class="hljs-comment">//递归遍历x结点的左子树</span><br>	<span class="hljs-keyword">if</span>(x.left!=<span class="hljs-literal">null</span>) &#123;<br>		preErgodic(x.left,keys);<br>	&#125;<br>	<span class="hljs-comment">//递归遍历x结点的右子树</span><br>	<span class="hljs-keyword">if</span>(x.right!=<span class="hljs-literal">null</span>) &#123;<br>		preErgodic(x.right,keys);<br>	&#125;<br>&#125; <br></code></pre></td></tr></table></figure>



<p>2.中序遍历； 先访问左子树，中间访问根节点，最后访问右子树 </p>
<p><strong>中序遍历</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Queue&lt;Key&gt; <span class="hljs-title function_">midErgodic</span><span class="hljs-params">()</span>&#123;<br>	Queue&lt;Key&gt; keys=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>&lt;Key&gt;();<br>	midErgodic(root,keys);<br>	<span class="hljs-keyword">return</span> keys;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">midErgodic</span><span class="hljs-params">(Node x,Queue&lt;Key&gt; keys)</span> &#123;<br>	<span class="hljs-keyword">if</span>(x==<span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-comment">//递归遍历x结点的左子树</span><br>		<span class="hljs-keyword">if</span>(x.left!=<span class="hljs-literal">null</span>) &#123;<br>			midErgodic(x.left,keys);<br>		&#125;<br>		<span class="hljs-comment">//把x结点的key放入到keys中</span><br>		keys.enqueue(x.key);<br>		<span class="hljs-comment">//递归遍历x结点的右子树</span><br>		<span class="hljs-keyword">if</span>(x.right!=<span class="hljs-literal">null</span>) &#123;<br>			midErgodic(x.right,keys);<br>		&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>3.<strong>后序遍历</strong>； 先访问左子树，再访问右子树，最后访问根节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lastErgodic</span><span class="hljs-params">(Node x,Queue&lt;Key&gt; keys)</span> &#123;<br>	<span class="hljs-keyword">if</span>(x==<span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-comment">//递归遍历x结点的左子树</span><br>		<span class="hljs-keyword">if</span>(x.left!=<span class="hljs-literal">null</span>) &#123;<br>			lastErgodic(x.left,keys);<br>		&#125;<br>		<span class="hljs-comment">//递归遍历x结点的右子树</span><br>		<span class="hljs-keyword">if</span>(x.right!=<span class="hljs-literal">null</span>) &#123;<br>			lastErgodic(x.right,keys);<br>		&#125;<br>		<span class="hljs-comment">//把x结点的key放入到keys中</span><br>		keys.enqueue(x.key);<br>	<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>二叉树的层序遍历</strong></p>
<p>所谓的层序遍历，就是从根节点开始依次向下，获取每一层所有结点的值（从左到右）</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656828.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220802163306818"></p>
<p>弹出一个的时候要判断弹出的这个结点有没有左子节点和右子节点按照先左后右的顺序去判断</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//层序遍历</span><br><span class="hljs-keyword">public</span> Queue&lt;Key&gt; <span class="hljs-title function_">layerErgodic</span><span class="hljs-params">()</span>&#123;<br>	<span class="hljs-comment">//定义两个队列，分别存储树中的键和树中的结点</span><br>	Queue&lt;Key&gt; keys=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>&lt;&gt;();<br>	Queue&lt;Node&gt; nodes=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>&lt;&gt;();<br>	<br><br>	<span class="hljs-comment">//默认往结点队列中放入根节点</span><br>	nodes.enqueue(root);<br>	<span class="hljs-keyword">while</span>(!nodes.isEmpty()) &#123;<br>		<span class="hljs-comment">//从队列中弹出一个结点</span><br>		Node n=nodes.dequeue();<br>		keys.enqueue(n.key);<br>		<span class="hljs-comment">//判断当前结点有没有左子节点，有则放入nodes中</span><br>		<span class="hljs-keyword">if</span>(n.left!=<span class="hljs-literal">null</span>) &#123;<br>			nodes.enqueue(n.left);<br>		&#125;<br>		<span class="hljs-comment">//判断当前结点有没有右子节点，有则放入nodes中</span><br>	    <span class="hljs-keyword">if</span>(n.right!=<span class="hljs-literal">null</span>) &#123;<br>	    	nodes.enqueue(n.right);<br>	    &#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> keys;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>包含全部遍历的API</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTree</span>&lt;Key <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;Key&gt;,Value&gt; &#123;<br><span class="hljs-comment">//记录根结点</span><br><span class="hljs-keyword">private</span> Node root;<br><span class="hljs-comment">//记录树中元素个数</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>	<span class="hljs-comment">//存储键</span><br>	<span class="hljs-keyword">public</span> Key key;<br>	<span class="hljs-comment">//存储值</span><br>	<span class="hljs-keyword">public</span> Value value;<br>	<span class="hljs-comment">//记录左子节点</span><br>	<span class="hljs-keyword">public</span> Node left;<br>	<span class="hljs-comment">//记录右子节点</span><br>	<span class="hljs-keyword">public</span> Node right;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(Key key,Value value,Node left,Node right)</span> &#123;<br>		<span class="hljs-built_in">this</span>.key=key;<br>		<span class="hljs-built_in">this</span>.value=value;<br>		<span class="hljs-built_in">this</span>.right=right;<br>	&#125;<br>&#125;<br><span class="hljs-comment">//获取树中元素的个数</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">return</span> N;<br>&#125;<br><br><span class="hljs-comment">//向树中添加元素key-value</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Key key,Value value)</span> &#123;<br>	root=put(root,key,value);<br>&#125;<br><span class="hljs-comment">//向指定的树中添加key-value，并返回添加元素后的新树</span><br><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">put</span><span class="hljs-params">(Node x,Key key,Value value)</span> &#123;<br>	<span class="hljs-comment">//x子树为空</span><br>	<span class="hljs-keyword">if</span>(x==<span class="hljs-literal">null</span>) &#123;<br>               N++;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key,value,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>);<br>	&#125;<br>	<span class="hljs-comment">//如果x子树不为空</span><br>		<span class="hljs-comment">//比较x结点的键和key的大小</span><br>		<span class="hljs-type">int</span> cmp=key.compareTo(x.key);<br>		<span class="hljs-keyword">if</span>(cmp&gt;<span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-comment">//如果key大于x结点的键，则继续找x结点右子树</span><br>			x.right=put(x.right,key,value);<br>		&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmp&lt;<span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-comment">//如果key小于x节点的键，则继续找x结点的左子树</span><br>			x.left=put(x.left,key,value);<br>		&#125;<br>		<span class="hljs-keyword">else</span><br>		&#123;<br>			<span class="hljs-comment">//如果key等于x结点的键，则替换value</span><br>			x.value=value;<br>		&#125;<br>		<span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-comment">//查询树中指定key对应的value</span><br><span class="hljs-keyword">public</span> Value <span class="hljs-title function_">get</span><span class="hljs-params">(Key key)</span> &#123;<br>	<span class="hljs-keyword">return</span> get(root,key);<br>&#125;<br><span class="hljs-comment">//从指定的树x中，查找key对应的值</span><br><span class="hljs-keyword">public</span> Value <span class="hljs-title function_">get</span><span class="hljs-params">(Node x,Key key)</span> &#123;<br>	<span class="hljs-comment">//x树为null</span><br>	<span class="hljs-keyword">if</span>(x==<span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>	&#125;<br>	<span class="hljs-comment">//x树不为null</span><br>	<span class="hljs-comment">//比较key和x结点键的大小</span><br>	<span class="hljs-type">int</span> cmp=key.compareTo(x.key);<br>	<span class="hljs-keyword">if</span>(cmp&gt;<span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-comment">//如果key大于x结点的键，则继续找x结点右子树</span><br>		<span class="hljs-keyword">return</span> get(x.right,key);<br>	&#125;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmp&lt;<span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-comment">//如果key小于x节点的键，则继续找x结点的左子树</span><br>		<span class="hljs-keyword">return</span> get(x.left,key);<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-comment">//如果key等于x结点的键，就找到了key的结点，只需要返回x结点的值即可</span><br>		<span class="hljs-keyword">return</span> x.value;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">//删除树中key对应的value值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(Key key)</span> &#123;<br>	delete(root,key);<br>&#125;<br><span class="hljs-comment">//删除指定树x中的key所对应的value，并返回删除后的新树</span><br><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">delete</span><span class="hljs-params">(Node x,Key key)</span> &#123;<br>	<span class="hljs-comment">//x树为null</span><br>	<br><br>	<span class="hljs-keyword">if</span>(x==<span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>	&#125;<br>	<span class="hljs-comment">//x树不为null</span><br>	<span class="hljs-comment">//比较key和x结点键的大小</span><br>			<span class="hljs-type">int</span> cmp=key.compareTo(x.key);<br>	<span class="hljs-keyword">if</span>(cmp&gt;<span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-comment">//如果key大于x结点的键，则继续找x结点右子树</span><br>		x.right=delete(x.right,key);<br>	&#125;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmp&lt;<span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-comment">//如果key小于x节点的键，则继续找x结点的左子树</span><br>		x.left=delete(x.left,key);<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-comment">//让元素个数减一</span><br>		N--;<br>		<span class="hljs-comment">//得找到x结点右子树中最小的结点</span><br>		<span class="hljs-keyword">if</span>(x.right==<span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">return</span> x.left;<span class="hljs-comment">//因为是递归所以这个返回值之后在上面会自动给那个被删除结点的父节点</span><br>		&#125;<br>		<span class="hljs-keyword">if</span>(x.left==<span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> x.right;<span class="hljs-comment">//因为是递归所以这个返回值之后在上面会自动给那个被删除结点的父节点</span><br>		&#125;<br>		Node minNode=x.right;<br>		<span class="hljs-keyword">while</span>(minNode.left!=<span class="hljs-literal">null</span>) &#123;<br>		minNode=minNode.left;<br>		<br>		&#125;<br>		<span class="hljs-comment">//删除右子树中的最小结点</span><br>		Node n=x.right;<br>		<span class="hljs-keyword">while</span>(n.left!=<span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-comment">//如果n结点的下一个的下一个是空，就将n结点的下一个设为null</span><br>		<span class="hljs-keyword">if</span>(n.left.left==<span class="hljs-literal">null</span>) &#123;<br>			n.left=<span class="hljs-literal">null</span>;<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-comment">//变换n结点即可</span><br>			n=n.left;<br>		&#125;<br>		&#125;<br>	<span class="hljs-comment">//让最小结点为被删结点左右结点的父结点</span><br>			minNode.right=x.right;<br>		<br>			minNode.left=x.left;<br>		<br>		<span class="hljs-comment">//被删结点的父结点为minNode的父节点</span><br>		x=minNode;<br>	<br>	&#125;<br>	<span class="hljs-keyword">return</span> x;<span class="hljs-comment">//因为是递归所以这个返回值为x也就是minNode之后在上面会自动给那个被删除结点的父节点，到最后返回的就是删除后的新树</span><br><br>&#125;<br><br><span class="hljs-comment">//找出整个树中找出最小的键</span><br><span class="hljs-keyword">public</span> Key <span class="hljs-title function_">min</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">return</span> min(root).key;<br>&#125;<br><span class="hljs-comment">//查找指定树x中找出最小键所在的结点</span><br><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">min</span><span class="hljs-params">(Node x)</span> &#123;<br>	<span class="hljs-keyword">if</span>(x.left!=<span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> min(x.left);<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-keyword">return</span> x;<br>	&#125;<br>&#125;<br><span class="hljs-comment">//找出整个树中最大的键</span><br><span class="hljs-keyword">public</span> Key <span class="hljs-title function_">max</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">return</span> max(root).key;<br>&#125;<br><span class="hljs-comment">//查找指定树中的最大键</span><br><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">max</span><span class="hljs-params">(Node x)</span> &#123;<br>	<span class="hljs-keyword">if</span>(x.right!=<span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> min(x.right);<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-keyword">return</span> x;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">//前序遍历</span><br><span class="hljs-comment">//获取整个树中的所有键</span><br><span class="hljs-keyword">public</span> Queue&lt;Key&gt; <span class="hljs-title function_">preErgodic</span><span class="hljs-params">()</span>&#123;<br>	Queue&lt;Key&gt; keys=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>&lt;Key&gt;();<br>	preErgodic(root,keys);<br>	<span class="hljs-keyword">return</span> keys;<br>&#125;<br><span class="hljs-comment">//获取指定树所有的键放到keys</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preErgodic</span><span class="hljs-params">(Node x,Queue&lt;Key&gt; keys)</span> &#123;<br>	<span class="hljs-keyword">if</span>(x==<span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-comment">//把x结点的key放入到keys中</span><br>	keys.enqueue(x.key);<br>	<span class="hljs-comment">//递归遍历x结点的左子树</span><br>	<span class="hljs-keyword">if</span>(x.left!=<span class="hljs-literal">null</span>) &#123;<br>		preErgodic(x.left,keys);<br>	&#125;<br>	<span class="hljs-comment">//递归遍历x结点的右子树</span><br>	<span class="hljs-keyword">if</span>(x.right!=<span class="hljs-literal">null</span>) &#123;<br>		preErgodic(x.right,keys);<br>	&#125;<br>&#125; <br><br><br><span class="hljs-keyword">public</span> Queue&lt;Key&gt; <span class="hljs-title function_">midErgodic</span><span class="hljs-params">()</span>&#123;<br>	Queue&lt;Key&gt; keys=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>&lt;Key&gt;();<br>	midErgodic(root,keys);<br>	<span class="hljs-keyword">return</span> keys;<br>&#125;<br><br><span class="hljs-comment">//中序遍历</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">midErgodic</span><span class="hljs-params">(Node x,Queue&lt;Key&gt; keys)</span> &#123;<br>	<span class="hljs-keyword">if</span>(x==<span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-comment">//递归遍历x结点的左子树</span><br>		<span class="hljs-keyword">if</span>(x.left!=<span class="hljs-literal">null</span>) &#123;<br>			midErgodic(x.left,keys);<br>		&#125;<br>		<span class="hljs-comment">//把x结点的key放入到keys中</span><br>		keys.enqueue(x.key);<br>		<span class="hljs-comment">//递归遍历x结点的右子树</span><br>		<span class="hljs-keyword">if</span>(x.right!=<span class="hljs-literal">null</span>) &#123;<br>			midErgodic(x.right,keys);<br>		&#125;<br>&#125;<br><span class="hljs-comment">//后序遍历</span><br><span class="hljs-keyword">public</span> Queue&lt;Key&gt; <span class="hljs-title function_">lastErgodic</span><span class="hljs-params">()</span>&#123;<br>	Queue&lt;Key&gt; keys=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>&lt;Key&gt;();<br>	lastErgodic(root,keys);<br>	<span class="hljs-keyword">return</span> keys;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lastErgodic</span><span class="hljs-params">(Node x,Queue&lt;Key&gt; keys)</span> &#123;<br>	<span class="hljs-keyword">if</span>(x==<span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-comment">//递归遍历x结点的左子树</span><br>		<span class="hljs-keyword">if</span>(x.left!=<span class="hljs-literal">null</span>) &#123;<br>			lastErgodic(x.left,keys);<br>		&#125;<br>		<span class="hljs-comment">//递归遍历x结点的右子树</span><br>		<span class="hljs-keyword">if</span>(x.right!=<span class="hljs-literal">null</span>) &#123;<br>			lastErgodic(x.right,keys);<br>		&#125;<br>		<span class="hljs-comment">//把x结点的key放入到keys中</span><br>		keys.enqueue(x.key);<br>	<br>&#125;<br><span class="hljs-comment">//层序遍历</span><br><span class="hljs-keyword">public</span> Queue&lt;Key&gt; <span class="hljs-title function_">layerErgodic</span><span class="hljs-params">()</span>&#123;<br>	<span class="hljs-comment">//定义两个队列，分别存储树中的键和树中的结点</span><br>	Queue&lt;Key&gt; keys=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>&lt;&gt;();<br>	Queue&lt;Node&gt; nodes=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>&lt;&gt;();<br>	<br><br>	<span class="hljs-comment">//默认往结点队列中放入根节点</span><br>	nodes.enqueue(root);<br>	<span class="hljs-keyword">while</span>(!nodes.isEmpty()) &#123;<br>		<span class="hljs-comment">//从队列中弹出一个结点</span><br>		Node n=nodes.dequeue();<br>		keys.enqueue(n.key);<br>		<span class="hljs-comment">//判断当前结点有没有左子节点，有则放入nodes中</span><br>		<span class="hljs-keyword">if</span>(n.left!=<span class="hljs-literal">null</span>) &#123;<br>			nodes.enqueue(n.left);<br>		&#125;<br>		<span class="hljs-comment">//判断当前结点有没有右子节点，有则放入nodes中</span><br>	    <span class="hljs-keyword">if</span>(n.right!=<span class="hljs-literal">null</span>) &#123;<br>	    	nodes.enqueue(n.right);<br>	    &#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> keys;<br><br>&#125;<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">testTree</span> &#123;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-comment">//创建二叉查找对象</span><br>		BinaryTree&lt;String,String&gt; tree=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BinaryTree</span>&lt;&gt;();<br>		tree.put(<span class="hljs-string">&quot;E&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>);<br>		tree.put(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>);<br>		tree.put(<span class="hljs-string">&quot;G&quot;</span>, <span class="hljs-string">&quot;7&quot;</span>);<br>		tree.put(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>);<br>		tree.put(<span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>);<br>		tree.put(<span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>);<br>		tree.put(<span class="hljs-string">&quot;H&quot;</span>, <span class="hljs-string">&quot;8&quot;</span>);<br>		tree.put(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>);<br>	<br>		<span class="hljs-comment">//前序遍历</span><br>		Queue&lt;String&gt; keys=tree.preErgodic();<br>		<span class="hljs-keyword">for</span>(String key:keys) &#123;<br>			String value=tree.get(key);<br>			System.out.println(key+<span class="hljs-string">&quot;----&quot;</span>+value);<br>		&#125;<br>		System.out.println(<span class="hljs-string">&quot;-----------------------------------&quot;</span>);<br>		<span class="hljs-comment">//中序遍历</span><br>	Queue&lt;String&gt; key1s=tree.midErgodic();<br>	<span class="hljs-keyword">for</span>(String key:key1s) &#123;<br>		String value=tree.get(key);<br>		System.out.println(key+<span class="hljs-string">&quot;----&quot;</span>+value);<br>	&#125;<br>	System.out.println(<span class="hljs-string">&quot;-----------------------------------&quot;</span>);<br>	<span class="hljs-comment">//后序遍历</span><br>	Queue&lt;String&gt; key2s=tree.lastErgodic();<br>	<span class="hljs-keyword">for</span>(String key:key2s) &#123;<br>		String value=tree.get(key);<br>		System.out.println(key+<span class="hljs-string">&quot;----&quot;</span>+value);<br>	&#125;<br>	System.out.println(<span class="hljs-string">&quot;-----------------------------------&quot;</span>);<br>	<span class="hljs-comment">//层序遍历</span><br>	Queue&lt;String&gt; key3s=tree.layerErgodic();<br>	<span class="hljs-keyword">for</span>(String key:key3s) &#123;<br>		String value=tree.get(key);<br>		System.out.println(key+<span class="hljs-string">&quot;----&quot;</span>+value);<br>	&#125;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="二叉树的最大深度问题"><a href="#二叉树的最大深度问题" class="headerlink" title="二叉树的最大深度问题"></a>二叉树的最大深度问题</h3><p>分别计算左右子树的最大深度然后再加一就是整个子树的最大深度</p>
<p>代码API</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//计算整个树的最大深度</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">return</span> maxDepth(root);<br>&#125;<br><br><span class="hljs-comment">//获取指定树x的最大深度</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(Node x)</span> &#123;<br>	<span class="hljs-keyword">if</span>(x==<span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-type">int</span> max=<span class="hljs-number">0</span>;<span class="hljs-comment">//这是x的最大深度</span><br>	<span class="hljs-type">int</span> maxl=<span class="hljs-number">0</span>;<span class="hljs-comment">//这是x的左子树的最大深度</span><br>	<span class="hljs-type">int</span> maxR=<span class="hljs-number">0</span>;<span class="hljs-comment">//这是x的右子树的最大深度</span><br>	<br><br>	<span class="hljs-comment">//计算x结点左子树的最大深度</span><br>	<span class="hljs-keyword">if</span>(x.left!=<span class="hljs-literal">null</span>) &#123;<br>		maxl=maxDepth(x.left);<br>	&#125;<br>	<span class="hljs-comment">//计算x结点右子树最大深度</span><br>	<span class="hljs-keyword">if</span>(x.right!=<span class="hljs-literal">null</span>) &#123;<br>		maxR=maxDepth(x.right);<br>	&#125;<br>	<span class="hljs-comment">//比较左子树最大深度和右子树最大深度，取较大值+1即可</span><br>	max=maxl&gt;maxR?maxl+<span class="hljs-number">1</span>:maxR+<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">return</span> max;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">testTree</span> &#123;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-comment">//创建二叉查找对象</span><br>		BinaryTree&lt;String,String&gt; tree=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BinaryTree</span>&lt;&gt;();<br>		tree.put(<span class="hljs-string">&quot;E&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>);<br>		tree.put(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>);<br>		tree.put(<span class="hljs-string">&quot;G&quot;</span>, <span class="hljs-string">&quot;7&quot;</span>);<br>		tree.put(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>);<br>		tree.put(<span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>);<br>		tree.put(<span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>);<br>		tree.put(<span class="hljs-string">&quot;H&quot;</span>, <span class="hljs-string">&quot;8&quot;</span>);<br>		tree.put(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>);<br><br>System.out.println(tree.maxDepth());<br><br>&#125;&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总的API</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTree</span>&lt;Key <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;Key&gt;,Value&gt; &#123;<br><span class="hljs-comment">//记录根结点</span><br><span class="hljs-keyword">private</span> Node root;<br><span class="hljs-comment">//记录树中元素个数</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>	<span class="hljs-comment">//存储键</span><br>	<span class="hljs-keyword">public</span> Key key;<br>	<span class="hljs-comment">//存储值</span><br>	<span class="hljs-keyword">public</span> Value value;<br>	<span class="hljs-comment">//记录左子节点</span><br>	<span class="hljs-keyword">public</span> Node left;<br>	<span class="hljs-comment">//记录右子节点</span><br>	<span class="hljs-keyword">public</span> Node right;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(Key key,Value value,Node left,Node right)</span> &#123;<br>		<span class="hljs-built_in">this</span>.key=key;<br>		<span class="hljs-built_in">this</span>.value=value;<br>		<span class="hljs-built_in">this</span>.right=right;<br>	&#125;<br>&#125;<br><span class="hljs-comment">//获取树中元素的个数</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">return</span> N;<br>&#125;<br><br><span class="hljs-comment">//向树中添加元素key-value</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Key key,Value value)</span> &#123;<br>	root=put(root,key,value);<br>&#125;<br><span class="hljs-comment">//向指定的树中添加key-value，并返回添加元素后的新树</span><br><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">put</span><span class="hljs-params">(Node x,Key key,Value value)</span> &#123;<br>	<span class="hljs-comment">//x子树为空</span><br>	<span class="hljs-keyword">if</span>(x==<span class="hljs-literal">null</span>) &#123;<br>               N++;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key,value,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>);<br>	&#125;<br>	<span class="hljs-comment">//如果x子树不为空</span><br>		<span class="hljs-comment">//比较x结点的键和key的大小</span><br>		<span class="hljs-type">int</span> cmp=key.compareTo(x.key);<br>		<span class="hljs-keyword">if</span>(cmp&gt;<span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-comment">//如果key大于x结点的键，则继续找x结点右子树</span><br>			x.right=put(x.right,key,value);<br>		&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmp&lt;<span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-comment">//如果key小于x节点的键，则继续找x结点的左子树</span><br>			x.left=put(x.left,key,value);<br>		&#125;<br>		<span class="hljs-keyword">else</span><br>		&#123;<br>			<span class="hljs-comment">//如果key等于x结点的键，则替换value</span><br>			x.value=value;<br>		&#125;<br>		<span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-comment">//查询树中指定key对应的value</span><br><span class="hljs-keyword">public</span> Value <span class="hljs-title function_">get</span><span class="hljs-params">(Key key)</span> &#123;<br>	<span class="hljs-keyword">return</span> get(root,key);<br>&#125;<br><span class="hljs-comment">//从指定的树x中，查找key对应的值</span><br><span class="hljs-keyword">public</span> Value <span class="hljs-title function_">get</span><span class="hljs-params">(Node x,Key key)</span> &#123;<br>	<span class="hljs-comment">//x树为null</span><br>	<span class="hljs-keyword">if</span>(x==<span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>	&#125;<br>	<span class="hljs-comment">//x树不为null</span><br>	<span class="hljs-comment">//比较key和x结点键的大小</span><br>	<span class="hljs-type">int</span> cmp=key.compareTo(x.key);<br>	<span class="hljs-keyword">if</span>(cmp&gt;<span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-comment">//如果key大于x结点的键，则继续找x结点右子树</span><br>		<span class="hljs-keyword">return</span> get(x.right,key);<br>	&#125;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmp&lt;<span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-comment">//如果key小于x节点的键，则继续找x结点的左子树</span><br>		<span class="hljs-keyword">return</span> get(x.left,key);<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-comment">//如果key等于x结点的键，就找到了key的结点，只需要返回x结点的值即可</span><br>		<span class="hljs-keyword">return</span> x.value;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">//删除树中key对应的value值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(Key key)</span> &#123;<br>	delete(root,key);<br>&#125;<br><span class="hljs-comment">//删除指定树x中的key所对应的value，并返回删除后的新树</span><br><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">delete</span><span class="hljs-params">(Node x,Key key)</span> &#123;<br>	<span class="hljs-comment">//x树为null</span><br>	<br><br>	<span class="hljs-keyword">if</span>(x==<span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>	&#125;<br>	<span class="hljs-comment">//x树不为null</span><br>	<span class="hljs-comment">//比较key和x结点键的大小</span><br>			<span class="hljs-type">int</span> cmp=key.compareTo(x.key);<br>	<span class="hljs-keyword">if</span>(cmp&gt;<span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-comment">//如果key大于x结点的键，则继续找x结点右子树</span><br>		x.right=delete(x.right,key);<br>	&#125;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmp&lt;<span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-comment">//如果key小于x节点的键，则继续找x结点的左子树</span><br>		x.left=delete(x.left,key);<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-comment">//让元素个数减一</span><br>		N--;<br>		<span class="hljs-comment">//得找到x结点右子树中最小的结点</span><br>		<span class="hljs-keyword">if</span>(x.right==<span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">return</span> x.left;<span class="hljs-comment">//因为是递归所以这个返回值之后在上面会自动给那个被删除结点的父节点</span><br>		&#125;<br>		<span class="hljs-keyword">if</span>(x.left==<span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> x.right;<span class="hljs-comment">//因为是递归所以这个返回值之后在上面会自动给那个被删除结点的父节点</span><br>		&#125;<br>		Node minNode=x.right;<br>		<span class="hljs-keyword">while</span>(minNode.left!=<span class="hljs-literal">null</span>) &#123;<br>		minNode=minNode.left;<br>		<br>		&#125;<br>		<span class="hljs-comment">//删除右子树中的最小结点</span><br>		Node n=x.right;<br>		<span class="hljs-keyword">while</span>(n.left!=<span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-comment">//如果n结点的下一个的下一个是空，就将n结点的下一个设为null</span><br>		<span class="hljs-keyword">if</span>(n.left.left==<span class="hljs-literal">null</span>) &#123;<br>			n.left=<span class="hljs-literal">null</span>;<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-comment">//变换n结点即可</span><br>			n=n.left;<br>		&#125;<br>		&#125;<br>	<span class="hljs-comment">//让最小结点为被删结点左右结点的父结点</span><br>			minNode.right=x.right;<br>		<br>			minNode.left=x.left;<br>		<br>		<span class="hljs-comment">//被删结点的父结点为minNode的父节点</span><br>		x=minNode;<br>	<br>	&#125;<br>	<span class="hljs-keyword">return</span> x;<span class="hljs-comment">//因为是递归所以这个返回值为x也就是minNode之后在上面会自动给那个被删除结点的父节点，到最后返回的就是删除后的新树</span><br><br>&#125;<br><br><span class="hljs-comment">//找出整个树中找出最小的键</span><br><span class="hljs-keyword">public</span> Key <span class="hljs-title function_">min</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">return</span> min(root).key;<br>&#125;<br><span class="hljs-comment">//查找指定树x中找出最小键所在的结点</span><br><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">min</span><span class="hljs-params">(Node x)</span> &#123;<br>	<span class="hljs-keyword">if</span>(x.left!=<span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> min(x.left);<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-keyword">return</span> x;<br>	&#125;<br>&#125;<br><span class="hljs-comment">//找出整个树中最大的键</span><br><span class="hljs-keyword">public</span> Key <span class="hljs-title function_">max</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">return</span> max(root).key;<br>&#125;<br><span class="hljs-comment">//查找指定树中的最大键</span><br><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">max</span><span class="hljs-params">(Node x)</span> &#123;<br>	<span class="hljs-keyword">if</span>(x.right!=<span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> min(x.right);<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-keyword">return</span> x;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">//前序遍历</span><br><span class="hljs-comment">//获取整个树中的所有键</span><br><span class="hljs-keyword">public</span> Queue&lt;Key&gt; <span class="hljs-title function_">preErgodic</span><span class="hljs-params">()</span>&#123;<br>	Queue&lt;Key&gt; keys=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>&lt;Key&gt;();<br>	preErgodic(root,keys);<br>	<span class="hljs-keyword">return</span> keys;<br>&#125;<br><span class="hljs-comment">//获取指定树所有的键放到keys</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preErgodic</span><span class="hljs-params">(Node x,Queue&lt;Key&gt; keys)</span> &#123;<br>	<span class="hljs-keyword">if</span>(x==<span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-comment">//把x结点的key放入到keys中</span><br>	keys.enqueue(x.key);<br>	<span class="hljs-comment">//递归遍历x结点的左子树</span><br>	<span class="hljs-keyword">if</span>(x.left!=<span class="hljs-literal">null</span>) &#123;<br>		preErgodic(x.left,keys);<br>	&#125;<br>	<span class="hljs-comment">//递归遍历x结点的右子树</span><br>	<span class="hljs-keyword">if</span>(x.right!=<span class="hljs-literal">null</span>) &#123;<br>		preErgodic(x.right,keys);<br>	&#125;<br>&#125; <br><br><br><span class="hljs-keyword">public</span> Queue&lt;Key&gt; <span class="hljs-title function_">midErgodic</span><span class="hljs-params">()</span>&#123;<br>	Queue&lt;Key&gt; keys=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>&lt;Key&gt;();<br>	midErgodic(root,keys);<br>	<span class="hljs-keyword">return</span> keys;<br>&#125;<br><br><span class="hljs-comment">//中序遍历</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">midErgodic</span><span class="hljs-params">(Node x,Queue&lt;Key&gt; keys)</span> &#123;<br>	<span class="hljs-keyword">if</span>(x==<span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-comment">//递归遍历x结点的左子树</span><br>		<span class="hljs-keyword">if</span>(x.left!=<span class="hljs-literal">null</span>) &#123;<br>			midErgodic(x.left,keys);<br>		&#125;<br>		<span class="hljs-comment">//把x结点的key放入到keys中</span><br>		keys.enqueue(x.key);<br>		<span class="hljs-comment">//递归遍历x结点的右子树</span><br>		<span class="hljs-keyword">if</span>(x.right!=<span class="hljs-literal">null</span>) &#123;<br>			midErgodic(x.right,keys);<br>		&#125;<br>&#125;<br><span class="hljs-comment">//后序遍历</span><br><span class="hljs-keyword">public</span> Queue&lt;Key&gt; <span class="hljs-title function_">lastErgodic</span><span class="hljs-params">()</span>&#123;<br>	Queue&lt;Key&gt; keys=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>&lt;Key&gt;();<br>	lastErgodic(root,keys);<br>	<span class="hljs-keyword">return</span> keys;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lastErgodic</span><span class="hljs-params">(Node x,Queue&lt;Key&gt; keys)</span> &#123;<br>	<span class="hljs-keyword">if</span>(x==<span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-comment">//递归遍历x结点的左子树</span><br>		<span class="hljs-keyword">if</span>(x.left!=<span class="hljs-literal">null</span>) &#123;<br>			lastErgodic(x.left,keys);<br>		&#125;<br>		<span class="hljs-comment">//递归遍历x结点的右子树</span><br>		<span class="hljs-keyword">if</span>(x.right!=<span class="hljs-literal">null</span>) &#123;<br>			lastErgodic(x.right,keys);<br>		&#125;<br>		<span class="hljs-comment">//把x结点的key放入到keys中</span><br>		keys.enqueue(x.key);<br>	<br>&#125;<br><span class="hljs-comment">//层序遍历</span><br><span class="hljs-keyword">public</span> Queue&lt;Key&gt; <span class="hljs-title function_">layerErgodic</span><span class="hljs-params">()</span>&#123;<br>	<span class="hljs-comment">//定义两个队列，分别存储树中的键和树中的结点</span><br>	Queue&lt;Key&gt; keys=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>&lt;&gt;();<br>	Queue&lt;Node&gt; nodes=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>&lt;&gt;();<br>	<br><br>	<span class="hljs-comment">//默认往结点队列中放入根节点</span><br>	nodes.enqueue(root);<br>	<span class="hljs-keyword">while</span>(!nodes.isEmpty()) &#123;<br>		<span class="hljs-comment">//从队列中弹出一个结点</span><br>		Node n=nodes.dequeue();<br>		keys.enqueue(n.key);<br>		<span class="hljs-comment">//判断当前结点有没有左子节点，有则放入nodes中</span><br>		<span class="hljs-keyword">if</span>(n.left!=<span class="hljs-literal">null</span>) &#123;<br>			nodes.enqueue(n.left);<br>		&#125;<br>		<span class="hljs-comment">//判断当前结点有没有右子节点，有则放入nodes中</span><br>	    <span class="hljs-keyword">if</span>(n.right!=<span class="hljs-literal">null</span>) &#123;<br>	    	nodes.enqueue(n.right);<br>	    &#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> keys;<br><br>&#125;<br><br><span class="hljs-comment">//计算整个树的最大深度</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">return</span> maxDepth(root);<br>&#125;<br><br><span class="hljs-comment">//获取指定树x的最大深度</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(Node x)</span> &#123;<br>	<span class="hljs-keyword">if</span>(x==<span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-type">int</span> max=<span class="hljs-number">0</span>;<span class="hljs-comment">//这是x的最大深度</span><br>	<span class="hljs-type">int</span> maxl=<span class="hljs-number">0</span>;<span class="hljs-comment">//这是x的左子树的最大深度</span><br>	<span class="hljs-type">int</span> maxR=<span class="hljs-number">0</span>;<span class="hljs-comment">//这是x的右子树的最大深度</span><br>	<br><br>	<span class="hljs-comment">//计算x结点左子树的最大深度</span><br>	<span class="hljs-keyword">if</span>(x.left!=<span class="hljs-literal">null</span>) &#123;<br>		maxl=maxDepth(x.left);<br>	&#125;<br>	<span class="hljs-comment">//计算x结点右子树最大深度</span><br>	<span class="hljs-keyword">if</span>(x.right!=<span class="hljs-literal">null</span>) &#123;<br>		maxR=maxDepth(x.right);<br>	&#125;<br>	<span class="hljs-comment">//比较左子树最大深度和右子树最大深度，取较大值+1即可</span><br>	max=maxl&gt;maxR?maxl+<span class="hljs-number">1</span>:maxR+<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">return</span> max;<br><br>&#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>




<h3 id="二叉树的折纸问题"><a href="#二叉树的折纸问题" class="headerlink" title="二叉树的折纸问题"></a>二叉树的折纸问题</h3><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>1，堆是完全二叉树</p>
<p>2.堆通常是通过数组来实现</p>
<p>如果一个结点的位置为k，则它的父结点的位置为[k&#x2F;2],而它的两个子结点的位置则分别为2k和2k+1。这样，在不 使用指针的情况下，我们也可以通过计算数组的索引在树中上下移动：从a[k]向上一层，就令k等于k&#x2F;2,向下一层就 令k等于2k或2k+1。</p>
<p>3.每个<strong>结点都大于等于它的两个子结点</strong>。这里要注意堆中仅仅规定了每个结点大于等于它的两个子结点，但这两个 子结点的顺序并没有做规定，跟我们之前学习的二叉查找树是有区别的。</p>
<h3 id="堆的API设计"><a href="#堆的API设计" class="headerlink" title="堆的API设计"></a>堆的API设计</h3><p>类名：Heap&lt;T extends Comparable<T>&gt;</p>
<p>构造方法 Heap(int capacity)：创建容量为capacity的Heap对象</p>
<p>成员方法:</p>
<p>1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素 </p>
<p>2.private void exch(int i,int j):交换堆中i索引和j索引处的值 </p>
<p>3.public T delMax():删除堆中最大的元素,并返回这个最大元素 </p>
<p>4.public void insert(T t)：往堆中插入一个元素 </p>
<p>5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置 </p>
<p>6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</p>
<p>成员变量：</p>
<p>1.private T[] imtes : 用来存储元素的数组 </p>
<p>2.private int N：记录堆中元素的个数</p>
<p><strong>堆的API设计</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Heap</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt;&gt; &#123;<br>	<span class="hljs-comment">//存放堆中的元素</span><br>	<span class="hljs-keyword">private</span> T[] item;<br>	<span class="hljs-comment">//堆中元素的个数</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br>	<span class="hljs-comment">//构造方法，生成元素个数为capacity的堆</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Heap</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>	item=(T[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparable</span>[capacity+<span class="hljs-number">1</span>];<span class="hljs-comment">//不能直接定义一个泛型数组，要用这钟强转形式,同时T类继承Comparable所以应该这样，而且0被弃用，所以要capacity+1</span><br>	<span class="hljs-built_in">this</span>.N=<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//判断堆中索引i处的元素是否小于索引j处的值</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">less</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> &#123;<br>		<span class="hljs-keyword">return</span> item[i].compareTo(item[j])&lt;<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//交换堆中i索引和j索引的值</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exch</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> &#123;<br>		T a;<br>		a=item[i];<br>		item[i]=item[j];<br>		item[j]=a;<br>	&#125;<br>	<span class="hljs-comment">//往堆中插入一个元素</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(T t)</span> &#123;<br>		item[++N]=t;<br>		swim(N);<span class="hljs-comment">//因为新加进去之后在最后所以一定是上浮</span><br>	&#125;<br>	<span class="hljs-comment">//使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>		<span class="hljs-comment">//通过循环不断比较当前结点和其父结点的值，如果发现父结点比当前结点的值小就交换</span><br>		<span class="hljs-keyword">while</span>(k&gt;<span class="hljs-number">1</span>) &#123;<br>			<span class="hljs-comment">//比较当前结点和其父节点</span><br>			<span class="hljs-keyword">if</span>(less(k/<span class="hljs-number">2</span>,k)) &#123;<br>				exch(k/<span class="hljs-number">2</span>,k);<br>			&#125;<br>			k=k/<span class="hljs-number">2</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">//删除堆中最大的元素，并返回这个最大的元素</span><br>	<span class="hljs-keyword">public</span> T <span class="hljs-title function_">delMax</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-type">T</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span>item[<span class="hljs-number">1</span>];<span class="hljs-comment">//记录被删除的最大值</span><br>		<span class="hljs-comment">//让根节点和最大索引处的结点y交换位置</span><br>		exch(<span class="hljs-number">1</span>,N);<br>		<span class="hljs-comment">//让现在的最大索引处指向null</span><br>		item[N]=<span class="hljs-literal">null</span>;<br>		<span class="hljs-comment">//元素个数-1</span><br>		N--;<br>		<span class="hljs-comment">//通过下沉算法，让堆重新有序</span><br>		sink(<span class="hljs-number">1</span>);<br>		<span class="hljs-keyword">return</span> max;<br>		<br><br>	&#125;<br>	<br>	<span class="hljs-comment">//使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sink</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>		<span class="hljs-comment">//通过循环不断对比当前k结点和其左子节点2k和右子节点2k+1处的元素大小，如果当前结点小，则需要交换位置</span><br>		<span class="hljs-keyword">while</span>(<span class="hljs-number">2</span>*k&lt;=N) &#123;<br>			<span class="hljs-comment">//获取当前子节点中的较大值</span><br>			<span class="hljs-type">int</span> max=<span class="hljs-number">0</span>;<span class="hljs-comment">//记录较大子结点所在的索引</span><br>			<span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*k+<span class="hljs-number">1</span>&lt;=N) &#123;<br>				<span class="hljs-keyword">if</span>(less(<span class="hljs-number">2</span>*k,<span class="hljs-number">2</span>*k+<span class="hljs-number">1</span>)) &#123;<br>					max=<span class="hljs-number">2</span>*k+<span class="hljs-number">1</span>;<br>				&#125;<br>				<span class="hljs-keyword">else</span><br>				&#123;<br>					max=<span class="hljs-number">2</span>*k;<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">else</span><br>			&#123;<br>				max=<span class="hljs-number">2</span>*k;<br>			&#125;<br>			<span class="hljs-comment">//比较当前结点和较大子节点的值,因为k是从最底下弄上来的，所以不存在它比一个子节点大比另一个子节点小的情况</span><br>			<span class="hljs-keyword">if</span>(less(max,k)) &#123;<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>			<span class="hljs-comment">//交换k索引处的键和max索引处的位置</span><br>			exch(k,max);<br>			<span class="hljs-comment">//变换k的值</span><br>			k=max;<br>		&#125;<br>	&#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Heaptest</span> &#123;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>	    <span class="hljs-comment">//创建堆对象</span><br>		Heap&lt;String&gt; heap=<span class="hljs-keyword">new</span>&lt;String&gt; Heap(<span class="hljs-number">10</span>);<br>		<span class="hljs-comment">//往堆中存入字符串数据</span><br>		heap.insert(<span class="hljs-string">&quot;a&quot;</span>);<br>		heap.insert(<span class="hljs-string">&quot;b&quot;</span>);<br>		heap.insert(<span class="hljs-string">&quot;c&quot;</span>);<br>		heap.insert(<span class="hljs-string">&quot;d&quot;</span>);<br>		heap.insert(<span class="hljs-string">&quot;e&quot;</span>);<br>		heap.insert(<span class="hljs-string">&quot;f&quot;</span>);<br>		heap.insert(<span class="hljs-string">&quot;g&quot;</span>);<br>		heap.insert(<span class="hljs-string">&quot;h&quot;</span>);<br>		heap.insert(<span class="hljs-string">&quot;i&quot;</span>);<br>		<br>		<span class="hljs-comment">//通过循环从堆中删除数据</span><br>		String result=<span class="hljs-literal">null</span>;<br>		<span class="hljs-keyword">while</span>((result=heap.delMax())!=<span class="hljs-literal">null</span>) &#123;<br>	      System.out.println(result);<br>	&#125;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="堆的排序"><a href="#堆的排序" class="headerlink" title="堆的排序"></a>堆的排序</h3><p>给定一个数组：</p>
<p> String[] arr &#x3D; {“S”,”O”,”R”,”T”,”E”,”X”,”A”,”M”,”P”,”L”,”E”} </p>
<p>请对数组中的字符按从小到大排序。</p>
<p>类名：HeapSort&lt;T extends Comparable<T>&gt;</p>
<p>成员方法：1.public static void sort(Comparable[] source)：对source数组中的数据从小到大排序 </p>
<p>2.private static void createHeap(Comparable[] source, Comparable[] heap):根据原数组 source，构造出堆heap </p>
<p>3.private static boolean less(Comparable[] heap, int i, int j)：判断heap堆中索引i处的元素是否 小于索引j处的元素 </p>
<p>4.private static void exch(Comparable[] heap, int i, int j):交换heap堆中i索引和j索引处的值 </p>
<p>5.private static void sink(Comparable[] heap, int target, int range):在heap堆中，对target处的 元素做下沉，范围是0~range。</p>
<p>createHeap方法</p>
<p><strong>用排列好的从小到大的数组，得到堆数组，就是对不是叶子结点的元素进行下沉所以</strong></p>
<p>非叶子结点的个数是总的个数除以二</p>
<p>sort方法是拿堆中最大的元素和未排序的最后一个交换，然后再对现在的那个根节点进行下沉，并且下沉范围不包括已经排好序的</p>
<p>API代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapSort</span> &#123;<br><span class="hljs-comment">//判断heap堆中索引i处的元素是否小于索引j处的元素</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">less</span><span class="hljs-params">(Comparable[] heap,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> &#123;<br>		<span class="hljs-keyword">return</span> heap[i].compareTo(heap[j])&lt;<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//交换heap堆中i索引和j索引处的值</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exch</span><span class="hljs-params">(Comparable[] heap,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> &#123;<br>		Comparable temp=heap[i];<br>		heap[i]=heap[j];<br>		heap[j]=temp;<br>	&#125;<br>	<span class="hljs-comment">//根据原数组source，构成出堆heap</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createHeap</span><span class="hljs-params">(Comparable[] source,Comparable[] heap)</span> &#123;<br>		<span class="hljs-comment">//把source中的元素拷贝到heap中，heap中的元素就形成一个无序的堆</span><br>		System.arraycopy(source,<span class="hljs-number">0</span>, heap, <span class="hljs-number">1</span>, source.length);<br>		<span class="hljs-comment">//对堆中的元素做下沉调整（从长度的一半处开始往索引1出扫描）</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=source.length/<span class="hljs-number">2</span>;i&gt;<span class="hljs-number">0</span>;i--) &#123;<br>			sink(heap,i,heap.length-<span class="hljs-number">1</span>);<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">//对source数组中的数据从小到大排序</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(Comparable[] source)</span> &#123;<br>		<span class="hljs-comment">//拿堆中最大的元素和未排序的最后一个交换</span><br>		<span class="hljs-comment">//构建堆</span><br>         Comparable []heap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparable</span>[source.length+<span class="hljs-number">1</span>];<span class="hljs-comment">//0索引废弃掉</span><br>		createHeap(source,heap);<br>		<span class="hljs-comment">//定义一个变量，记录未排序的元素中最大索引</span><br>		<span class="hljs-type">int</span> N=heap.length-<span class="hljs-number">1</span>;<br>		<span class="hljs-comment">//通过循环交换1索引和未排序的元素中最大索引处的元素交换</span><br>		<span class="hljs-keyword">while</span>(N!=<span class="hljs-number">1</span>) &#123;<br>			exch(heap,<span class="hljs-number">1</span>,N);<br>			<span class="hljs-comment">//排除交换后最大元素所在的索引让他不要参与堆的下沉调整</span><br>			N--;<br>			<span class="hljs-comment">//对索引1处的元素进行下沉调整</span><br>			sink(heap,<span class="hljs-number">1</span>,N);<br>		&#125;<br>         <span class="hljs-comment">//把heap中的数据复制到原数组中</span><br>		System.arraycopy(heap,<span class="hljs-number">1</span>,source,<span class="hljs-number">0</span>,source.length);<br>		<br><br>	&#125;<br>	<span class="hljs-comment">//在heap堆中，对target处的元素做下沉，范围是0-range</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sink</span><span class="hljs-params">(Comparable[] heap,<span class="hljs-type">int</span> target,<span class="hljs-type">int</span> range)</span> &#123;<br>		<span class="hljs-keyword">while</span>(<span class="hljs-number">2</span>*target&lt;=range) &#123;<br>			<span class="hljs-comment">//如果这个没有左子结点连while循环都进不来，所以下面没有     没有子节点的情况</span><br>			<span class="hljs-comment">//1.找出当前结点的较大的子结点</span><br>			    <span class="hljs-type">int</span> max;<br>			    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*target+<span class="hljs-number">1</span>&lt;=range) &#123;<br>			    	<span class="hljs-keyword">if</span>(less(heap,<span class="hljs-number">2</span>*target,<span class="hljs-number">2</span>*target+<span class="hljs-number">1</span>)) &#123;<br>			    		max=<span class="hljs-number">2</span>*target+<span class="hljs-number">1</span>;<br>			    	&#125;<br>			    	<span class="hljs-keyword">else</span><br>			    	&#123;<br>			    		max=<span class="hljs-number">2</span>*target;<br>			    	&#125;<br>			    &#125;<span class="hljs-keyword">else</span><br>			    &#123;<br>			    	max=<span class="hljs-number">2</span>*target;<br>			    &#125;<br>			<span class="hljs-comment">//2.比较当前结点的值和较大子结点的值</span><br>			<span class="hljs-keyword">if</span>(less(heap,max,target)) &#123;<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>			exch(heap,target,max);<br>			target=max;<br>			&#125;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapSortTest</span> &#123;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-comment">//待排序的数组</span><br>		String[] arr = &#123;<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;R&quot;</span>,<span class="hljs-string">&quot;T&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;M&quot;</span>,<span class="hljs-string">&quot;P&quot;</span>,<span class="hljs-string">&quot;L&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>&#125;;<br>		HeapSort.sort(arr);<br>		<span class="hljs-comment">//打印排序后数组中元素</span><br>		System.out.println(Arrays.toString(arr));<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>就是想要特定的元素从队列中先出来</p>
<p>优先队列按照其作用不同，可以分为以下两种： </p>
<p>最大优先队列： 可以获取并删除队列中最大的值</p>
<p> 最小优先队列： 可以获取并删除队列中最小的值</p>
<h3 id="最大优先队列"><a href="#最大优先队列" class="headerlink" title="最大优先队列"></a>最大优先队列</h3><p>最大优先队列的API设计</p>
<p>类名：MaxPriorityQueue&lt;T extends Comparable<T>&gt;</p>
<p>构造方法 MaxPriorityQueue(int capacity)：创建容量为capacity的MaxPriorityQueue对象</p>
<p>1.private T[] imtes : 用来存储元素的数组 </p>
<p>2.private int N：记录堆中元素的个数</p>
<p>成员方法：1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素 </p>
<p>2.private void exch(int i,int j):交换堆中i索引和j索引处的值 </p>
<p>3.public T delMax():删除队列中最大的元素,并返回这个最大元素 </p>
<p>4.public void insert(T t)：往队列中插入一个元素 </p>
<p>5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置 </p>
<p>6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置 </p>
<p>7.public int size():获取队列中元素的个数 </p>
<p>8.public boolean isEmpty():判断队列是否为空</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxPriorityQueue</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt;&gt; &#123;<br> <br>	<span class="hljs-comment">//存储堆中的元素</span><br>	<span class="hljs-keyword">private</span> T[] items;<br>	<span class="hljs-comment">//记录堆中元素的个数</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">MaxPriorityQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> Capacity)</span> &#123;<br>		<span class="hljs-built_in">this</span>.items=(T[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparable</span>[Capacity+<span class="hljs-number">1</span>];<br>		<span class="hljs-built_in">this</span>.N=<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//获取队列中元素个数</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> N;<br>	&#125;<br>	<span class="hljs-comment">//判断队列是否为空</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> N==<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//判断堆中索引i处的元素是否小于索引j处的元素</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">less</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> &#123;<br>         <span class="hljs-keyword">return</span> items[i].compareTo(items[j])&lt;<span class="hljs-number">0</span>;	<br>	&#125;<br>	<span class="hljs-comment">//交换堆中i索引和j索引处的值</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exch</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> &#123;<br>		T a=items[i];<br>		items[i]=items[j];<br>		items[j]=a;<br>	&#125;<br>	<span class="hljs-comment">//往堆中插入一个元素</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(T t)</span> &#123;<br>		items[++N]=t;<br>		swim(N);<br>	&#125;<br>	<span class="hljs-comment">//删除堆中最大的元素，并返回这个最大的值</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">delMax</span><span class="hljs-params">()</span> &#123;<br> T max=items[<span class="hljs-number">1</span>];<br> exch(<span class="hljs-number">1</span>,N);<br> items[N]=<span class="hljs-literal">null</span>;<br> N--;<br> sink(<span class="hljs-number">1</span>);<br> <span class="hljs-keyword">return</span> max;<br>    &#125;<br>    <span class="hljs-comment">//使用上浮算法，使索引k处的元素都在堆中处于一个正确的位置</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>    	<span class="hljs-keyword">while</span>(k&gt;<span class="hljs-number">1</span>) &#123;<br>    		<span class="hljs-keyword">if</span>(less(k/<span class="hljs-number">2</span>,k)) &#123;<br>    			exch(k/<span class="hljs-number">2</span>,k);<br>    		&#125;<br>    		<br>    		k=k/<span class="hljs-number">2</span>;<br>    	&#125;<br>    &#125;<br>    <span class="hljs-comment">//使用下沉算法，使索引k处的元素在堆中处于一个正确的位置</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sink</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>    	<span class="hljs-keyword">while</span>(<span class="hljs-number">2</span>*k&lt;=N) &#123;<br>    		<span class="hljs-type">int</span> max;<br>    		<span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*k+<span class="hljs-number">1</span>&lt;=N) &#123;<br>    			<span class="hljs-keyword">if</span>(less(<span class="hljs-number">2</span>*k,<span class="hljs-number">2</span>*k+<span class="hljs-number">1</span>)) &#123;<br>    				max=<span class="hljs-number">2</span>*k+<span class="hljs-number">1</span>;<br>    			&#125;<br>    			<span class="hljs-keyword">else</span><br>    			&#123;<br>    				max=<span class="hljs-number">2</span>*k;<br>    			&#125;<br>    		&#125;<br>    		<span class="hljs-keyword">else</span><br>    		&#123;<br>    			max=<span class="hljs-number">2</span>*k;<br>    		&#125;<br>    		<span class="hljs-keyword">if</span>(!less(k,max)) &#123;<br>    			<span class="hljs-keyword">break</span>;<br>    		&#125;<br>    		exch(k,max);<br>    		k=max;<br>    	&#125;<br>    &#125;<br>	<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxPriorityQueueTest</span> &#123;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>	      <span class="hljs-comment">//创建优先队列</span><br>		MaxPriorityQueue&lt;String&gt; queue=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MaxPriorityQueue</span>&lt;&gt;(<span class="hljs-number">10</span>);<br>		<span class="hljs-comment">//往队列中存储元素</span><br>		queue.insert(<span class="hljs-string">&quot;a&quot;</span>);<br>		queue.insert(<span class="hljs-string">&quot;b&quot;</span>);<br>		queue.insert(<span class="hljs-string">&quot;c&quot;</span>);<br>		queue.insert(<span class="hljs-string">&quot;d&quot;</span>);<br>		queue.insert(<span class="hljs-string">&quot;e&quot;</span>);<br>		queue.insert(<span class="hljs-string">&quot;f&quot;</span>);<br>		queue.insert(<span class="hljs-string">&quot;g&quot;</span>);<br>		<span class="hljs-comment">//通过循环从队列中获取最大的元素</span><br>	      <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>	    	  String max=queue.delMax();<br>	    	  System.out.println(max);<br>	      &#125;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="最小优先队列"><a href="#最小优先队列" class="headerlink" title="最小优先队列"></a>最小优先队列</h3><p>最小优先队列的实现也是通过堆来完成最小优先队列</p>
<p>我们前面学习堆的时候，堆中存放数据元素的数组要满足都满足如下特性： </p>
<p>1.最大的元素放在数组的索引1处。 </p>
<p>2.每个结点的数据总是大于等于它的两个子结点的数据。</p>
<p>我们可以用相反的思想实现最小堆，让堆中存放数据元素的数组满足 如下特性： </p>
<p>1.最小的元素放在数组的索引1处。 </p>
<p>2.每个结点的数据总是小于等于它的两个子结点的数据。</p>
<p>API设计</p>
<p>类名：MinPriorityQueue&lt;T extends Comparable<T>&gt;</p>
<p>构造方法 MinPriorityQueue(int capacity)：创建容量为capacity的MinPriorityQueue对象</p>
<p>成员变量：1.private T[] imtes : 用来存储元素的数组 </p>
<p>​                     2.private int N：记录堆中元素的个数</p>
<p> 成员方法：</p>
<p>​    1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素 </p>
<p>2.private void exch(int i,int j):交换堆中i索引和j索引处的值 </p>
<p>3.public T delMin():删除队列中最小的元,并返回这个最小元素 </p>
<p>4.public void insert(T t)：往队列中插入一个元素 </p>
<p>5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置 </p>
<p>6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置 </p>
<p>7.public int size():获取队列中元素的个数 </p>
<p>8.public boolean isEmpty():判断队列是否为空</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MinPriorityQueue</span>&lt;T extends Comparable&lt;T&gt;&gt;&#123;<br>	<span class="hljs-comment">//存储堆中的元素</span><br>	<span class="hljs-keyword">private</span> T[] items;<br>	<span class="hljs-comment">//记录堆中元素的个数</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br>	<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinPriorityQueue</span> <span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.items=(T[]) <span class="hljs-keyword">new</span> Comparable[capacity+<span class="hljs-number">1</span>];<br>		<br>	&#125;<br>	<span class="hljs-comment">//获取队列中元素个数</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> N;<br>	&#125;<br>	<span class="hljs-comment">//判断队列是否为空</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> N==<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//判断堆中索引i处的元素是否小于索引j处的元素</span><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title">less</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> items[i].<span class="hljs-built_in">compareTo</span>(items[j])&lt;<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//交换堆中索引i的值和索引j的值</span><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">void</span> <span class="hljs-title">exch</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> </span>&#123;<br>		T a=items[i];<br>		items[i]=items[j];<br>		items[j]=a;<br>	&#125;<br>	<span class="hljs-comment">//往堆中添加一个元素</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(T t)</span> </span>&#123;<br>		items[++N]=t;<br>		<span class="hljs-built_in">swim</span>(N);<br>	&#125;<br>	<span class="hljs-comment">//删除堆中最小的元素，并返回这个最小元素</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">delMin</span><span class="hljs-params">()</span> </span>&#123;<br>		T min=items[<span class="hljs-number">1</span>];<br>		<span class="hljs-built_in">exch</span>(<span class="hljs-number">1</span>,N);<br>		items[N]=null;<br>		N--;<br>		<span class="hljs-built_in">sink</span>(<span class="hljs-number">1</span>);<br>		<span class="hljs-keyword">return</span> min;<br>	&#125;<br>	<span class="hljs-comment">//使用上浮算法，使索引为k的元素在堆中处于一个正确的位置</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">swim</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>		<span class="hljs-comment">//通过循环比较当前结点和其父节点的大小</span><br>		<span class="hljs-keyword">while</span>(k&gt;<span class="hljs-number">1</span>) &#123;<br>			<span class="hljs-keyword">if</span>(<span class="hljs-built_in">less</span>(k,k/<span class="hljs-number">2</span>)) &#123;<br>				<span class="hljs-built_in">exch</span>(k,k/<span class="hljs-number">2</span>);<br>			&#125;<br>			k=k/<span class="hljs-number">2</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">//使用下沉算法，使索引为k的元素在堆中处于一个正确的位置</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">sink</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>		<span class="hljs-comment">//通过循环比较当前结点和子结点中的较小值</span><br>		<span class="hljs-keyword">while</span>(<span class="hljs-number">2</span>*k&lt;=N) &#123;<br>			<span class="hljs-comment">//找到子结点中的较小值</span><br>			<span class="hljs-type">int</span> min;<br>			<span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*k+<span class="hljs-number">1</span>&lt;=N) &#123;<br>				<span class="hljs-keyword">if</span>(<span class="hljs-built_in">less</span>(<span class="hljs-number">2</span>*k,<span class="hljs-number">2</span>*k+<span class="hljs-number">1</span>)) &#123;<br>					min=<span class="hljs-number">2</span>*k;<br>				&#125;<br>				<span class="hljs-keyword">else</span> &#123;<br>					min=<span class="hljs-number">2</span>*k+<span class="hljs-number">1</span>;<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">else</span><br>			&#123;<br>				min=<span class="hljs-number">2</span>*k;<br>			&#125;<br>			<br>			<span class="hljs-comment">//判断当前结点和较小值的大小</span><br>			<span class="hljs-keyword">if</span>(<span class="hljs-built_in">less</span>(k,min)) &#123;<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>			<span class="hljs-built_in">exch</span>(k,min);<br>			k=min;<br>		&#125;<br><br><br>​		<br><br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> MinPriorityQueueTest &#123;<br><br>	<span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>	          MinPriorityQueue&lt;String&gt; mpqt=<span class="hljs-built_in">new</span> MinPriorityQueue&lt;&gt;(<span class="hljs-number">10</span>);<br>	          mpqt.<span class="hljs-keyword">insert</span>(&quot;f&quot;);<br>	          mpqt.<span class="hljs-keyword">insert</span>(&quot;e&quot;);<br>	          mpqt.<span class="hljs-keyword">insert</span>(&quot;d&quot;);<br>	          mpqt.<span class="hljs-keyword">insert</span>(&quot;c&quot;);<br>	          mpqt.<span class="hljs-keyword">insert</span>(&quot;b&quot;);<br>	          mpqt.<span class="hljs-keyword">insert</span>(&quot;a&quot;);<br>	       <span class="hljs-keyword">while</span>(!mpqt.isEmpty()) &#123;<br>	    	   String min=mpqt.delMin();<br>	    	   <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(min+&quot; &quot;);<br>	       &#125; <br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<pre><code class="hljs">### 索引最小优先队列
</code></pre>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656829.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220805083244840"></p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656830.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220805082934010"></p>
<p>第一个数组是储存不符合堆排序的元素的，索引与元素有一一对应关系</p>
<p>为了调整顺序但索引对应关系不变有了第二个辅助数组，是满足堆调整的</p>
<p>第三个是当修改（不是交换）某个元素的值时更容易找到那个值所对应的索引</p>
<p>qp就是把pq数组的索引当值，值当索引</p>
<p><strong>索引最小优先队列的API设计</strong></p>
<p>类名：IndexMinPriorityQueue&lt;T extends Comparable<T>&gt;</p>
<p>构造方法 IndexMinPriorityQueue(int capacity)：创建容量为capacity的IndexMinPriorityQueue对象</p>
<p>成员变量：1.private T[] imtes : 用来存储元素的数组 </p>
<p>​                   2.private int[] pq:保存每个元素在items数组中的索引，pq数组需要堆有序 </p>
<p>​                   3.private int [] qp:保存qp的逆序，pq的值作为索引，pq的索引作为值 </p>
<p>​                   4.private int N：记录堆中元素的个数</p>
<p>成员方法：1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素 </p>
<p>​                    2.private void exch(int i,int j):交换堆中i索引和j索引处的值 </p>
<p>​                    3.public int delMin():删除队列中最小的元素,并返回该元素关联的索引 </p>
<p>​                     4.public void insert(int i,T t)：往队列中插入一个元素,并关联索引i </p>
<p>​                    5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置 </p>
<p>​                   6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置 </p>
<p>​                     7.public int size():获取队列中元素的个数 </p>
<p>​                   8.public boolean isEmpty():判断队列是否为空 </p>
<p>​                     9.public boolean contains(int k):判断k对应的元素是否存在 </p>
<p>​                   10.public void changeItem(int i, T t):把与索引i关联的元素修改为为t </p>
<p>​                   11.public int minIndex():最小元素关联的索引 12.public void delete(int i):删除索引i关联的元素</p>
<p>​                    </p>
<p>API</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IndexMinPriorityQueue</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt;&gt; &#123;<br><span class="hljs-comment">//存储堆中的元素</span><br>	<span class="hljs-keyword">private</span> T[] items;<br>	<span class="hljs-comment">//保存每个元素在items数组中的索引，pq数组需要堆有序</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] pq;<br>	<span class="hljs-comment">//保存pq的逆序，pq的值是索引，pq的索引是值</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] qp;<br>	<span class="hljs-comment">//记录堆中元素个数</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">IndexMinPriorityQueue</span> <span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>		<span class="hljs-built_in">this</span>.items=(T[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparable</span>[capacity+<span class="hljs-number">1</span>];<br>		<span class="hljs-built_in">this</span>.pq=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[capacity+<span class="hljs-number">1</span>];<br>		<span class="hljs-built_in">this</span>.qp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[capacity+<span class="hljs-number">1</span>];<br>		<span class="hljs-built_in">this</span>.N=<span class="hljs-number">0</span>;<br>		<br><br>		<span class="hljs-comment">//默认情况下，队列中没有任何数据，qp中元素都为-1</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;qp.length;i++) &#123;<br>			qp[i]=-<span class="hljs-number">1</span>;<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-comment">//获取队列中的元素个数</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> N;<br>	&#125;<br>	<span class="hljs-comment">//判断队列是否为空</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> N==<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//判断堆中索引i处的元素是否小于索引j处的元素</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">less</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> &#123;<br>		<span class="hljs-keyword">return</span> items[pq[i]].compareTo(items[pq[j]])&lt;<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">//交换堆中索引i和索引j的位置</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exch</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> &#123;<br>	<span class="hljs-comment">//交换pq中的数据</span><br>		<span class="hljs-type">int</span> tmp=pq[i];<br>		pq[i]=pq[j];<br>		pq[j]=tmp;<br>		<br>		<span class="hljs-comment">//更新qp中的数据</span><br>		qp[pq[i]]=i;<br>		qp[pq[j]]=j;<br>	&#125;<br>	<span class="hljs-comment">//判断k对应的元素是否存在</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>		<span class="hljs-keyword">return</span> qp[k]!=-<span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-comment">//最小元素关联的索引</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minIndex</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> pq[<span class="hljs-number">1</span>];<br>	<br>	&#125;<br>	<span class="hljs-comment">//往队列中插入一个元素，并关联索引i</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i,T t)</span> &#123;<br>		<span class="hljs-comment">//判断i是否已经被关联,如果已经被关联则不让插入</span><br>		<span class="hljs-keyword">if</span>(contains(i)) &#123;<br>			<span class="hljs-keyword">return</span> ;<br>		&#125;<br>		<span class="hljs-comment">//元素个数加一</span><br>		N++;<br>		<span class="hljs-comment">//把数据存储到items对应的i位置处</span><br>		items[i]=t;<br>		<span class="hljs-comment">//把i存储到pq中</span><br>		pq[N]=i;<br>		<span class="hljs-comment">//通过qp来记录pq中的i</span><br>		qp[i]=N;<br>		<br>		<span class="hljs-comment">//通过堆的上浮来完成堆序列</span><br>		swim(N);<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">delMin</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">//获取最小元素关联的索引</span><br>		<span class="hljs-type">int</span> minIndex=pq[<span class="hljs-number">1</span>];<br>		<br>		<span class="hljs-comment">//交换pq中索引1处和最大索引处的元素</span><br>		exch(<span class="hljs-number">1</span>,N);<br>		<span class="hljs-comment">//删除qp中对应的内容</span><br>		qp[pq[N]]=-<span class="hljs-number">1</span>;<br>		<span class="hljs-comment">//删除pq中最大索引处的内容</span><br>		pq[N]=-<span class="hljs-number">1</span>;<br>		<span class="hljs-comment">//删除items中对应的内容</span><br>		items[minIndex]=<span class="hljs-literal">null</span>;<br>		<span class="hljs-comment">//元素个数-1</span><br>		N--;<br>		<span class="hljs-comment">//下沉调整</span><br>	     sink(<span class="hljs-number">1</span>);<br>	     <span class="hljs-keyword">return</span> minIndex;<br>	&#125;<br>	<br>	<span class="hljs-comment">//删除索引i关联的元素</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>		<span class="hljs-comment">//找到i在pq中的索引</span><br>		<span class="hljs-type">int</span> k=qp[i];<br>		<span class="hljs-comment">//交换pq中的索引k处的值和索引N处的值</span><br>	    exch(k,N);<br>		<span class="hljs-comment">//删除qp中的对应内容</span><br>		qp[pq[N]]=-<span class="hljs-number">1</span>;<br>		<span class="hljs-comment">//删除pq中的内容</span><br>		pq[N]=-<span class="hljs-number">1</span>;<br>		<span class="hljs-comment">//删除items中的内容</span><br>		items[k]=<span class="hljs-literal">null</span>;<br>		<span class="hljs-comment">//堆的调整</span><br>	    sink(k);<br>	    swim(k);<br>	&#125;<br>	<br>	<span class="hljs-comment">//修改索引i关联的元素修改为t</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changeItem</span> <span class="hljs-params">(<span class="hljs-type">int</span> i,T t)</span> &#123;<br>		<span class="hljs-comment">//修改items数组中i位置的元素为t</span><br>		items[i]=t;<br>		<span class="hljs-comment">//找到i在pq中出现的位置</span><br>		<span class="hljs-type">int</span> k=qp[i];<br>		<span class="hljs-comment">//堆调整</span><br>		sink(k);<br>		swim(k);<br>	&#125;<br>	<span class="hljs-comment">//堆上浮算法，使索引k处的元素在堆中处于一个正确的位置</span><br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>	   <span class="hljs-keyword">while</span>(k&gt;<span class="hljs-number">1</span>) &#123;<br>		   <span class="hljs-keyword">if</span>(less(k,k/<span class="hljs-number">2</span>)) &#123;<br>			   exch(k,k/<span class="hljs-number">2</span>);<br>		   &#125;<br>		   k=k/<span class="hljs-number">2</span>;<br>	   &#125;<br>   &#125;<br>   <span class="hljs-comment">//使用下沉算法，使索引k处的元素在堆中处于一个正确的位置</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sink</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>	   <span class="hljs-keyword">while</span>(<span class="hljs-number">2</span>*k&lt;=N) &#123;<br>		   <span class="hljs-type">int</span> min;<br>		   <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*k+<span class="hljs-number">1</span>&lt;=N) &#123;<br>			   <span class="hljs-keyword">if</span>(less(<span class="hljs-number">2</span>*k,<span class="hljs-number">2</span>*k+<span class="hljs-number">1</span>)) &#123;<br>				   min=<span class="hljs-number">2</span>*k;<br>			   &#125;<br>			   <span class="hljs-keyword">else</span><br>			   &#123;<br>				   min=<span class="hljs-number">2</span>*k+<span class="hljs-number">1</span>;<br>			   &#125;<br>		   &#125;<br>		   <span class="hljs-keyword">else</span><br>		   &#123;<br>			   min=<span class="hljs-number">2</span>*k;<br>		   &#125;<br>		   <span class="hljs-comment">//比较当前结点和较小值</span><br>		   <span class="hljs-keyword">if</span>(less(k,min)) &#123;<br>			   <span class="hljs-keyword">break</span>;<br>		   &#125;<br>		   <br><br>		   exch(k,min);<br>		   k=min;<br>	   &#125;<br><br>   &#125;<br>	<br>	<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IndexMinPriorityQueueTest</span> &#123;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		IndexMinPriorityQueue&lt;String&gt; queue=<span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexMinPriorityQueue</span>&lt;&gt;(<span class="hljs-number">10</span>);<br>		queue.insert(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;A&quot;</span>);<br>		queue.insert(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>		queue.insert(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;F&quot;</span>);<br>	    <br>		queue.changeItem(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;B&quot;</span>);<br>		<span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>			<span class="hljs-type">int</span> index=queue.delMin();<br>			System.out.println(index);<br>		&#125;<br>	<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="树的进阶"><a href="#树的进阶" class="headerlink" title="树的进阶"></a>树的进阶</h2><p>如果是二叉查找树会出现</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656831.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220808164615531"></p>
<p>可能会出现这样的情况，查找1的效率会很低</p>
<p>我们有一种方法，能够不受插入数据的影响，让生成的树都像完全二叉树那样，那么即使在最坏情 况下，查找的效率依旧会很好。</p>
<h3 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h3><p>这块笔记不详细，可以去看它的原版笔记</p>
<h4 id="2-3查找树的定义"><a href="#2-3查找树的定义" class="headerlink" title="2-3查找树的定义"></a>2-3查找树的定义</h4><p> 一棵2-3查找树要么为空，要么满足满足下面两个要求： </p>
<p>2-结点： 含有一个键(及其对应的值)和两条链，左链接指向2-3树中的键都小于该结点，右链接指向的2-3树中的键都大 于该结点。 </p>
<p>3-结点：  含有两个键(及其对应的值)和三条链，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都 位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656832.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220808164434828"></p>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656833.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220808170734447"></p>
<p>在这个数中找H，先和第一个比较M比较，H比M小所以找M的左联结，然后将H和EJ比较发先H在E J的中间，所以查找E J 的中连接，然后找到H</p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p><strong>向2-结点中插入新键应该让它变成3-结点，同时3-结点中小的在左边</strong></p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656834.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220808171832161"></p>
<p><strong>向只含有一个3-结点的树中插入新键</strong></p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656835.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220808171804317"></p>
<p><strong>向一个父节点为2-结点的3-结点中插入新键</strong></p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656836.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220808172215253"></p>
<p><strong>向一个父节点为3-结点的3-结点中插入新键</strong></p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656837.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220808172428384"></p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656838.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220808172446208"></p>
<p><strong>分解根节点</strong></p>
<p>当插入结点到根节点的路径上全部都是3-结点，最终我们的根节点会拆分为两个2-结点，树高度加一</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656839.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220808172905191"></p>
<h4 id="2-3树的性质"><a href="#2-3树的性质" class="headerlink" title="2-3树的性质"></a>2-3树的性质</h4><p>举例上面这个最近的图，有四个叶子结点，八个空链接</p>
<ol>
<li><p>​          任意空链接到根结点的路径长度都是相等的。 </p>
</li>
<li><p>​           4-结点变换为3-结点时，树的高度不会发生变化，只有当根结点是临时的4-结点，分解根结点时，树高+1。</p>
</li>
<li><p>​           2-3树与普通二叉查找树最大的区别在于，普通的二叉查找树是自顶向下生长，而2-3树是自底向上生长。</p>
</li>
</ol>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树主要是对2-3树进行编码，红黑树背后的基本思想是用标准的二叉查找树(完全由2-结点构成)和一些额外的信 息(替换3-结点)来表示2-3树。我们将树中的链接分为两种类型：</p>
<p> 红链接：将两个2-结点连接起来构成一个3-结点；</p>
<p>黑链接：则是2-3树中的普通链接。</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656840.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220808174337990"></p>
<p>准确来说红链接连接的两个2-节点其实就组成了3-结点</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>基于二叉查找树，满足以下条件</p>
<ol>
<li>红链接均为左链接；</li>
<li>没有任何一个结点同时和两条红链接相连；</li>
<li>该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同；</li>
</ol>
<h4 id="红黑树结点API"><a href="#红黑树结点API" class="headerlink" title="红黑树结点API"></a>红黑树结点API</h4><p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656841.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220808175856813"></p>
<p>类名 Node 构造方法 Node(Key key, Value value, Node left, Node right，boolean color)：创建Node对象 </p>
<p>成员变量 1.public Node left:记录左子结点 </p>
<p>​                 2.public Node right:记录右子结点 </p>
<p>​                 3.public Key key:存储键 </p>
<p>​                 4.public Value value:存储值 </p>
<p>​                 5.public boolean color:由其父结点指向它的链接的颜色</p>
<h4 id="红黑树平衡化"><a href="#红黑树平衡化" class="headerlink" title="红黑树平衡化"></a>红黑树平衡化</h4><p>对红黑树进行增删改查操作之后，容易破坏红黑树的定义，所以我们需要对这些情况通过旋转进行修复</p>
<p><strong>左旋</strong></p>
<p>当某个结点的左子结点为黑色，右子结点为红色，此时需要左旋。</p>
<p>左旋过程： 1.让x的左子结点变为h的右子结点：h.right&#x3D;x.left; </p>
<p>​                     2.让h成为x的左子结点：x.left&#x3D;h; </p>
<p>​                    3.让h的color属性变为x的color属性值：x.color&#x3D;h.color; </p>
<p>​                     4.让h的color属性变为RED：h.color&#x3D;true</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656842.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220808180731280"></p>
<p>右旋</p>
<p>当某个结点的左子结点是红色，且左子结点的左子结点也是红色，需要右旋</p>
<p>右旋过程： 1. 让x的右子结点成为h的左子结点：h.left &#x3D; x.right; </p>
<p>​                     2.让h成为x的右子结点：x.right&#x3D;h; </p>
<p>​                     3.让x的color变为h的color属性值：x.color &#x3D; h.color;</p>
<p>​                      4. 让h的color为RED；</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656843.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220808181126928"></p>
<h4 id="红黑树插入"><a href="#红黑树插入" class="headerlink" title="红黑树插入"></a>红黑树插入</h4><p>红黑树插入键的时候其实就是插入红色的，因为每一个都可以被看作2-结点</p>
<p><strong>向单个2-结点中插入新建</strong></p>
<p>如果新键小于当前结点的键，我们只需要新增一个红色结点即可，新的红黑树和单个3-结点完全等价</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656845.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220809083619174"></p>
<p>新键大于当前结点的键，那么新增的红色结点将会产生一条红色的右链接，此时我们需要通过左旋，把 红色右链接变成左链接，插入操作才算完成</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656846.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220809083712469"></p>
<p><strong>向底部的2-结点插入新键</strong></p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656847.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220809084043767"></p>
<p><strong>颜色反转</strong></p>
<p>当一个结点的左子结点和右子结点的color都为RED时，也就是出现了临时的4-结点，此时只需要把左子结点和右子 结点的颜色变为BLACK，同时让当前结点的颜色变为RED即可。</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656848.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220809084334735"></p>
<p><strong>向一颗双键树（即一个3-结点）中插入新建</strong></p>
<p>1.新键大于原树中的两个键</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656849.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220809084955143"></p>
<p>新键小于原树中的两个键</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656850.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220809085302451"></p>
<p>.新键介于原数中两个键之间</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656851.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220809085539689"></p>
<p>根节点的颜色总是黑色的，因为指向它的是空的，每次插入操作后都要把根节点的颜色设置为黑色</p>
<p><strong>向树底部的3-结点插入新建</strong></p>
<p>详细见资料</p>
<h4 id="红黑树的API设计"><a href="#红黑树的API设计" class="headerlink" title="红黑树的API设计"></a>红黑树的API设计</h4><p>类名：RedBlackTree&lt;Key extends Comparable<Key>,Value&gt;</p>
<p>构造方法 RedBlackTree()：创建RedBlackTree对象 </p>
<p>成员方法 1.private boolean isRed(Node x)：判断当前结点的父指向链接是否为红色 </p>
<p>2.private Node rotateLeft(Node h):左旋调整 </p>
<p>3.private Node rotateRight(Node h):右旋调整 </p>
<p>4.private void flipColors(Node h)：颜色反转,相当于完成拆分4-结点 </p>
<p>5.public void put(Key key, Value val):在整个树上完成插入操作 </p>
<p>6.private Node put(Node h, Key key, Value val):在指定树中，完成插入操作,并返回添加元素后 新的树 </p>
<p>7.public Value get(Key key):根据key，从树中找出对应的值 </p>
<p>8.private Value get(Node x, Key key):从指定的树x中，找出key对应的值 </p>
<p>9.public int size():获取树中元素的个数 </p>
<p>成员变量 1.private Node root : 记录根结点 </p>
<p>2.private int N:记录树中元素的个数 </p>
<p>3.private static final boolean RED：红色链接标识 </p>
<p>4.private static final boolean BLACK:黑色链接标识</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedBlackTree</span> &lt;Key <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;Key&gt;,Value&gt; &#123;<br><span class="hljs-comment">//根节点</span><br>	<span class="hljs-keyword">private</span> Node root;<br>	<span class="hljs-comment">//记录树中元素的个数</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N;<br>	<span class="hljs-comment">//红色链接</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> RED=<span class="hljs-literal">true</span>;<br>	<span class="hljs-comment">//黑色链接</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> BLACK=<span class="hljs-literal">false</span>;<br>	<br>	<span class="hljs-comment">//结点类</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>		<span class="hljs-comment">//存储键</span><br>		<span class="hljs-keyword">public</span> Key key;<br>		<span class="hljs-comment">//存储值</span><br>		<span class="hljs-keyword">public</span> Value value;<br>		<span class="hljs-comment">//记录左子节点</span><br>		<span class="hljs-keyword">public</span> Node left;<br>		<span class="hljs-comment">//记录右子结点</span><br>		<span class="hljs-keyword">public</span> Node right;<br>		<span class="hljs-comment">//由其父节点指向它的链接的颜色</span><br>		<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> color;<br>		<span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(Key key,Value value,Node left,Node right,<span class="hljs-type">boolean</span> color)</span> &#123;<br>			<span class="hljs-built_in">this</span>.key=key;<br>			<span class="hljs-built_in">this</span>.value=value;<br>			<span class="hljs-built_in">this</span>.left=left;<br>			<span class="hljs-built_in">this</span>.right=right;<br>			<span class="hljs-built_in">this</span>.color=color;<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-comment">//获取树中元素的个数</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">return</span> N;<br>	&#125;<br>	<br>	<span class="hljs-comment">//判断当前结点的父节点指向链接是否为红色</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isRed</span><span class="hljs-params">(Node x)</span> &#123;<br>		<span class="hljs-keyword">if</span>(x==<span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>		&#125;<br>		<span class="hljs-keyword">return</span> x.color==RED;<br>	&#125;<br>	<span class="hljs-comment">//左旋</span><br>	<span class="hljs-keyword">private</span> Node <span class="hljs-title function_">rotateleft</span><span class="hljs-params">(Node h)</span> &#123;<br>		<span class="hljs-comment">//获取h结点的右子节点，表示为x</span><br>		Node x=h.right;<br>		<span class="hljs-comment">//让x结点的左子节点称为h节点的右子结点</span><br>	      h.right=x.left;<br>		<span class="hljs-comment">//让h称为x的左子节点</span><br>		x.left=h;<br>		<span class="hljs-comment">//让x节点的color属性等于h结点的color属性</span><br>		x.color=h.color;<br>		<span class="hljs-comment">//让h结点的color属性变为红色</span><br>		h.color=RED;<br>		<span class="hljs-keyword">return</span> x;<br>	&#125;<br>	<span class="hljs-comment">//右旋</span><br>	<span class="hljs-keyword">private</span> Node <span class="hljs-title function_">rotateright</span><span class="hljs-params">(Node h)</span> &#123;<br>		<span class="hljs-comment">//获取h结点的左子结点，表示为x</span><br>		Node x=h.left;<br>		<span class="hljs-comment">//让x节点的右子节点为h的左子节点</span><br>		h.left=x.right;<br>		<span class="hljs-comment">//让h节点成为x节点的右子结点</span><br>		x.right=h;<br>		<span class="hljs-comment">//让x结点的color属性等于h节点的color属性</span><br>		x.color=h.color;<br>		<span class="hljs-comment">//让h节点的color属性为红色</span><br>		h.color=RED;<br>		<span class="hljs-keyword">return</span> x;<br>	&#125;<br>	<br>	<span class="hljs-comment">//颜色反转，左右子结点是黑色，当前节点是红色</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flipColor</span><span class="hljs-params">(Node n)</span> &#123;<br>		n.left.color=BLACK;<br>		n.right.color=BLACK;<br>		n.color=RED;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Key key,Value value)</span> &#123;<br><br>		root=put(root,key,value);<br>		<span class="hljs-comment">//根节点的颜色总是黑色的</span><br>		root.color=BLACK;<br>	&#125;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * 在指定树中完成插入操作，并返回添加元素后新的树</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">private</span> Node <span class="hljs-title function_">put</span><span class="hljs-params">(Node h,Key key,Value val)</span> &#123;<br>		<span class="hljs-comment">//判断h是否为空</span><br>		<span class="hljs-keyword">if</span>(h==<span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-comment">//数量加一</span><br>			N++;<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key,val,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,RED);<br>		&#125;<br>		<span class="hljs-comment">//不为空就得去比较h节点的键和key的大小</span><br>		<span class="hljs-type">int</span> cmp=key.compareTo(h.key);<br>		<span class="hljs-keyword">if</span>(cmp&lt;<span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-comment">//小于零，继续往左</span><br>			h.left=put(h.left,key,val);<br>		&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmp&gt;<span class="hljs-number">0</span>)<br>		&#123;<br>			<span class="hljs-comment">//大于零继续往右</span><br>			h.right=put(h.right,key,val);<br>		&#125;<br>		<span class="hljs-keyword">else</span><br>		&#123;<br>			<span class="hljs-comment">//等于零,进行替换</span><br>			h.value=val;<br>		&#125;<br>       <span class="hljs-comment">//进行左旋，当当前结点h的左子节点为黑色，右子结点为红色，需要左旋</span><br>		<span class="hljs-keyword">if</span>(isRed(h.right)&amp;&amp;!isRed(h.left)) &#123;<br>			h=rotateleft(h);<br>		&#125;<br>		<span class="hljs-comment">//进行右旋，当当前结点h的左子节点，和左子节点的左子节点都为红色需要右旋</span><br>		<span class="hljs-keyword">if</span>(isRed(h.left)&amp;&amp;isRed(h.left.left)) &#123;<br>			h=rotateright(h);<br>		&#125;<br>		<span class="hljs-comment">//颜色反转当前结点的左右子结点都为红色</span><br>		<br>		<span class="hljs-keyword">if</span>(isRed(h.left)&amp;&amp;isRed(h.right)) &#123;<br>			flipColor(h);<br>		&#125;<br>		<span class="hljs-keyword">return</span> h;<br>		<br>	&#125;<br>	<span class="hljs-comment">//这个查找方法和二叉查找树一摸一样</span><br>	<span class="hljs-comment">//查询树中指定key对应的value</span><br>	<span class="hljs-keyword">public</span> Value <span class="hljs-title function_">get</span><span class="hljs-params">(Key key)</span> &#123;<br>		<span class="hljs-keyword">return</span> get(root,key);<br>	&#125;<br>	<span class="hljs-comment">//从指定的树x中，查找key对应的值</span><br>	<span class="hljs-keyword">public</span> Value <span class="hljs-title function_">get</span><span class="hljs-params">(Node x,Key key)</span> &#123;<br>		<span class="hljs-comment">//x树为null</span><br>		<span class="hljs-keyword">if</span>(x==<span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>		&#125;<br>		<span class="hljs-comment">//x树不为null</span><br>		<span class="hljs-comment">//比较key和x结点键的大小</span><br>		<span class="hljs-type">int</span> cmp=key.compareTo(x.key);<br>		<span class="hljs-keyword">if</span>(cmp&gt;<span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-comment">//如果key大于x结点的键，则继续找x结点右子树</span><br>			<span class="hljs-keyword">return</span> get(x.right,key);<br>		&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmp&lt;<span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-comment">//如果key小于x节点的键，则继续找x结点的左子树</span><br>			<span class="hljs-keyword">return</span> get(x.left,key);<br>		&#125;<br>		<span class="hljs-keyword">else</span><br>		&#123;<br>			<span class="hljs-comment">//如果key等于x结点的键，就找到了key的结点，只需要返回x结点的值即可</span><br>			<span class="hljs-keyword">return</span> x.value;<br>		&#125;<br>	&#125;<br>	<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedBlackTreeTest</span> &#123;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>	    RedBlackTree&lt;String ,String&gt; tree=<span class="hljs-keyword">new</span> <span class="hljs-title class_">RedBlackTree</span>&lt;String ,String&gt;();<br>	    tree.put(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>);<br>	    tree.put(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>);<br>	    tree.put(<span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>);<br>	    String r1=tree.get(<span class="hljs-string">&quot;1&quot;</span>);<br>	    System.out.println(r1);<br>	    String r2=tree.get(<span class="hljs-string">&quot;2&quot;</span>);<br>	    System.out.println(r2);<br>	    String r3=tree.get(<span class="hljs-string">&quot;3&quot;</span>);<br>	    System.out.println(r3);<br>	<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>B树中允许一个结点中包含多个key，可以是3个、4个、5个甚至更多，并不确定，需要看具体的实现。现在我们选 择一个参数M，来构造一个B树，我们可以把它称作是M阶的B树，那么该树会具有如下特点：</p>
<p> 每个结点最多有M-1个key，并且以升序排列；</p>
<p> 每个结点最多能有M个子结点； </p>
<p>根结点至少有两个子结点；</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656852.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220809102727928"></p>
<p>所以，即使存储大量的数据，B树的高度仍然比较小，这 样在某些应用场景下，就可以体现出它的优势。</p>
<h4 id="B树存储数据"><a href="#B树存储数据" class="headerlink" title="B树存储数据"></a>B树存储数据</h4><p>详情见资料</p>
<h4 id="B树在磁盘文件中的应用"><a href="#B树在磁盘文件中的应用" class="headerlink" title="B树在磁盘文件中的应用"></a>B树在磁盘文件中的应用</h4><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+数的所有元素都会出现在叶子结点中</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202212241141914.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20221224114101928"></p>
<p>黄色区域是一页，b树叶子节点中也存储值，导致一页中存储的key减少，就导致指针减少，就会不断增高层级，但是b+树除了叶子结点都不存储值，就存储的key，一页中存储的key就多，树的层级就少，效率就高</p>
<p>上面这段话中的值是指比如二级索引节点中会存储对应的主键也就是聚合索引的值，聚合索引节点中会存储对应的行信息，也就是这些信息b树存储在所有节点上，而b+树存储在叶子节点上</p>
<p>key是对应索引的字段</p>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集是一种树型的数据结构 ，并查集可以高效地进行如下操作：</p>
<p>查询元素p和元素q是否属于同一组 </p>
<p>合并元素p和元素q所在的组</p>
<p>并查集也是一种树型结构</p>
<ol>
<li>每个元素都唯一的对应一个结点； </li>
<li>每一组数据中的多个元素都在同一颗树中； </li>
<li>一个组中的数据对应的树和另外一个组中的数据对应的树之间没有任何联系</li>
<li>元素在树中并没有子父级关系的硬性要求；</li>
</ol>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656853.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220809133849159"></p>
<h3 id="并查集的API设计"><a href="#并查集的API设计" class="headerlink" title="并查集的API设计"></a>并查集的API设计</h3><p>类名：UF</p>
<p>构造方法 UF(int N)：初始化并查集，以整数标识(0,N-1)个结点 </p>
<p>成员方法 1.public int count()：获取当前并查集中的数据有多少个分组 </p>
<p>2.public boolean connected(int p,int q):判断并查集中元素p和元素q是否在同一分组中 </p>
<p>3.public int find(int p):元素p所在分组的标识符 </p>
<p>4.public void union(int p,int q)：把p元素所在分组和q元素所在分组合并 </p>
<p>成员变量 1.private int[] eleAndGroup: 记录结点元素和该元素所在分组的标识 </p>
<p>​                2.private int count：记录并查集中数据的分组个数</p>
<p>构造方法的实现</p>
<ol>
<li>初始情况下，每个元素都在一个独立的分组中，所以，初始情况下，并查集中的数据默认分为N个组；</li>
<li>初始化数组eleAndGroup；</li>
<li>把eleAndGroup数组的索引看做是每个结点存储的元素，把eleAndGroup数组每个索引处的值看做是该结点 所在的分组，那么初始化情况下，i索引处存储的值就是i</li>
</ol>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656854.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220809135225831"></p>
<p>union方法的实现</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656855.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220809140811943"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UF</span> &#123;<br>	<span class="hljs-comment">//记录结点元素和该元素所在分组的标识</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] eleAndGroup;<br><span class="hljs-comment">//记录并查集中数据的分组个数</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br><span class="hljs-comment">//初始化并查集</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">UF</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> &#123;<br>	<span class="hljs-comment">//初始化分组的数量，默认情况下有N个分组</span><br>		<span class="hljs-built_in">this</span>.count=N;<br>		<span class="hljs-comment">//初始化end数组</span><br>		<span class="hljs-built_in">this</span>.eleAndGroup=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [N];<br>		<span class="hljs-comment">//初始化eleAndGroup中的元素极其所在的组的标识符,让eleAndGroup数组的索引作为并查集的每个节点的元素，并且让每个索引处的值(该元素所在组的标识符)就是该索引</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;eleAndGroup.length;i++) &#123;<br>        	eleAndGroup[i]=i;<br>        &#125;<br>&#125;<br><br><span class="hljs-comment">//获取当前并查集中的数据有多少个分组</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">count</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.count;<br>	<br>&#125;<br><span class="hljs-comment">//查询p所在分组的标识符</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> &#123;<br>	<span class="hljs-keyword">return</span> eleAndGroup[p];<br>&#125;<br><br><span class="hljs-comment">//判断并查集中元素p和元素q是否在同一个分组中</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">connected</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span> &#123;<br>	<span class="hljs-keyword">return</span> find(p)==find(q);<br>&#125;<br><span class="hljs-comment">//合并p元素和q元素所在的分组</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span> &#123;<br>	<span class="hljs-comment">//判断元素p和q是否已经在同一分组中，如果已经在同一分组中，则结束方法就可以了</span><br>	<span class="hljs-keyword">if</span>(connected(p,q)) &#123;<br>		<span class="hljs-keyword">return</span> ;<br>	&#125;<br>	<br><br>	<span class="hljs-comment">//找到p所在分组的标识符</span><br>	<span class="hljs-type">int</span> pgroup=find(p);<br>	<span class="hljs-comment">//找到q所在分组的标识符</span><br>	<span class="hljs-type">int</span> qgroup=find(q);<br>	<span class="hljs-comment">//合并组，让p所在组的所有元素的组标识符变为q所在分组的标识符</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;eleAndGroup.length;i++) &#123;<br>	<span class="hljs-keyword">if</span>(eleAndGroup[i]==pgroup) &#123;<br>		eleAndGroup[i]=qgroup;<br>	&#125;<br>	&#125;<br>	<span class="hljs-comment">//组数减一</span><br>	<span class="hljs-built_in">this</span>.count--;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> UFTest &#123;<br><br>	<span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>		UF uf=<span class="hljs-built_in">new</span> UF(<span class="hljs-number">5</span>);<br>		<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;默认情况分组个数&quot;+uf.count());<br>		Scanner <span class="hljs-keyword">in</span>=<span class="hljs-built_in">new</span> Scanner(<span class="hljs-keyword">System</span>.<span class="hljs-keyword">in</span>);<br>		<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>			<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;请输入第一个要合并的元素&quot;);<br>			<span class="hljs-type">int</span> p=<span class="hljs-keyword">in</span>.nextInt();<br>			<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;请输入第二个要合并的元素&quot;);<br>			<span class="hljs-type">int</span> q=<span class="hljs-keyword">in</span>.nextInt();<br>			<br>			<span class="hljs-keyword">if</span>(uf.connected(p,q)) &#123;<br>				<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(p+&quot;元素和&quot;+q+&quot;已经在同一个组中了&quot;);<br>				<span class="hljs-keyword">continue</span>;<br>			&#125;<br>			uf.<span class="hljs-keyword">union</span>(p, q);<br>			<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;当前并查集中还有：&quot;+uf.count()+&quot;个分组&quot;);<br>		&#125;<br>	<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面这种并查集的效率很低</p>
<h3 id="UF-Tree算法优化"><a href="#UF-Tree算法优化" class="headerlink" title="UF-Tree算法优化"></a>UF-Tree算法优化</h3><p>为了提升union算法的性能，我们需要重新设计find方法和union方法的实现，此时我们先需要对我们的之前数据结 构中的eleAndGourp数组的含义进行重新设定： </p>
<p>1.我们仍然让eleAndGroup数组的索引作为某个结点的元素； </p>
<p>2.eleAndGroup[i]的值不再是当前结点所在的分组标识，而是该结点的父结点；</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656856.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220809142404400"></p>
<p> find(int p)查询方法实现 </p>
<p>1.判断当前元素p的父结点eleAndGroup[p]是不是自己，如果是自己则证明已经是根结点了； </p>
<p>2.如果当前元素p的父结点不是自己，则让p&#x3D;eleAndGroup[p]，继续找父结点的父结点,直到找到根结点为止；</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656857.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220809143043613"></p>
<p>这个元素的标识符就是元素的根节点</p>
<p>union方法</p>
<p>1.3.5.3 union(int p,int q)合并方法实现 </p>
<ol>
<li><p>找到p元素所在树的根结点 </p>
</li>
<li><p>找到q元素所在树的根结点 </p>
</li>
<li><p>. 如果p和q已经在同一个树中，则无需合并； </p>
</li>
<li><ol start="4">
<li>如果p和q不在同一个分组，则只需要将p元素所在树根结点的父结点设置为q元素的根结点即可； </li>
<li><ol start="5">
<li>分组数量-1</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UFTREE</span> &#123;<br>		<span class="hljs-comment">//记录结点元素和该元素所在分组的标识</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] eleAndGroup;<br>	<span class="hljs-comment">//记录并查集中数据的分组个数</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br>	<span class="hljs-comment">//初始化并查集</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">UFTREE</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> &#123;<br>		<span class="hljs-comment">//初始化分组的数量，默认情况下有N个分组</span><br>			<span class="hljs-built_in">this</span>.count=N;<br>			<span class="hljs-comment">//初始化end数组</span><br>			<span class="hljs-built_in">this</span>.eleAndGroup=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [N];<br>			<span class="hljs-comment">//初始化eleAndGroup中的元素极其所在的组的标识符,让eleAndGroup数组的索引作为并查集的每个节点的元素，并且让每个索引处的值(该元素所在组的标识符)就是该索引</span><br>	        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;eleAndGroup.length;i++) &#123;<br>	        	eleAndGroup[i]=i;<br>	        &#125;<br>	&#125;<br><br>	<span class="hljs-comment">//获取当前并查集中的数据有多少个分组</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">count</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.count;<br>		<br>	&#125;<br>	<span class="hljs-comment">//查询p所在分组的标识符</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> &#123;<br>		<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>			<span class="hljs-keyword">if</span>(p==eleAndGroup[p]) &#123;<br>				<span class="hljs-keyword">return</span> p;<br>			&#125;<br>			<br>			p=eleAndGroup[p];<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-comment">//判断并查集中元素p和元素q是否在同一个分组中</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">connected</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span> &#123;<br>		<span class="hljs-keyword">return</span> find(p)==find(q);<br>	&#125;<br>	<span class="hljs-comment">//合并p元素和q元素所在的分组</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span> &#123;<br>	<br>		<span class="hljs-comment">//找到p所在分组的对应的根节点</span><br>		<span class="hljs-type">int</span> pRoot=find(p);<br>		<span class="hljs-comment">//找到q所在分组的根节点</span><br>		<span class="hljs-type">int</span> qRoot=find(q);<br><br><span class="hljs-comment">//如果p和q已经在一个分组就不用合并了</span><br>		<span class="hljs-keyword">if</span>(pRoot==qRoot) &#123;<br>			<span class="hljs-keyword">return</span> ;<br>		&#125;<br>		<span class="hljs-comment">//让p所在树的根节点的父节点为q所在树的根节点即可</span><br>		eleAndGroup[pRoot]=qRoot;<br>		<span class="hljs-comment">//组数减一</span><br>		<span class="hljs-built_in">this</span>.count--;<br>	&#125;<br>	<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UFTREETEST</span> &#123;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		UFTREE uf=<span class="hljs-keyword">new</span> <span class="hljs-title class_">UFTREE</span>(<span class="hljs-number">5</span>);<br>		System.out.println(<span class="hljs-string">&quot;默认情况分组个数&quot;</span>+uf.count());<br>		Scanner in=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>		<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>			System.out.println(<span class="hljs-string">&quot;请输入第一个要合并的元素&quot;</span>);<br>			<span class="hljs-type">int</span> p=in.nextInt();<br>			System.out.println(<span class="hljs-string">&quot;请输入第二个要合并的元素&quot;</span>);<br>			<span class="hljs-type">int</span> q=in.nextInt();<br>			<br>			<span class="hljs-keyword">if</span>(uf.connected(p,q)) &#123;<br>				System.out.println(p+<span class="hljs-string">&quot;元素和&quot;</span>+q+<span class="hljs-string">&quot;已经在同一个组中了&quot;</span>);<br>				<span class="hljs-keyword">continue</span>;<br>			&#125;<br>			uf.union(p, q);<br>			System.out.println(<span class="hljs-string">&quot;当前并查集中还有：&quot;</span>+uf.count()+<span class="hljs-string">&quot;个分组&quot;</span>);<br>		&#125;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>优化之后这个union方法的时间复杂度从O(N^2)便成了O(N)</p>
<p>find方法从时间复杂度为O(1)变为现在最坏的情况下为O(N)</p>
<h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>如果 我们把并查集中每一棵树的大小记录下来，然后在每次合并树的时候，把较小的树连接到较大的树上，就可以减小 树的深度。</p>
<p>只要我们保证每次合并，都能把小树合并到大树上，就能够压缩合并后新树的路径，这样就能提高find方法的效率</p>
<p>为了完成这个需求，我们需要另外一个数组来记录存储每个根结点对应的树中元素的个数，并且需要一些代码 调整数组中的值。</p>
<p>改进之后的API</p>
<p>主要是union方法的改动</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> UF_TREE_WEIGHTED &#123;<br><br>		<span class="hljs-comment">//记录结点元素和该元素所在分组的标识</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] eleAndGroup;<br>	<span class="hljs-comment">//记录并查集中数据的分组个数</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">count</span>;<br>	<span class="hljs-comment">//用来存储每一个根节点对应树中保存的结点个数</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] sz;<br>	<span class="hljs-comment">//初始化并查集</span><br>	<span class="hljs-keyword">public</span> UF_TREE_WEIGHTED(<span class="hljs-keyword">int</span> N) &#123;<br>		<span class="hljs-comment">//初始化分组的数量，默认情况下有N个分组</span><br>			<span class="hljs-keyword">this</span>.<span class="hljs-keyword">count</span>=N;<br>			<span class="hljs-comment">//初始化end数组</span><br>			<span class="hljs-keyword">this</span>.eleAndGroup=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [N];<br>			<span class="hljs-comment">//初始化eleAndGroup中的元素极其所在的组的标识符,让eleAndGroup数组的索引作为并查集的每个节点的元素，并且让每个索引处的值(该元素所在组的标识符)就是该索引</span><br>	        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;eleAndGroup.length;i++) &#123;<br>	        	eleAndGroup[i]=i;<br>	        &#125;<br>	        <span class="hljs-keyword">this</span>.sz=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N];<br>	        <span class="hljs-comment">//默认情况下，sz中每个索引处的值都是1</span><br>	        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;sz.length;i++) &#123;<br>	        	sz[i]=<span class="hljs-number">1</span>;<br>	        &#125;<br>	&#125;<br>	<br>	<span class="hljs-comment">//获取当前并查集中的数据有多少个分组</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">count</span>() &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.<span class="hljs-keyword">count</span>;<br>		<br>	&#125;<br>	<span class="hljs-comment">//查询p所在分组的标识符</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">find</span>(<span class="hljs-keyword">int</span> p) &#123;<br>		<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>			<span class="hljs-keyword">if</span>(p==eleAndGroup[p]) &#123;<br>				<span class="hljs-keyword">return</span> p;<br>			&#125;<br>			<br>			p=eleAndGroup[p];<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-comment">//判断并查集中元素p和元素q是否在同一个分组中</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> connected(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> q) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">find</span>(p)==<span class="hljs-keyword">find</span>(q);<br>	&#125;<br>	<span class="hljs-comment">//合并p元素和q元素所在的分组</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> union(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> q) &#123;<br>	<br>		<span class="hljs-comment">//找到p所在分组的对应的根节点</span><br>		<span class="hljs-keyword">int</span> pRoot=<span class="hljs-keyword">find</span>(p);<br>		<span class="hljs-comment">//找到q所在分组的根节点</span><br>		<span class="hljs-keyword">int</span> qRoot=<span class="hljs-keyword">find</span>(q);<br><br><span class="hljs-comment">//如果p和q已经在一个分组就不用合并了</span><br>		<span class="hljs-keyword">if</span>(pRoot==qRoot) &#123;<br>			<span class="hljs-keyword">return</span> ;<br>		&#125;<br>		<span class="hljs-comment">//判断是pRoot对应的树大还是qRoot对应的树大</span><br>		<span class="hljs-keyword">if</span>(sz[pRoot]&lt;sz[qRoot]) &#123;<br>			eleAndGroup[pRoot]=qRoot;<br>			sz[qRoot]+=sz[pRoot];<br>		&#125;<br>		<span class="hljs-keyword">else</span><br>		&#123;<br>			eleAndGroup[qRoot]=pRoot;<br>			sz[pRoot]=sz[qRoot];<br>		&#125;<br>		<span class="hljs-comment">//组数减一</span><br>		<span class="hljs-keyword">this</span>.<span class="hljs-keyword">count</span>--;<br>	&#125;<br>	<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UFWEIGHTEDTEST</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span> &#123;<br>	UF_TREE_WEIGHTED uf=<span class="hljs-keyword">new</span> <span class="hljs-title class_">UF_TREE_WEIGHTED</span>(<span class="hljs-number">5</span>);<br>	System.out.println(<span class="hljs-string">&quot;默认情况分组个数&quot;</span>+uf.count());<br>	Scanner in=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>	<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>		System.out.println(<span class="hljs-string">&quot;请输入第一个要合并的元素&quot;</span>);<br>		<span class="hljs-type">int</span> p=in.nextInt();<br>		System.out.println(<span class="hljs-string">&quot;请输入第二个要合并的元素&quot;</span>);<br>		<span class="hljs-type">int</span> q=in.nextInt();<br>		<br><br>		<span class="hljs-keyword">if</span>(uf.connected(p,q)) &#123;<br>			System.out.println(p+<span class="hljs-string">&quot;元素和&quot;</span>+q+<span class="hljs-string">&quot;已经在同一个组中了&quot;</span>);<br>			<span class="hljs-keyword">continue</span>;<br>		&#125;<br>		uf.union(p, q);<br>		System.out.println(<span class="hljs-string">&quot;当前并查集中还有：&quot;</span>+uf.count()+<span class="hljs-string">&quot;个分组&quot;</span>);<br>	&#125;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="畅通工程"><a href="#畅通工程" class="headerlink" title="畅通工程"></a>畅通工程</h3><p>某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目 标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。</p>
<p>总共有20个城市，目前已经修改好了7条道路，问还需要修建多少条道路，才能让这20个城市之间全部相通？</p>
<p>解题思路： 1.创建一个并查集UF_Tree_Weighted(20); </p>
<p>2.分别调用union(0,1),union(6,9),union(3,8),union(5,11),union(2,12),union(6,10),union(4,8)，表示已经修建好的 道路把对应的城市连接起来； </p>
<p>3.如果城市全部连接起来，那么并查集中剩余的分组数目为1，所有的城市都在一个树中，所以，只需要获取当前 并查集中剩余的数目，减去1，就是还需要修建的道路数目；</p>
<p>20个城市就是20个元素，修路就是两个变成一个组，然后7条路再看剩下还有多少组，得到剩下的组数之后，减去1就是要修的路的数量，如此组数便可为零</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Traffic_Project_Test</span> &#123;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NumberFormatException, IOException &#123;<br>		BufferedReader br=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;D:\\放乱七八糟\\a.txt&quot;</span>));<br>		<span class="hljs-comment">//城市数量</span><br>		<span class="hljs-type">int</span> number=Integer.parseInt(br.readLine());<br>		UF_TREE_WEIGHTED uf=<span class="hljs-keyword">new</span> <span class="hljs-title class_">UF_TREE_WEIGHTED</span>(number);<br>		<span class="hljs-comment">//路的数量</span><br>		<span class="hljs-type">int</span> roadNumber=Integer.parseInt(br.readLine());<br>		<span class="hljs-comment">//循环读取已经修建好的道路，并调用union方法</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;roadNumber;i++) &#123;<br>			<span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> br.readLine();<br>			<span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Integer.parseInt(line.split(<span class="hljs-string">&quot; &quot;</span>)[<span class="hljs-number">0</span>]);<br>			<span class="hljs-type">int</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> Integer.parseInt(line.split(<span class="hljs-string">&quot; &quot;</span>)[<span class="hljs-number">1</span>]);<br>			uf.union(p,q);<br>	<br>		&#125;<br>		<span class="hljs-comment">//获取剩余的分组数量</span><br>		<span class="hljs-type">int</span> <span class="hljs-variable">groupNumber</span> <span class="hljs-operator">=</span> uf.count();<br>		<span class="hljs-comment">//计算出还需要修建的道路</span><br>		System.out.println(<span class="hljs-string">&quot;还需要修建&quot;</span>+(groupNumber-<span class="hljs-number">1</span>)+<span class="hljs-string">&quot;道路，城市才能相通&quot;</span>);<br><br><br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h2><p>定义：图是由一组顶点和一组能够将两个顶点相连的边组成的</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656858.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220809155717599"></p>
<p><strong>特殊的图：</strong></p>
<ol>
<li>自环：即一条连接一个顶点和其自身的边；</li>
<li>平行边：连接同一对顶点的两条边；</li>
</ol>
<p>图的分类： 按照连接两个顶点的边的不同，可以把图分为以下两种： </p>
<p>无向图：边仅仅连接两个顶点，没有其他含义； </p>
<p>有向图：边不仅连接两个顶点，并且具有方向；</p>
<p><strong>相关术语</strong></p>
<p>相邻顶点： 当两个顶点通过一条边相连时，我们称这两个顶点是相邻的，并且称这条边依附于这两个顶点。</p>
<p> 度： 某个顶点的度就是依附于该顶点的边的个数 </p>
<p>子图： 是一幅图的所有边的子集(包含这些边依附的顶点)组成的图； </p>
<p>路径： 是由边顺序连接的一系列的顶点组成 </p>
<p>环： 是一条至少含有一条边且终点和起点相同的路径</p>
<p>连通图： 如果图中任意一个顶点都存在一条路径到达另外一个顶点，那么这幅图就称之为连通图</p>
<p>连通子图： 一个非连通图由若干连通的部分组成，每一个连通的部分都可以称为该图的连通子图</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656860.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220809160102712"></p>
<p><strong>图的存储结构</strong></p>
<p>1.图中所有的顶点；</p>
<ol start="2">
<li>所有连接顶点的边； </li>
<li>常见的图的存储结构有两种：邻接矩阵和邻接表</li>
</ol>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656861.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220809160517267"></p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656862.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220809160701184"></p>
<h3 id="图的API设计"><a href="#图的API设计" class="headerlink" title="图的API设计"></a>图的API设计</h3><p>类名：Graph</p>
<p>构造方法 Graph(int V)：创建一个包含V个顶点但不包含边的图</p>
<p>成员方法：</p>
<p>1.public int V():获取图中顶点的数量 </p>
<p>2.public int E():获取图中边的数量 </p>
<p>3.public void addEdge(int v,int w):向图中添加一条边 v-w </p>
<p>4.public Queue adj(int v)：获取和顶点v相邻的所有顶点</p>
<p>成员变量：</p>
<p>1.private final int V: 记录顶点数量 </p>
<p>2.private int E: 记录边数量 </p>
<p>3.private Queue[] adj: 邻接表</p>
<p>代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span> &#123;<br>	<span class="hljs-comment">//顶点数目</span><br><span class="hljs-keyword">private</span> final <span class="hljs-built_in">int</span> V;<br><span class="hljs-comment">//边的数目</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> E;<br><span class="hljs-comment">//邻接表</span><br><span class="hljs-keyword">private</span> Queue&lt;Integer&gt;[] adj;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> v</span>)</span> &#123;<br>	<span class="hljs-comment">//初始化顶点数量</span><br>	<span class="hljs-keyword">this</span>.V=v;<br>	<span class="hljs-comment">//初始化边的数量</span><br>	<span class="hljs-keyword">this</span>.E=<span class="hljs-number">0</span>;<br>	<span class="hljs-comment">//初始化邻接表</span><br>	<span class="hljs-keyword">this</span>.adj=<span class="hljs-keyword">new</span> Queue[v];<br>	<br><br>	<span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;adj.length;i++) &#123;<br>		adj[i]=<span class="hljs-keyword">new</span> Queue&lt;Integer&gt;();<br>	&#125;<br><br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span>获取顶点的数目</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">V</span>()</span> &#123;<br>	<span class="hljs-keyword">return</span> V;<br>&#125;<br><span class="hljs-comment">//获取边的数目</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">E</span>()</span> &#123;<br>	<span class="hljs-keyword">return</span> E;<br>&#125;<br><span class="hljs-comment">//如图中添加一条边v-w</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> v,<span class="hljs-built_in">int</span> w</span>)</span> &#123;<br>	<span class="hljs-comment">//在无向图中，边是没有方向的，该边既可以说是从v到w也可以说是从w到v得边，让w出现在v邻接表中，让v出现在w邻接表中</span><br>	adj[v].enqueue(w);<br>	adj[w].enqueue(v);<br>	<span class="hljs-comment">//边的数量加一</span><br>	E++;<br>&#125;<br><br><span class="hljs-comment">//获取和顶点v相邻的所有顶点</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Queue&lt;Integer&gt; <span class="hljs-title">adj</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> v</span>)</span>&#123;<br>	<span class="hljs-keyword">return</span> adj[v];<br>&#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="图的搜索"><a href="#图的搜索" class="headerlink" title="图的搜索"></a>图的搜索</h3><p>找出图中与指定的顶点相连的所有顶点，或者判定某个顶点与指定顶点是否相通，是非常常见的需求。 有关图的搜索，最经典的算法有深度优先搜索和广度优先搜索，接下来我们分别讲解这两种搜索算法。</p>
<h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><p>所谓的深度优先搜索，指的是在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找子结点，然后找 兄弟结点。</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656863.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220809163752727"></p>
<p>红色的线是查询的顺序，已经被重复过搜索的顶点，要避免被搜索，直到你要搜索的都被搜索过了，然后去往回返找你的兄弟结点</p>
<p>看兄弟结点有没有被搜索过</p>
<p><strong>API设计</strong></p>
<p>类名 DepthFirstSearch</p>
<p>构造方法：DepthFirstSearch(Graph G,int s)：构造深度优先搜索对象，使用深度优先搜索找出G图中s顶点 的所有相通顶点</p>
<p>成员方法：1.private void dfs(Graph G, int v)：使用深度优先搜索找出G图中v顶点的所有相通顶点 </p>
<p>​                    2.public boolean marked(int w):判断w顶点与s顶点是否相通 </p>
<p>​                   3.public int count():获取与顶点s相通的所有顶点的总数</p>
<p>成员变量：</p>
<p>​                   1.private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索 </p>
<p>​                    2.private int count：记录有多少个顶点与s顶点相通</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DepthFirstSearch</span> &#123;<br>	<span class="hljs-comment">//索引代表顶点，值表示当前顶点是否已经被搜索</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[] marked; <br>	<span class="hljs-comment">//记录有多少个顶点与s顶点相通</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br>	<span class="hljs-comment">//构造深度优先搜索对象，使用深度优先搜索找出G图中s顶点 的所有相通顶点</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">DepthFirstSearch</span><span class="hljs-params">(Graph G,<span class="hljs-type">int</span> s)</span> &#123;<br>		<span class="hljs-comment">//初始化marked数组</span><br>		<span class="hljs-built_in">this</span>.marked=<span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[G.V()];<br>		<span class="hljs-comment">//初始化和顶点s相通的顶点的数量</span><br>		<span class="hljs-built_in">this</span>.count=<span class="hljs-number">0</span>;<br>		<br><br>	dfs(G,s);<br>	&#125;<br>	<span class="hljs-comment">//使用深度优先搜索找出G图中v顶点的所有相通顶点 </span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(Graph G,<span class="hljs-type">int</span> v )</span> &#123;<br>		<span class="hljs-comment">//把v顶点标识为已搜索</span><br>		marked[v]=<span class="hljs-literal">true</span>;<br>		<span class="hljs-comment">//没被搜索，遍历当前v顶点的邻接表</span><br>		<span class="hljs-keyword">for</span>(Integer w:G.adj(v)) &#123;<br>			<span class="hljs-comment">//判断这些元素有没有被搜索过，如果没有搜索过，则递归调用dfs方法进行深度搜索</span><br>			<span class="hljs-keyword">if</span>(!marked[w]) &#123;<br>				dfs(G,w);<br>			&#125;<br>		&#125;<br>		count++;<br>	&#125;<br>	<span class="hljs-comment">//判断顶点w与s顶点是否相通</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">marked</span><span class="hljs-params">(<span class="hljs-type">int</span> w)</span> &#123;<br>		<span class="hljs-keyword">return</span> marked[w];<br>	&#125;<br>	<span class="hljs-comment">//获取与顶点s相通的所有顶点的总数</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">count</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> count;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DepthFirstSearchTest</span> &#123;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-comment">//准备Graph对象</span><br>		Graph graph=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Graph</span>(<span class="hljs-number">13</span>);<br>		graph.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);<br>		graph.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">6</span>);<br>		graph.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>		graph.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>);<br>		graph.addEdge(<span class="hljs-number">5</span>,<span class="hljs-number">3</span>);<br>		graph.addEdge(<span class="hljs-number">5</span>,<span class="hljs-number">4</span>);<br>		graph.addEdge(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<br>		graph.addEdge(<span class="hljs-number">4</span>,<span class="hljs-number">6</span>);<br>		graph.addEdge(<span class="hljs-number">7</span>,<span class="hljs-number">8</span>);<br>		graph.addEdge(<span class="hljs-number">9</span>,<span class="hljs-number">11</span>);<br>		graph.addEdge(<span class="hljs-number">9</span>,<span class="hljs-number">10</span>);<br>		graph.addEdge(<span class="hljs-number">9</span>,<span class="hljs-number">12</span>);<br>		graph.addEdge(<span class="hljs-number">11</span>,<span class="hljs-number">12</span>);<br>	    <span class="hljs-comment">//准备深度优先搜索对象</span><br>		DepthFirstSearch dfs=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DepthFirstSearch</span>(graph,<span class="hljs-number">0</span>);<br>		<span class="hljs-comment">//测试与某个顶点相通的顶点数量</span><br>		System.out.println(dfs.count());<span class="hljs-comment">//与0顶点相通的顶点数量</span><br>		<span class="hljs-comment">//测试某个0点与5点是否相通</span><br>		<span class="hljs-type">boolean</span> marked1=dfs.marked(<span class="hljs-number">5</span>);<br>		System.out.println(marked1);<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><p>如果遇到一个结点既有子结点，又有兄弟结点，那么先找兄弟结点，然后 找子结点。</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656864.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220809173009303"></p>
<p>红色代表查找的顺序</p>
<p>类名：BreadFirstSearch</p>
<p>构造方法：BreadthFirstSearch(Graph G,int s)：构造广度优先搜索对象，使用广度优先搜索找出G图中s顶点的所有相邻顶点</p>
<p>成员方法：1.private void bfs(Graph G, int v)：使用广度优先搜索找出G图中v顶点的所有相邻顶点 </p>
<p>​                   2.public boolean marked(int w):判断w顶点与s顶点是否相通 </p>
<p>​                    3.public int count():获取与顶点s相通的所有顶点的总数</p>
<p>成员变量：</p>
<p>​             1.private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索 </p>
<p>​               2.private int count：记录有多少个顶点与s顶点相通 </p>
<p>​             3.private Queue waitSearch: 用来存储待搜索邻接表的点</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BreadFirstSearch</span> &#123;<br>	<span class="hljs-comment">//索引代表顶点，值表示当前顶点是否已经被搜索 </span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[] marked;<br>	<span class="hljs-comment">//记录有多少个顶点与s顶点相通 </span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br>	<span class="hljs-comment">//用来存储待搜索邻接表的点</span><br>	<span class="hljs-keyword">private</span> Queue&lt;Integer&gt; waitSearch;<br>	<span class="hljs-comment">//构造广度优先搜索对象，使用广度优先搜索找出G图中s顶点的所有相邻顶点</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">BreadFirstSearch</span><span class="hljs-params">(Graph G,<span class="hljs-type">int</span> s)</span> &#123;<br>		<span class="hljs-built_in">this</span>.marked=<span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[G.V()];<br>		<span class="hljs-built_in">this</span>.count=<span class="hljs-number">0</span>;<br>		<span class="hljs-built_in">this</span>.waitSearch=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>&lt;Integer&gt;();<br>		bfs(G,s);<br>	&#125;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bfs</span><span class="hljs-params">(Graph G,<span class="hljs-type">int</span> v)</span> &#123;<br>		<span class="hljs-comment">//将当前v标识为已搜索</span><br>		marked[v]=<span class="hljs-literal">true</span>;<br>		<span class="hljs-comment">//还要让v进入队列待搜索</span><br>		waitSearch.enqueue(v);<br>		<span class="hljs-comment">//通过循环，如果队列不为空，则从队列中弹出一个待搜索的顶点进行搜索</span><br>	   <span class="hljs-keyword">while</span>(!waitSearch.isEmpty()) &#123;<br>		   <span class="hljs-comment">//弹出一个待搜索的顶点</span><br>		   Integer wait=waitSearch.dequeue();<br>		   <br><br>		   <span class="hljs-comment">//遍历wait顶点的邻接表</span><br>		  <span class="hljs-keyword">for</span>(Integer w: G.adj(wait))<br>		  &#123;<br>			  <span class="hljs-comment">//判断当前结点是否被搜索</span><br>			  <span class="hljs-keyword">if</span>(!marked[w]) &#123;<br>				  bfs(G,w);<br>			  &#125;<br>		  &#125;<br>		   <br>	   &#125;<br>	   <span class="hljs-comment">//让相通的顶点+1</span><br>	  count++;<br>	&#125;<br>	<span class="hljs-comment">//判断w顶点是否与s顶点相通</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">marked</span><span class="hljs-params">(<span class="hljs-type">int</span> w)</span> &#123;<br>		<span class="hljs-keyword">return</span> marked[w];<br>	&#125;<br>	<span class="hljs-comment">//获取与顶点s相通的所有顶点的总数</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">count</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> count;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> BreadFirstSearchTest &#123;<br>	public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>		<span class="hljs-comment">//准备Graph对象</span><br>		Graph graph=<span class="hljs-keyword">new</span> <span class="hljs-constructor">Graph(13)</span>;<br>		graph.add<span class="hljs-constructor">Edge(0,5)</span>;<br>		graph.add<span class="hljs-constructor">Edge(0,6)</span>;<br>		graph.add<span class="hljs-constructor">Edge(0,1)</span>;<br>		graph.add<span class="hljs-constructor">Edge(0,2)</span>;<br>		graph.add<span class="hljs-constructor">Edge(5,3)</span>;<br>		graph.add<span class="hljs-constructor">Edge(5,4)</span>;<br>		graph.add<span class="hljs-constructor">Edge(3,4)</span>;<br>		graph.add<span class="hljs-constructor">Edge(4,6)</span>;<br>		graph.add<span class="hljs-constructor">Edge(7,8)</span>;<br>		graph.add<span class="hljs-constructor">Edge(9,11)</span>;<br>		graph.add<span class="hljs-constructor">Edge(9,10)</span>;<br>		graph.add<span class="hljs-constructor">Edge(9,12)</span>;<br>		graph.add<span class="hljs-constructor">Edge(11,12)</span>;<br>        <span class="hljs-comment">//准备深度优先搜索对象</span><br>		BreadFirstSearch dfs=<span class="hljs-keyword">new</span> <span class="hljs-constructor">BreadFirstSearch(<span class="hljs-params">graph</span>,0)</span>;<br>		<span class="hljs-comment">//测试与某个顶点相通的顶点数量</span><br>		<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(dfs.count<span class="hljs-literal">()</span>);<span class="hljs-comment">//与0顶点相通的顶点数量</span><br>		<span class="hljs-comment">//测试某个0点与5点是否相通</span><br>		boolean marked1=dfs.marked(<span class="hljs-number">5</span>);<br>		<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(marked1);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="畅通工程的续集"><a href="#畅通工程的续集" class="headerlink" title="畅通工程的续集"></a>畅通工程的续集</h4><p>总共有20个城市，目前已经修改好了7条道路，问9号城市和10号城市是否相通？9号城市和8号城市是否相通？</p>
<p>解题思路： 1.创建一个图Graph对象，表示城市； </p>
<p>​                     2.分别调用 addEdge(0,1),addEdge(6,9),addEdge(3,8),addEdge(5,11),addEdge(2,12),addEdge(6,10),addEdge(4,8)，表示已 经修建好的道路把对应的城市连接起来； </p>
<p>​                     3.通过Graph对象和顶点9，构建DepthFirstSearch对象或BreadthFirstSearch对象； </p>
<p>​                     4.调用搜索对象的marked(10)方法和marked(8)方法，即可得到9和城市与10号城市以及9号城市与8号城市是否相 通。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Traffic_Project_test2</span> &#123;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NumberFormatException, IOException &#123;<br>		BufferedReader br=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;D:\\放乱七八糟\\a.txt&quot;</span>));<br>		<span class="hljs-type">int</span> citynumber=Integer.parseInt(br.readLine());<br>		Graph group=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Graph</span>(citynumber);<br>		<span class="hljs-type">int</span> roadnumber=Integer.parseInt(br.readLine());<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;roadnumber;i++) &#123;<br>			String line=br.readLine();<br>			<span class="hljs-type">int</span> p=Integer.parseInt(line.split(<span class="hljs-string">&quot; &quot;</span>)[<span class="hljs-number">0</span>]);<br>			<span class="hljs-type">int</span> q=Integer.parseInt(line.split(<span class="hljs-string">&quot; &quot;</span>)[<span class="hljs-number">1</span>]);<br>			group.addEdge(p,q);<br>		&#125;<br>		DepthFirstSearch search=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DepthFirstSearch</span>(group,<span class="hljs-number">9</span>);<br>		<span class="hljs-comment">//判断第九个城市和第八个第十个是否相通</span><br>	    System.out.println(search.marked(<span class="hljs-number">10</span>));<br>	    System.out.println(search.marked(<span class="hljs-number">8</span>));<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="路径查找"><a href="#路径查找" class="headerlink" title="路径查找"></a>路径查找</h3><p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656865.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220810085526979"></p>
<p>类名 DepthFirstPaths</p>
<p>构造方法 DepthFirstPaths(Graph G,int s)：构造深度优先搜索对象，使用深度优先搜索找出G图中起点为 s的所有路径</p>
<p>成员方法 1.private void dfs(Graph G, int v)：使用深度优先搜索找出G图中v顶点的所有相通顶点 </p>
<p>​                2.public boolean hasPathTo(int v):判断v顶点与s顶点是否存在路径 </p>
<p>​                3.public Stack pathTo(int v):找出从起点s到顶点v的路径(就是该路径经过的顶点)</p>
<p>成员变量 1.private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索 </p>
<p>​                2.private int s:起点 </p>
<p>​                3.private int[] edgeTo:索引代表顶点，值代表从起点s到当前顶点路径上的最后一个顶点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DepthFirstPaths</span> &#123;<br><span class="hljs-comment">//索引代表顶点，值表示当前顶点是否已经被搜索 </span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[] marked;<br>	<span class="hljs-comment">//起点</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> s;<br>	<span class="hljs-comment">//索引代表顶点，值代表从起点s到当前顶点路径上的最后一个顶点</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] edgeTo;<br>	<br><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">DepthFirstPaths</span><span class="hljs-params">(Graph G,<span class="hljs-type">int</span> s)</span> &#123;<br>	<span class="hljs-comment">//初始化marked数组</span><br>		<span class="hljs-built_in">this</span>.marked=<span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[G.V()];<br>		<span class="hljs-comment">//初始化s起点</span><br>		<span class="hljs-built_in">this</span>.s=s;<br>		<span class="hljs-comment">//初始化edgeTo数组</span><br>	    <span class="hljs-built_in">this</span>.edgeTo=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[G.V()];<br>	    dfs(G,s);<br>	&#125;<br>	<br>	<span class="hljs-comment">//使用深度优先搜索找出G图中v顶点的所有相通顶点 </span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(Graph G,<span class="hljs-type">int</span> v)</span> &#123;<br>		<span class="hljs-comment">//把v标识为已搜索</span><br>		marked[v]=<span class="hljs-literal">true</span>;<br>		<br>		<span class="hljs-comment">//通过顶点v的邻接表，拿到每一个相邻的顶点，继续进行搜索</span><br>		<span class="hljs-keyword">for</span>(Integer w:G.adj(v)) &#123;<br>			<br>			<span class="hljs-comment">//如果w没有被搜索则继续递归搜索</span><br>			<span class="hljs-keyword">if</span>(!marked[w]) &#123;<br>				edgeTo[w]=v;<span class="hljs-comment">//到达顶点w路径上的最后一个顶点是v,通过v找到w的</span><br>				dfs(G,w);<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-comment">//判断v顶点与s顶点是否存在路径 </span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPathTo</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> &#123;<br>		<span class="hljs-keyword">return</span> marked[v];<br>	&#125;<br>	<br>	<span class="hljs-comment">//找出从起点s到顶点v的路径(就是该路径经过的顶点)</span><br>	  <span class="hljs-keyword">public</span> Stack&lt;Integer&gt; <span class="hljs-title function_">pathTo</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span>&#123;<br>		  <span class="hljs-keyword">if</span>(!hasPathTo(v)) &#123;<br>			  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>		  &#125;<br>		  <span class="hljs-comment">//创键栈对象，保存路径中的所有顶点</span><br>		  Stack&lt;Integer&gt; path=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>		  <br>		  <span class="hljs-comment">//通过循环，从顶点v开始，一直往前找找到起点为止</span><br>		  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=v;x!=s;x=edgeTo[x]) &#123;<br>			  path.push(x);<br>		  &#125;<br>		  <span class="hljs-comment">//把起点s放到栈中</span><br>		  path.push(s);<br>		  <span class="hljs-keyword">return</span> path;<br>	  &#125;<br><br>&#125; <br></code></pre></td></tr></table></figure>

<p>测试：</p>
<p>这个测试的例子就是上面右方那个图</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DepthFirstSearchPathsTest</span> &#123;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>		BufferedReader br=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;D:\\放乱七八糟\\b.txt&quot;</span>));<br>		<span class="hljs-type">int</span> pointnumber=Integer.parseInt(br.readLine());<br>		Graph g=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Graph</span>(pointnumber);<br>		<br>		<span class="hljs-type">int</span> edgenumber=Integer.parseInt(br.readLine());<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;edgenumber;i++) &#123;<br>			String line=br.readLine();<br>			<span class="hljs-type">int</span> p=Integer.parseInt(line.split(<span class="hljs-string">&quot; &quot;</span>)[<span class="hljs-number">0</span>]);<br>			<span class="hljs-type">int</span> q=Integer.parseInt(line.split(<span class="hljs-string">&quot; &quot;</span>)[<span class="hljs-number">1</span>]);<br>			g.addEdge(p, q);<br>		&#125;<br>	         DepthFirstPaths paths=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DepthFirstPaths</span>(g,<span class="hljs-number">0</span>);<br>	         Stack&lt;Integer&gt; path=paths.pathTo(<span class="hljs-number">4</span>);<br>	         StringBuilder sb=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>	         <span class="hljs-keyword">for</span>(Integer v:path) &#123;<br>	        	sb.append(v+<span class="hljs-string">&quot;-&quot;</span>);<br>	         &#125;<br>	         sb.deleteCharAt(sb.length()-<span class="hljs-number">1</span>);<br>	         System.out.println(sb);<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><p>有向图是一副具有方向性的图，是由一组顶点和一组有方向的边组成的，每条方向的边都连着一对有序的顶点。</p>
<p> 出度： 由某个顶点指出的边的个数称为该顶点的出度。 </p>
<p>入度： 指向某个顶点的边的个数称为该顶点的入度。 </p>
<p>有向路径： 由一系列顶点组成，对于其中的每个顶点都存在一条有向边，从它指向序列中的下一个顶点。 </p>
<p>有向环： 一条至少含有一条边，且起点和终点相同的有向路径。</p>
<p>一副有向图中两个顶点v和w可能存在以下四种关系：</p>
<ol>
<li>没有边相连；</li>
<li>存在从v到w的边v—&gt;w;</li>
<li>存在从w到v的边w—&gt;v</li>
<li>既存在w到v的边，也存在v到w的边，即双向连接；</li>
</ol>
<h3 id="有向图的API设计"><a href="#有向图的API设计" class="headerlink" title="有向图的API设计"></a>有向图的API设计</h3><p>类名   Digraph</p>
<p>构造方法 Digraph(int V)：创建一个包含V个顶点但不包含边的有向图</p>
<p>成员方法</p>
<p>1.public int V():获取图中顶点的数量 </p>
<p>2.public int E():获取图中边的数量 </p>
<p>3.public void addEdge(int v,int w):向有向图中添加一条边 v-&gt;w </p>
<p>4.public Queue adj(int v)：获取由v指出的边所连接的所有顶点 </p>
<p>5.private Digraph reverse():该图的反向图</p>
<p>成员变量</p>
<p>1.private final int V: 记录顶点数量 </p>
<p>2.private int E: 记录边数量 </p>
<p>3.private Queue[] adj: 邻接表</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Digraph</span> &#123;<br><span class="hljs-comment">//顶点数目</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> V;<br>	<span class="hljs-comment">//边的数目</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> E;<br>	<span class="hljs-comment">//邻接表</span><br>	<span class="hljs-keyword">private</span> Queue&lt;Integer&gt;[] adj;<br>	<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Digraph</span><span class="hljs-params">(<span class="hljs-type">int</span> V)</span> &#123;<br>		<span class="hljs-comment">//初始化顶点数量</span><br>		<span class="hljs-built_in">this</span>.V=V;<br>		<span class="hljs-comment">//初始化边的数量</span><br>		<span class="hljs-built_in">this</span>.E=<span class="hljs-number">0</span>;<br>		<span class="hljs-comment">//初始化邻接表</span><br>		<span class="hljs-built_in">this</span>.adj=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>[V];<br>		<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;adj.length;i++) &#123;<br>			adj[i]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>&lt;Integer&gt;();<br>		&#125;<br>		<br>	&#125;<br>	<br>	<span class="hljs-comment">//获取顶点的数目</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">V</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> V;<br>	&#125;<br>	<span class="hljs-comment">//获取边的数目</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">E</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> E;<br>	&#125;<br>	<br>	<span class="hljs-comment">//往有向图中添加一条边  v-&gt;w</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)</span> &#123;<br>		<span class="hljs-comment">//让顶点w出现在顶点v的邻接表中，因为边是有方向的，最终，顶点v的邻接表中存储的相邻顶点的含义是v到其他顶点</span><br>		adj[v].enqueue(w);<br>		E++;<br>	&#125;<br>	<span class="hljs-comment">//获取由v指出的边所链接的顶点</span><br>	<span class="hljs-keyword">public</span> Queue&lt;Integer&gt; <span class="hljs-title function_">adj</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span>&#123;<br>	<span class="hljs-keyword">return</span> adj[v];<br>	&#125;<br>	<span class="hljs-comment">//获取该图的反向图</span><br>	<span class="hljs-keyword">private</span> Digraph <span class="hljs-title function_">reverse</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">//创建有向图对象</span><br>		Digraph r=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Digraph</span>(V);<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v=<span class="hljs-number">0</span>;v&lt;V;v++) &#123;<br>			<span class="hljs-comment">//获取由该顶点指出的所有边</span><br>			<span class="hljs-keyword">for</span>(Integer w:adj[v]) &#123;<span class="hljs-comment">//原图中表示的是由v-&gt;w得边</span><br>				r.addEdge(w, v);<span class="hljs-comment">//将两个点反向添加，就可以让边都反向</span><br>				<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> r;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>给定一副有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素，此时就可以明 确的表示出每个顶点的优先级。下列是一副拓扑排序后的示意图：</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656866.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220810152031140"></p>
<p><strong>如果有向图中有了环就无法对它进行拓扑排序了</strong></p>
<h4 id="检测有向图中的环"><a href="#检测有向图中的环" class="headerlink" title="检测有向图中的环"></a>检测有向图中的环</h4><p>类名 DirectedCircle</p>
<p>构造方法 DirectedCycle(Digraph G)：创建一个检测环对象，检测图G中是否有环</p>
<p>成员方法</p>
<p>1.private void dfs(Digraph G,int v)：基于深度优先搜索，检测图G中是否有环 </p>
<p>2.public boolean hasCycle():判断图中是否有环</p>
<p>成员变量</p>
<p>1.private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索 </p>
<p>2.private boolean hasCycle: 记录图中是否有环 </p>
<p>3.private boolean[] onStack:索引代表顶点，使用栈的思想，记录当前顶点有没有已经处于正在 搜索的有向路径上</p>
<p>检测的一个步骤</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656867.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220810153510565"></p>
<p>API</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectedCircle</span> &#123;<br><br>	<span class="hljs-comment">//索引代表顶点，值表示当前顶点是否已经被搜索 </span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[] marked;<br>	<span class="hljs-comment">//记录图中是否有环 </span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> hasCycle;<br>	<span class="hljs-comment">//索引代表顶点，使用栈的思想，记录当前顶点有没有已经处于正在 搜索的有向路径上</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[] onStack;<br>	<br>	<span class="hljs-comment">//创建一个检测环对象，检测图G中是否有环</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">DirectedCircle</span><span class="hljs-params">(Digraph G)</span> &#123;<br>		<span class="hljs-comment">//初始化marked数组</span><br>		<span class="hljs-built_in">this</span>.marked=<span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[G.V()];<br>		<span class="hljs-comment">//初始化hasCycle</span><br>		<span class="hljs-built_in">this</span>.hasCycle=<span class="hljs-literal">false</span>;<br>		<span class="hljs-comment">//初始化onStack</span><br>		<span class="hljs-built_in">this</span>.onStack=<span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[G.V()];<br>	 <br>		<span class="hljs-comment">//找到图中每一个顶点，让每一个顶点作为入口，调用一次dfs进行搜索</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v=<span class="hljs-number">0</span>;v&lt;G.V();v++) &#123;<br>			<span class="hljs-comment">//判断如果当前顶点还没有搜索过，则调用dfs进行搜索</span><br>			<span class="hljs-keyword">if</span>(!marked[v]) &#123;<br>				dfs(G,v);<br>			&#125;<br>		&#125;<br><br><br>​		<br>​		<br><br>	&#125;<br>	<span class="hljs-comment">//基于深度优先搜索，检测图G中是否有环 </span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(Digraph G,<span class="hljs-type">int</span> v)</span> &#123;<br>		<span class="hljs-comment">//把顶点v标识为已搜索</span><br>		marked[v]=<span class="hljs-literal">true</span>;<br>		<br>		<span class="hljs-comment">//把当前顶点进栈</span><br>		onStack[v]=<span class="hljs-literal">true</span>;<br>		<span class="hljs-comment">//进行深度搜索</span><br>		<span class="hljs-keyword">for</span>(Integer w:G.adj(v)) &#123;<br>			<span class="hljs-comment">//如果当前结点w没有被搜索过则继续递归调用dfs方法</span><br>			<span class="hljs-keyword">if</span>(!marked[w]) &#123;<br>				dfs(G,w);<br>			&#125;<br>			<br>			<span class="hljs-comment">//判断当前顶点w是否已经在栈中，如果已经在栈中，证明当前顶点之前处于正在搜索的状态，那么现在又要搜索一次，就证明检测到环了</span><br>			<span class="hljs-keyword">if</span>(onStack[w]) &#123;<br>				hasCycle=<span class="hljs-literal">true</span>;<br>				<span class="hljs-keyword">return</span> ;<br>			&#125;<br>			<br>		&#125;<br>		<span class="hljs-comment">//让当前节点出栈</span><br>		onStack[v]=<span class="hljs-literal">false</span>;<br>	&#125;<br>	<span class="hljs-comment">//判断图中是否有环</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> hasCycle;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="顶点排序"><a href="#顶点排序" class="headerlink" title="顶点排序"></a>顶点排序</h4><p>类名：DepthFirstOrder</p>
<p>构造方法 DepthFirstOrder(Digraph G)：创建一个顶点排序对象，生成顶点线性序列；</p>
<p>成员方法：1.private void dfs(Digraph G,int v)：基于深度优先搜索，生成顶点线性序列 </p>
<p>​                    2.public Stack reversePost():获取顶点线性序列</p>
<p>成员变量：1.private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索 </p>
<p>​                   2.private Stack reversePost: 使用栈，存储顶点序列</p>
<p><strong>顶点排序的具体定义去看资料</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DepthFirstOrder</span> &#123;<br>	<span class="hljs-comment">//索引代表顶点，值表示当前顶点是否已经被搜索 </span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[] marked;<br>	<span class="hljs-comment">//使用栈，存储顶点序列</span><br>	<span class="hljs-keyword">private</span> Stack reversePost;<br>	<br><br>	<span class="hljs-comment">//创建一个检测环对象，检测图G中是否有环</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">DepthFirstOrder</span><span class="hljs-params">(Digraph G)</span> &#123;<br>		<span class="hljs-comment">//初始化marked数组</span><br>		<span class="hljs-built_in">this</span>.marked=<span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[G.V()];<br>		<span class="hljs-comment">//初始化reversePost栈</span><br>		<span class="hljs-built_in">this</span>.reversePost=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Integer&gt;();<br>		<br>		<span class="hljs-comment">//让图中的每一个顶点作为一次入口完成深度搜索</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v=<span class="hljs-number">0</span>;v&lt;G.V();v++) &#123;<br>			<span class="hljs-keyword">if</span>(!marked[v]) &#123;<br>				dfs(G,v);<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">//基于深度优先搜索，生成顶点线性序列</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(Digraph G,<span class="hljs-type">int</span> v)</span> &#123;<br>		marked[v]=<span class="hljs-literal">true</span>;<br>		<span class="hljs-keyword">for</span>(Integer w:G.adj(v)) &#123;<br>			<span class="hljs-keyword">if</span>(!marked[w]) &#123;<br>				dfs(G,w);<br>			&#125;<br>		&#125;<br>		<span class="hljs-comment">//让顶点v进栈</span><br>		reversePost.push(v);<br>	&#125;<br>	<span class="hljs-comment">//获取顶点线性序列</span><br>	<span class="hljs-keyword">public</span> Stack <span class="hljs-title function_">reversePost</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> reversePost;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="拓扑排序的实现"><a href="#拓扑排序的实现" class="headerlink" title="拓扑排序的实现"></a>拓扑排序的实现</h4><p>那么拓扑排序就很简单了，基于一幅图，先检测有没有环，如果没有环， 则调用顶点排序即可</p>
<p>类名 TopoLogical </p>
<p>构造方法 TopoLogical(Digraph G)：构造拓扑排序对象 </p>
<p>成员方法 1.public boolean isCycle()：判断图G是否有环 </p>
<p>​                 2.public Stack order():获取拓扑排序的所有顶点 </p>
<p>成员变量 1.private Stack order: 顶点的拓扑排序</p>
<p>API</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TopoLogical</span> &#123;<br>	<span class="hljs-comment">//顶点的拓扑排序</span><br>	<span class="hljs-keyword">private</span> Stack order;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">TopoLogical</span><span class="hljs-params">(Digraph G)</span> &#123;<br>		<span class="hljs-comment">//先检测图中有没有环</span><br>		DirectedCircle circle=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectedCircle</span>(G);<br>		<span class="hljs-comment">//判断G图中有没有环，如果没有环，则进行顶点排序，创建一个顶点排序对象</span><br>		<span class="hljs-keyword">if</span>(!circle.hasCycle()) &#123;<br>		DepthFirstOrder depthFirstOrder=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DepthFirstOrder</span>(G);<br>		order=depthFirstOrder.reversePost();<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">//判断图G是否有环 </span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCycle</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> order==<span class="hljs-literal">null</span>;<br>	&#125;<br>	<span class="hljs-comment">//获取拓扑排序的所有顶点 </span><br>	<span class="hljs-keyword">public</span> Stack <span class="hljs-title function_">order</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> order;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TopLogicalTest</span> &#123;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-comment">//准备有向图</span><br>		Digraph digraph=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Digraph</span>(<span class="hljs-number">6</span>);<br>		digraph.addEdge(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br>		digraph.addEdge(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br>		digraph.addEdge(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>);<br>		digraph.addEdge(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>		digraph.addEdge(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>		digraph.addEdge(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br>		<span class="hljs-comment">//通过TopoLogical对象对有向图中的顶点进行排序</span><br>		TopoLogical topological=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TopoLogical</span>(digraph);<br>		<span class="hljs-comment">//获取顶点的线性序列，进行打印就可以了</span><br>	     Stack&lt;Integer&gt; order=topological.order();<br>	     <span class="hljs-keyword">for</span>(Integer s:order) &#123;<br>	    	 System.out.println(s);<br>	     &#125;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>例子就是这个</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656868.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220810170218646"></p>
<h2 id="加权无向图"><a href="#加权无向图" class="headerlink" title="加权无向图"></a>加权无向图</h2><p>每一条边都有一个权值</p>
<p>两个顶点之间可以有多条路径，可以通过权值来判断最好的路径</p>
<h3 id="加权无向图的表示"><a href="#加权无向图的表示" class="headerlink" title="加权无向图的表示"></a>加权无向图的表示</h3><p>加权无向图的边是用对象来表示的</p>
<p>加权无向图中的边我们就不能简单的使用v-w两个顶点表示了，而必须要给边关联一个权重值，因此我们可以使用 对象来描述一条边。</p>
<p><strong>边的API</strong></p>
<p>类名 Edge implements Comparable<Edge></p>
<p>构造方法 Edge(int v,int w,double weight)：通过顶点v和w，以及权重weight值构造一个边对象 </p>
<p>成员方法 1.public double weight():获取边的权重值 </p>
<p>​                 2.public int either():获取边上的一个点 </p>
<p>​                 3.public int other(int vertex)):获取边上除了顶点vertex外的另外一个顶点 </p>
<p>​                 4.public int compareTo(Edge that)：比较当前边和参数that边的权重，如果当前边权重大，返回 1，如果一样大，返回0，如果当前权重小，返回-1 </p>
<p>成员变量 1.private final int v：顶点一    2.private final int w：顶点二    3.private final double weight：当前边的权重</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Edge</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Edge&gt;&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> v;<span class="hljs-comment">//顶点一</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> w;<span class="hljs-comment">//顶点二</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> weight;<span class="hljs-comment">//权重值</span><br><span class="hljs-comment">//通过顶点v和w，以及权重weight值构成一个边对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Edge</span><span class="hljs-params">(<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w,<span class="hljs-type">double</span> weight)</span> &#123;<br>	<span class="hljs-built_in">this</span>.v=v;<br>	<span class="hljs-built_in">this</span>.w=w;<br>	<span class="hljs-built_in">this</span>.weight=weight;<br>&#125;<br><br><span class="hljs-comment">//获取边的权重值</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">weight</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">return</span> weight;<br>&#125;<br><br><span class="hljs-comment">//获取边上的一个点</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">either</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">return</span> v;<br>&#125;<br><span class="hljs-comment">//获取边上除了顶点vertex外的另外一个顶点</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">other</span><span class="hljs-params">(<span class="hljs-type">int</span> vertex)</span> &#123;<br>	<span class="hljs-keyword">if</span>(vertex==v) &#123;<br>		<span class="hljs-keyword">return</span> w;<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-keyword">return</span> v;<br>	&#125;<br>&#125;<br><span class="hljs-comment">//比较当前边和参数that边的权重，如果当前边权重大，返回 1，如果一样大，返回0，如果当前权重小，返回-1 </span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Edge that)</span> &#123;<br>	<span class="hljs-type">int</span> cmp=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.weight()&gt;that.weight()) &#123;<br>		cmp=<span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.weight()&lt;that.weight()) &#123;<br>		cmp=-<span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		cmp=<span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> cmp;<br>	<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="加权无向图的API"><a href="#加权无向图的API" class="headerlink" title="加权无向图的API"></a>加权无向图的API</h3><p>类名：EdgeWeightedGraph</p>
<p>构造方法 EdgeWeightedGraph(int V)：创建一个含有V个顶点的空加权无向图</p>
<p>成员方法：</p>
<p>1.public int V():获取图中顶点的数量 </p>
<p>2.public int E():获取图中边的数量 </p>
<p>3.public void addEdge(Edge e):向加权无向图中添加一条边e </p>
<p>4.public Queue adj(int v)：获取和顶点v关联的所有</p>
<p>5.public Queue<Edge> edges()：获取加权无向图的所有边</p>
<p>成员变量</p>
<p>1.private final int V: 记录顶点数量 </p>
<p>2.private int E: 记录边数量 </p>
<p>3.private Queue[] adj: 邻接表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EdgeWeightedGraph</span> &#123;<br>	<span class="hljs-comment">//记录顶点数量 </span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> V;<br>	<span class="hljs-comment">//记录边数量 </span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> E;<br>	<span class="hljs-comment">//邻接表</span><br>	<span class="hljs-keyword">private</span> Queue&lt;Edge&gt;[] adj;<br>	<br><br>	<span class="hljs-comment">//创建一个含有V个顶点的空加权无向图</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">EdgeWeightedGraph</span><span class="hljs-params">(<span class="hljs-type">int</span> V)</span> &#123;<br>		<span class="hljs-comment">//初始化顶点的数量</span><br>		<span class="hljs-built_in">this</span>.V=V;<br>		<span class="hljs-comment">//初始化边的数量</span><br>		<span class="hljs-built_in">this</span>.E=<span class="hljs-number">0</span>;<br>		<span class="hljs-comment">//初始化邻接表</span><br>		<span class="hljs-built_in">this</span>.adj=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>[V];<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;adj.length;i++) &#123;<br>			adj[i]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>&lt;Edge&gt;();<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-comment">//获取图中顶点的数量</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">V</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> V;<br>	&#125;<br>	<br>	<span class="hljs-comment">//获取图中边的数量</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">E</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> E;<br>	&#125;<br>	<span class="hljs-comment">//往无向图中添加一条边e</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addEdge</span><span class="hljs-params">(Edge e)</span> &#123;<br>		<span class="hljs-comment">//获取这条边的两个顶点</span><br>		<span class="hljs-type">int</span> v=e.either();<br>		<span class="hljs-type">int</span> w=e.other(v);<br>		adj[v].enqueue(e);<br>		adj[w].enqueue(e);<br>		<br>		<span class="hljs-comment">//边的数量加一</span><br>		E++;<br>	&#125;<br>	<span class="hljs-comment">//获取顶点v所关联的所有边</span><br>	<span class="hljs-keyword">public</span> Queue&lt;Edge&gt; <span class="hljs-title function_">adj</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span>&#123;<br>		<span class="hljs-keyword">return</span> adj[v];<br>	&#125;<br>	<span class="hljs-comment">//获取加权无向图的所有边</span><br>	<span class="hljs-keyword">public</span> Queue&lt;Edge&gt; <span class="hljs-title function_">edges</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">//创建一个队列对象存储所有边</span><br>		Queue&lt;Edge&gt; alledges=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>&lt;&gt;();<br>		<br>		<span class="hljs-comment">//遍历图中的每一个顶点，找到该顶点的邻接表，邻接表中存储了该顶点关联的每一条边</span><br>		<span class="hljs-comment">//因为这是无向图，所以同一条边同时出现在了它关联的两个点的邻接表中，如果按照上述方法会一条边出现两次，需要让一条边只记录一次</span><br>		<span class="hljs-comment">//解决方法就是如果当前结点小于另一个结点的时候才会添加，这样就砍去了一半的情况</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;V;i++) &#123;<br>			<span class="hljs-keyword">for</span>(Edge w:adj[i]) &#123;<br>				<span class="hljs-keyword">if</span>(w.other(i)&lt;i) &#123;<br>					alledges.enqueue(w);<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> alledges;<br>		<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>图的生成树是它的一棵含有其所有顶点的无环连通子图，一副加权无向图的最小生成树它的一棵权值(树中所有边的权重之和)最小的生成树</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656869.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220810191845051"></p>
<h4 id="最小生成树原理"><a href="#最小生成树原理" class="headerlink" title="最小生成树原理"></a>最小生成树原理</h4><p><strong>树的性质</strong></p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656870.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220810192326446"></p>
<p><strong>切分定理</strong></p>
<p>详情见资料</p>
<p><strong>贪心算法</strong></p>
<p>详情见资料</p>
<p><strong>Prim算法</strong></p>
<p>Prim算法的切分规则： 把最小生成树中的顶点看做是一个集合，把不在最小生成树中的顶点看做是另外一个集合。</p>
<p>把红线连着的点看成一个集合，把剩下的点看成一个集合然后用切分算法去找到最小横切边然后标红</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656871.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220810194032229"></p>
<p><strong>prem算法的API设计</strong></p>
<p>类名：PrimMST</p>
<p>构造方法 PrimMST(EdgeWeightedGraph G)：根据一副加权无向图，创建最小生成树计算对象；</p>
<p>成员方法</p>
<p>1.private void visit(EdgeWeightedGraph G, int v)：将顶点v添加到最小生成树中，并且更新数 据 </p>
<p>2.public Queue edges():获取最小生成树的所有边</p>
<p>成员变量：</p>
<p>1.private Edge[] edgeTo: 索引代表顶点，值表示当前顶点和最小生成树之间的最短边 </p>
<p>2.private double[] distTo: 索引代表顶点，值表示当前顶点和最小生成树之间的最短边的权重 </p>
<p>3.private boolean[] marked:索引代表顶点，如果当前顶点已经在树中，则值为true，否则为 false </p>
<p>4.private IndexMinPriorityQueue pq:存放树中顶点与非树中顶点之间的有效横切边</p>
<p><strong>Prim算法的实现原理</strong></p>
<p>详情见资料</p>
<p>最小生成树中的点是一个集合，其他的是一个集合，要往最小生成树中加点，就是找连接两个集合的边的权值最小的那个，把这个边中不属于最小生成树中的顶点加进去</p>
<p><strong>Prim算法的代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> 优先队列.IndexMinPriorityQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrimMST</span> &#123;<br>	<span class="hljs-comment">//索引代表顶点，值表示当前顶点和最小生成树之间的最短边 </span><br>	<span class="hljs-keyword">private</span> Edge[] edgeTo; <br>	<span class="hljs-comment">//索引代表顶点，值表示当前顶点和最小生成树之间的最短边的权重</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">double</span>[] distTo;<br>	<span class="hljs-comment">//索引代表顶点，如果当前顶点已经在树中，则值为true，否则为 false </span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[] marked;<br>	<span class="hljs-comment">//存放树中顶点与非树中顶点之间的有效横切边</span><br>	<span class="hljs-keyword">private</span> IndexMinPriorityQueue pq;<br>	<br><br>	<span class="hljs-comment">//根据一副加权无向图，创建最小生成树计算对象；</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">PrimMST</span><span class="hljs-params">(EdgeWeightedGraph G)</span> &#123;<br>		<span class="hljs-built_in">this</span>.edgeTo=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Edge</span>[G.V()];<br>		<span class="hljs-built_in">this</span>.distTo=<span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[G.V()];<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;distTo.length;i++) &#123;<br>			distTo[i]=Double.POSITIVE_INFINITY;<br>		&#125;<br>		<span class="hljs-built_in">this</span>.marked=<span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[G.V()];<br>		<br>		pq=<span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexMinPriorityQueue</span>&lt;Double&gt;(G.V());<br>		<br>		<span class="hljs-comment">//默认让顶点0进入到树中，但是树中只有一个顶点0，因此零顶点默认没有与其他顶点相连，所以让distTo对应位置的值存储0.0</span><br>		distTo[<span class="hljs-number">0</span>]=<span class="hljs-number">0.0</span>;<br>		pq.insert(<span class="hljs-number">0</span>, <span class="hljs-number">0.0</span>);<br>		<br>		<span class="hljs-comment">//遍历索引最小优先队列，拿到最小的横切边对应的顶点，把该顶点加入到最小生成树中</span><br>		<span class="hljs-keyword">while</span>(!pq.isEmpty()) &#123;<br>			visit(G,pq.delMin());<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-comment">//将顶点v添加到最小生成树中，并且更新数 据 </span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(EdgeWeightedGraph G, <span class="hljs-type">int</span> v)</span><br>	&#123;<br>		<span class="hljs-comment">//把顶点v添加到最小生成树中</span><br>		marked[v]=<span class="hljs-literal">true</span>;<br>		<span class="hljs-comment">//更新数据</span><br>		<span class="hljs-keyword">for</span>(Edge e:G.adj(v)) &#123;<br>			<span class="hljs-comment">//获取e边的另外一个顶点</span><br>			<span class="hljs-type">int</span> w=e.other(v);<br>			<span class="hljs-comment">//判断另外一个顶点是不是已经在树中，如果在树中不做处理，不在树中，更新数据</span><br>			<span class="hljs-keyword">if</span>(marked[w]) &#123;<br>				<span class="hljs-keyword">continue</span>;<br>			&#125;<br>			<br>			<span class="hljs-comment">//判断边e的权重是否小于从w顶点到树中已经存在最小边的权重</span><br>			<span class="hljs-keyword">if</span>(e.weight()&lt;distTo[w]) &#123;<br>				<span class="hljs-comment">//更新数据</span><br>				edgeTo[w]=e;<br>				distTo[w]=e.weight();<br>				<span class="hljs-keyword">if</span>(pq.contains(w)) &#123;<br>					pq.changeItem(w,e.weight());<br>				&#125;<br>				<span class="hljs-keyword">else</span><br>				&#123;<br>					pq.insert(w, e.weight());<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">//获取最小生成树的所有边</span><br>	<span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">edges</span><span class="hljs-params">()</span> &#123;<br>		Queue&lt;Edge&gt; alledges=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>&lt;&gt;();<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;edgeTo.length;i++) &#123;<br>			<span class="hljs-keyword">if</span>(edgeTo[i]!=<span class="hljs-literal">null</span>) &#123;<br>				alledges.enqueue(edgeTo[i]);<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> alledges;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试：</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656872.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20220810205501649"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrimMSTTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span> <span class="hljs-keyword">throws</span> NumberFormatException, IOException &#123;<br>	<span class="hljs-comment">//先创建一个加权无向图</span><br>	BufferedReader br=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;D:\\放乱七八糟\\c.txt&quot;</span>));<br>	<span class="hljs-type">int</span> pointnumbers=Integer.parseInt(br.readLine());<br>	EdgeWeightedGraph G=<span class="hljs-keyword">new</span> <span class="hljs-title class_">EdgeWeightedGraph</span>(pointnumbers);<br>	<span class="hljs-type">int</span> edgenumbers=Integer.parseInt(br.readLine());<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;edgenumbers;i++) &#123;<br>		String []line=br.readLine().split(<span class="hljs-string">&quot; &quot;</span>);<br>	    <span class="hljs-type">int</span> v=Integer.parseInt(line[<span class="hljs-number">0</span>]);<br>	    <span class="hljs-type">int</span> w=Integer.parseInt(line[<span class="hljs-number">1</span>]);<br>	    <span class="hljs-type">double</span> weight=Double.parseDouble(line[<span class="hljs-number">2</span>]);<br>	    <br><br>	    <span class="hljs-comment">//构建加权无向边</span><br>	    Edge edge=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Edge</span>(v,w,weight);<br>	    G.addEdge(edge);<br>	&#125;<br>	<span class="hljs-comment">//创建一个PrimMST对象，计算加权无向图中的最小生成树</span><br>	PrimMST primMST=<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrimMST</span>(G);<br>	<br>	<span class="hljs-comment">//获取最小生成树中的所有边</span><br>	Queue&lt;Edge&gt; edges=primMST.edges();<br>	<br>	<span class="hljs-comment">//遍历打印所有的边</span><br>	<span class="hljs-keyword">for</span>(Edge e:edges) &#123;<br>		<span class="hljs-type">int</span> v=e.either();<br>		<span class="hljs-type">int</span> w=e.other(v);<br>		<span class="hljs-type">double</span> weight=e.weight();<br>		System.out.println(v+<span class="hljs-string">&quot;-&quot;</span>+w+<span class="hljs-string">&quot;::&quot;</span>+weight);<br>	&#125;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>kruskal算法</strong></p>
<p>kruskal算法API设计</p>
<p>类名  KruskalMST</p>
<p>构造方法   KruskalMST(EdgeWeightedGraph G)：根据一副加权无向图，创建最小生成树计算对象；</p>
<p>成员方法    1.public Queue edges():获取最小生成树的所有边</p>
<p>成员变量     1.private Queue mst：保存最小生成树的所有边 </p>
<p>​                     2.private UF_Tree_Weighted uf: 索引代表顶点，使用uf.connect(v,w)可以判断顶点v和顶点w是否在 同一颗树中，使用uf.union(v,w)可以把顶点v所在的树和顶点w所在的树合并 </p>
<p>​                    3.private MinPriorityQueue pq: 存储图中所有的边，使用最小优先队列，对边按照权重进行排序</p>
<p>原理：通过pq对所有边的权重进行排序，然后找到最小的边加入到一个树中，然后再找第二小的边，看这个边的两个点是否在同一个树中，不在则把两个点所在的树连接起来，在就不做处理</p>
<p>每一个顶点在最开始的时候都是一个树，然后用并查集对它进行分组</p>
<p>代码：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> 优先队列.MinPriorityQueue;<br><span class="hljs-keyword">import</span> 树.UF_TREE_WEIGHTED;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">kruskalMST</span> &#123;<br>	<span class="hljs-comment">//保存最小生成树的所有边 </span><br>	<span class="hljs-keyword">private</span> Queue mst;<br>	<span class="hljs-comment">//索引代表顶点，使用uf.connect(v,w)可以判断顶点v和顶点w是否在 同一颗树中，使用uf.union(v,w)可以把顶点v所在的树和顶点w所在的树合并</span><br>	<span class="hljs-keyword">private</span> UF_TREE_WEIGHTED uf ;<br>	<span class="hljs-comment">//存储图中所有的边，使用最小优先队列，对边按照权重进行排序</span><br>	<span class="hljs-keyword">private</span> MinPriorityQueue&lt;Edge&gt; pq;<br>	<br><br>	<span class="hljs-comment">//根据一副加权无向图，创建最小生成树计算对象；</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">kruskalMST</span><span class="hljs-params">(EdgeWeightedGraph G)</span> </span>&#123;<br>		<span class="hljs-comment">//初始化mst</span><br>		mst=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Queue</span>&lt;Edge&gt;();<br>		<span class="hljs-comment">//初始化uf</span><br>		uf=<span class="hljs-keyword">new</span> <span class="hljs-built_in">UF_TREE_WEIGHTED</span>(G.<span class="hljs-built_in">V</span>());<br>		<span class="hljs-comment">//初始化pq</span><br>		pq=<span class="hljs-keyword">new</span> MinPriorityQueue&lt;&gt;(G.<span class="hljs-built_in">E</span>()+<span class="hljs-number">1</span>);<br>		<span class="hljs-comment">//把图中所有的边存储到pq中</span><br>		<span class="hljs-keyword">for</span>(Edge e:G.<span class="hljs-built_in">edges</span>()) &#123;<br>			pq.<span class="hljs-built_in">insert</span>(e);<br>		&#125;<br>		<span class="hljs-comment">//遍历pq队列，拿到最小权重的边进行处理</span><br>		<span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">isEmpty</span>()&amp;&amp;mst.<span class="hljs-built_in">size</span>()&lt;G.<span class="hljs-built_in">V</span>()<span class="hljs-number">-1</span>) &#123;<br>			<span class="hljs-comment">//找到权重最小的边</span><br>			Edge e=pq.<span class="hljs-built_in">delMin</span>();<br>			<span class="hljs-comment">//找到该边的两个顶点</span><br>			<span class="hljs-type">int</span> v=e.<span class="hljs-built_in">either</span>();<br>			<span class="hljs-type">int</span> w=e.<span class="hljs-built_in">other</span>(v);<br>			<span class="hljs-comment">//判断这两个顶点是否已经在同一颗树中，如果在同一颗树中，不对该边做处理，不在一棵树中，则让这两个顶点属于的两棵树合并成一颗树</span><br>			<span class="hljs-keyword">if</span>(uf.<span class="hljs-built_in">connected</span>(v,w)) &#123;<br>				<span class="hljs-keyword">continue</span>;<br>			&#125;<br>			<br>			uf.<span class="hljs-built_in">union</span>(v, w);<br>			<span class="hljs-comment">//让边e进入到mst队列中</span><br>			mst.<span class="hljs-built_in">enqueue</span>(e);<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">//获取最小生成树的所有边</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">edges</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> mst;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="加权有向图"><a href="#加权有向图" class="headerlink" title="加权有向图"></a>加权有向图</h2><p>加权有向图边的表示</p>
<p>类名     DirectedEdge</p>
<p>构造方法        DirectedEdge(int v,int w,double weight)：通过顶点v和w，以及权重weight值构造一个边对象</p>
<p>成员方法        1.public double weight():获取边的权重值 </p>
<p>​                        2.public int from():获取有向边的起点 </p>
<p>​                        3.public int to():获取有向边的终点</p>
<p>成员变量        1.private final int v：起点 </p>
<p>​                       2.private final int w：终点 </p>
<p>​                       3.private final double weight：当前边的权重</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectedEdge</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> v;<span class="hljs-comment">//起点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> w;<span class="hljs-comment">//终点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> weight;<span class="hljs-comment">//当前边的权重</span><br><br><span class="hljs-comment">//通过顶点v和w，以及权重weight值构造一个边对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">DirectedEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w,<span class="hljs-type">double</span> weight)</span> &#123;<br>	<span class="hljs-built_in">this</span>.v=v;<br>	<span class="hljs-built_in">this</span>.w=w;<br>	<span class="hljs-built_in">this</span>.weight=weight;<br>&#125;<br><span class="hljs-comment">//获取边的权重值</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">weight</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">return</span> weight;<br>&#125;<br><br><span class="hljs-comment">//获取有向边的起点</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">from</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">return</span> v;<br>&#125; <br><br><span class="hljs-comment">//获取有向边的终点</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">to</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">return</span> w;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="加权有向图的API"><a href="#加权有向图的API" class="headerlink" title="加权有向图的API"></a>加权有向图的API</h3><p>类名    EdgeWeightedDigraph</p>
<p>构造方法 EdgeWeightedDigraph(int V)：创建一个含有V个顶点的空加权有向图</p>
<p>成员方法</p>
<p>1.public int V():获取图中顶点的数量 </p>
<p>2.public int E():获取图中边的数量 </p>
<p>3.public void addEdge(DirectedEdge e):向加权有向图中添加一条边e </p>
<p>4.public Queue adj(int v)：获取由顶点v指出的所有的边 </p>
<p>5.public Queue edges()：获取加权有向图的所有边</p>
<p>成员变量</p>
<p>1.private final int V: 记录顶点数量 </p>
<p>2.private int E: 记录边数量 </p>
<p>3.private Queue[] adj: 邻接表</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EdgeWeightedDigraph</span> &#123;<br>	<br><br>	<span class="hljs-comment">//记录顶点数量</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> V; <br>	<br>	<span class="hljs-comment">//记录边数量</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> E; <br>	<br>	<span class="hljs-comment">//邻接表</span><br>	<span class="hljs-keyword">private</span> Queue&lt;DirectedEdge&gt;[] adj;<br>	<br>	<span class="hljs-comment">//创建一个含有V个顶点的空加权有向图</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">EdgeWeightedDigraph</span><span class="hljs-params">(<span class="hljs-type">int</span> V)</span>&#123;<br>		<span class="hljs-comment">//初始化顶点数量</span><br>		<span class="hljs-built_in">this</span>.V=V;<br>		<span class="hljs-comment">//初始化边的数量</span><br>		<span class="hljs-built_in">this</span>.E=<span class="hljs-number">0</span>;<br>		<span class="hljs-comment">//初始化邻接表</span><br>		<span class="hljs-built_in">this</span>.adj=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>[V];<br>		<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;adj.length;i++) &#123;<br>			adj[i]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>&lt;DirectedEdge&gt;();<br>		&#125;<br>		<br>	&#125;<br>	<br>	<span class="hljs-comment">//获取图中顶点的数量 </span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">V</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">return</span> V;	<br>	&#125;<br>	<br>	<span class="hljs-comment">//获取图中边的数量 </span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">E</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">return</span> E;<br>&#125;<br><br><span class="hljs-comment">//向加权有向图中添加一条边e </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addEdge</span><span class="hljs-params">(DirectedEdge e)</span> &#123;<br>	<span class="hljs-comment">//边e是有方向的，只需要让e出现在起点的邻接表中即可</span><br>	<span class="hljs-type">int</span> v=e.from();<br>	adj[v].enqueue(e);<br>	E++;<br>&#125;<br><br><span class="hljs-comment">//获取由顶点v指出的所有的边 </span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">adj</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> &#123;<br>	<span class="hljs-keyword">return</span> adj[v];<br>&#125;<br><br><span class="hljs-comment">//获取加权有向图的所有边</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">edges</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//遍历图中的每一个顶点然后得到该顶点的邻接表，遍历得到每一条边添加到队列中</span><br>Queue&lt;DirectedEdge&gt; edges=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>&lt;DirectedEdge&gt;();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v=<span class="hljs-number">0</span>;v&lt;V;v++) &#123;<br>	<span class="hljs-keyword">for</span>(DirectedEdge edge:adj[v]) &#123;<br>		edges.enqueue(edge);<br>	&#125;<br>&#125;<br><span class="hljs-keyword">return</span> edges;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><p>在一副加权有向图中，从顶点s到顶点t的最短路径是所有从顶点s到顶点t的路径中总权重最小的那条路径。</p>
<p>性质： 1.路径具有方向性；</p>
<p>​             2 .权重不一定等价于距离。权重可以是距离、时间、花费等内容，权重最小指的是成本最低 </p>
<p>​             3.只考虑连通图。一副图中并不是所有的顶点都是可达的，如果s和t不可达，那么它们之间也就不存在最短路径， 为了简化问题，这里只考虑连通图。 </p>
<p>​             4.最短路径不一定是唯一的。从一个顶点到达另外一个顶点的权重最小的路径可能会有很多条，这里只需要找出一 条即可</p>
<p><strong>最短路径树： 给定一副加权有向图和一个顶点s，以s为起点的一棵最短路径树是图的一副子图，它包含顶点s以及从s可达的所有顶点。这棵有向树的根结点为s，树的每条路径都是有向图中的一条最短路径。</strong></p>
<p>说白了就是这个树里s顶点到每一个顶点的权重都是最小的</p>
<p>最短路径API设计</p>
<p>类名   DijkstraSP</p>
<p>构造方法   public DijkstraSP(EdgeWeightedDigraph G, int s)：根据一副加权有向图G和顶点s，创建一个计 算顶点为s的最短路径树对象</p>
<p>成员方法    1.private void relax(EdgeWeightedDigraph G, int v)：松弛图G中的顶点v </p>
<p>​                   2.public double distTo(int v):获取从顶点s到顶点v的最短路径的总权重 </p>
<p>​                   3.public boolean hasPathTo(int v):判断从顶点s到顶点v是否可达 </p>
<p>​                   4.public Queue pathTo(int v):查询从起点s到顶点v的最短路径中所有的边</p>
<p>成员变量    1.private DirectedEdge[] edgeTo: 索引代表顶点，值表示从顶点s到当前顶点的最短路径上的最 后一条边 </p>
<p>​                    2.private double[] distTo: 索引代表顶点，值从顶点s到当前顶点的最短路径的总权重 </p>
<p>​                    3.private IndexMinPriorityQueue pq:存放树中顶点与非树中顶点之间的有效横切边</p>
<p><strong>松弛技术</strong></p>
<p>就是比较w点到s点的距离是经过v点更远，还是不经过v直接到s更远</p>
<p>详情见资料</p>
<h4 id="Dijstra算法实现最短路径"><a href="#Dijstra算法实现最短路径" class="headerlink" title="Dijstra算法实现最短路径"></a>Dijstra算法实现最短路径</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> DijkstraSP &#123;<br>	<span class="hljs-comment">//索引代表顶点，值表示从顶点s到当前顶点的最短路径上的最后一条边 </span><br>	<span class="hljs-keyword">private</span> DirectedEdge<span class="hljs-literal">[]</span> edgeTo;<br>	<span class="hljs-comment">//索引代表顶点，值从顶点s到当前顶点的最短路径的总权重</span><br>	<span class="hljs-keyword">private</span> double<span class="hljs-literal">[]</span> distTo;<br>	<span class="hljs-comment">//存放树中顶点与非树中顶点之间的有效横切边</span><br>	<span class="hljs-keyword">private</span> IndexMinPriorityQueue pq;<br>	<span class="hljs-comment">//根据一副加权有向图G和顶点s，创建一个计 算顶点为s的最短路径树对象</span><br>	 public <span class="hljs-constructor">DijkstraSP(EdgeWeightedDigraph G, <span class="hljs-params">int</span> <span class="hljs-params">s</span>)</span> &#123;<br>		 <span class="hljs-comment">//初始化edgeTo</span><br>		 this.edgeTo=<span class="hljs-keyword">new</span> DirectedEdge<span class="hljs-literal">[G.V()]</span>;<br>		 <span class="hljs-comment">//初始化distTo</span><br>		 this.distTo=<span class="hljs-keyword">new</span> double<span class="hljs-literal">[G.V()]</span>;<br>		 <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;distTo.length;i++) &#123;<br>			 distTo<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>=Double.POSITIVE_INFINITY;<br>		 &#125;<br>		 <span class="hljs-comment">//初始化pq</span><br>		 this.pq=<span class="hljs-keyword">new</span> IndexMinPriorityQueue&lt;&gt;(G.<span class="hljs-constructor">V()</span>);<br>		 <br><br>		 <span class="hljs-comment">//找到图G中以顶点s为起点的最短路径</span><br>		 <br>		 <span class="hljs-comment">//默认让顶点s进入到最短路径树中</span><br>		 distTo<span class="hljs-literal">[<span class="hljs-identifier">s</span>]</span>=<span class="hljs-number">0.0</span>;<br>		 pq.insert(s, <span class="hljs-number">0.0</span>);<br>		 <span class="hljs-comment">//遍历pq</span><br>		 <span class="hljs-keyword">while</span>(!pq.is<span class="hljs-constructor">Empty()</span>) &#123;<br>			 relax(G,pq.del<span class="hljs-constructor">Min()</span>);<br>		 &#125;<br>	 &#125;<br>	 <br>	 <span class="hljs-comment">//松弛图G中的顶点v </span><br>	  <span class="hljs-keyword">private</span> void relax(EdgeWeightedDigraph G, <span class="hljs-built_in">int</span> v) &#123;<br>		  <span class="hljs-keyword">for</span>(DirectedEdge edge:<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">G</span>.</span></span>adj(v)) &#123;<br>		  <span class="hljs-comment">//获取到该边中的终点w</span><br>			  <span class="hljs-built_in">int</span> w=edge.<span class="hljs-keyword">to</span><span class="hljs-literal">()</span>;<br>			  <br>			  <span class="hljs-comment">//通过松弛技术，判断从起点s到顶点w的最短路径是否需要从顶点s到顶点v，然后再由顶点v到顶点w</span><br>			  <span class="hljs-keyword">if</span>(dist<span class="hljs-constructor">To(<span class="hljs-params">v</span>)</span>+edge.weight<span class="hljs-literal">()</span>&lt;dist<span class="hljs-constructor">To(<span class="hljs-params">w</span>)</span>) &#123;<br>				  distTo<span class="hljs-literal">[<span class="hljs-identifier">w</span>]</span>=dist<span class="hljs-constructor">To(<span class="hljs-params">v</span>)</span>+edge.weight<span class="hljs-literal">()</span>;<br>				  edgeTo<span class="hljs-literal">[<span class="hljs-identifier">w</span>]</span>=edge;<span class="hljs-comment">//更新数据</span><br>				  <br>				  <span class="hljs-comment">//判断pq中是否已经存在顶点w，如果存在则更新权重，如果不存在则直接添加</span><br>				  <span class="hljs-keyword">if</span>(pq.contains(w)) &#123;<br>					  pq.change<span class="hljs-constructor">Item(<span class="hljs-params">w</span>, <span class="hljs-params">distTo</span>(<span class="hljs-params">w</span>)</span>);<br>				  &#125;<br>				  <span class="hljs-keyword">else</span> &#123;<br>					  pq.insert(w, dist<span class="hljs-constructor">To(<span class="hljs-params">w</span>)</span>);<br>				  &#125;<br>				<br>			  &#125;<br>			  <br>		  &#125;<br>		  <br>	  &#125;<br>	<br>	  <span class="hljs-comment">//获取从顶点s到顶点v的最短路径的总权重 </span><br>	  public double dist<span class="hljs-constructor">To(<span class="hljs-params">int</span> <span class="hljs-params">v</span>)</span>&#123;<br>		  return distTo<span class="hljs-literal">[<span class="hljs-identifier">v</span>]</span>;<br>	  &#125;<br>	  <span class="hljs-comment">//判断从顶点s到顶点v是否可达 </span><br>	  public boolean has<span class="hljs-constructor">PathTo(<span class="hljs-params">int</span> <span class="hljs-params">v</span>)</span> &#123;<br>		  return distTo<span class="hljs-literal">[<span class="hljs-identifier">v</span>]</span>&lt;Double.POSITIVE_INFINITY;<br>	  &#125;<br><br><span class="hljs-comment">//查询从起点s到顶点v的最短路径中所有的边</span><br>	  public Queue&lt;DirectedEdge&gt; path<span class="hljs-constructor">To(<span class="hljs-params">int</span> <span class="hljs-params">v</span>)</span> &#123;<br>		  <span class="hljs-comment">//从顶点s到顶点v是否可达，如果不可达，直接返回null</span><br>		  <span class="hljs-keyword">if</span>(!has<span class="hljs-constructor">PathTo(<span class="hljs-params">v</span>)</span>) &#123;<br>			  return null;<br>		  &#125;<br>		  Queue&lt;DirectedEdge&gt; allEdges=<span class="hljs-keyword">new</span> Queue&lt;&gt;<span class="hljs-literal">()</span>;<br>		  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>			  DirectedEdge e=edgeTo<span class="hljs-literal">[<span class="hljs-identifier">v</span>]</span>;<br>			  <span class="hljs-keyword">if</span>(e==null) &#123;<br>				  break;<br>			  &#125;<br>			  allEdges.enqueue(e);<br>			  v=e.from<span class="hljs-literal">()</span>;<br>		  &#125;<br>	  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试</p>
<p>最小生成树的测试差不多</p>
<h1 id="蓝桥杯准备"><a href="#蓝桥杯准备" class="headerlink" title="蓝桥杯准备"></a>蓝桥杯准备</h1><p>提交题目不能有包名，且类必须要Main类，而且用到别的包的时候要导入</p>
<p>一个可以看数据结构的网站</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/">https://programmercarl.com/</a></p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202212102050123.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20221210205053066"></p>
<p><strong>java基础</strong></p>
<p><strong>跳出两层循环,在两层循环外加上OUT：然后代码处用的是break OUT;    跳出多层循环可以类推</strong></p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">OUT</span>:<br>  for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-keyword">number</span>-<span class="hljs-number">1</span>;i++)&#123;<br>  for(<span class="hljs-built_in">int</span> j=i+<span class="hljs-number">1</span>;j&lt;<span class="hljs-keyword">number</span>;j++)&#123;<br>    <span class="hljs-keyword">if</span>(a[i]+a[j]==<span class="hljs-built_in">sum</span>)&#123;<br>         <span class="hljs-built_in">min</span>=i;<br>        <span class="hljs-built_in">max</span>=j;<br>        break <span class="hljs-keyword">OUT</span>;<br>     &#125;<br><br>    &#125;<br><br>  &#125;<br></code></pre></td></tr></table></figure>



<p><strong>泛型数组对象</strong></p>
<p>泛型的实例化对象不能直接创建</p>
<pre><code class="hljs">//初始化
public SequenceList(int capacity) &#123;
    
    //获取泛型对象的数组
eles=(T[])new Object[capacity];
N=0;
&#125;
</code></pre>
<p><strong>按照key或者value对map排序的方法</strong></p>
<p>Map会根据key的大小来自动排序</p>
<p>因为LinekedHashMap是按照顺序添加的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">compare1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Map.Entry&gt;&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Map.Entry o1,Map.Entry o2)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(o2.getValue())-(<span class="hljs-type">int</span>)(o1.getValue());<span class="hljs-comment">//注意这个地方的()缺一不可</span><br>    &#125;<br><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span>&#123;<br>        Scanner in=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        String a=in.nextLine();<br>        String b[]=a.split(<span class="hljs-string">&quot; &quot;</span>);<br>        Hashtable&lt;String,Integer&gt; c=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>&lt;String,Integer&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;b.length;i++) &#123;<br>            <span class="hljs-keyword">if</span>(c.containsKey(b[i])) &#123;<br>                c.put(b[i],c.get(b[i])+<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                c.put(b[i],<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br><br>        List list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(c.entrySet());<br>        compare1 q=<span class="hljs-keyword">new</span> <span class="hljs-title class_">compare1</span>();<br>        Collections.sort(list,q);<br>        Map sortedMap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>();<span class="hljs-comment">//这个地方必须使用LinkedHashMap</span><br>        <span class="hljs-keyword">for</span>(Iterator it=list.iterator();it.hasNext();) &#123;<br>        Map.Entry entry=(Map.Entry)it.next();<span class="hljs-comment">//这里的迭代器如果加泛型&lt;Iterator&gt;,就不用强制转换了</span><br>         sortedMap.put(entry.getKey(), entry.getValue());<br><br>&#125;<br>        Set h=sortedMap.keySet();<br>        Iterator&lt;String&gt; r=h.iterator();<br>        <span class="hljs-keyword">while</span>(r.hasNext()) &#123;<br>            String i=r.next();<br>            System.out.println(i+<span class="hljs-string">&quot;:&quot;</span>+ sortedMap.get(i));<br>        &#125;<br><br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>用函数法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.Map.Entry;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Compare</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Map.Entry&gt;&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Map.Entry o1,Map.Entry o2)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(o2.getValue())-(<span class="hljs-type">int</span>)(o1.getValue());<br>    &#125;<br><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map <span class="hljs-title function_">getMap</span><span class="hljs-params">(Map unsortedMap)</span> &#123;<br>        List a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(unsortedMap.entrySet());<br>        Compare b=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Compare</span>();<br>         Collections.sort(a,b);<br>        Map sortedMap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>();<span class="hljs-comment">//这里必须是LinkedHashMap</span><br>         <span class="hljs-keyword">for</span>(Iterator it=a.iterator();it.hasNext();) &#123;<br>             Map.Entry entry=(Map.Entry)it.next();<br>             sortedMap.put(entry.getKey(), entry.getValue());<br>         &#125;<br><br>        <span class="hljs-keyword">return</span> sortedMap;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span> &#123;<br>        Scanner in=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        String a=in.nextLine();<br>        String b[]=a.split(<span class="hljs-string">&quot; &quot;</span>);<br>        Hashtable&lt;String,Integer&gt; c=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>&lt;String,Integer&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;b.length;i++) &#123;<br>            <span class="hljs-keyword">if</span>(c.containsKey(b[i])) &#123;<br>                c.put(b[i],c.get(b[i])+<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                c.put(b[i],<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        Map n=getMap(c);<br>        Set i=n.keySet();<br>        Iterator&lt;String&gt; e=i.iterator();<br>        <span class="hljs-keyword">while</span>(e.hasNext()) &#123;<br>            String t=e.next();<br>        System.out.println(t+<span class="hljs-string">&quot;:&quot;</span>+n.get(t));<br><br>        &#125;<br>    &#125;<br><br>&#125;<br>就是java是向下兼容的，如果函数返回类型是Map其实是返回的只要是Map的子类的实例化对象都可以<br>    如果函数的参数类型是Map类型，其实这个参数只要是Map子类的实例化对象都可以<br></code></pre></td></tr></table></figure>

<p>​    </p>
<p>当集合或者Iterator没有泛型的时候，就是很多类似的如果没有泛型获取里面集合里面对象之后，是不能直接调用集合中对象特有的方法的</p>
<p>hashmap.getOrDefault(key,0);          这个意思就是如果map中没有key，就返回0，hashmap.get(key)如果没有key会报错</p>
<p>while(scanner.hasNext()){</p>
<p>&#x2F;&#x2F;用来进行持续的输入</p>
<p>}</p>
<p>用BufferedReader方式实现快读，防止考试中有题目是大量输入</p>
<p>line.split(“ +”)如果有多个空格要分开就用这个+号，是正则表达式</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202212142107025.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20221214210711516"></p>
<p>有些题目，就是求总和的地方最好是用long类型的因为有的时候测试的数据量会比较大</p>
<p><strong>判断一个数是否是完全平方数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isQurt</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br> <span class="hljs-comment">//它是Math.sqrt的返回值是浮点数</span><br> <span class="hljs-type">int</span> b=(<span class="hljs-type">int</span>)Math.sqrt(a);<br><span class="hljs-keyword">if</span>(b*b==a) &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>





<p><strong>日期模拟</strong></p>
<p><strong>本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。</strong></p>
<p>19491949 年的国庆节（ 1010 月 11 日）是星期六。</p>
<p>今年（20122012）的国庆节是星期一。</p>
<p>那么，从建国到现在，有几次国庆节正好是星期日呢？</p>
<p>不要求写出具体是哪些年，只要一个数</p>
<p>这是利用w数组模仿一个月有多少天，根据是否闰年判断二月的天数</p>
<p>用w，y，m，d来模拟日历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-comment">//1:无需package</span><br><br><span class="hljs-comment">//2: 类名必须Main, 不可修改</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> w[]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> y=<span class="hljs-number">1949</span>;<br><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> m=<span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> d=<span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> day=<span class="hljs-number">6</span>；<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    <span class="hljs-keyword">while</span>(y!=<span class="hljs-number">2012</span>||m!=<span class="hljs-number">10</span>||d!=<span class="hljs-number">1</span>)&#123;<br><br>         <span class="hljs-keyword">if</span>(y%<span class="hljs-number">400</span>==<span class="hljs-number">0</span>||(y%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>&amp;&amp;y%<span class="hljs-number">100</span>!=<span class="hljs-number">0</span>))&#123;<br><br>          w[<span class="hljs-number">2</span>]=<span class="hljs-number">29</span>;<br><br>         &#125;<br><br>         <span class="hljs-keyword">else</span><br><br>            w[<span class="hljs-number">2</span>]=<span class="hljs-number">28</span>;<br><br>      <span class="hljs-keyword">if</span>(m==<span class="hljs-number">10</span>&amp;&amp;d==<span class="hljs-number">1</span>&amp;&amp;day==<span class="hljs-number">7</span>)&#123;<br><br>       sum++;<br><br>      &#125;<br><br>      d++;<br><br>      day++;<br><br>      <span class="hljs-keyword">if</span>(day&gt;<span class="hljs-number">7</span>)&#123;<br><br>       day=<span class="hljs-number">1</span>;<br><br>      &#125;<br><br>      <span class="hljs-keyword">if</span>(d&gt;w[m])&#123;<br><br>       d=<span class="hljs-number">1</span>;<br><br>       m++;<br><br>      &#125;<br><br>      <span class="hljs-keyword">if</span>(m&gt;<span class="hljs-number">12</span>)&#123;<br><br>       m=<span class="hljs-number">1</span>;<br><br>       y++;<br><br>      &#125;<br><br>    &#125;<br><br>    System.out.println(sum);<br><br> &#125;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure>





<h2 id="16-基础语法巩固实战"><a href="#16-基础语法巩固实战" class="headerlink" title="16.基础语法巩固实战"></a>16.基础语法巩固实战</h2><p><strong>一</strong></p>
<p>得到了1，3，5三个数字想要得到135步骤是</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>*<span class="hljs-number">10</span>+<span class="hljs-number">1</span>=<span class="hljs-number">1</span><br><span class="hljs-attribute">1</span>*<span class="hljs-number">10</span>+<span class="hljs-number">3</span>=<span class="hljs-number">13</span>,然后<span class="hljs-number">13</span>*<span class="hljs-number">10</span>+<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p>题目：输入一个数，然后对其进行翻转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span> &#123;<br><br>    	 Scanner scanner=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    	 <span class="hljs-comment">//输入要反转的整数</span><br>    	 <span class="hljs-type">int</span> number=scanner.nextInt();<br>    	 <br>    	 <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>    	 <br>    	 <span class="hljs-keyword">while</span>(number&gt;<span class="hljs-number">0</span>) &#123;<br>    		 sum=sum*<span class="hljs-number">10</span>+number%<span class="hljs-number">10</span>;<br>    		 number=number/<span class="hljs-number">10</span>;<br>    	 &#125;<br>    	 <br>    	 System.out.println(sum);<br>    	 <br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span> &#123;<br><br>    	 Scanner scanner=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    	 <span class="hljs-comment">//输入要反转的整数</span><br>    	 <span class="hljs-type">int</span> number=scanner.nextInt();<br>    	 <br>    	 <span class="hljs-comment">//利用字符串反转的方法</span><br>         String reversenumber=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(String.valueOf(number)).reverse().toString();<br>    	 System.out.println(reversenumber);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<p>二.交换值不用变量省掉一个空间</p>
<p>第一种方法</p>
<p>正常交换a和b ：int temp&#x3D;a;      int a&#x3D;b;    int b&#x3D;temp;</p>
<p>省掉空间：a&#x3D;a+b;         b&#x3D;a-b;       a&#x3D;a-b</p>
<p>第二种方法</p>
<p>a&#x3D;a^b ,b&#x3D;a^b ,a&#x3D;a^b</p>
<p>三，获取三个数当中的最大值</p>
<p>第一种方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span> &#123;<br><br>    	 Scanner scanner=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    	 <span class="hljs-type">int</span> a=scanner.nextInt();<br>    	 <span class="hljs-type">int</span> b=scanner.nextInt();<br>    	 <span class="hljs-type">int</span> c=scanner.nextInt();<br>    	 <br>    	<span class="hljs-type">int</span> max=get3Max(a,b,c);<br>    	System.out.println(max);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get3Max</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span> &#123;<br>    	<br>    	<span class="hljs-keyword">if</span>(a&gt;b) &#123;<br>    		<br>    		<span class="hljs-keyword">if</span>(a&gt;c) &#123;<br>    			<span class="hljs-keyword">return</span> a;<br>    		&#125;<br>    		<span class="hljs-keyword">else</span><br>    		&#123;<br>    			<span class="hljs-keyword">return</span> c;<br>    		&#125;<br>    		<br>    	&#125;<br>    	<span class="hljs-keyword">else</span><br>    	&#123;<br>    		<br>    		<span class="hljs-keyword">if</span>(b&gt;c) &#123;<br>    			<span class="hljs-keyword">return</span> b;<br>    		&#125;<br>    		<span class="hljs-keyword">else</span> &#123;<br>    			<span class="hljs-keyword">return</span> c;<br>    		&#125;<br>    		<br>    	&#125;<br><br>    &#125;<br><br><br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<p>第二种方法我就比较熟悉了</p>
<p>就是设立一个最大值max一开始第一个数或者等于0然后把这个max和参与比较的数轮流比较，找到比max大的就赋值给max，最后max就是这些数中的最大值</p>
<p>第三种方法</p>
<p>Math.max(Math.max(a,b),c)来获得三个数的最大值</p>
<h2 id="18-优雅的型号图按"><a href="#18-优雅的型号图按" class="headerlink" title="18.优雅的型号图按"></a>18.优雅的型号图按</h2><p>画实心圆和空心圆</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 排序算法;<br><br><span class="hljs-keyword">import</span> 基础结构.BinaryTree;<br><span class="hljs-keyword">import</span> 基础结构.Queue;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span> &#123;<br><br>    circle(<span class="hljs-number">16</span>);<br>    <br>    circle2(<span class="hljs-number">16</span>);<br>    <br>    &#125;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">circle</span><span class="hljs-params">(<span class="hljs-type">int</span> r)</span> &#123;<br>    <br>    	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y=-r;y&lt;=r;y+=<span class="hljs-number">2</span>) &#123;<br>    		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=-r;x&lt;=r;x++) &#123;<br>    			<br>    			<span class="hljs-keyword">if</span>(x*x+y*y&lt;=r*r) &#123;<br>    				System.out.print(<span class="hljs-string">&quot;*&quot;</span>);<br>    			&#125;<br>    			<span class="hljs-keyword">else</span><br>    			&#123;<br>    				System.out.print(<span class="hljs-string">&quot; &quot;</span>);<br>    			&#125;<br>  			<br><br>    		&#125;<br>    		System.out.println();<br>    	&#125;<br>    	<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">circle2</span><span class="hljs-params">(<span class="hljs-type">int</span> r)</span> &#123;<br>    	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y=-r;y&lt;=r;y+=<span class="hljs-number">2</span>) &#123;<br>    		<br>    		<span class="hljs-type">int</span> x=(<span class="hljs-type">int</span>)Math.sqrt(r*r-y*y);<br>    		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;r-x;i++) &#123;<br>    			System.out.print(<span class="hljs-string">&quot; &quot;</span>);<br>    		&#125;<br>    		<br>    		System.out.print(<span class="hljs-string">&quot;*&quot;</span>);<br>    		<br>             <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>*x;i++) &#123;<br>            	 System.out.print(<span class="hljs-string">&quot; &quot;</span>);<br>             &#125;<br>             System.out.print(<span class="hljs-string">&quot;*&quot;</span>);<br>    		<br>    	System.out.println();	<br>    	&#125;<br>    	<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>爱心的公式</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202212182010089.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20221218201056455"></p>
<p> public static void love() {</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">	<span class="hljs-keyword">for</span>(<span class="hljs-type">double</span> y=<span class="hljs-number">2</span>;y&gt;=-<span class="hljs-number">3</span>;y-=<span class="hljs-number">0.1</span>) &#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">double</span> x=-<span class="hljs-number">4</span>;x&lt;=<span class="hljs-number">4</span>;x+=<span class="hljs-number">0.05</span>) &#123;<br>			<span class="hljs-keyword">if</span>(Math.pow(x*x+y*y-<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)-x*x*y*y*y&lt;=<span class="hljs-number">0</span>) &#123;<br>				System.out.print(<span class="hljs-string">&quot;*&quot;</span>);<br>			&#125;<br>			<span class="hljs-keyword">else</span><br>			&#123;<br>				System.out.print(<span class="hljs-string">&quot; &quot;</span>);<br>			&#125;<br>		&#125;<br>		System.out.println();<br>	&#125;<br>	<br>&#125;<br></code></pre></td></tr></table></figure>

<p>取值没看出来特别的，就是x和y的开头和结尾必须一正一负才行</p>
<h2 id="19"><a href="#19" class="headerlink" title="19"></a>19</h2><p><strong>1.判断一个数的二进制形式有多少个1</strong></p>
<p>Integer类的函数用法</p>
<p>​         int a&#x3D;Integer.bitCount(number) ;           返回number这个long或者int类型数字的二进制数中1的个数</p>
<p>​         int b&#x3D;Integer.toString(a,2)            这是把a这个Integer转换为它二进制数对应得字符串,第二个参数是进制</p>
<p>​         String c&#x3D;  Integer.parseInt(a);           把ca转换为String类型的   </p>
<p>求一个数的二进制数中有多少个1       这些数和1&amp;，不管这个数二进制有多少位和1&amp;除了最后一位其他肯定全是0，最后一位如果是1那么&amp;结果就是1，如果是0那么&amp;结果就是0</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Main&#123;<br><br>  <span class="hljs-keyword">public</span> static void main(String []args) &#123;<br><br>        Scanner <span class="hljs-built_in">scan</span>=new Scanner(System.<span class="hljs-keyword">in</span>);<br><br>       <span class="hljs-built_in">int</span> <span class="hljs-built_in">count</span>=<span class="hljs-built_in">scan</span>.nextInt();<br><br>       <span class="hljs-built_in">int</span> <span class="hljs-keyword">number</span>=<span class="hljs-number">0</span>;<br><br>       <span class="hljs-keyword">while</span>(<span class="hljs-built_in">count</span>&gt;<span class="hljs-number">0</span>) &#123;<br>         //这个括号必须有<br>         <span class="hljs-keyword">if</span>((<span class="hljs-built_in">count</span>&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>) &#123;<br>         <span class="hljs-keyword">number</span>++;<br>        &#125;<br>         <span class="hljs-built_in">count</span>&gt;&gt;=<span class="hljs-number">1</span>;<br>        &#125;<br>       System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">number</span>);<br>       <span class="hljs-built_in">scan</span>.close();<br><br>  &#125;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure>



<p><strong>判断一个数是否为2的幂</strong></p>
<p>输出一下这些2的幂的数的二进制的形式，可以发现规律，2的幂的二进制数只有一个1</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202212182144477.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20221218214428256"></p>
<p>这个例子是没把1当作2的幂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>    <span class="hljs-type">int</span> number=scan.nextInt();<br><br>     <span class="hljs-keyword">if</span>(number==<span class="hljs-number">1</span>)&#123;<br><br>      System.out.println(<span class="hljs-string">&quot;NO&quot;</span>);<br><br>      <span class="hljs-keyword">return</span> ;<br><br>     &#125;<br><br>    <span class="hljs-type">int</span> count=Integer.bitCount(number);<br><br>    <span class="hljs-keyword">if</span>(count==<span class="hljs-number">1</span>)&#123;<br><br>     System.out.println(<span class="hljs-string">&quot;YES&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-keyword">else</span><br><br>    &#123;<br><br>     System.out.println(<span class="hljs-string">&quot;NO&quot;</span>);<br><br>    &#125;<br><br>    scan.close();<br><br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="视频二十进位模拟与数位拆分"><a href="#视频二十进位模拟与数位拆分" class="headerlink" title="视频二十进位模拟与数位拆分"></a>视频二十进位模拟与数位拆分</h2><p>求a和b两个数最后两位的和，获得两位就是a%100,获得最后三位就是a%1000,获得最后一位就是a%10</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202212242031835.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20221224203120330"></p>
<p>求a和b两个数相加进位多少次</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202212242055553.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20221224205519252"></p>
<p>这个if(a&#x3D;&#x3D;0&amp;&amp;b&#x3D;&#x3D;0) break;     不能写在for循环里面，否则会漏掉进位，还有for循环那个次数，如果不够用，可以设置的再大一点</p>
<h2 id="视频二十一最大公约数和最小公倍数"><a href="#视频二十一最大公约数和最小公倍数" class="headerlink" title="视频二十一最大公约数和最小公倍数"></a>视频二十一最大公约数和最小公倍数</h2><p>求两个数的最大公约数</p>
<p>这个是辗转相除法，24 和15的最大公约数是  与15和24%15的最大公约数相同，一直到小的那个值等于0，另一个值就是最大公约数</p>
<p>所以一定要保证a大于b</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202212242134802.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20221224213458683"></p>
<p>求两个数的最小公倍数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>         Scanner scan=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>         <span class="hljs-type">int</span> a=scan.nextInt();<br>         <span class="hljs-type">int</span> b=scan.nextInt();<br>         <br><br>         <span class="hljs-type">int</span> index=gcd(a,b);<br>         System.out.println(lcm(a,b,index));<br><br> &#125;<br><br><br> <span class="hljs-comment">//求最大公约数的方法二</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> &#123;<br>	 <span class="hljs-keyword">return</span> b==<span class="hljs-number">0</span>?a:gcd(b,a%b);<br> &#125;<br><br> <span class="hljs-comment">//这个是算最小公倍数的方法，a，b分别是那两个数，index是他俩的最大公约数</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lcm</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> index)</span> &#123;<br>	 <span class="hljs-comment">//返回的是两个数相乘再除以他俩的最大公约数</span><br>	 <span class="hljs-keyword">return</span> a*b/index;<br> &#125;<br><br> <span class="hljs-comment">//求最大公约数的方法</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd1</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> &#123;<br>	 <span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-type">int</span> temp=a%b;<br>		a=b;<br>		b=temp;<br>	 &#125;<br>	 <span class="hljs-keyword">return</span> a;<br> &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="视频二十二进制理论篇"><a href="#视频二十二进制理论篇" class="headerlink" title="视频二十二进制理论篇"></a>视频二十二进制理论篇</h2><p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202212251936077.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20221225193643897"></p>
<p>圈3和圈4是提供了16进制专二进制，和8转2进制的方法</p>
<p>D是十进制，H是十六进制，B是二进制，O是八进制</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202212251940975.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20221225194006037"></p>
<p>第二个会报错</p>
<h2 id="视频二十三进制实践篇"><a href="#视频二十三进制实践篇" class="headerlink" title="视频二十三进制实践篇"></a>视频二十三进制实践篇</h2><p>判断一个数的12进制，16进制，10进制是否相等</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202212251955901.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20221225195519944"></p>
<p>把数组a当作集合打印a集合的所有子集</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202212252010429.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20221225201043709"></p>
<p>for循环的次数根据集合元素个数来定，有</p>
<h2 id="视频二十四位运算理论篇"><a href="#视频二十四位运算理论篇" class="headerlink" title="视频二十四位运算理论篇"></a>视频二十四位运算理论篇</h2><p>x^x&#x3D;0</p>
<p>x^0&#x3D;x</p>
<p>a^b^c&#x3D;a^c^b&#x3D;b^c^a;</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202212252027875.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20221225202704537"></p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202212252027050.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20221225202711194"></p>
<p>&lt;&lt;是左移，&gt;&gt;是右移</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202303131442535.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20221225203754207"></p>
<p>负数右移，在左边高位补1            负数左移右边低位补0</p>
<p>负数移动的都是补码，移动完事之后得到的也是对应数的补码</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202212252039402.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20221225203932388"></p>
<p>正数左移右移都是补零</p>
<p>-7&gt;&gt;&gt;3     无符号右移    </p>
<p>是指把-7补码右移三位之后，左侧高位用零补，得到的是对应数的源码或者补码都可以（因为得到的一定是正数）</p>
<h2 id="视频二十五位运算实践篇"><a href="#视频二十五位运算实践篇" class="headerlink" title="视频二十五位运算实践篇"></a>视频二十五位运算实践篇</h2><p><strong>输入一个数如果是2的次方，输出yes，否则输出no</strong></p>
<p>一个数如果是2的次方，它的二进制形式大概就是100(4)，1000(8),</p>
<p>这个数如果是2的次方，那么这个数减一的二进制形式大概是011(3),0111(7),所以只要这个数和这个数减一取&amp;为零，这个数就是二的次方</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-keyword">while</span>(scan.hasNext()) &#123;<br>        	<span class="hljs-type">int</span> a=scan.nextInt();<br>        	System.out.println((a&amp;(a-<span class="hljs-number">1</span>))==<span class="hljs-number">0</span>?<span class="hljs-string">&quot;yes&quot;</span>:<span class="hljs-string">&quot;no&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>输入一个数，输出它二进制数中1的个数</strong></p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202301021717872.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20230102171721665"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-keyword">while</span>(scan.hasNext()) &#123;<br>        	<span class="hljs-type">int</span> a=scan.nextInt();<br>        	<span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        	<span class="hljs-keyword">while</span>(a&gt;<span class="hljs-number">0</span>) &#123;<br>        		a=a&amp;(a-<span class="hljs-number">1</span>);<span class="hljs-comment">//做一次就把a最右边的1置为0</span><br>        	    count++;<br>        	&#125;<br>        	System.out.println(count);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<p>输入n，然后再输入2*n-1个数</p>
<p>0^n&#x3D;n,n^n&#x3D;0，所以就一直^就能得到输入这些数中不重复的那个数</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202301021946139.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20230102194614525"></p>
<h2 id="视频26大整数乘法模拟"><a href="#视频26大整数乘法模拟" class="headerlink" title="视频26大整数乘法模拟"></a>视频26大整数乘法模拟</h2><p>a，b是两个字符串，是大数要进行乘法运算</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202301022038949.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20230102203857185"></p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202301022038579.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20230102203848520"></p>
<h2 id="判断一个数是否是质数"><a href="#判断一个数是否是质数" class="headerlink" title="判断一个数是否是质数"></a>判断一个数是否是质数</h2><p>1和0都不是质数</p>
<p>第一种方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br>	<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=a/i;i++) &#123;<br>		<span class="hljs-keyword">if</span>(a%i==<span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>			<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第二种方法</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202301042011641.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20230104201120683"></p>
<h2 id="视频三十埃氏筛法"><a href="#视频三十埃氏筛法" class="headerlink" title="视频三十埃氏筛法"></a>视频三十埃氏筛法</h2><p>判断一个数n，从1到n有多少个素数</p>
<p>就是i是素数，就把2i，3i，4i都当做是素数</p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202301042051847.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20230104205134914"></p>
<h2 id="判断一个数是否是回文数"><a href="#判断一个数是否是回文数" class="headerlink" title="判断一个数是否是回文数"></a>判断一个数是否是回文数</h2><p>把这个数的每一位都放进数组中，然后把最后一位和第一位作比较，倒数第二位和第二位作比较，以此类推，中间如果出现不相等，直接跳出循环，说明不是回文数</p>
<p><strong>蓝桥杯的填空题直接输出答案就可以了，如果把程序也交上去可能会超时</strong></p>
<h2 id="视频四十"><a href="#视频四十" class="headerlink" title="视频四十"></a>视频四十</h2><p>字符’0’的ASCII码是48，字符’1’的ASCII码是49，字符’9’的ASCII码是57</p>
<p>‘9’&#x3D;&#x3D;57是可以判断成功的，两个字符相减，数字减字符或者字符减数字都是ascii码值相减但是最后得到的结果是ascii码值的差值，还是ascii码值的差值对应的字符，取决于你想得到哪个</p>
<p>输入一个英文句子，判断英文句子中有多少个不重复的单词，英文句子中的每个单词中间有一个或者多个空格</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>	 Scanner scan=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>	 <br>	 String juzi=scan.nextLine();<br>	 juzi.trim();<span class="hljs-comment">//去除句子的首尾空格</span><br>	 <br>	 <span class="hljs-comment">//按照空格分开，+可以防止两个单词之间有多个空格</span><br>	 String[]danci=juzi.split(<span class="hljs-string">&quot; +&quot;</span>);<br>	 <span class="hljs-comment">//用set保证单词不重复</span><br>	 Set&lt;String&gt; set=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;String&gt;();<br>	 <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;danci.length;i++) &#123;<br>		 set.add(danci[i]);<br>	 &#125;<br>	 System.out.println(set.size()); <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>	 <span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;192.168.0.1&quot;</span>;<br>	 <span class="hljs-comment">//.在正则表达式中有自己的语义所以要用/.来表示单纯的.</span><br>	 <span class="hljs-comment">//   斜杠\在java字符串中有别的语义所以一个斜杠\要用两个斜杠\\来表示</span><br>	 <span class="hljs-comment">//所以split中的内容应该是//.</span><br>	 String [] ips=ip.split(<span class="hljs-string">&quot;\\.&quot;</span>);<br>	 <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;ips.length;i++) &#123;<br>		 System.out.println(ips[i]);<br>	 &#125; <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="求阶乘"><a href="#求阶乘" class="headerlink" title="求阶乘"></a>求阶乘</h2><p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202303081727189.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20230308172704797"></p>
<p>一个数N的阶乘后面有多少零，决定他2和5因数的个数，这个个数可以通过N&#x2F;K+N&#x2F;K的平方+N&#x2F;K的三次方。。。。（K为2或者5）以此类推，直到一项为零停止，  显然这个个数一定是5的小，所以有多少个零取决于这个数有多少个5的因数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 排序算法;<br><br><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-comment">// 1:无需package</span><br><span class="hljs-comment">// 2: 类名必须Main, 不可修改</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    	<br><br>    	Scanner scan=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">long</span> k=scan.nextLong();<br>    	<br>    	<span class="hljs-type">long</span> l=<span class="hljs-number">0L</span> ;<br>    	<span class="hljs-comment">//9e18是9乘以十的十八次方</span><br>    	<span class="hljs-type">long</span> r=(<span class="hljs-type">long</span>)<span class="hljs-number">9e18</span>;<br><br>    	<span class="hljs-comment">//二分法，因为要找check==k的，所以check&gt;=k条件下要r=mid，而另一个是l=mid+1</span><br>    	<span class="hljs-keyword">while</span>(l&lt;r) &#123;<br>    		<span class="hljs-type">long</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    		<span class="hljs-keyword">if</span>(check(mid)&gt;=k) &#123;<br>    			r=mid;<br>    		&#125;<br>    		<span class="hljs-keyword">else</span><br>    		&#123;<br>    			l=mid+<span class="hljs-number">1</span>;<br>    		&#125;<br>    	&#125;<br>    	<br>    	<span class="hljs-keyword">if</span>(check(l)==k) &#123;<br>    		System.out.println(l);<br>    	&#125;<br>    	<span class="hljs-keyword">else</span><br>    	&#123;<br>    		System.out.println(<span class="hljs-string">&quot;-1&quot;</span>);<br>    	&#125;<br>    	scan.close();<br><br>    &#125;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> <span class="hljs-type">long</span>  <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">long</span> x)</span> &#123;<br>    	<span class="hljs-type">long</span> res=<span class="hljs-number">0</span>;<br>    	<span class="hljs-keyword">while</span>(x&gt;<span class="hljs-number">0</span>) &#123;<br>    		res+=x/<span class="hljs-number">5</span>;<br>    		x=x/<span class="hljs-number">5</span>;<br>    	&#125;<br>    	<span class="hljs-keyword">return</span> res;<br>    &#125;<br>           &#125;<br><br></code></pre></td></tr></table></figure>



<h2 id="最少刷题数"><a href="#最少刷题数" class="headerlink" title="最少刷题数"></a>最少刷题数</h2><p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202303082044424.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20230308204425325"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-comment">// 1:无需package</span><br><span class="hljs-comment">// 2: 类名必须Main, 不可修改</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    	Scanner scan=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-comment">//输入有多少个学生</span><br>        <span class="hljs-type">int</span> count=scan.nextInt();<br>        <span class="hljs-comment">//用来存储每个学生对应的刷题数</span><br>    	<span class="hljs-type">int</span> a[]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[count+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//用来存储从1到100000刷题数分别有多少学生完成</span><br>    	<span class="hljs-type">int</span> cnt[]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">100001</span>];<br>    	<span class="hljs-type">int</span> max=<span class="hljs-number">0</span>;<br>    	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=count;i++) &#123;<br>            <span class="hljs-comment">//完成a数组</span><br>    		a[i]=scan.nextInt();<br>            <span class="hljs-comment">//完成cnt数组</span><br>    		cnt[a[i]]++;<br>            <span class="hljs-comment">//找出最多的刷题数目为max</span><br>    		max=Math.max(max, a[i]);<br>    	&#125;<br>        <span class="hljs-comment">//这就是一个前缀码思想，这样操作得到的cnt数组，cnt[i-1]是刷题小于i的人数，cnt[i]是刷题小于等于i的人数</span><br>        <span class="hljs-comment">//n-cnt[i]是刷题大于i的人数</span><br>    	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=max;i++) &#123;<br>    		cnt[i]=cnt[i-<span class="hljs-number">1</span>]+cnt[i];<br>    	&#125;<br>    <br>        <span class="hljs-comment">//pos是增加某同学刷题数之前的中间值，就是满足刷题数大于i的人小于等于刷题数小于i的人的i的最小值</span><br>    	<span class="hljs-type">int</span> pos=-<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//pos1是增加某同学刷题数之后的中间值</span><br>    	<span class="hljs-type">int</span> pos1=-<span class="hljs-number">1</span>;<br>    	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=max;i++) &#123;<br>    		<br>    		<span class="hljs-keyword">if</span>(cnt[i-<span class="hljs-number">1</span>]&gt;=count-cnt[i]) &#123;<br>    			<span class="hljs-keyword">if</span>(pos==-<span class="hljs-number">1</span>) &#123;<br>    				pos=i;<br>    			&#125;<br>    		&#125;<br>    		<span class="hljs-comment">//这里求pos1 用cnt[i-1]减1是因为，某同学增加了一些刷题数之后从小于pos变成了pos1，所以小于中间值的人数要减1</span><br>    		<span class="hljs-keyword">if</span>(cnt[i-<span class="hljs-number">1</span>]-<span class="hljs-number">1</span>&gt;=count-cnt[i]) &#123;<br>    			<span class="hljs-keyword">if</span>(pos1==-<span class="hljs-number">1</span>) &#123;<br>    				pos1=i;<br>    				<span class="hljs-keyword">break</span>;<br>    			&#125;<br>    		&#125;<br>    		<br>    	&#125;<br> <br>    	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=count;i++) &#123;<br>               	<span class="hljs-comment">//如果这个刷题数大于等于pos就不需要再刷题了</span><br>    		<span class="hljs-keyword">if</span>(a[i]&gt;=pos) &#123;<br>    			System.out.print(<span class="hljs-string">&quot;0 &quot;</span>);<br>    		&#125;<br>            <span class="hljs-comment">//如果刷题数小于pos，就要再刷pos1-a[i]道题，让刷题数变为pos1</span><br>    		<span class="hljs-keyword">else</span><br>    		&#123;<br>    			System.out.print(pos1-a[i]+<span class="hljs-string">&quot; &quot;</span>);<br>    		&#125;<br>    	&#125;<br>           &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="直线"><a href="#直线" class="headerlink" title="直线"></a>直线</h2><p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202303091607921.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20230309160711855"></p>
<p>选用kx+b截距式来表示直线，最方便，能够最好的判断两条直线是否是同一条直线</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 排序算法;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-comment">//1:无需package</span><br><span class="hljs-comment">//2: 类名必须Main, 不可修改</span><br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br> 	<span class="hljs-comment">//用set来存储点，保持了这个不重复性</span><br> 	 Set&lt;Integer&gt; set=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Integer&gt;();<br> 	 <span class="hljs-comment">//用ans这个set类型集合存储直线保证了这个不重复性</span><br> 	 Set&lt;String&gt; ans=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;String&gt;();<br> 	 <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;i++) &#123;<br> 		 <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> m=<span class="hljs-number">0</span>;m&lt;<span class="hljs-number">21</span>;m++) &#123;<br> 			 <span class="hljs-comment">//往set中存储点，用100*i+m是因为，如果直接存储i+m可能会有重复,并且用100*i+m存储方便取出x和y，i对应为x，m对应为y</span><br> 			 set.add(<span class="hljs-number">100</span>*i+m);<br> 		 &#125;<br> 	 &#125;<br> 	 <span class="hljs-comment">//这个list用来存储点，它可以很方便把点取出来</span><br> 	ArrayList&lt;Integer&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(set);<br> 	<span class="hljs-comment">//这里两个for循环遍历，就是把点两两不重复的组合，先取第一个点和后面所有点组合，再取第二个点和后面所有点组合，以此类推</span><br> 	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;list.size();i++) &#123;<br> 		<span class="hljs-comment">//取出一个点</span><br> 		<span class="hljs-type">int</span> a=list.get(i);<br> 		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;list.size();j++) &#123;<br> 			<span class="hljs-comment">//取出第二个点</span><br> 			<span class="hljs-type">int</span> d=list.get(j);<br> 			<span class="hljs-comment">//算出x1，x2，y1，y2，因为存储时用100*x+y存储的，所以要这样取出</span><br> 			<span class="hljs-type">int</span> x1=a/<span class="hljs-number">100</span>;<span class="hljs-type">int</span> x2=d/<span class="hljs-number">100</span>; <span class="hljs-type">int</span> y1=a%<span class="hljs-number">100</span>;<span class="hljs-type">int</span> y2=d%<span class="hljs-number">100</span>;<br> 			<span class="hljs-comment">//斜率k的分子</span><br> 			<span class="hljs-type">int</span> up=y1-y2;<br> 			<span class="hljs-comment">//斜率k的分母</span><br> 			<span class="hljs-type">int</span> down=x1-x2;<br> 			<span class="hljs-comment">//如果down为零这种直线，就用特殊的方式存储(保证不重复存储同一条线)，因为它的k不存在</span><br> 			<span class="hljs-comment">//用x=x1是因为这个里面这个for循环中x1是固定的，都是其他点和x1的点组合，如果x1和两个点组合的直线分别都是down为0的，那这两条直线相同，存储一次即可，所以存储x=x1保证不重复存储同一条直线</span><br> 			<span class="hljs-keyword">if</span>(down==<span class="hljs-number">0</span>) &#123;<br> 				ans.add(<span class="hljs-string">&quot;x =&quot;</span>+x1);<br> 				<span class="hljs-keyword">continue</span>;<br> 			&#125;<br> 			<span class="hljs-comment">//算up和down的最大公约数</span><br> 			<span class="hljs-type">int</span> gcd=gcd(up,down);<br> 			<span class="hljs-comment">//因为k可能除不尽，所以用这种形式表示k，分子分母中间加空格是因为，分母为13分子为1和分子为11分母3这两种情况如果中间没有空格就都是113不符合要求</span><br> 			<span class="hljs-comment">//分子分母除以最大公约数约分，保证ans中不会存储相同直线</span><br> 			String k=up/gcd+<span class="hljs-string">&quot; &quot;</span>+down/gcd;<br> 			<br> 		    <span class="hljs-type">int</span> ky=y1*down-up*x1;<br> 		    <span class="hljs-type">int</span> kx=down;<br> 		    <span class="hljs-type">int</span> gcd2=gcd(ky,kx);<br> 		    <span class="hljs-comment">//求b，b也是分子+分母这种形式，加空格原因和上面一样，分子分母约分原因也是一样</span><br> 		    String b=ky/gcd2+<span class="hljs-string">&quot; &quot;</span>+kx/gcd2;<br> 		    ans.add(k+<span class="hljs-string">&quot; &quot;</span>+b);<br> 		&#125;<br> 	&#125;<br> 	<span class="hljs-comment">//输出ans中直线数量</span><br> 	System.out.println(ans.size());<br><br>&#125;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> &#123;<br>	 <span class="hljs-keyword">return</span> b==<span class="hljs-number">0</span>?a:gcd(b,a%b);<br> &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="卡片"><a href="#卡片" class="headerlink" title="卡片"></a>卡片</h2><p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202303091638348.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20230309163802287"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 排序算法;<br><br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-comment">//1:无需package</span><br><span class="hljs-comment">//2: 类名必须Main, 不可修改</span><br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>	<span class="hljs-comment">//用数组存储0~9卡片的个数，0号位存储0卡片个数，1号位存储1卡片个数，一直存储到9卡片</span><br> 	<span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a[]= &#123;<span class="hljs-number">2021</span>,<span class="hljs-number">2021</span>,<span class="hljs-number">2021</span>,<span class="hljs-number">2021</span>,<span class="hljs-number">2021</span>,<span class="hljs-number">2021</span>,<span class="hljs-number">2021</span>,<span class="hljs-number">2021</span>,<span class="hljs-number">2021</span>,<span class="hljs-number">2021</span>&#125;;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//不断用卡片组成1，2，3，4，以此类推，直到check返回0的时候说明这个i这个数无法组成，所以输出i-1</span><br> 	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;;i++) &#123;<br> 	<br> 		<span class="hljs-keyword">if</span>(check(i)==<span class="hljs-number">0</span>) &#123;<br> 			System.out.println(i-<span class="hljs-number">1</span>);<br> 			<span class="hljs-keyword">break</span>;<br> 		&#125;<br> 		<br> 		<br> 	&#125;<br>	 <br> <br>&#125;<br> <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> &#123;<br>	<span class="hljs-comment">//一直取c的最低位，取到之后从数组中扣除对应的卡片，直到有一个卡片槽为零，返回0，如果所有卡片槽一直大于零，就返回1</span><br>	 <span class="hljs-keyword">while</span>(c&gt;<span class="hljs-number">0</span>) &#123;<br>		 <span class="hljs-type">int</span> b=c%<span class="hljs-number">10</span>;<br>		 <span class="hljs-keyword">if</span>(a[b]&gt;<span class="hljs-number">0</span>) &#123;<br>			 a[b]--;<br>		 &#125;<br>		 <span class="hljs-keyword">else</span><br>		 &#123;<br>			 <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		 &#125;<br>		 c=c/<span class="hljs-number">10</span>;<br>	 &#125;<br>	 <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br> &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h2 id="货物摆放"><a href="#货物摆放" class="headerlink" title="货物摆放"></a>货物摆放</h2><p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202303091711101.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20230309171101130"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 排序算法;<br><br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-comment">//1:无需package</span><br><span class="hljs-comment">//2: 类名必须Main, 不可修改</span><br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;	<br><br>		<span class="hljs-type">int</span> maxn=<span class="hljs-number">1000</span>;<br>		<span class="hljs-comment">//a数组保存b(输入)的因数,大概是不到1000个因数，所以建立数组大小是1000</span><br>		<span class="hljs-type">long</span> a[]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[maxn];<br>		<span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;<br>		<span class="hljs-comment">//输入的数</span><br>		<span class="hljs-type">long</span> b=<span class="hljs-number">2021041820210418L</span>;<br>		<span class="hljs-comment">//获取b的因数，如果i是因数，只要b%i!=i,b%i也就是b的因数，所以只需要检查i&lt;根号b的i</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> i=<span class="hljs-number">1</span>;i*i&lt;b;i++) &#123;<br>			<span class="hljs-keyword">if</span>(b%i==<span class="hljs-number">0</span>) &#123;<br>				a[len++]=i;<br>				<span class="hljs-keyword">if</span>(b/i!=i) &#123;<br>					a[len++]=b/i;<br>				&#125;<br>			&#125;<br>			<br>		&#125;<br>		<span class="hljs-comment">//三个for循环一次取三个因数组合测试看相乘是不是等于b</span><br>		<span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++) &#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;len;j++) &#123;<br>				<span class="hljs-comment">//如果前两个数相乘就大于b了，直接进入下次循环就可以了，不用再乘第三个数了</span><br>				<span class="hljs-keyword">if</span>(a[i]*a[j]&gt;b) &#123;<br>					<span class="hljs-keyword">continue</span>;<br>				&#125;<br>				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> m=<span class="hljs-number">0</span>;m&lt;len;m++) &#123;<br>					<span class="hljs-comment">//如果三个因数相乘为b，count++;</span><br>					<span class="hljs-keyword">if</span>(a[i]*a[j]*a[m]==b) &#123;<br>					count++;	<br>					&#125;<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-comment">//最后输出count</span><br>		System.out.println(count);<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="时间显示"><a href="#时间显示" class="headerlink" title="时间显示"></a>时间显示</h2><p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202303131442536.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20230313085721502"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">import</span> java.util.HashSet;<br><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-comment">//1:无需package</span><br><br><span class="hljs-comment">//2: 类名必须Main, 不可修改</span><br><br><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br><br>  <span class="hljs-comment">//输入毫秒数</span><br><br>  Scanner scan=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>  <span class="hljs-type">long</span> data=scan.nextLong();<br><br>  <span class="hljs-comment">//将毫秒数转换为秒数</span><br><br>  <span class="hljs-type">long</span> data2=data/<span class="hljs-number">1000</span>;<br><br>  <span class="hljs-comment">//n是除去能凑成一天的秒数之后剩下的秒数</span><br><br>  <span class="hljs-type">long</span> n=data2%(<span class="hljs-number">24</span>*<span class="hljs-number">60</span>*<span class="hljs-number">60</span>);<br><br>  <span class="hljs-comment">//输出小时</span><br><br>  System.out.printf(<span class="hljs-string">&quot;%02d:&quot;</span>,n/<span class="hljs-number">3600</span>);<br><br>  <span class="hljs-comment">//输出分钟，n/60是为了看这些秒数总共能有多少分钟然后在对60取模就是除去那些能凑成小时的分钟最后得到的就是对应的分钟</span><br><br>  System.out.printf(<span class="hljs-string">&quot;%02d:&quot;</span>, n/<span class="hljs-number">60</span>%<span class="hljs-number">60</span>);<br><br>  <span class="hljs-comment">//输出秒数</span><br><br>   <span class="hljs-comment">//%02d是占位符，占两位，不够两位用0补</span><br><br>  <span class="hljs-comment">//%2d也是占位符，占两位，不够的话会留出空位</span><br><br>  System.out.printf(<span class="hljs-string">&quot;%02d&quot;</span>, n%<span class="hljs-number">60</span>);<br> &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="最少砝码"><a href="#最少砝码" class="headerlink" title="最少砝码"></a>最少砝码</h2><p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202303131442537.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20230313144126496"></p>
<p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202303130937371.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20230313093724877"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">import</span> java.util.HashSet;<br><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-comment">//1:无需package</span><br><br><span class="hljs-comment">//2: 类名必须Main, 不可修改</span><br><br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br><br>       Scanner scan=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>        <span class="hljs-comment">//输入一个数</span><br><br>        <span class="hljs-type">long</span> data=scan.nextLong();<br><br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> curr=<span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">//直到sum大于data停止循环，sum就是3的零次方加3的1次方加3的2次方以此类推</span><br><br>        <span class="hljs-keyword">while</span>(sum&lt;data) &#123;<br><br>         sum+=Math.pow(<span class="hljs-number">3</span>,curr);<br><br>         curr++;<br><br>        &#125;<br><br>        System.out.println(curr);<br><br> &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="寻找2020"><a href="#寻找2020" class="headerlink" title="寻找2020"></a>寻找2020</h2><p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202303131442538.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20230313111314389"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.FileNotFoundException;<br><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">import</span> java.util.HashSet;<br><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-comment">//1:无需package</span><br><br><span class="hljs-comment">//2: 类名必须Main, 不可修改</span><br><br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>	 <span class="hljs-comment">//记事本中能看到行数是300</span><br>     String []str=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">300</span>];       <br>     <span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;<br>	 <span class="hljs-keyword">try</span> &#123;<br>		         <span class="hljs-comment">//读取2020.txt</span><br>				 Scanner scan=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;C:\\Users\\#赵梓皓&amp;\\Desktop\\2020.txt&quot;</span>));<br>				 <span class="hljs-comment">//判断是否有下一行，读取下一行</span><br>				 <span class="hljs-keyword">while</span>(scan.hasNextLine()) &#123;<br>				   <span class="hljs-comment">//也可以通过这个n来判断有多少行</span><br>					 str[n++]=scan.nextLine();<br>				 &#125;<br>			&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>				<span class="hljs-comment">// TODO Auto-generated catch block</span><br>				e.printStackTrace();<br>			&#125;<br>	 <br><br>	 <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>	 <span class="hljs-comment">//遍历行</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">300</span>;i++) &#123;<br>		<span class="hljs-comment">//遍历列</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;str[i].length();j++) &#123;<br>			<span class="hljs-comment">//如果这个数是2满足条件接着判断</span><br>			<span class="hljs-keyword">if</span>(str[i].charAt(j)==<span class="hljs-string">&#x27;2&#x27;</span>) &#123;<br>				<span class="hljs-comment">//这个是判断当前遍历那个数所在那一列的四个能否满足2020</span><br>				<span class="hljs-keyword">if</span>(j+<span class="hljs-number">3</span>&lt;str[i].length()&amp;&amp;str[i].charAt(j+<span class="hljs-number">1</span>)==<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;str[i].charAt(j+<span class="hljs-number">2</span>)==<span class="hljs-string">&#x27;2&#x27;</span>&amp;&amp;str[i].charAt(j+<span class="hljs-number">3</span>)==<span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>				ans++;	<br>				&#125;<br>				<span class="hljs-comment">//这个是判断当前遍历那个数所在那一行的四个能否满足2020</span><br>				<span class="hljs-keyword">if</span>(i+<span class="hljs-number">3</span>&lt;<span class="hljs-number">300</span>&amp;&amp;str[i+<span class="hljs-number">1</span>].charAt(j)==<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;str[i+<span class="hljs-number">2</span>].charAt(j)==<span class="hljs-string">&#x27;2&#x27;</span>&amp;&amp;str[i+<span class="hljs-number">3</span>].charAt(j)==<span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>					ans++;<br>				&#125;<br>			    <span class="hljs-comment">//这个是判断当前遍历那个数所在那一45度斜线的四个能否满足2020</span><br>				<span class="hljs-keyword">if</span>(i+<span class="hljs-number">3</span>&lt;<span class="hljs-number">300</span>&amp;&amp;j+<span class="hljs-number">3</span>&lt;str[i].length()&amp;&amp;str[i+<span class="hljs-number">1</span>].charAt(j+<span class="hljs-number">1</span>)==<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;str[i+<span class="hljs-number">2</span>].charAt(j+<span class="hljs-number">2</span>)==<span class="hljs-string">&#x27;2&#x27;</span>&amp;&amp;str[i+<span class="hljs-number">3</span>].charAt(j+<span class="hljs-number">3</span>)==<span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>					ans++;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">//最后输出满足条件的个数</span><br>	System.out.println(ans);<br><br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>









<h2 id="蛇形填数"><a href="#蛇形填数" class="headerlink" title="蛇形填数"></a>蛇形填数</h2><p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202303131528491.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20230313152837434"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">package</span> 排序算法;<br><br><span class="hljs-keyword">import</span> java.io.FileNotFoundException;<br><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">import</span> java.util.HashSet;<br><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-comment">//1:无需package</span><br><br><span class="hljs-comment">//2: 类名必须Main, 不可修改</span><br><br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>	<br><br>	 <span class="hljs-comment">//ans是模拟的数字，每次循环加1，一开始为1是因为当r=20，c=20的时候没有加1</span><br>	 <span class="hljs-comment">//r是行号，c是列号</span><br><br><span class="hljs-type">int</span> r=<span class="hljs-number">1</span>; <span class="hljs-type">int</span> c=<span class="hljs-number">1</span>; <span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;<br><span class="hljs-comment">//当行和列同时为20的时候停止循环</span><br><span class="hljs-keyword">while</span>(r!=<span class="hljs-number">20</span> || c!=<span class="hljs-number">20</span>) &#123;<br>	<span class="hljs-comment">//第一行时奇数列会直接向右移动一个，偶数列向左下移动</span><br>	<span class="hljs-keyword">if</span>(r==<span class="hljs-number">1</span>) &#123;<br>		<span class="hljs-keyword">if</span>(c%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>) &#123;<br>			c++;<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			r++;c--;<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">//第一列时，奇数行向右上移动，偶数行向下移动</span><br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-number">1</span>) &#123;<br>		<span class="hljs-keyword">if</span>(r%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) &#123;<br>			r++;<br>		&#125;<br>		<span class="hljs-keyword">else</span><br>		&#123;<br>			r--;<br>			c++;<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">//既不是第一列也不是第一行的当行列号加起来时偶数向右上移动，当行列号加起来是奇数向坐下移动</span><br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-keyword">if</span>((r+c)%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) &#123;<br>			r--;<br>			c++;<br>		&#125;<br>		<span class="hljs-keyword">else</span><br>		&#123;<br>			r++;<br>			c--;<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">//每次循环加1模拟我们要得到的数字</span><br>		<br>ans++;<br><br>&#125;<br><br>System.out.println(ans);<br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<h2 id="成绩分析"><a href="#成绩分析" class="headerlink" title="成绩分析"></a>成绩分析</h2><p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202303140943692.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20230314094324336"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-comment">// 1:无需package</span><br><span class="hljs-comment">// 2: 类名必须Main, 不可修改</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    <span class="hljs-type">int</span> count=scan.nextInt();<br>    <span class="hljs-type">int</span> max=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> min=<span class="hljs-number">100</span>;<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;count;i++)&#123;<br>       <span class="hljs-type">int</span> a=scan.nextInt();<br>       <span class="hljs-keyword">if</span>(a&gt;max)&#123;<br>        max=a;<br>       &#125;<br>       <span class="hljs-keyword">if</span>(a&lt;min)&#123;<br>        min=a;<br>       &#125;<br>      sum+=a;<br>    &#125;<br>  System.out.println(max);<br><br>  System.out.println(min);<br><br><span class="hljs-comment">//保留两位小数，把1.0*sum是把后面这个数转换为double形式，才能以%.2f输出</span><br>  System.out.printf(<span class="hljs-string">&quot;%.2f&quot;</span>,(<span class="hljs-number">1.0</span>*sum)/count);<br><br>    scan.close();<br><br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="不同子串"><a href="#不同子串" class="headerlink" title="不同子串"></a>不同子串</h2><p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202303141111657.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20230314111157680"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 排序算法;<br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">import</span> java.util.TreeSet;<br><span class="hljs-comment">//1:无需package</span><br><span class="hljs-comment">//2: 类名必须Main, 不可修改</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <br>	 <br><br>	 <span class="hljs-comment">//用set来存储子串，保证不重复</span><br>	 TreeSet&lt;String&gt; set=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;String&gt;();<br>	 <br>	 String s=<span class="hljs-string">&quot;0100110001010001&quot;</span>;<br>	 <span class="hljs-comment">//两个for循环遍历s的所有子串</span><br>	 <span class="hljs-comment">//i表示子串起点</span><br>	 <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++) &#123;<br>		 <span class="hljs-comment">//j表示子串终点</span><br>		 <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;s.length();j++) &#123;<br>			 StringBuilder t=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>	        <span class="hljs-comment">//得到对应的子串</span><br>			 <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i;k&lt;=j;k++) &#123;<br>				 t.append(s.charAt(k));<br>			 &#125;<br>			 <span class="hljs-comment">//将子串加入到set中</span><br>			 set.add(t.toString());<br>		 &#125;<br>	 &#125;<br>	 <span class="hljs-comment">//输出set中元素的个数</span><br>	 System.out.println(set.size());<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h2><p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202303161521502.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20230316152119607"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-comment">// 1:无需package</span><br><br><span class="hljs-comment">// 2: 类名必须Main, 不可修改</span><br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>​    <span class="hljs-type">Scanner</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>​    <span class="hljs-comment">//在此输入您的代码...</span><br><br>​    <span class="hljs-type">int</span> n=scan.nextInt();<span class="hljs-comment">//输入行数n</span><br><br>​    <span class="hljs-type">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<span class="hljs-comment">//存储数字三角形的二维数组，n+1行n+1列</span><br><br>​    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//因为是从数组下标为1开始存储，表示第一行，1到n有n个数字，一共存储n行</span><br><br>​     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<span class="hljs-comment">//每列小于等于当前列的行数，例如第二行有两列，第三行有三列</span><br><br>​      arr[i][j]=scan.nextInt();<br><br>​     &#125;<br><br>​    &#125;<br><br>​    <span class="hljs-comment">//求到每个数字路径的最大值，然后赋值给到这个数字</span><br><br>​    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><br>​     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br><br>​     <span class="hljs-comment">//按照题目的说法：路径上的每一步只能从一个数走到下一层和它最近的左边的那个数或者右边的那个数。</span><br><br>​     <span class="hljs-comment">//那求最大值则是当前数字加上它上一层的左边的数字或右边的数字，就看哪边的数字大</span><br><br>​     <span class="hljs-comment">//用数组描述上一层左边的数字就是当前数字的上一层前一列，上一层右边数字的话就是当前数字的上一层当前列。</span><br><br>​      arr[i][j]=arr[i][j]+Math.max(arr[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>], arr[i-<span class="hljs-number">1</span>][j]);<br><br>​     &#125;<br><br>​    &#125;<br><br>​    <span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br><br>​     <span class="hljs-comment">//因为定义的数组是n+1行n+1列,所以行数n直接就是最后一行了</span><br><br>​     <span class="hljs-comment">//因为题目中说到向左下走的次数与向右下走的次数相差不能超过1。</span><br><br>​     <span class="hljs-comment">//意思就是无论如何我们最后到达的数字都是最后一行的中间数。</span><br><br>​     <span class="hljs-comment">//偶数行则必是最后一行中间两个数，看一下谁大谁小进行输出</span><br><br>​     System.out.println(Math.max(arr[n][n/<span class="hljs-number">2</span>],arr[n][n/<span class="hljs-number">2</span> + <span class="hljs-number">1</span>]));<br><br>​    &#125;<span class="hljs-keyword">else</span>&#123;<br><br>​     <span class="hljs-comment">//奇数行中间数就是n/2 + 1 </span><br><br>​     System.out.println(arr[n][n/<span class="hljs-number">2</span> + <span class="hljs-number">1</span>]);<br><br>​    &#125;<br><br>​    scan.close();<br><br>  &#125;<br><br><br><br>  <br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="空间"><a href="#空间" class="headerlink" title="空间"></a>空间</h2><p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202303161612211.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20230316161216300"></p>
<h2 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h2><p><img src="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202303201104607.png" srcset="https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209301019837.jpeg" lazyload alt="image-20230320110448019"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><br><br><br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sc.nextInt();<br><br><br><br>   <span class="hljs-comment">//定义一个数组</span><br><br>    Long [] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Long</span>[n];<br><br><br><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0l</span>;<br><br>    <span class="hljs-comment">//对数组赋值</span><br><br>    <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; arr.length ; i++ )&#123;<br><br>      arr[i] = sc.nextLong();<br><br>      sum += arr[i]; <span class="hljs-comment">//对数组求和</span><br><br>    &#125;<br><br><br><br>    <span class="hljs-comment">//结果</span><br><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0l</span>;<br><br>    <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; arr.length - <span class="hljs-number">1</span> ; i++ )&#123;<br><br>      <span class="hljs-comment">//依次减去当前索引所指的数</span><br><br>      sum -= arr[i];<br><br>      <span class="hljs-comment">//累加求和</span><br><br>      res += sum * arr[i];<br><br>    &#125;<br><br><br><br>    System.out.println(res);<br><br><br><br>  &#125;<br><br>&#125;<br><br><br><br><span class="hljs-comment">//考察了数学知识，重点是将数学语言转换成编程语言</span><br><br><br><br><span class="hljs-comment">//假如有5个数：a0,a1,a2,a3,a4</span><br><br><span class="hljs-comment">//求解：</span><br><br><span class="hljs-comment">//   sum0 = a0 + a1 + a2 + a3 + a4</span><br><br><span class="hljs-comment">//   用乘法分配律进行分组求和</span><br><br><span class="hljs-comment">//   sum1 = ( a1 + a2 + a3 + a4 ) * a0 = (sum0 - a0        ) * a0</span><br><br><span class="hljs-comment">//   sum2 = (   a2 + a3 + a4 ) * a1 = (sum0 - a0 - a1      ) * a1</span><br><br><span class="hljs-comment">//   sum3 = (      a3 + a4 ) * a2 = (sum0 - a0 - a1 - a2   ) * a2</span><br><br><span class="hljs-comment">//   sum4 = (        a4 ) * a3 = (sum0 - a0 - a1 - a2 - a3 ) * a3</span><br><br><span class="hljs-comment">//   res = sum1 + sum2 + sum3 + sum4</span><br><br><br><br><span class="hljs-comment">//可以看到非常的有规律</span><br><br><span class="hljs-comment">//我们求出数组的和(sum)后，在遍历求和时，依次减去当前索引所指的数，再与这个被减的数相乘</span><br><br><br><br><span class="hljs-comment">//用常规方法，双重for循环遍历数组，时间复杂度为 O(n2)。显然，只能拿30％的分</span><br><br><span class="hljs-comment">//如果运用些数学知识，只用一个for循环即可完成求解，时间复杂度为 O(n)</span><br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>数据结构与算法</div>
      <div>http://example.com/2022/09/29/数据结构与算法/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>September 29, 2022</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/09/29/vue2/" title="vue2">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">vue2</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/09/29/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE/" title="瑞吉外卖项目">
                        <span class="hidden-mobile">瑞吉外卖项目</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Table of Contents</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    
      <script  src="/js/img-lazyload.js" ></script>
    
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
