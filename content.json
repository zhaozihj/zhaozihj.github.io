{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"标题","date":"2022-09-29T15:18:19.000Z","updated":"2022-09-30T03:20:40.179Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"​ ​ 以一灌之的努力，不可懈怠的人生 ​ ​ 努力是奇迹的别名"},{"title":"example","date":"2022-09-30T03:23:42.000Z","updated":"2022-09-30T03:27:44.080Z","comments":false,"path":"example/index.html","permalink":"http://example.com/example/index.html","excerpt":"","text":"12312312"}],"posts":[{"title":"mybatis","slug":"mybatis","date":"2022-11-04T15:31:35.000Z","updated":"2022-11-04T02:59:46.599Z","comments":true,"path":"2022/11/04/mybatis/","link":"","permalink":"http://example.com/2022/11/04/mybatis/","excerpt":"","text":"MybatisJDBC代码冗长，维护不易，所以有了mybatis去封装了JDBC的框架 特点：sql和java分开，功能边界清晰 搭建mybatisIDE：idea 2019.2 构建工具：maven 3.5.4 mysql版本：Mysql 8 MyBatis版本:Mybatis 3.5.7 MySQL 5版本使用jdbc5驱动，驱动类使用：com.mysql.jdbc.Driver MySQL 8版本使用jdbc8驱动，驱动类使用：com.mysql.cj.jdbc.Driver 2、连接地址url MySQL 5版本的url： jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ssm MySQL 8版本的url： jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ssm?serverTimezone&#x3D;UTC 创建Maven工程创建Maven工程的时候 第二个就是那个模块的名字 其他的可以在maven.pdf中看到 然后在pom.xml中加入 123456789101112131415161718192021&lt;dependencies&gt; &lt;!-- Mybatis核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; **创建一个t_user表 ** 创建一个这个表对应的对象 User 创建Mybatis的核心配置文件习惯上命名为mybatis-config.xml，这个是自己命名的，不一定非要是这个 这个核心配置文件是用来连接数据库的和Mybatis的全局信息 放在resoures文件夹中，resources文件夹就是存放配置文件的 文件内容 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--设置连接数据库的环境--&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--驱动--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;!--url--&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC&quot;/&gt; &lt;!--数据库的用户名和密码--&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--引入映射文件--&gt; &lt;mappers&gt; &lt;package name=&quot;mappers/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 创建Mapper接口和映射文件Mapper接口其实就是以前的dao，但dao有接口还有实现类，Mapper接口不需要我们提供实现类 当我们调用Mapper接口的一个方法，就会直接对应一个sql语句来执行 在mapper包里创建UserMapper 12345678package com.atguigu.mybatis.mapper;public interface UserMapper &#123; int insertUser();&#125; 1、映射文件的命名规则： 表所对应的实体类的类名+Mapper.xml 例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml 用处：Mybatis映射文件就是针对一个mapper接口中的方法的实现，也就是sql语句的编写，进行一个javabean类和数据库中一个表中数据的交互 把UserMapper.xml映射文件放在resources下的mappers下 mapper接口的全类名和映射文件的命名空间（namespace）保持一致 mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--这个namespace要和Mapper接口的全类名相同--&gt;&lt;mapper namespace=&quot;com.atguigu.mybatis.mapper.UserMapper&quot;&gt; &lt;!--insert标签说明是插入语句，id要和mapper接口中对应的方法名字相同--&gt; &lt;!--int insertUser();--&gt; &lt;insert id=&quot;insertUser&quot;&gt;insert into t_user values(null,&#x27;admin&#x27;,&#x27;123456&#x27;,23,&#x27;男&#x27;,&#x27;12345@qq.com&#x27;)&lt;/insert&gt;&lt;/mapper&gt; 在mybatis-config.xml中引入映射文件 12345&lt;!--引入映射文件--&gt;&lt;mappers&gt; &lt;!--相对路径，这个配置文件和mappers在同一文件夹下--&gt; &lt;package name=&quot;mappers/UserMapper.xml&quot;/&gt;&lt;/mappers&gt; 测试添加用户功能mybatis-config.xml中引入映射文件 12345&lt;!--引入映射文件--&gt;&lt;mappers&gt; &lt;!--相对路径，这个配置文件和mappers在同一文件夹下--&gt; &lt;mapper resource=&quot;mappers/UserMapper.xml&quot;/&gt;&lt;/mappers&gt; test 下的java包中的com.atguigu.mybatis.test包下的MyBatisTest文件，用来测试的 123456789101112131415161718192021222324252627282930313233343536373839package com.atguigu.mybatis.test;import com.atguigu.mybatis.mapper.UserMapper;import com.atguigu.mybatis.pojo.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.net.URL;public class MyBatisTest &#123;@Test public void testInsert() throws IOException &#123; //获取核心配置文件的输入流 InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); //获取SalSessionFactoryBuilder对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); //获取SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); //获取sql的会话对象SqlSession,是Mybatis提供的操作数据库的对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //获取UserMapper的代理实现类对象 UserMapper mapper = sqlSession.getMapper(UserMapper.class); //调用Mapper接口中的方法，实现添加用户信息的功能 int result = mapper.insertUser(); //提交事务 sqlSession.commit(); System.out.println(&quot;结果+&quot;+result); //关闭sqlSession对象 sqlSession.close();&#125;&#125; Resources.getResourceAsStream(“mybatis-config.xml”);这个方法的参数路径直接映射到resources目录下 其实也是加载之后java和reources都在classes路径下 所以Resources.getResourceAsStream(“mybatis-config.xml”);是定位到target&#x2F;classes文件下 优化功能1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.atguigu.mybatis.test;import com.atguigu.mybatis.mapper.UserMapper;import com.atguigu.mybatis.pojo.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.net.URL;public class MyBatisTest &#123;@Test public void testInsert() throws IOException &#123; //获取核心配置文件的输入流 InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); //获取SalSessionFactoryBuilder对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); //获取SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); //获取sql的会话对象SqlSession,是Mybatis提供的操作数据库的对象 //布尔类型参数如果为true就是自动提交，如果不写true就不会自动提交事务 SqlSession sqlSession = sqlSessionFactory.openSession(true); //获取UserMapper的代理实现类对象 UserMapper mapper = sqlSession.getMapper(UserMapper.class); //调用Mapper接口中的方法，实现添加用户信息的功能 int result = mapper.insertUser(); /*//提供sql的唯一标识找到sql并执行，唯一标识是namespace.(sql的id) //执行insert的sql语句 //根据UserMapper的全类名找到UserMapper根据insertUser方法名找到对应的sql语句 int result = sqlSession.insert(&quot;com.atguigu.mybatis.mapper.UserMapper.insertUser&quot;);*/ //提交事务 //sqlSession.commit(); System.out.println(&quot;结果+&quot;+result); //关闭sqlSession对象 sqlSession.close();&#125;&#125; 加入log4j日志功能 在pom.xml中加上依赖 123456&lt;!-- log4j日志 --&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 加入log4j.xml配置文件在resources文件夹下 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt;&lt;log4j:configuration xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt; &lt;param name=&quot;Encoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt; &lt;param name=&quot;ConversionPattern&quot; value=&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125;%m (%F:%L) \\n&quot; /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;logger name=&quot;java.sql&quot;&gt; &lt;level value=&quot;debug&quot; /&gt; &lt;/logger&gt; &lt;logger name=&quot;org.apache.ibatis&quot;&gt; &lt;level value=&quot;info&quot; /&gt; &lt;/logger&gt; &lt;root&gt; &lt;level value=&quot;debug&quot; /&gt; &lt;appender-ref ref=&quot;STDOUT&quot; /&gt; &lt;/root&gt;&lt;/log4j:configuration&gt; 效果就是 执行代码的时候，能看到影响的行数，传递的参数，执行的sql语句 123DEBUG 10-16 13:54:41,170 ==&gt; Preparing: insert into t_user values(null,&#x27;admin&#x27;,&#x27;123456&#x27;,23,&#x27;男&#x27;,&#x27;12345@qq.com&#x27;); (BaseJdbcLogger.java:137) DEBUG 10-16 13:54:41,193 ==&gt; Parameters: (BaseJdbcLogger.java:137) DEBUG 10-16 13:54:41,281 &lt;== Updates: 1 (BaseJdbcLogger.java:137) 日志的级别 FATAL(致命)&gt;ERROR(错误)&gt;WARN(警告)&gt;INFO(信息)&gt;DEBUG(调试) 从左到右打印的内容越来越详细 你选择了一个日志的级别，那么之后就可以打印出大于等于这个日志级别的日志 mybatis的增删改先封装了获取sqlSession会话的方法 utils包下的 123456789101112131415161718192021222324252627282930313233343536package com.atguigu.mybatis.utils;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class SqlSessionUtil &#123; public static SqlSession getSqlSession()&#123; SqlSession sqlSession=null; //获取核心配置文件的输入流 try &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); //获取SalSessionFactoryBuilder对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); //获取SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); //获取sql的会话对象SqlSession,是Mybatis提供的操作数据库的对象 //布尔类型参数如果为true就是自动提交，如果不写true就不会自动提交事务 sqlSession = sqlSessionFactory.openSession(true); return sqlSession; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return sqlSession; &#125;&#125; UserMapper接口 123456789101112131415161718192021package com.atguigu.mybatis.mapper;public interface UserMapper &#123; /** * 添加用户信息 * @return */ int insertUser(); /* 修改用户信息 */ int updateUser(); /* 删除用户信息 */ int deleteUser();&#125; UserMapper.xml 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--这个namespace要和Mapper接口的全类名相同--&gt;&lt;mapper namespace=&quot;com.atguigu.mybatis.mapper.UserMapper&quot;&gt; &lt;!--insert标签说明是插入语句，id要和mapper接口中对应的方法名字相同--&gt; &lt;!--int insertUser();--&gt; &lt;insert id=&quot;insertUser&quot;&gt;insert into t_user values(null,&#x27;admin&#x27;,&#x27;123456&#x27;,23,&#x27;男&#x27;,&#x27;12345@qq.com&#x27;);&lt;/insert&gt; &lt;update id=&quot;updateUser&quot;&gt; update t_user set username=&#x27;root&#x27; ,password=&#x27;123&#x27; where id=3 &lt;/update&gt; &lt;delete id=&quot;deleteUser&quot;&gt; delete from t_user where id=3 &lt;/delete&gt;&lt;/mapper&gt; MyBatisTest 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.atguigu.mybatis.test;import com.atguigu.mybatis.mapper.UserMapper;import com.atguigu.mybatis.pojo.User;import com.atguigu.mybatis.utils.SqlSessionUtil;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.net.URL;public class MyBatisTest &#123;@Test public void testInsert() throws IOException &#123; //获取核心配置文件的输入流 InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); //获取SalSessionFactoryBuilder对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); //获取SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); //获取sql的会话对象SqlSession,是Mybatis提供的操作数据库的对象 //布尔类型参数如果为true就是自动提交，如果不写true就不会自动提交事务 SqlSession sqlSession = sqlSessionFactory.openSession(true); //获取UserMapper的代理实现类对象 UserMapper mapper = sqlSession.getMapper(UserMapper.class); //调用Mapper接口中的方法，实现添加用户信息的功能 int result = mapper.insertUser(); /*//提供sql的唯一标识找到sql并执行，唯一标识是namespace.(sql的id) //执行insert的sql语句 //根据UserMapper的全类名找到UserMapper根据insertUser方法名找到对应的sql语句 int result = sqlSession.insert(&quot;com.atguigu.mybatis.mapper.UserMapper.insertUser&quot;);*/ //提交事务 //sqlSession.commit(); System.out.println(&quot;结果+&quot;+result); //关闭sqlSession对象 sqlSession.close();&#125;@Testpublic void testUpdate()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); mapper.updateUser(); sqlSession.close(); &#125; @Test public void testDelete()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); mapper.deleteUser(); sqlSession.close();&#125;&#125; 测试查询功能UserMapper.xml 12345678910&lt;!--resultType 设置结果类型，即查询的数据要转换为的java类型--&gt;&lt;!--resultMap是自定义映射，处理多对一或一对多的映射关系--&gt;&lt;select id=&quot;getUserById&quot; resultType=&quot;com.atguigu.mybatis.pojo.User&quot;&gt; select *from t_user where id=1;&lt;/select&gt;&lt;select id=&quot;getAllUser&quot; resultType=&quot;com.atguigu.mybatis.pojo.User&quot;&gt; select *from t_user&lt;/select&gt; UserMapper 接口 123456789/*根据id查询用户信息 */User getUserById();/*查询所有的用户信息 */List&lt;User&gt; getAllUser(); 注意： 1、查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射关系 resultType：自动映射，用于属性名和表中字段名一致的情况 resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况 测试 1234567891011121314151617@Test public void testGetUserById()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User userById = mapper.getUserById(); System.out.println(userById);&#125;@Testpublic void testGetAllUser()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; allUser = mapper.getAllUser(); System.out.println(allUser);&#125; mybatis的核心配置文件environments12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- environments :配置连接数据库的环境 default:设置默认使用的环境的id --&gt; &lt;!--设置连接数据库的环境--&gt; &lt;environments default=&quot;development&quot;&gt; &lt;!-- environment:设置一个具体的连接数据库的环境 id:设置环境的唯一标识，不能重复 --&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 设置事务管理器 属性：type：设置事务管理的方式 type=&quot;JDBC/MANAGED&quot; JDBC:标识使用JDBC原生的事务管理方式，手动提交事务回滚事务，也可以自动提交事务 MANAGED:被管理的，例如spring --&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!-- dataSource:设置数据源 属性： type：设置数据源的类型 type=&quot;POOLED/UNPOOLED/JNDI&quot; POOLED:表示使用数据库连接池 UNPOOLED:表示不使用数据库连接池 JNDI:表示使用上下文中的数据源 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--驱动--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;!--url--&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC&quot;/&gt; &lt;!--数据库的用户名和密码--&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--引入映射文件--&gt; &lt;mappers&gt; &lt;!--相对路径，这个配置文件和mappers在同一文件夹下--&gt; &lt;mapper resource=&quot;mappers/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; properties存储连接数据库的信息这是resources下的jdbc.properties 1234jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=UTCjdbc.username=rootjdbc.password=root mybatis-config.xml &lt;!--引入properties文件，此后就可以在当前文件中使用$&#123;key&#125;的方式来访问value--&gt; &lt;properties resource=&quot;jdbc.properties&quot;/&gt; 123456789&lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--驱动--&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;!--url--&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;!--数据库的用户名和密码--&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--引入properties文件，此后就可以在当前文件中使用$&#123;key&#125;的方式来访问value--&gt; &lt;properties resource=&quot;jdbc.properties&quot;/&gt; &lt;!-- environments :配置连接数据库的环境 default:设置默认使用的环境的id --&gt; &lt;!--设置连接数据库的环境--&gt; &lt;environments default=&quot;development&quot;&gt; &lt;!-- environment:设置一个具体的连接数据库的环境 id:设置环境的唯一标识，不能重复 --&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 设置事务管理器 属性：type：设置事务管理的方式 type=&quot;JDBC/MANAGED&quot; JDBC:标识使用JDBC原生的事务管理方式，手动提交事务回滚事务，也可以自动提交事务 MANAGED:被管理的，例如spring --&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!-- dataSource:设置数据源 属性： type：设置数据源的类型 type=&quot;POOLED/UNPOOLED/JNDI&quot; POOLED:表示使用数据库连接池 UNPOOLED:表示不使用数据库连接池 JNDI:表示使用上下文中的数据源 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--驱动--&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;!--url--&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;!--数据库的用户名和密码--&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--引入映射文件--&gt; &lt;mappers&gt; &lt;!--相对路径，这个配置文件和mappers在同一文件夹下--&gt; &lt;mapper resource=&quot;mappers/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 核心配置文件之typeAliases1234567891011121314151617&lt;!-- typeAliases :设置类型别名，即为某个具体的类型设置一个别名 在Mybatis的范围中，就可以使用别名表示一个具体的类型 --&gt; &lt;typeAliases&gt; &lt;!-- type:设置需要起别名的类型 alias:设置某个类型的别名 --&gt; &lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.pojo.User&quot; alias=&quot;abc&quot;&gt;&lt;/typeAlias&gt;--&gt; &lt;!--只设置一个type属性，就会有一个默认的别名，就是他的类名，也就是User--&gt; &lt;!-- &lt;typeAlias type=&quot;com.atguigu.mybatis.pojo.User&quot;&gt;&lt;/typeAlias&gt;--&gt; &lt;!--通过包来设置类型别名，指定包下的所有的类型全部用有默认的别名。--&gt; &lt;package name=&quot;com.atguigu.mybatis.pojo&quot;/&gt; &lt;/typeAliases&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- mybatis中的核心配置文件中的标签必须要按照指定的顺序配置 properties?,settings?,typeAliases?,typeHandlers?, objectFactory?,objectWrapperFactory?,reflectorFactory?, plugins?,environments?,databaseIdProvider?,mappers? --&gt; &lt;!--引入properties文件，此后就可以在当前文件中使用$&#123;key&#125;的方式来访问value--&gt; &lt;properties resource=&quot;jdbc.properties&quot;/&gt; &lt;!-- typeAliases :设置类型别名，即为某个具体的类型设置一个别名 在Mybatis的范围中，就可以使用别名表示一个具体的类型 --&gt; &lt;typeAliases&gt; &lt;!-- type:设置需要起别名的类型 alias:设置某个类型的别名 --&gt; &lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.pojo.User&quot; alias=&quot;abc&quot;&gt;&lt;/typeAlias&gt;--&gt; &lt;!--只设置一个type属性，就会有一个默认的别名，就是他的类名，也就是User--&gt; &lt;!-- &lt;typeAlias type=&quot;com.atguigu.mybatis.pojo.User&quot;&gt;&lt;/typeAlias&gt;--&gt; &lt;!--通过包来设置类型别名，指定包下的所有的类型全部用有默认的别名。--&gt; &lt;package name=&quot;com.atguigu.mybatis.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- environments :配置连接数据库的环境 default:设置默认使用的环境的id --&gt; &lt;!--设置连接数据库的环境--&gt; &lt;environments default=&quot;development&quot;&gt; &lt;!-- environment:设置一个具体的连接数据库的环境 id:设置环境的唯一标识，不能重复 --&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 设置事务管理器 属性：type：设置事务管理的方式 type=&quot;JDBC/MANAGED&quot; JDBC:标识使用JDBC原生的事务管理方式，手动提交事务回滚事务，也可以自动提交事务 MANAGED:被管理的，例如spring --&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!-- dataSource:设置数据源 属性： type：设置数据源的类型 type=&quot;POOLED/UNPOOLED/JNDI&quot; POOLED:表示使用数据库连接池 UNPOOLED:表示不使用数据库连接池 JNDI:表示使用上下文中的数据源 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--驱动--&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;!--url--&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;!--数据库的用户名和密码--&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--引入映射文件--&gt; &lt;mappers&gt; &lt;!--以包的方式引入映射文件，但是必须满足两个条件1.mapper接口和映射文件所在的包名字必须一致2.mapper接口的名字和映射文件的名字必须一致--&gt; &lt;!--相对路径，这个配置文件和mappers在同一文件夹下--&gt; &lt;package name=&quot;com.atguigu.mybatis.mapper&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 核心配置文件中的mappers1234567891011 &lt;!--引入映射文件--&gt; &lt;!--以包的方式引入映射文件，但是必须满足两个条件1.mapper接口和映射文件所在的包名字必须一致2.mapper接口的名字和映射文件的名字必须一致--&gt; &lt;!--相对路径，这个配置文件和mappers在同一文件夹下--&gt; &lt;mappers&gt; &lt;package name=&quot;com.atguigu.mybatis.mapper&quot;/&gt; &lt;/mappers&gt; 在目录中创建包，用new directory的时候，要实现目录层级的变化要用&#x2F;来分割 java下和resources下的com.atguigu.mybatis.mapper包最终都会加载到同一个包中 创建核心配置文件和映射文件的模板这个就是创建一个模板，然后右键之后可以生成这个模板文件 mybatis-config.xml文件的模板 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- mybatis中的核心配置文件中的标签必须要按照指定的顺序配置 properties?,settings?,typeAliases?,typeHandlers?, objectFactory?,objectWrapperFactory?,reflectorFactory?, plugins?,environments?,databaseIdProvider?,mappers? --&gt; &lt;properties resource=&quot;jdbc.properties&quot;/&gt; &lt;typeAliases&gt; &lt;package name=&quot;&quot;/&gt; &lt;/typeAliases&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--驱动--&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;!--url--&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;!--数据库的用户名和密码--&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;package name=&quot;com.atguigu.mybatis.mapper&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 映射文件模板的创建 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;&quot;&gt;&lt;/mapper&gt; 用模板搭建mybatis框架就是又创建了一个mybatis项目 Mybatis获取参数值的两种方式MyBatis获取参数值的两种方式：${}和#{} ${}的本质就是字符串拼接，#{}的本质就是占位符赋值 ${}使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号；但是#{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单引号 获取单个字面量类型的参数若mapper接口中的方法参数为单个的字面量类型 此时可以使用${}和#{}以任意的名称获取参数的值，注意${}需要手动加单引号 UserMapper接口 12345678910111213package com.atguigu.mybatis.mapper;import com.atguigu.mybatis.pojo.User;public interface UserMapper &#123; /* 根据用户名查询用户信息 */ User getUserByUsername(String username);&#125; UserMapper.xml #{}或者${}大括号里面其实都是任意的，但最后是和函数的参数名字相同 ${}要加单引号 ‘${}’ 123456 &lt;!-- User getUserByUsername(String username);--&gt; &lt;select id=&quot;getUserByUsername&quot; resultType=&quot;com.atguigu.mybatis.pojo.User&quot;&gt;&lt;!--获取getUserByUsername的参数--&gt; &lt;!--select *from t_user where username=#&#123;username&#125;--&gt; select * from t_user where username=&#x27;$&#123;username&#125;&#x27; &lt;/select&gt; 测试 12345678public class ParameterTest &#123;@Test public void testGetUserByUsername()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User admin = mapper.getUserByUsername(&quot;admin&quot;); System.out.println(admin);&#125; 获取多个字面量类型的参数若mapper接口中的方法参数为多个时 此时MyBatis会自动将这些参数放在一个map集合中，以arg0,arg1…为键，以参数为值； 以 param1,param2…为键，以参数为值； 因此只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号 UserMapper接口 1234/*验证登录 */User checklogin(String username,String password); UserMapper.xml arg0或者param1表示第一个参数，arg1和param2表示第二个参数，接下来以此类推就可以 12345&lt;!-- User checklogin(String username,String password);--&gt;&lt;select id=&quot;checklogin&quot; resultType=&quot;com.atguigu.mybatis.pojo.User&quot;&gt; &lt;!-- select * from t_user where username=#&#123;arg0&#125; and password=#&#123;arg1&#125;--&gt; select *from t_user where username=#&#123;param1&#125; and password=#&#123;param2&#125;&lt;/select&gt; 测试 12345678 @Testpublic void testCheckLogin()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User admin = mapper.checklogin(&quot;admin&quot;,&quot;123456&quot;); System.out.println(admin); &#125; 获取map集合类型的参数若mapper接口中的方法需要的参数为多个时，此时可以手动创建map集合，将这些数据放在 map中 只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号 UserMapper 1234/*以map集合作为参数的验证登录 */User checkloginByMap(Map&lt;String,Object&gt; map); UserMapper.xml #{username}和#{password}大括号中的内容都是map对象中的key 1234&lt;!--User checkloginByMap(Map&lt;String,Object&gt; map);--&gt;&lt;select id=&quot;checkloginByMap&quot; resultType=&quot;com.atguigu.mybatis.pojo.User&quot;&gt; select *from t_user where username=#&#123;username&#125; and password=#&#123;password&#125;&lt;/select&gt; test 1234567891011@Testpublic void testCheckLoginByMap()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); Map&lt;String,Object&gt; map=new HashMap&lt;&gt;(); map.put(&quot;username&quot;,&quot;admin&quot;); map.put(&quot;password&quot;,&quot;123456&quot;); User admin = mapper.checkloginByMap(map); System.out.println(admin);&#125; 获取实体类类型的参数若mapper接口中的方法参数为实体类对象时 此时可以使用${}和#{}，通过访问实体类对象中的属性名获取属性值，注意${}需要手动加单引号 Usermapper 1234/*添加用户信息的功能 */int insertUser(User user); Usermapper.xml 1234&lt;!-- void insertUser(User user);--&gt;&lt;insert id=&quot;insertUser&quot;&gt; insert into t_user values(null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;gender&#125;,#&#123;email&#125;)&lt;/insert&gt; 通过属性名获取属性值，是和成员变量没有关系的，是和get和set方法有关的，只有这个属性有get方法才能够这样来获取 测试： 123456789@Testpublic void testInsertUser()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user=new User(null,&quot;root&quot;,&quot;123456&quot;,22,&quot;女&quot;,&quot;342qq.com&quot;); int i = mapper.insertUser(user); System.out.println(i);&#125; 使用@Param标识参数可以通过@Param注解标识mapper接口中的方法参数 此时，会将这些参数放在map集合中，以@Param注解的value属性值为键，以参数为值； 或者也可以 param1,param2…为键，以参数为值；只需要通过${}和#{}访问map集合的键就可以获取相对应 的值， 注意${}需要手动加单引号 @Param(“username”)给注解类的value参数赋值 12345678/** * 验证登录（使用@param注解） * @param username * @param password * @return *///@Param中不是键值对，就是默认给注解类的value属性赋值User checkLoginByParam(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password); 小结将这些获取参数值就分为两种 当参数类型是实体类对象的时候通过属性值获取 当参数类型是其他的时候，通过@Param标记来获取 @Param也可以获取list类型集合，或者Map类型集合 获取Map类型时可以通过 参数名.key来获取value值 list类型集合，可以通过遍历foreach来访问其中的每一个元素 ，如果元素是一个对象就得用对象名.属性名访问属性值 12345678&lt;!-- void insertMoreEmp(List&lt;Emp&gt; emps);--&gt;&lt;insert id=&quot;insertMoreEmp&quot;&gt; insert into t_emp values &lt;!--separator是每一次循环之间的分隔符的设置--&gt; &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;,&quot;&gt; (null,#&#123;emp.empName&#125;,#&#123;emp.age&#125;,#&#123;emp.gender&#125;,null) &lt;/foreach&gt;&lt;/insert&gt; 而且在sql语句中使用参数需要加#{}或者${}，在标签中使用参数不需要，直接用就可以 Mybatis的查询功能创建SelectMapperl.xml和SelectMapper接口 和selectMapperTest 查询返回一个实体类对象或list集合当查询的数据为多条时，不能使用实体类作为返回值，否则会抛出异常TooManyResultsException 但是若查询的数据只有一条，可以使用实体类或集合作为返回值 SelectMapper 123456789 /* 根据id查询用户信息 */ User getUserbyId(@Param(&quot;id&quot;) Integer id);/*查询所有的用户信息 */List&lt;User&gt; getAllUser(); SelectMapper.xml 123456789&lt;!--User getUserbyId(@Param(&quot;id&quot;) Integer id);--&gt;&lt;select id=&quot;getUserbyId&quot; resultType=&quot;User&quot;&gt; select *from t_user where id=#&#123;id&#125;&lt;/select&gt;&lt;!--List&lt;User&gt; getAllUser();--&gt;&lt;select id=&quot;getAllUser&quot; resultType=&quot;User&quot;&gt; select *from t_user&lt;/select&gt; SelectMapperTest 123456789101112131415@Testpublic void testGetUserById()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); SelectMapper mapper = sqlSession.getMapper(SelectMapper.class); User user = mapper.getUserbyId(9); System.out.println(user);&#125;@Testpublic void testGetAllUser()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); SelectMapper mapper = sqlSession.getMapper(SelectMapper.class); List&lt;User&gt; list = mapper.getAllUser(); list.forEach(System.out::println);&#125; 查询单行单列的数据SelectMapper接口 1234/*查询用户的总数量 */Integer getCount(); SelectMapper.xml mybatis中为java中常用的类型设置了类型别名类名:别名Integer:Integer ,intint :_int,_integerMap:mapString:string 有一个规律就是原本类名是小写字母开头的，别名是前面加一个_ 原本类名是大写字母开头的，别名是第一个字母变为小写字母 12345678910111213 &lt;!--Integer getCount();--&gt; &lt;select id=&quot;getCount&quot; resultType=&quot;integer&quot;&gt;&lt;!--mybatis中为java中常用的类型设置了类型别名类名:别名Integer:Integer ,intint :_int,_integerMap:mapString:string--&gt; select count(*) from t_user &lt;/select&gt; test 1234567@Testpublic void testGetCount()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); SelectMapper mapper = sqlSession.getMapper(SelectMapper.class); Integer count=mapper.getCount(); System.out.println(count);&#125; 查询一条数据为map集合查询出来的数据用map保存时 以字段名为键以字段值为值，以及如果哪个字段的值为null,它是不会放在map集合中的 用类保存的时候，必须保证字段名和类中的属性名相一致，但用map保存不需要 SelectMapper接口 1234/*根据id查询用户信息然后为一个map集合 */Map&lt;String,Object&gt; getUserByIdToMap(@Param(&quot;id&quot;) Integer id); SelectMapper.xml 1234&lt;!--Map&lt;String,Object&gt; getUserByIdToMap(@Param(&quot;id&quot;) Integer id);--&gt;&lt;select id=&quot;getUserByIdToMap&quot; resultType=&quot;map&quot;&gt; select *from t_user where id=#&#123;id&#125;&lt;/select&gt; test 12345678@Testpublic void testGetUserByIdToMap()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); SelectMapper mapper = sqlSession.getMapper(SelectMapper.class); Map&lt;String, Object&gt; userByIdToMap = mapper.getUserByIdToMap(9); System.out.println(userByIdToMap); //&#123;password=123456, gender=男, id=9, age=23, email=123@qq.com, username=admin&#125;&#125; 查询多条数据为map集合方法一： 1将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此 时可以将这些map放在一个list集合中获取 SelectMapper 1List&lt;Map&lt;String,Object&gt;&gt; getAllUserToMap(); SelectMapper.xml 1234&lt;!--Map&lt;String,Object&gt; getAllUserToMap();--&gt;&lt;select id=&quot;getAllUserToMap&quot; resultType=&quot;map&quot;&gt; select *from t_user;&lt;/select&gt; test 1234567@Testpublic void testGetAllUserToMap()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); SelectMapper mapper = sqlSession.getMapper(SelectMapper.class); List&lt;Map&lt;String, Object&gt;&gt; userByIdToMap = mapper.getAllUserToMap(); System.out.println(userByIdToMap);&#125; 方法二 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并 且最终要以一个map的方式返回数据，此时需要通过@MapKey注解设置map集合的键，值是每条数据所对应的 map集合 SelectMapper 123456 /* 查询所有用户信息在一个map中 */ //最后的大map集合是以id为键，一个map为值@MapKey(&quot;id&quot;)Map&lt;String,Object&gt; getAllUserToMap(); SelectMapper.xml 1234&lt;!--Map&lt;String,Object&gt; getAllUserToMap();--&gt;&lt;select id=&quot;getAllUserToMap&quot; resultType=&quot;map&quot;&gt; select *from t_user;&lt;/select&gt; test 1234567@Testpublic void testGetAllUserToMap()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); SelectMapper mapper = sqlSession.getMapper(SelectMapper.class); Map&lt;String,Object&gt; userByIdToMap = mapper.getAllUserToMap(); System.out.println(userByIdToMap);&#125; 结果 这是以id为键的大集合 12345678&#123;9=&#123;password=123456, gender=男, id=9, age=23, email=123@qq.com, username=admin&#125;, 10=&#123;password=123456, gender=女, id=10, age=22, email=342qq.com, username=root&#125;, 11=&#123;password=123456, gender=女, id=11, age=22, email=342qq.com, username=root&#125;, 12=&#123;password=123456, gender=女, id=12, age=22, email=342qq.com, username=root&#125;, 13=&#123;password=123456, gender=女, id=13, age=22, email=342qq.com, username=root&#125;, 14=&#123;password=123456, gender=女, id=14, age=22, email=342qq.com, username=root&#125;&#125; Mybatis特殊sql模糊查询新建specailSQLMapper 和specialSQLMapper.xml specailSQLMapper 1234/*通过用户名模糊查询用户信息 */List&lt;User&gt; getUserByLike(@Param(&quot;mohu&quot;) String mohu); specialSQLMapper.xml ‘%#{mohu}%’不行，#{}的原理是占位符，这样的话占位符在字符串中就失去意义了 ‘%${mohu}%’可以，因为${mohu}是字符串拼接原理，所以就没问题 下面三种方法都可以 1234567&lt;!-- List&lt;User&gt; getUserByLike(@Param(&quot;mohu&quot;) String mohu);--&gt;&lt;select id=&quot;getUserByLike&quot; resultType=&quot;User&quot;&gt; &lt;!--select * from t_user where username like &#x27;%$&#123;mohu&#125;%&#x27;--&gt; &lt;!--这个可以大概率是因为先用#&#123;mohu&#125;得到值再拼接字符串--&gt; &lt;!--select * from t_user where username like concat(&#x27;%&#x27;,#&#123;mohu&#125;,&#x27;%&#x27;);--&gt; select *from t_user where username like &quot;%&quot;#&#123;mohu&#125;&quot;%&quot;&lt;/select&gt; 测试 123456789public class SpecialSQLMapperTest &#123; @Test public void testGetUserByLike()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); SpecialSQLMapper mapper = sqlSession.getMapper(SpecialSQLMapper.class); List&lt;User&gt; list = mapper.getUserByLike(&quot;a&quot;); list.forEach(System.out::println); &#125;&#125; 批量删除SpecialSQLMapper 1234/*批量删除 */void deleteMoreUser(String ids); SpecialSQLMapper.xml 这个地方不能用#{ids}因为这个自动给参数加上单引号 sql语句就是：delete from t_user where id in(‘9,10’); 所以是不对的 用${ids}就不会自动加上单引号 sql语句就是：delete from t_user where id in(9,10);这个是正确的 1234&lt;!-- void deleteMoreUser(String ids);--&gt;&lt;delete id=&quot;deleteMoreUser&quot;&gt; delete from t_user where id in($&#123;ids&#125;);&lt;/delete&gt; SpecialSQLMapperTest 123456@Testpublic void testDeleteMoreUser()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); SpecialSQLMapper mapper = sqlSession.getMapper(SpecialSQLMapper.class); mapper.deleteMoreUser(&quot;9,10&quot;);&#125; 动态设置表名SpecialSQLMapper接口 1234/*动态设置表名，查询当前用户信息 */List&lt;User&gt; getUserList(@Param(&quot;tableName&quot;) String tableName); SpecialSQLMapper.xml 这里不能使用#{}因为这个会给语句加上单引号 select *from ‘tableName’ 用${}就是 select *from tableName这就是正确的 1234&lt;!-- List&lt;User&gt; getUserList(@Param(&quot;tableName&quot;) String tableName);--&gt;&lt;select id=&quot;getUserList&quot; resultType=&quot;User&quot;&gt; select *from $&#123;tableName&#125;&lt;/select&gt; test 1234567@Testpublic void testGetUserList()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); SpecialSQLMapper mapper = sqlSession.getMapper(SpecialSQLMapper.class); List&lt;User&gt; t_user = mapper.getUserList(&quot;t_user&quot;); t_user.forEach(System.out::println);&#125; 添加功能获取自增的主键（报错）场景模拟： t_clazz(clazz_id,clazz_name) ​ t_student(student_id,student_name,clazz_id) ​ 1、添加班级信息 ​ 2、获取新添加的班级的id ​ 3、为班级分配学生，即将某学的班级id修改为新添加的班级的id SpecialSQLMatter 1234/*添加用户信息，并获取自增的主键 */void insertUser(User user); SpecialSQLMatter.xml 123456&lt;!-- void insertUser(User user);--&gt;&lt;!--userGeneratedKeys是指是否获取主键，keyProperty是指将主键获取后赋给传递参数那个对象的哪个属性--&gt;&lt;!--因为增删改查sql方法默认都是返回数字的，所以不能用方法返回值作为获取id的值--&gt;&lt;select id=&quot;insertUser&quot; userGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into t_user values(null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;gender&#125;,#&#123;email&#125;)&lt;/select&gt; test 一开始user对象没有id，insertUser之后，id就有值了 12345678@Testpublic void testInsertUser()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); SpecialSQLMapper mapper = sqlSession.getMapper(SpecialSQLMapper.class); User user=new User(null,&quot;xiaoming&quot;,&quot;123456&quot;,23,&quot;女&quot;,&quot;3241525036@qq.com&quot;); mapper.insertUser(user); System.out.println(user);&#125; 自定义映射resultMap搭建mybatis 建立t_emp是员工信息表，里面的dept_id是员工所属部门的id 建立t_dept是部门信息表，里面的t_dept是部门的信息，部门的名字和id 处理字段名和属性名不一致的情况字段名和属性名不一致的情况下，如何处理映射关系 若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_），实体类中的属性名符合Java的规则（使用驼峰） 此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系 1.可以通过为字段起别名的方式，保证和实体类中的属性名保持一致 2.可以在MyBatis的核心配置文件中设置一个全局配置信息mapUnderscoreToCamelCase，可以在查询表中数据时，自动将_类型的字段名转换为驼峰 在mybatis-config.xml中加 12345678&lt;settings&gt; &lt;!--将下划线映射为驼峰--&gt; &lt;!-- 前面是字段，后面是映射成的驼峰 emp_id:empId, emp_name:empName --&gt;&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; EmpMatter 123456/** * 根据id来查询员工信息 * @param empId * @return */Emp getEmpById(@Param(&quot;empId&quot;) Integer empId); EmpMatter.xml 1234&lt;!-- Emp getEmpById(@Param(&quot;id&quot;) Integer id);--&gt;&lt;select id=&quot;getEmpById&quot; resultType=&quot;Emp&quot;&gt; select *from t_emp where emp_id=#&#123;empId&#125;&lt;/select&gt; test 12345678@Test public void testGetEmptyEmpId()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); Emp empById = mapper.getEmpById(1); System.out.println(empById);&#125; resultMap处理字段名和属性名不一致的情况EmpMatter 123456/** * 根据id来查询员工信息 * @param empId * @return */ Emp getEmpById(@Param(&quot;empId&quot;) Integer empId); EmpMatter.xml 123456789101112131415161718192021222324252627&lt;!--resultMap:设置自定义的映射关系id:唯一标识，就是在select标签中使用resultMap属性的时候那个value的值type:处理映射关系的实体类的类型，就是把那个数据表对应的java类的名字写上--&gt;&lt;!--resultMap常用的子标签id:处理主键和实体类属性的映射关系,也就是数据表主键用这个result:处理普通字段的实体类中属性的映射关系column:设置映射关系中的字段名，必须是sql查询出的某个字段property:设置映射关系中的属性的属性名，必须是处理的实体类类型中的属性名--&gt;&lt;resultMap id=&quot;empResultMap&quot; type=&quot;Emp&quot;&gt; &lt;id column=&quot;emp_id&quot; property=&quot;empId&quot;&gt;&lt;/id&gt; &lt;result column=&quot;emp_name&quot; property=&quot;empName&quot;&gt;&lt;/result&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;&gt;&lt;/result&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;&gt;&lt;/result&gt;&lt;/resultMap&gt;&lt;select id=&quot;getEmpById&quot; resultMap=&quot;empResultMap&quot;&gt; select *from t_emp where emp_id=#&#123;empId&#125;&lt;/select&gt; test 12345678910@Test public void testGetEmptyEmpId()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); Emp empById = mapper.getEmpById(1); System.out.println(empById);&#125; 处理多对一映射关系功能分析EMP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.atguigu.mybatis.pojo;public class Emp &#123; private Integer empId; private Dept dept; public Emp() &#123; &#125; public Dept getDept() &#123; return dept; &#125; public void setDept(Dept dept) &#123; this.dept = dept; &#125; @Override public String toString() &#123; return &quot;Emp&#123;&quot; + &quot;empId=&quot; + empId + &quot;, dept=&quot; + dept + &quot;, empName=&#x27;&quot; + empName + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public Integer getEmpId() &#123; return empId; &#125; public void setEmpId(Integer empId) &#123; this.empId = empId; &#125; public String getEmpName() &#123; return empName; &#125; public void setEmpName(String empName) &#123; this.empName = empName; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public Emp(Integer empId, Dept dept, String empName, Integer age, String gender) &#123; this.empId = empId; this.dept = dept; this.empName = empName; this.age = age; this.gender = gender; &#125; public Emp(Integer empId, String empName, Integer age, String gender) &#123; this.empId = empId; this.empName = empName; this.age = age; this.gender = gender; &#125; private String empName; private Integer age; private String gender;&#125; Dept 12345678910111213141516171819202122232425262728293031323334353637package com.atguigu.mybatis.pojo;public class Dept &#123; public Dept(Integer deptId, String deptName) &#123; this.deptId = deptId; this.deptName = deptName; &#125; private Integer deptId; @Override public String toString() &#123; return &quot;Dept&#123;&quot; + &quot;deptId=&quot; + deptId + &quot;, deptName=&#x27;&quot; + deptName + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public Integer getDeptId() &#123; return deptId; &#125; public void setDeptId(Integer deptId) &#123; this.deptId = deptId; &#125; public String getDeptName() &#123; return deptName; &#125; public void setDeptName(String deptName) &#123; this.deptName = deptName; &#125; private String deptName;&#125; 一对多多对一表关系解释一对多，两张表，多的表加外键 表一对多的意思是 一张表(父表)中的一条记录可以对应另一张表(子表)中的多条记录 就像一张部门表可以对应多个员工，但一个员工信息表只能对应部门表中的一条记录 多对一就是反过来 一堆员工在一个部门 多对一功能就是查询员工部门顺带查到它所在的部门的信息 一对多功能就是查询部门顺带查询其中员工的所有信息 所以就是在Emp类中加一个属性是Dept对象，来存储这个员工所处的部门的信息 1private Dept dept; EmpMapper.xml 这个sql语句是多表查询，可以查询到t_emp表中的所有员工以及员工对应的部门信息，但resultType是Emp肯定不行，因为查到的是dept的名字和id，不可能赋给emp中的dept的对象 123456789&lt;!--Emp getEmpAndDeptByEmpId(@Param(&quot;empId&quot;) Integer empId);--&gt;&lt;select id=&quot;getEmpAndDeptByEmpId&quot; resultType=&quot;Emp&quot;&gt; select t_emp.*,t_dept.* from t_emp left join t_dept on t_emp.dept_id=t_dept.dept_id where t_emp.emp_id=#&#123;empId&#125;&lt;/select&gt; 接下来是处理这个问题 处理多对一的映射关系： 1.级联方式处理（出错） dept是Emp中的Dept对象属性，所以property中就填这个dept.deptId和dept.deptName column就是两个分别对应的列字段名 12&lt;result column=&quot;dept_id&quot; property=&quot;dept.deptId&quot;&gt;&lt;/result&gt;&lt;result column=&quot;dept_name&quot; property=&quot;dept.deptName&quot;&gt;&lt;/result&gt; 1234567891011121314151617181920&lt;resultMap id=&quot;empAndDeptResultMap&quot; type=&quot;Emp&quot;&gt; &lt;id column=&quot;emp_id&quot; property=&quot;empId&quot;&gt;&lt;/id&gt; &lt;result column=&quot;emp_name&quot; property=&quot;empName&quot;&gt;&lt;/result&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;&gt;&lt;/result&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;&gt;&lt;/result&gt; &lt;result column=&quot;dept_id&quot; property=&quot;dept.deptId&quot;&gt;&lt;/result&gt; &lt;result column=&quot;dept_name&quot; property=&quot;dept.deptName&quot;&gt;&lt;/result&gt;&lt;/resultMap&gt;&lt;!--Emp getEmpAndDeptByEmpId(@Param(&quot;empId&quot;) Integer empId);--&gt;&lt;select id=&quot;getEmpAndDeptByEmpId&quot; resultMap=&quot;empAndDeptResultMap&quot;&gt; select t_emp.*,t_dept.* from t_emp left join t_dept on t_emp.dept_id=t_dept.dept_id where t_emp.emp_id=#&#123;empId&#125;&lt;/select&gt; EmpMapper 1234/*获取员工以及所对应的部门的信息 */Emp getEmpAndDeptByEmpId(@Param(&quot;empId&quot;) Integer empId); test 1234567@Testpublic void testGetEmpAndDeptByEmpId()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); Emp empById = mapper.getEmpAndDeptByEmpId(1); System.out.println(empById);&#125; association处理多对一映射 association标签：处理多对一的映射关系（处理实体类类型的属性） property:Emp中dept这个实体类对象的名字 javatype:dept这个实体类对象的类名 id 和result和之前一样，id是处理主键的映射，result是处理其他属性的映射， column是列字段名，property是dept这个实体类对象的属性名 1234&lt;association property=&quot;dept&quot; javaType=&quot;Dept&quot;&gt; &lt;id column=&quot;dept_id&quot; property=&quot;deptId&quot;&gt;&lt;/id&gt; &lt;result column=&quot;dept_name&quot; property=&quot;deptName&quot;&gt;&lt;/result&gt;&lt;/association&gt; 123456789101112131415161718192021&lt;resultMap id=&quot;empAndDeptResultMap&quot; type=&quot;Emp&quot;&gt; &lt;id column=&quot;emp_id&quot; property=&quot;empId&quot;&gt;&lt;/id&gt; &lt;result column=&quot;emp_name&quot; property=&quot;empName&quot;&gt;&lt;/result&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;&gt;&lt;/result&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;&gt;&lt;/result&gt; &lt;association property=&quot;dept&quot; javaType=&quot;Dept&quot;&gt; &lt;id column=&quot;dept_id&quot; property=&quot;deptId&quot;&gt;&lt;/id&gt; &lt;result column=&quot;dept_name&quot; property=&quot;deptName&quot;&gt;&lt;/result&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;!--Emp getEmpAndDeptByEmpId(@Param(&quot;empId&quot;) Integer empId);--&gt;&lt;select id=&quot;getEmpAndDeptByEmpId&quot; resultMap=&quot;empAndDeptResultMap&quot;&gt; select t_emp.*,t_dept.* from t_emp left join t_dept on t_emp.dept_id=t_dept.dept_id where t_emp.emp_id=#&#123;empId&#125;&lt;/select&gt; 分步查询处理多对一的映射 新建一个 DeptMapper用来查询dept表，所以就是最好一个mapper接口对应着一个表的操作 DeptMapper 因为最后是要给emp中的dept对象赋值所以第二次查询是用第一次查询的id做参数，得到Dept对象 123456789101112package com.atguigu.mybatis.mapper;import com.atguigu.mybatis.pojo.Dept;import org.apache.ibatis.annotations.Param;public interface DeptMapper &#123; /* 根据员工部门id查询部门信息 通过分布查询获取员工以及对应的部门信息的第一步 */ Dept getEmpAndDeptByStepTwo(@Param(&quot;deptId&quot;) Integer deptId);&#125; DeptMapper.xml 12345&lt;!-- Dept getEmpAndDeptByStepTwo(@Param(&quot;deptId&quot;) Integer deptId);--&gt;&lt;select id=&quot;getEmpAndDeptByStepTwo&quot; resultType=&quot;Dept&quot;&gt; select *from t_dept where t_dept.dept_id=#&#123;deptId&#125;&lt;/select&gt; EmpMapper 1234/*通过分布查询获取员工以及对应的部门信息的第一步 */Emp getEmpAndDeptByStepOne(@Param(&quot;empId&quot;) Integer empId); EmpMapper.xml 这个select对应的方法的返回值要和dept也就是property中那个对象的类型相同 1234567891011121314151617181920&lt;resultMap id=&quot;empAndDeptByStepResultMap&quot; type=&quot;Emp&quot;&gt; &lt;id column=&quot;emp_id&quot; property=&quot;empId&quot;&gt;&lt;/id&gt; &lt;result column=&quot;emp_name&quot; property=&quot;empName&quot;&gt;&lt;/result&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;&gt;&lt;/result&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;&gt;&lt;/result&gt; &lt;!-- peoperty：就是Emp中的那个需要处理映射关系的实体类对象的名字 select：设置分布查询的sql的唯一标识，就是选中mapper中的那个方法然后右键点击copy reference就可以获得它的唯一标识 column:将查询出的某个字段作为分布查询的下一步也就是select那个方法的参数，因为select标签那个方法参数是部门id所以这里column就是dept_id --&gt; &lt;association property=&quot;dept&quot; select=&quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot; column=&quot;dept_id&quot;&gt;&lt;/association&gt;&lt;/resultMap&gt;&lt;!-- Emp getEmpAndDeptByStepOne(@Param(&quot;empId&quot;) Integer empId);--&gt;&lt;select id=&quot;getEmpAndDeptByStepOne&quot; resultMap=&quot;empAndDeptByStepResultMap&quot;&gt; select *from t_emp where t_emp.emp_id=#&#123;empId&#125;&lt;/select&gt; mybatis分布查询的优势：延迟加载 可以实现就是有的时候想只要员工信息，有的时候想要员工信息以及对应的部门信息 mybatis-config.xml 1234&lt;!--开启延迟加载--&gt;&lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;&lt;!--按需加载，这个其实默认就是false--&gt;&lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; 123456789101112&lt;settings&gt; &lt;!--将下划线映射为驼峰--&gt; &lt;!-- 前面是字段，后面是映射成的驼峰 emp_id:empId, emp_name:empName --&gt;&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;!--开启延迟加载--&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;!--按需加载，这个其实默认就是false--&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; &lt;/settings&gt; test 12//这个地方只获得了员工的名字，所以不需要执行第二步的sql语句，这里可以用这个延迟加载System.out.println(empById.getEmpName()); 123456789@Testpublic void testGetEmpAndDeptByStep()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); Emp empById = mapper.getEmpAndDeptByStepOne(1); // System.out.println(empById); //这个地方只获得了员工的名字，所以不需要执行第二步的sql语句，这里可以用这个延迟加载 System.out.println(empById.getEmpName());&#125; 上面是进行了全局配置，对所有的分布查询都有效，现在想让有一些想让他不实现延迟加载 解决： fetchType属性可以指定这个分步查询是立即加载（eager）还是延迟加载(lazy) ，括号里是这个属性的value值 立即加载就是即使只要员工姓名，也会执行查询部门信息的那个sql语句 123&lt;association property=&quot;dept&quot; fetchType=&quot;eager&quot; select=&quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot; column=&quot;dept_id&quot;&gt;&lt;/association&gt; 处理一对多的映射关系的功能分析一对多就是一个部门中有很多的员工，就是实现查询部门信息的时候顺便也能查询到这个部门中员工的所有信息 在Dept表中加上一个属性 private List emps; 这个属性当中存储的是这个部门中的所有员工的信息 处理一对多的映射关系：1.collection 2.分布查询 1.collection属性:处理一对多的映射关系（处理集合类型的属性） DeptMapper 123456/** * 查询部门以及部门中的员工信息 * @param deptId * @return * */Dept getDeptAndEmpByDeptId(@Param(&quot;deptId&quot;) Integer deptId); DeptMapper.xml collection标签是用来对集合类型的属性进行映射的 就是Dept对象中存储多个员工信息的集合emps property的值就是这个集合类型属性的名字，ofType是这个集合中存储的元素的类型 id和result和之前一样 column是字段名，property就是emps中存储的emp对象中的属性名，要被映射处理的属性名 123456&lt;collection property=&quot;emps&quot; ofType=&quot;Emp&quot;&gt; &lt;id column=&quot;emp_id&quot; property=&quot;empId&quot;&gt;&lt;/id&gt; &lt;result column=&quot;emp_name&quot; property=&quot;empName&quot;&gt;&lt;/result&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;&gt;&lt;/result&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;&gt;&lt;/result&gt;&lt;/collection&gt; 123456789101112131415161718192021&lt;resultMap id=&quot;deptAndEmpResultMap&quot; type=&quot;Dept&quot;&gt; &lt;id column=&quot;dept_id&quot; property=&quot;deptId&quot;&gt;&lt;/id&gt; &lt;result column=&quot;dept_name&quot; property=&quot;deptName&quot;&gt;&lt;/result&gt; &lt;collection property=&quot;emps&quot; ofType=&quot;Emp&quot;&gt; &lt;id column=&quot;emp_id&quot; property=&quot;empId&quot;&gt;&lt;/id&gt; &lt;result column=&quot;emp_name&quot; property=&quot;empName&quot;&gt;&lt;/result&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;&gt;&lt;/result&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;&gt;&lt;/result&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;!-- Dept getDeptAndEmpByDeptId(@Param(&quot;deptId&quot;) Integer deptId);--&gt;&lt;!--这个sql语句是多表连接查询--&gt;&lt;select id=&quot;getDeptAndEmpByDeptId&quot; resultMap=&quot;deptAndEmpResultMap&quot;&gt; select t_dept.*,t_emp.* from t_dept left join t_emp on t_dept.dept_id=t_emp.dept_id where t_dept.dept_id=#&#123;deptId&#125;&lt;/select&gt; test 1234567@Testpublic void testGetDeptAndEmpByDeptId()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); DeptMapper mapper = sqlSession.getMapper(DeptMapper.class); Dept deptAndEmpByDeptId = mapper.getDeptAndEmpByDeptId(1); System.out.println(deptAndEmpByDeptId);&#125; 使用分步查询处理一对多的映射关系 DeptMapper 1234/*通过分布查询查询部门以及部门中的员工信息的第一步 */Dept getDeptAndEmpByStepOne(@Param(&quot;deptId&quot;)Integer deptId); DeptMapper.xml property是要赋值的属性，select是第二个sql语句的全名，第二个sql语句的返回值类型要和property中的那个类型一致 column是第二个sql语句的参数 123456789101112131415&lt;resultMap id=&quot;deptAndEmpResultMapByStep&quot; type=&quot;Dept&quot;&gt; &lt;id column=&quot;dept_id&quot; property=&quot;deptId&quot;/&gt; &lt;result column=&quot;dept_name&quot; property=&quot;deptName&quot;&gt;&lt;/result&gt; &lt;collection property=&quot;emps&quot; select=&quot;com.atguigu.mybatis.mapper.EmpMapper.getDeptAndEmpByStepTwo&quot; column=&quot;dept_id&quot; &gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;!-- Dept getDeptAndEmpByStepOne(@Param(&quot;deptId&quot;)Integer deptId);--&gt;&lt;select id=&quot;getDeptAndEmpByStepOne&quot; resultMap=&quot;deptAndEmpResultMapByStep&quot;&gt; select * from t_dept where dept_id=#&#123;deptId&#125;&lt;/select&gt; EmpMapper 123456/*通过分步查询获取部门以及部门的员工信息的第二步分布查询第二步的返回值类型一定要和要映射的那个属性类型相同用部门id作为参数查部门中的员工 */List&lt;Emp&gt; getDeptAndEmpByStepTwo(Integer deptId); EmpMapper.xml 1234&lt;!-- List&lt;Emp&gt; getDeptAndEmpByStepTwo(Integer deptId);--&gt;&lt;select id=&quot;getDeptAndEmpByStepTwo&quot; resultType=&quot;Emp&quot;&gt; select *from t_emp where dept_id=#&#123;deptId&#125;&lt;/select&gt; test 1234567@Testpublic void testGetDeptAndEmpByStep()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); DeptMapper mapper = sqlSession.getMapper(DeptMapper.class); Dept deptAndEmpByDeptId = mapper.getDeptAndEmpByStepOne(1); System.out.println(deptAndEmpByDeptId);&#125; 设为立即加载还是collection标签中加上fetchType属性设置为eager Mybatis动态sql就是比如选课的时候，有课外名师，有课程不冲突，有美术类型的，有创新类型的，选哪个过滤哪个，有的不选就不过滤，所以这个sql语句它不是固定的，它的条件不止有一个，也不是单纯的改参数，而是整个sql语句的长度 1.如何判断是否提交某个条件的问题，看这个表单项上传到服务器之后是否是null或者空字符串，如果不是就要加上这个条件 2.把这个条件拼接到sql中 if标签DynamicSQLMapper 123456/** * 根据条件查询员工信息 * @param emp * @return */ List&lt;Emp&gt; getEmpByCondition(Emp emp); DynamicSQLMapper.xml 1.if，通过test属性中的表达式判断标签内的内容是否有效，也就是是否是null或者空字符串(是否会拼接到sql中)，也就是判断表单传递的参数 方法的参数是Emp对象，判断它的属性是否有效可以直接用属性名，底下获取参数也是可以直接用属性名 12345678910111213&lt;!-- List&lt;Emp&gt; getEmpByCondition(Emp emp); --&gt;&lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;Emp&quot;&gt; select * from t_emp where &lt;if test=&quot;empName!=null and empName!=&#x27;&#x27;&quot;&gt; emp_name=#&#123;empName&#125; &lt;/if&gt; &lt;if test=&quot;age!=null and age!=&#x27;&#x27;&quot;&gt; and age=#&#123;age&#125; &lt;/if&gt; &lt;if test=&quot;gender!=null and gender!=&#x27;&#x27;&quot;&gt; and gender=#&#123;gender&#125; &lt;/if&gt;&lt;/select&gt; 执行的sql的语句的演示 1select * from t_emp where emp_name=? and age=? and gender=? where标签上面的第一种优化 DyanmicSQLMapper.xml 避免第一个条件不符合，或者都不符合的情况下sql语句错误 12345678910111213&lt;!-- List&lt;Emp&gt; getEmpByCondition(Emp emp); --&gt;&lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;Emp&quot;&gt; select * from t_emp where 1=1 &lt;if test=&quot;empName!=null and empName!=&#x27;&#x27;&quot;&gt; and emp_name=#&#123;empName&#125; &lt;/if&gt; &lt;if test=&quot;age!=null and age!=&#x27;&#x27;&quot;&gt; and age=#&#123;age&#125; &lt;/if&gt; &lt;if test=&quot;gender!=null and gender!=&#x27;&#x27;&quot;&gt; and gender=#&#123;gender&#125; &lt;/if&gt;&lt;/select&gt; 第二种优化 DyanmicSQLMapper.xml 123456789101112131415&lt;!-- List&lt;Emp&gt; getEmpByCondition(Emp emp); --&gt;&lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;Emp&quot;&gt; select * from t_emp &lt;where&gt; &lt;if test=&quot;empName!=null and empName!=&#x27;&#x27;&quot;&gt; emp_name=#&#123;empName&#125; &lt;/if&gt; &lt;if test=&quot;age!=null and age!=&#x27;&#x27;&quot;&gt; and age=#&#123;age&#125; &lt;/if&gt; &lt;if test=&quot;gender!=null and gender!=&#x27;&#x27;&quot;&gt; and gender=#&#123;gender&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; where标签的作用： 1.若where标签中有条件成立，会自动生成where关键字 2.会自动将where标签中内容前多余的and去掉,但是后面多余的and无法去掉 3.若where标签中没有任何一个条件成立，则where标签没有任何功能 trim标签第三种方法： DynamicSQLMapper.xml trim标签： prefix,suffix:在标签中内容前面，后面添加指定内容 prefixOverrides,suffixOverrides:在标签中内容前面，后面去掉指定内容 下面这种情况是把and放在后面，这样如果age符合条件，gender是null的话就会出错，所以用trim标签解决 123456789101112131415&lt;!-- List&lt;Emp&gt; getEmpByCondition(Emp emp); --&gt;&lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;Emp&quot;&gt; select * from t_emp &lt;trim prefix=&quot;where&quot; suffixOverrides=&quot;and&quot;&gt; &lt;if test=&quot;empName!=null and empName!=&#x27;&#x27;&quot;&gt; emp_name=#&#123;empName&#125; and &lt;/if&gt; &lt;if test=&quot;age!=null and age!=&#x27;&#x27;&quot;&gt; age=#&#123;age&#125; and &lt;/if&gt; &lt;if test=&quot;gender!=null and gender!=&#x27;&#x27;&quot;&gt; gender=#&#123;gender&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; choose when otherwise标签choose: when: 相当于if或者else if otherwise:相当于else 这个是其中有一个条件成立，其他的都不判断了 DynamicSQLMapper 1234/*使用choose来查询员工信息 */List&lt;Emp&gt; getEmpByChoose(Emp emp); DynamicSQLMapper.xml 这种如果empName成立了，后面也就不会再执行了，所以前面不用加and 1234567891011121314151617&lt;!-- List&lt;Emp&gt; getEmpByChoose(Emp emp); --&gt;&lt;select id=&quot;getEmpByChoose&quot; resultType=&quot;Emp&quot;&gt; select * from t_emp &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;empName!=null and empName!=&#x27;&#x27;&quot;&gt; emp_name=#&#123;empName&#125; &lt;/when&gt; &lt;when test=&quot;age!=null and age!=&#x27;&#x27;&quot;&gt; age=#&#123;age&#125; &lt;/when&gt; &lt;when test=&quot;gender!=null and gender!=&#x27;&#x27;&quot;&gt; gender=#&#123;gender&#125; &lt;/when&gt; &lt;/choose&gt; &lt;/where&gt; test 12345678@Testpublic void testGetEmpByChoose()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class); Emp emp=new Emp(null,&quot;张三&quot;,20,&quot;&quot;); List&lt;Emp&gt; list = mapper.getEmpByChoose(emp); list.forEach(System.out::println);&#125; foreach标签(获取list集合参数)批量添加 获取list形式的参数也用@Param(“emps”)，#{}是在sql语句中使用的用来获得参数的，在标签中不用 实现批量操作 DynamicSQLMapper 12345/*添加多条员工信息参数是一个存储员工信息的集合 */void insertMoreEmp(@Param(&quot;emps&quot;) List&lt;Emp&gt; emps); DynamicSQLMapper.xml collections中是要遍历的集合，item是集合中每一个元素 这里访问对象的属性，不能直接用属性名 要用对象名字.属性名 12345678&lt;!-- void insertMoreEmp(List&lt;Emp&gt; emps);--&gt;&lt;insert id=&quot;insertMoreEmp&quot;&gt; insert into t_emp values &lt;!--separator是每一次循环之间的分隔符的设置--&gt; &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;,&quot;&gt; (null,#&#123;emp.empName&#125;,#&#123;emp.age&#125;,#&#123;emp.gender&#125;,null) &lt;/foreach&gt;&lt;/insert&gt; TEST 12345678910111213@Test public void testInsertMoreEmp()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class); Emp emp1=new Emp(null,&quot;小明1&quot;,20,&quot;男&quot;); Emp emp2=new Emp(null,&quot;小明2&quot;,20,&quot;男&quot;); Emp emp3=new Emp(null,&quot;小明3&quot;,20,&quot;男&quot;); ArrayList&lt;Emp&gt; list1 = new ArrayList&lt;Emp&gt;();list1.add(emp1);list1.add(emp2);list1.add(emp3); mapper.insertMoreEmp(list1); &#125; 批量删除 DynamicSQLMapper 12345/*批量删除参数是存储的员工id的数组 */void deleteMoreEmp(@Param(&quot;empIds&quot;)Integer[] empIds); DynamicSQLMapper.xml empId是Integer类型的所以可以用#{empId}来获取 12345678910&lt;!-- void delteMoreEmp(@Param(&quot;empIds&quot;)Integer[] empIds);--&gt;&lt;delete id=&quot;deleteMoreEmp&quot;&gt; delete from t_emp where emp_id in ( &lt;foreach collection=&quot;empIds&quot; item=&quot;empId&quot; separator=&quot;,&quot;&gt; #&#123;empId&#125; &lt;/foreach&gt; )&lt;/delete&gt; test 1234567@Testpublic void testdeleteMoreEmp()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class); Integer[] empIds=new Integer[]&#123;5,6,7&#125;; mapper.deleteMoreEmp(empIds);&#125; 优化 12345678910&lt;!-- void delteMoreEmp(@Param(&quot;empIds&quot;)Integer[] empIds);--&gt;&lt;delete id=&quot;deleteMoreEmp&quot; &gt; delete from t_emp where emp_id in &lt;foreach collection=&quot;empIds&quot; item=&quot;empId&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; #&#123;empId&#125; &lt;/foreach&gt;&lt;/delete&gt; open和close属性代表循环以什么开始和以什么结束 优化2 123456789101112&lt;!-- void delteMoreEmp(@Param(&quot;empIds&quot;)Integer[] empIds);--&gt;&lt;delete id=&quot;deleteMoreEmp&quot; &gt; &lt;!-- delete from t_emp where emp_id in &lt;foreach collection=&quot;empIds&quot; item=&quot;empId&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; #&#123;empId&#125; &lt;/foreach&gt;--&gt; delete from t_emp where &lt;foreach collection=&quot;empIds&quot; item=&quot;empId&quot; separator=&quot;or&quot;&gt; emp_id=#&#123;empId&#125; &lt;/foreach&gt;&lt;/delete&gt; separator：设置每次循环的数据之间的分隔符，前后会自动加空格 优化2的sql语句 delete from t_emp where emp_id&#x3D;? or emp_id&#x3D;? or emp_id&#x3D;? sql标签就是把sql中每次都用到的片段进行封装，然后用include标签来进行引用，比如说*在mybatis中解析为所有字段名，你可以自己将所有字段名封装起来，然后去引用，也避免了mybatis的解析 123&lt;sql id=&quot;empColumns&quot;&gt; emp_id,emp_name,age,gender,dept_id&lt;/sql&gt; 1select &lt;include refid=&quot;empColumns&quot;&gt;&lt;/include&gt; from t_emp 123456789101112131415161718&lt;sql id=&quot;empColumns&quot;&gt; emp_id,emp_name,age,gender,dept_id&lt;/sql&gt;&lt;!-- List&lt;Emp&gt; getEmpByCondition(Emp emp); --&gt;&lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;Emp&quot;&gt; select &lt;include refid=&quot;empColumns&quot;&gt;&lt;/include&gt; from t_emp &lt;trim prefix=&quot;where&quot; suffixOverrides=&quot;and&quot;&gt; &lt;if test=&quot;empName!=null and empName!=&#x27;&#x27;&quot;&gt; emp_name=#&#123;empName&#125; and &lt;/if&gt; &lt;if test=&quot;age!=null and age!=&#x27;&#x27;&quot;&gt; age=#&#123;age&#125; and &lt;/if&gt; &lt;if test=&quot;gender!=null and gender!=&#x27;&#x27;&quot;&gt; gender=#&#123;gender&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; Mybatis缓存一级缓存：默认就是一级缓存 一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问 sqlSession级别，是指一级缓存生效的条件是同一个sqlSession 虽然执行了两次mapper.getEmpById(1);方法但是只用了一个sql语句这就是一级缓存，注意参数必须相同 test 123456789@Testpublic void testGetEmpById()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); CacheMapper mapper = sqlSession.getMapper(CacheMapper.class); Emp emp1 = mapper.getEmpById(1); System.out.println(emp1); Emp emp = mapper.getEmpById(1); System.out.println(emp);&#125; 一级缓存失效的四种情况 使一级缓存失效的四种情况： 不同的SqlSession对应不同的一级缓存 同一个SqlSession但是查询条件不同 同一个SqlSession两次查询期间执行了任何一次增删改操作 同一个SqlSession两次查询期间手动清空了缓存 test 中间进行了一个删除操作，就会清空一级缓存，这样就是总共执行3个sql语句 12345678910@Testpublic void testGetEmpById()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); CacheMapper mapper = sqlSession.getMapper(CacheMapper.class); Emp emp1 = mapper.getEmpById(1); System.out.println(emp1); mapper.deleteEmpById(4); Emp emp = mapper.getEmpById(1); System.out.println(emp);&#125; test 清空一级缓存用sqlSession.clearCache()方法 1234567891011@Testpublic void testGetEmpById()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); CacheMapper mapper = sqlSession.getMapper(CacheMapper.class); Emp emp1 = mapper.getEmpById(1); System.out.println(emp1); sqlSession.clearCache(); // mapper.deleteEmpById(4); Emp emp = mapper.getEmpById(1); System.out.println(emp);&#125; 二级缓存二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被 缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取 使用同一个SqlSessionFactory创建的sqlSession缓存都有效 二级缓存开启的条件： a&gt;在核心配置文件中，设置全局配置属性cacheEnabled&#x3D;”true”，默认为true，不需要设置 b&gt;在映射文件中设置标签 c&gt;二级缓存必须在SqlSession关闭或提交之后有效 d&gt;查询的数据所转换的实体类类型必须实现序列化的接口 实现接口 1public class Emp implements Serializable &#123; test 先关闭sqlSession才能将数据进入二级缓存 12//sqlSession1关闭之后才能将保存在一级缓存中的数据保存到二级缓存中sqlSession1.close(); 12345678910111213141516171819@Testpublic void testCache() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); SqlSession sqlSession1 = sqlSessionFactory.openSession(true); CacheMapper mapper1 = sqlSession1.getMapper(CacheMapper.class); Emp empById = mapper1.getEmpById(1); System.out.println(empById); //sqlSession1关闭之后才能将保存在一级缓存中的数据保存到二级缓存中 sqlSession1.close(); SqlSession sqlSession2 = sqlSessionFactory.openSession(true); CacheMapper mapper2 = sqlSession2.getMapper(CacheMapper.class); Emp empById2 = mapper2.getEmpById(1); System.out.println(empById2); sqlSession2.close();&#125; 使二级缓存失效的情况： 两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效 先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用。 如果二级缓存没有命中，再查询一级缓存 如果一级缓存也没有命中，则查询数据库 SqlSession关闭之后一级缓存中的数据会写入二级缓存 整合第三方缓存Ehache第三方缓存是在二级缓存的基础上来使用的 1.导入依赖 123456789101112&lt;!-- Mybatis EHCache整合包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- slf4j日志门面的一个具体实现 --&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt; 创建EHCache的配置文件ehcache.xml 在resources文件夹下 设置二级缓存的类型 1&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt; 加入logback日志 存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日 志。 创建logback的配置文件logback.xml 改动：name是自己的方mapper接口的包 1&lt;logger name=&quot;com.atguigu.mybatis.mapper&quot; level=&quot;DEBUG&quot;/&gt; resources下面的logback.xml 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration debug=&quot;true&quot;&gt; &lt;!-- 指定日志输出的位置 --&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;!-- 日志输出的格式 --&gt; &lt;!-- 按照顺序分别是： 时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt; &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;] [%-5level] [%thread] [%logger] [%msg]%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 设置全局日志级别。日志级别按顺序分别是： DEBUG、INFO、WARN、ERROR --&gt; &lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt; &lt;root level=&quot;DEBUG&quot;&gt; &lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt; &lt;appender-ref ref=&quot;STDOUT&quot; /&gt; &lt;/root&gt; &lt;!-- 根据特殊需求指定局部日志级别 --&gt; &lt;logger name=&quot;com.atguigu.mybatis.mapper&quot; level=&quot;DEBUG&quot;/&gt;&lt;/configuration&gt; mybatis的逆向工程正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。 Hibernate是支持正向工 程的。 逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成资源： Java实体类 Mapper接口 Mapper映射文件 先改了以下maven的镜像源 1234567891011&lt;mirror&gt;&lt;id&gt;nexus-aliyun&lt;/id&gt;&lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;name&gt;Nexus aliyun&lt;/name&gt;&lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;&lt;/mirror&gt; 添加依赖 pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;packaging&gt;jar&lt;/packaging&gt;&lt;dependencies&gt; &lt;!--依赖mybaits核心--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- log4j日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;!-- 控制Maven在构建过程中相关配置 --&gt;&lt;build&gt; &lt;!-- 构建过程中用到的插件 --&gt; &lt;plugins&gt; &lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;!-- 插件的依赖 --&gt; &lt;dependencies&gt; &lt;!-- 逆向工程的核心依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 在resources下加入generatorConfig.xml 1.\\是在当前工程目录下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!-- targetRuntime: 执行生成的逆向工程的版本 MyBatis3Simple: 生成基本的CRUD（清新简洁版） MyBatis3: 生成带条件的CRUD（奢华尊享版） --&gt; &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3Simple&quot;&gt; &lt;!-- 数据库的连接信息 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC&quot; userId=&quot;root&quot; password=&quot;root&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- javaBean的生成策略--&gt; &lt;!--targetPackage是生成的文件所在的包名，targetProject是整个包所在的文件夹--&gt; &lt;javaModelGenerator targetPackage=&quot;com.atguigu.mybatis.pojo&quot; targetProject=&quot;.\\src\\main\\java&quot;&gt; &lt;!--这个就是让com.atguigu.mybatis.pojo是多个包层级，而不是一个包的名字--&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;!--把字段前后空格去掉生成对应的属性--&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- SQL映射文件的生成策略 --&gt; &lt;!--下面这些标签的意思都和上面相同--&gt; &lt;sqlMapGenerator targetPackage=&quot;com.atguigu.mybatis.mapper&quot; targetProject=&quot;.\\src\\main\\resources&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- Mapper接口的生成策略 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.atguigu.mybatis.mapper&quot; targetProject=&quot;.\\src\\main\\java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 逆向分析的表 --&gt; &lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt; &lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt; &lt;!--tableName是需要逆向生成的表--&gt; &lt;table tableName=&quot;t_emp&quot; domainObjectName=&quot;Emp&quot;/&gt; &lt;table tableName=&quot;t_dept&quot; domainObjectName=&quot;Dept&quot;/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 点击mybatis-generator:generate进行逆向工程的运行 双击之后就会出现 类中的属性是根据mysql中的字段生成的 emp_id字段会自动生成empId 会自动变成驼峰形式 这个逆向工程不能给类中的对象类型的属性赋值，不支持多表联查的那种形式 byExample就是指通过条件，这个方法是通过条件获得记录数 这个可以通过所有的属性来删除 1234567/** * This method was generated by MyBatis Generator. * This method corresponds to the database table t_emp * * @mbggenerated Thu Oct 20 11:30:05 CST 2022 */int countByExample(EmpExample example); 这个只能通过id来删除 1int deleteByPrimaryKey(Integer empId); insert和insertSelective方法差别是，insert如果插入null，就真的是null，insertSelective如果插入为null，则插入的是mysql默认值 123456789int insert(Emp record);/** * This method was generated by MyBatis Generator. * This method corresponds to the database table t_emp * * @mbggenerated Thu Oct 20 11:30:05 CST 2022 */int insertSelective(Emp record); selectByExample可以通过任意属性来查询 selectByPrimatyKey只可以通过id属性查询 123456789List&lt;Emp&gt; selectByExample(EmpExample example);/** * This method was generated by MyBatis Generator. * This method corresponds to the database table t_emp * * @mbggenerated Thu Oct 20 11:30:05 CST 2022 */Emp selectByPrimaryKey(Integer empId); updateByExampleSelective如果修改哪个字段为null，就不会修改这个字段 updateByExample是null，也会修改这个字段 123456789int updateByExampleSelective(@Param(&quot;record&quot;) Emp record, @Param(&quot;example&quot;) EmpExample example);/** * This method was generated by MyBatis Generator. * This method corresponds to the database table t_emp * * @mbggenerated Thu Oct 20 11:30:05 CST 2022 */int updateByExample(@Param(&quot;record&quot;) Emp record, @Param(&quot;example&quot;) EmpExample example); 这两个是根据主键来实现修改功能 加上Selective那个也是如果属性为null不会给字段赋值 123456789int updateByPrimaryKeySelective(Emp record);/** * This method was generated by MyBatis Generator. * This method corresponds to the database table t_emp * * @mbggenerated Thu Oct 20 11:30:05 CST 2022 */int updateByPrimaryKey(Emp record); test 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.atguigu.mybatis.test;import com.atguigu.mybatis.mapper.EmpMapper;import com.atguigu.mybatis.pojo.Emp;import com.atguigu.mybatis.pojo.EmpExample;import com.atguigu.mybatis.utils.SqlSessionUtil;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import java.util.List;public class MBGTest &#123;@Test public void testMBG()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); //根据id查询数据 /*Emp emp = mapper.selectByPrimaryKey(1); System.out.println(emp); */ /* 根据条件查寻，不加任何条件，就是查询全部 List&lt;Emp&gt; emps = mapper.selectByExample(null); emps.forEach(System.out::println);*、 */ /* 根据条件查询员工信息 example对象就是条件，createCriteria()方法之后加.and然后你想要关于name的条件就.andEmpName然后会有方法 要求条件姓名(是张三，且年龄大于19岁)或者(性别为男) 对应的sql语句： &lt;!--select emp_id, emp_name, age, gender, dept_id from t_emp WHERE ( emp_name = ? and age &gt; ? ) or( gender = ? )--&gt; EmpExample example=new EmpExample(); example.createCriteria().andEmpNameEqualTo(&quot;张三&quot;).andAgeGreaterThan(19); example.or().andGenderEqualTo(&quot;男&quot;); List&lt;Emp&gt; emps = mapper.selectByExample(example);emps.forEach(System.out::println);*/ /* 根据id来修改员工信息，所以emp对象中的id属性要和你想修改的那一行数据的id相同 */ /* updateByPrimaryKeySelective如果修改的属性为null就不会修改了 updateByPrimaryKey如果修改了为null就真是为null */ Emp emp=new Emp(1,&quot;小黑&quot;,null,&quot;女&quot;); // mapper.updateByPrimaryKey(emp);mapper.updateByPrimaryKeySelective(emp);&#125;&#125; 分页插件limit index,pageSize pageSize:每页显示的条数 pageNum:当前页的页码 index:当前页的起始索引 (pageNum-1)*pageSize 要显示的是第九条，那索引就是8 pageSize&#x3D;4，pageNum&#x3D;1，index&#x3D;0 limit 0,4 pageSize&#x3D;4，pageNum&#x3D;3，index&#x3D;8 limit 8,4 pageSize&#x3D;4，pageNum&#x3D;6，index&#x3D;20 limit 8,4 count：总记录数 totalPage：总页数 totalPage &#x3D; count &#x2F; pageSize; if(count % pageSize !&#x3D; 0) { totalPage +&#x3D; 1; } 分页插件的使用步骤添加依赖 pom.xml文件中添加依赖 123456&lt;!--分页插件的依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt;&lt;/dependency&gt; 配置插件分页 在mybatis-config.xml中加入 123&lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;&lt;/plugin&gt;&lt;/plugins&gt; 分页插件的使用这个测试显示的第二页的四条记录 12345678910111213141516171819202122232425262728package com.atguigu.mybatis.test;import com.atguigu.mybatis.mapper.EmpMapper;import com.atguigu.mybatis.pojo.Emp;import com.atguigu.mybatis.utils.SqlSessionUtil;import com.github.pagehelper.PageHelper;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import java.util.List;public class PageTest &#123; @Test public void testPage()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); //开启分页功能，参数是第几页和一页的记录数 //如果只有一个参数，则是每页有几条记录，默认显示第一页 PageHelper.startPage(2,4); //查询功能之前要开启分页功能 List&lt;Emp&gt; emps = mapper.selectByExample(null); emps.forEach(System.out::println); &#125;&#125; 优化 pageInfo是获取分页相关的所有数据比page要更详细一点 1PageInfo&lt;Emp&gt; pageInfo=new PageInfo&lt;&gt;(emps,5); 123456789101112131415161718192021222324252627@Testpublic void testPage()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); //开启分页功能，参数是第几页和一页的记录数 //如果只有一个参数，则是每页有几条记录，默认显示第一页 //page就是分页对象 Page&lt;Object&gt; page = PageHelper.startPage(2, 4); //查询功能之前要开启分页功能 List&lt;Emp&gt; emps = mapper.selectByExample(null); emps.forEach(System.out::println); //查询功能之后可以获取分页相关的所有数据 //navigatePages:导航分页的页码首页上一页【导航页】下一页末页 PageInfo&lt;Emp&gt; pageInfo=new PageInfo&lt;&gt;(emps,5); //输出pageInfo对象 System.out.println(pageInfo); //输出查询之后的分页对象 System.out.println(page);&#125; pageInfo的信息 可以从当中获取分页的信息，在进行分页处理的时候可以直接用 12345678910111213141516171819202122232425 /* pageInfo信息 */ //PageInfo&#123; // pageNum=2, pageSize=4, size=4, // startRow=5, endRow=8, total=30, // pages=8, list=Page&#123;count=true, pageNum=2, pageSize=4, startRow=4, endRow=8, total=30, pages=8, reasonable=false, pageSizeZero=false&#125;[Emp&#123;empId=5, empName=&#x27;a&#x27;, age=null, gender=&#x27;null&#x27;, deptId=null&#125;, Emp&#123;empId=6, empName=&#x27;aa&#x27;, age=null, gender=&#x27;null&#x27;, deptId=null&#125;, Emp&#123;empId=7, empName=&#x27;a&#x27;, age=null, gender=&#x27;null&#x27;, deptId=null&#125;, Emp&#123;empId=8, empName=&#x27;a&#x27;, age=null, gender=&#x27;null&#x27;, deptId=null&#125;], // prePage=1, nextPage=3, isFirstPage=false, // isLastPage=false, hasPreviousPage=true, // hasNextPage=true, navigatePages=5, // navigateFirstPage=1, navigateLastPage=5, navigatepageNums=[1, 2, 3, 4, 5]&#125;/*pageNum：当前页的页码pageSize：每页显示的条数size：当前页显示的真实条数total：总记录数pages：总页数prePage：上一页的页码nextPage：下一页的页码isFirstPage/isLastPage：是否为第一页/最后一页hasPreviousPage/hasNextPage：是否存在上一页/下一页navigatePages：导航分页的页码数navigatepageNums：导航分页的页码，[1,2,3,4,5] */","categories":[],"tags":[]},{"title":"spring","slug":"spring","date":"2022-11-04T15:31:35.000Z","updated":"2022-11-04T02:59:44.637Z","comments":true,"path":"2022/11/04/spring/","link":"","permalink":"http://example.com/2022/11/04/spring/","excerpt":"","text":"SpringSpring是一个轻量级框架 SpringFramework基础框架，其他所有的Spring都是以它为基础的 IOCIOC思想IOC：Inversion of Control，翻译过来是反转控制。 传统的： 在应用程序中的组件需要获取资源时，传统的方式是组件主动的从容器中获取所需要的资源，在这样的 模式下开发人员往往需要知道在具体容器中特定资源的获取方式，增加了学习成本，同时降低了开发效 率。 反转控制ioc： 反转控制的思想完全颠覆了应用程序组件获取资源的传统方式：反转了资源的获取方向——改由容器主 动的将资源推送给需要的组件，开发人员不需要知道容器是如何创建资源对象的，只需要提供接收资源 的方式即可，极大的降低了学习成本，提高了开发的效率。这种行为也称为查找的被动形式。 ioc思想总结 传统方式中需要我们自己去new对象，现在有了spring之后我们需要哪个对象通过springioc容器进行赋值就可以了，这个是通过DI来实现的，依赖哪个对象，就可以以提前定义好的方式（构造器，setter方法），被动的去接受spring所注入的对象 也就是依赖哪个对象，ioc就可以给哪个对象赋值 DI DI：Dependency Injection，翻译过来是依赖注入。 DI是IOC的一种实现方式，即组件以一些预先定义好的方式（例如：setter 方法）接受来自于ioc容器的资源注入。 接受ioc容器的资源注入其实就是接受ioc容器对属性的赋值 ioc容器在spring中的实现两种实现方式： BeanFactory: 这是 IOC 容器的基本实现，是 Spring 内部使用的接口。面向 Spring 本身，不提供给开发人员使用。 ApplicationContext: BeanFactory 的子接口，提供了更多高级特性。面向 Spring 的使用者，几乎所有场合都使用 ApplicationContext 而不是底层的 BeanFactory。 创建一个新的模块，测试spring 在pom.xml中导入依赖 12345678910111213141516&lt;packaging&gt;jar&lt;/packaging&gt;&lt;dependencies&gt; &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ioc的实现类 最常用的是ClassPathXmlApplicationContext是实现类，因为它是从工程路径中读取ioc容器（也就是那个spring的xml配置文件） FileSystemXmlApplicationContext是通过硬盘路径读取ioc容器，之后工程要打包成jar不一定在自己的计算机上执行，所以不用这个 基于xml管理bean入门案例创建module，引入依赖，上面做过了 pom.xml 123456789101112131415&lt;dependencies&gt; &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建类Helloword 在java下新建com.atguigu.spring.pojo包下 12345678package com.atguigu.spring.pojo;public class HelloWorld &#123; public void sayHello()&#123; System.out.println(&quot;hello spring&quot;); &#125;&#125; 创建Spring配置文件在resources文件夹下 applicationContext.xml springioc的配置文件 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- bean:配置一个bean对象，将对象交给ioc容器管理 属性： id: bean的唯一标识 class:设置bean对象所对应的类型的全类名 --&gt; &lt;bean id=&quot;helloworld&quot; class=&quot;com.atguigu.spring.pojo.HelloWorld&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; test 1234567891011121314151617181920package com.atguigu.spring.test;import com.atguigu.spring.pojo.HelloWorld;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class HelloWorldTest &#123; @Test public void test()&#123; //获取IOC容器 //new ClassPathXmlApplicationContext直接定位到targer/classes下，java和resources加载后都在这个下面 ApplicationContext ioc=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //根据bean的id当作name来作为getBean参数获取对象,然后自己强转 HelloWorld helloworld = (HelloWorld) ioc.getBean(&quot;helloworld&quot;); helloworld.sayHello(); &#125;&#125; new ClassPathXmlApplicationContext(“applicationContext.xml”);定位到target&#x2F;classes&#x2F;下，就是java和resources加载之后其实都是在target&#x2F;classes&#x2F;下 ioc容器获取bean的方式重新建一个模块，spring_ioc_xml 创建一个student类在java包下的com.atguigu.spring.pojo包中 Student 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.atguigu.spring.pojo;public class Student &#123;private Integer sid; public Student() &#123; &#125; public Student(Integer sid, String sname, Integer age, String gender) &#123; this.sid = sid; this.sname = sname; this.age = age; this.gender = gender; &#125; public String getGender() &#123; return gender; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;sid=&quot; + sid + &quot;, sname=&#x27;&quot; + sname + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public Integer getSid() &#123; return sid; &#125; public void setSid(Integer sid) &#123; this.sid = sid; &#125; public String getSname() &#123; return sname; &#125; public void setSname(String sname) &#123; this.sname = sname; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; private String sname;private Integer age;private String gender;&#125; ioc创建对象原理就是反射，配置文件中给了全类名之后用.forName()方法获得这个类的Class对象，然后再newInstance创建实体类对象 所以pojo类中一定要有无参构造，通过反射创建对象大部分都是用无参构造 获取bean对象的三种方法 1.通过bean的id获取 2.根据bean的类型 3.根据bean的id和bean的类型 test 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.atguigu.spring.test;import com.atguigu.spring.pojo.Person;import com.atguigu.spring.pojo.Student;import com.sun.glass.ui.Application;import com.sun.org.apache.bcel.internal.util.ClassPath;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import sun.security.mscapi.CPublicKey;public class IOCByXMLTest &#123; @Test public void testIOC() &#123; //获取ioc容器 ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean //根据id来获取 //Student studentOne = (Student)ioc.getBean(&quot;studentOne&quot;); //通过类型来获取(用的多，因为一个类型的bean只需要写一次就够了) /* &lt;bean id=&quot;studentOne&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;studentTwo&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt;&lt;/bean&gt; 如果就是有两个id不一样但是class相同的bean就没法通过类型来获取，会报错NoUniqueBeanDefinitionException 如果没有相匹配的bean,也会报NoSuchBeanDefinitionException错 Student studentOne = ioc.getBean(Student.class); */ /* 根据bean的id和类型来获取 Student studentOne = ioc.getBean(&quot;studentOne&quot;, Student.class); */ /* 当有一个接口只有一个实现类的时候，可以通过接口的类型获取这个接口实现类的对象，同时是把这个实现类对象赋值给接口引用变量 */ Person studentOne = ioc.getBean(Person.class); System.out.println(studentOne); &#125;&#125; 当有一个接口只有一个实现类的时候，可以通过接口的类型获取这个接口实现类的对象，同时是把这个实现类对象赋值给接口引用变量 Person接口 1234package com.atguigu.spring.pojo;public interface Person &#123;&#125; Student implements Person test 12345/*当有一个接口只有一个实现类的时候，可以通过接口的类型获取这个接口实现类的对象，同时是把这个实现类对象赋值给接口引用变量 */Person studentOne = ioc.getBean(Person.class);System.out.println(studentOne); 小结： 根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 instanceof 指定的类 型』的返回结果，只要返回的是true就可以认定为和类型匹配，能够获取到。 即通过bean的类型，只被bean继承的类的类型，只被bean所实现的接口的类型都可以获取bean 依赖注入setter注入Student类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.atguigu.spring.pojo;public class Student implements Person &#123;private Integer sid; public Student() &#123; &#125; public Student(Integer sid, String sname, Integer age, String gender) &#123; this.sid = sid; this.sname = sname; this.age = age; this.gender = gender; &#125; public String getGender() &#123; return gender; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;sid=&quot; + sid + &quot;, sname=&#x27;&quot; + sname + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public Integer getSid() &#123; return sid; &#125; public void setSid(Integer sid) &#123; this.sid = sid; &#125; public String getSname() &#123; return sname; &#125; public void setSname(String sname) &#123; this.sname = sname; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; private String sname;private Integer age;private String gender;&#125; applicationContext.xml 123456789101112&lt;bean id=&quot;studentTwo&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt; &lt;!-- property:通过成员变量的set方法进行赋值 name:设置需要赋值的属性名(和set方法有关) value:设置为属性所附的值 --&gt; &lt;property name=&quot;sid&quot; value=&quot;1001&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sname&quot; value=&quot;张三&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/property&gt;&lt;/bean&gt; test 123456789@Testpublic void testDI()&#123; //获取ioc容器 ApplicationContext ioc= new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean Student student = ioc.getBean(&quot;studentTwo&quot;, Student.class); System.out.println(student);&#125; 结果： Student{sid&#x3D;1001, sname&#x3D;’张三’, age&#x3D;23, gender&#x3D;’男’} 依赖注入之构造器注入applicationContext.xml 1234567&lt;bean id=&quot;studentThree&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt; &lt;constructor-arg value=&quot;1002&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;李四&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;24&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;女&quot; &gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 这个的赋值顺序就是按照构造器的中参数顺序进行赋值的 123456public Student(Integer sid, String sname, Double score, String gender) &#123; this.sid = sid; this.sname = sname; this.gender=gender; this.score=score;&#125; 如果有两个参数个数重复且不一样的参数的地方类型可兼容的构造器，可以用name属性 12345678910111213public Student(Integer sid, String sname, Integer age, String gender) &#123; this.sid = sid; this.sname = sname; this.age = age; this.gender = gender;&#125;public Student(Integer sid, String sname, Double score, String gender) &#123; this.sid = sid; this.sname = sname; this.gender=gender; this.score=score;&#125; applicationContext.xml name是指构造器的参数的名字，这样即使调用的给age赋值的构造器，而不是给score赋值的构造器 1234567&lt;bean id=&quot;studentThree&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt; &lt;constructor-arg value=&quot;1002&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;李四&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;24&quot; name=&quot;age&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;女&quot; &gt;&lt;/constructor-arg&gt;&lt;/bean&gt; test 123456789@Testpublic void testDI2()&#123; //获取ioc容器 ApplicationContext ioc= new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean Student student = ioc.getBean(&quot;studentThree&quot;, Student.class); System.out.println(student);&#125; 如果不确定的话 其实可以把bean对象全都加上name标签，这样就可以一一对应了 特殊值处理1,给属性赋值字面量 什么是字面量？ int a &#x3D; 10; 声明一个变量a，初始化为10，此时a就不代表字母a了，而是作为一个变量的名字。当我们引用a 的时候，我们实际上拿到的值是10。 而如果a是带引号的：’a’，那么它现在不是一个变量，它就是代表a这个字母本身，这就是字面量。所以字面量没有引申含义，就是我们看到的这个数据本身。 12&lt;!-- 使用value属性给bean的属性赋值时，Spring会把value属性的值看做字面量 --&gt;&lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt; 2.给属性设置null值 123456789&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt; &lt;property name=&quot;sid&quot; value=&quot;100&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sname&quot; value=&quot;王五&quot;&gt;&lt;/property&gt; &lt;!--给属性设置null--&gt; &lt;property name=&quot;gender&quot;&gt; &lt;null /&gt; &lt;/property&gt;&lt;/bean&gt; 注意： 以下写法，为name所赋的值是字符串nul 1&lt;property name=&quot;name&quot; value=&quot;null&quot;&gt;&lt;/property&gt; 3.xml实体 &lt;和&gt;在xml中是特殊字符， 1所以得用&amp;lt;和&amp;gt;代替 1234567891011121314&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt; &lt;property name=&quot;sid&quot; value=&quot;100&quot;&gt;&lt;/property&gt; &lt;!-- &lt;: &amp;lt; &gt;: &amp;gt; --&gt; &lt;property name=&quot;sname&quot; value=&quot;&amp;lt;王五&amp;gt;&quot;&gt;&lt;/property&gt; &lt;!--给属性设置null--&gt; &lt;property name=&quot;gender&quot;&gt; &lt;null /&gt; &lt;/property&gt;&lt;/bean&gt; 12输出Student&#123;sid=100, score=null, sname=&#x27;&lt;王五&gt;&#x27;, age=null, gender=&#x27;null&#x27;&#125; 4.CDATA节 用CDATA节要把value属性拿出来，在里面用作标签，然后中间内容可以随便写 1&lt;![CDATA[中间]]&gt; 1234567&lt;property name=&quot;sname&quot;&gt; &lt;!-- 解决方案二：使用CDATA节 --&gt; &lt;!-- CDATA中的C代表Character，是文本、字符的含义，CDATA就表示纯文本数据 --&gt; &lt;!-- XML解析器看到CDATA节就知道这里是纯文本，就不会当作XML标签或属性来解析 --&gt; &lt;!-- 所以CDATA节中写什么符号都随意 --&gt; &lt;value&gt;&lt;![CDATA[&lt;王五&gt;]]&gt;&lt;/value&gt; &lt;/property&gt; 123456789101112131415161718192021&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt; &lt;property name=&quot;sid&quot; value=&quot;100&quot;&gt;&lt;/property&gt; &lt;!-- &lt;: &amp;lt; &gt;: &amp;gt; --&gt; &lt;property name=&quot;sname&quot;&gt; &lt;!-- 解决方案二：使用CDATA节 --&gt; &lt;!-- CDATA中的C代表Character，是文本、字符的含义，CDATA就表示纯文本数据 --&gt; &lt;!-- XML解析器看到CDATA节就知道这里是纯文本，就不会当作XML标签或属性来解析 --&gt; &lt;!-- 所以CDATA节中写什么符号都随意 --&gt; &lt;value&gt;&lt;![CDATA[&lt;王五&gt;]]&gt;&lt;/value&gt; &lt;/property&gt; &lt;!--给属性设置null--&gt; &lt;property name=&quot;gender&quot;&gt; &lt;null /&gt; &lt;/property&gt;&lt;/bean&gt; 为类类型属性赋值给Student加一个clazz对象属性 第一种方式（用的多）：引入外部的bean 这个是属性是一个类的对象的赋值操作 applicationContext.xml 123456789101112131415&lt;bean id=&quot;studentFive&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt; &lt;property name=&quot;sid&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sname&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/property&gt; &lt;!--给对象属性进行赋值--&gt; &lt;!--应用当前ioc中某一个bean的id来为clazz对象赋值--&gt; &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;clazzOne&quot; class=&quot;com.atguigu.spring.pojo.Clazz&quot;&gt; &lt;property name=&quot;cid&quot; value=&quot;1111&quot;&gt;&lt;/property&gt; &lt;property name=&quot;cname&quot; value=&quot;最强王者班&quot;&gt;&lt;/property&gt;&lt;/bean&gt; test 123456789@Testpublic void testDI2()&#123; //获取ioc容器 ApplicationContext ioc= new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean Student student = ioc.getBean(&quot;studentFive&quot;, Student.class); System.out.println(student);&#125; 结果：Student{sid&#x3D;1004, score&#x3D;null, clazz&#x3D;Clazz{cid&#x3D;1111, cname&#x3D;’最强王者班’}, sname&#x3D;’赵六’, age&#x3D;26, gender&#x3D;’男’} 第二种方法： 级联的方式，但提前要为clazz属性赋值 1234567891011&lt;bean id=&quot;studentFive&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt; &lt;property name=&quot;sid&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sname&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/property&gt; &lt;!--ref:应用ioc容器中的某一个bean的值--&gt; &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazz.cid&quot; value=&quot;222&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazz.cname&quot; value=&quot;远大前程班&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 第三种方法： 这个是通过内部bean的方式进行赋值的，这个内部bean只能在它外部bean的内部来使用，不能通过ioc容器来直接获取 1234567891011121314&lt;bean id=&quot;studentFive&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt; &lt;property name=&quot;sid&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sname&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazz&quot;&gt; &lt;!--内部bean的使用--&gt; &lt;bean id=&quot;clazzInner&quot; class=&quot;com.atguigu.spring.pojo.Clazz&quot;&gt; &lt;property name=&quot;cid&quot; value=&quot;222&quot;&gt;&lt;/property&gt; &lt;property name=&quot;cname&quot; value=&quot;远大前程班&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 为数组类型的属性赋值给Student加一个private String[]hobby属性 当数组中是字面量类型的数据的时候，用value标签 12345678910111213141516171819202122&lt;bean id=&quot;studentFive&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt; &lt;property name=&quot;sid&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sname&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazz&quot;&gt; &lt;bean id=&quot;clazzInner&quot; class=&quot;com.atguigu.spring.pojo.Clazz&quot;&gt; &lt;property name=&quot;cid&quot; value=&quot;222&quot;&gt;&lt;/property&gt; &lt;property name=&quot;cname&quot; value=&quot;远大前程班&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!--给数组变量赋值--&gt; &lt;property name=&quot;hobby&quot;&gt; &lt;array&gt; &lt;value&gt;抽烟&lt;/value&gt; &lt;value&gt;喝酒&lt;/value&gt; &lt;value&gt;烫头&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 给Clazz加一个private Student[] stus属性，给元素是对象的数组赋值用ref 12345678910&lt;bean id=&quot;clazzTwo&quot; class=&quot;com.atguigu.spring.pojo.Clazz&quot;&gt; &lt;property name=&quot;cid&quot; value=&quot;2222&quot;&gt;&lt;/property&gt; &lt;property name=&quot;cname&quot; value=&quot;好办&quot;&gt;&lt;/property&gt; &lt;property name=&quot;stus&quot;&gt; &lt;array&gt; &lt;ref bean=&quot;studentFive&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;studentFour&quot;&gt;&lt;/ref&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; test 123456789@Testpublic void testDI2()&#123; //获取ioc容器 ApplicationContext ioc= new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean Clazz clazz = ioc.getBean(&quot;clazzTwo&quot;, Clazz.class); System.out.println(clazz);&#125; 结果：Clazz{cid&#x3D;2222, stus&#x3D;[Student{sid&#x3D;1004, hobby&#x3D;[抽烟, 喝酒, 烫头], score&#x3D;null, clazz&#x3D;Clazz{cid&#x3D;222, stus&#x3D;null, cname&#x3D;’远大前程班’}, sname&#x3D;’赵六’, age&#x3D;26, gender&#x3D;’男’}, Student{sid&#x3D;100, hobby&#x3D;null, score&#x3D;null, clazz&#x3D;null, sname&#x3D;’&lt;王五&gt;’, age&#x3D;null, gender&#x3D;’null’}], cname&#x3D;’好办’} 为集合类型的属性进行赋值为list集合赋值 第一种： 这个是对list集合中如果存储的是对象类型的数据时list标签中用ref ，如果list集合中存储的是字面量类型的那就是用value标签，和上面的数组类型差不多 12345678910111213&lt;!--list集合中存储的是对象类型的进行赋值--&gt;&lt;bean id=&quot;clazzOne&quot; class=&quot;com.atguigu.spring.pojo.Clazz&quot;&gt; &lt;property name=&quot;cid&quot; value=&quot;1111&quot;&gt;&lt;/property&gt; &lt;property name=&quot;cname&quot; value=&quot;最强王者班&quot;&gt;&lt;/property&gt; &lt;property name=&quot;students&quot; &gt; &lt;list&gt; &lt;ref bean=&quot;studentFive&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;studentFour&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;studentThree&quot;&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 第二种： 用list类型的bean对它直接进行赋值 1234567891011121314&lt;!--list集合中存储的是对象类型的进行赋值--&gt;&lt;bean id=&quot;clazzOne&quot; class=&quot;com.atguigu.spring.pojo.Clazz&quot;&gt; &lt;property name=&quot;cid&quot; value=&quot;1111&quot;&gt;&lt;/property&gt; &lt;property name=&quot;cname&quot; value=&quot;最强王者班&quot;&gt;&lt;/property&gt; &lt;property name=&quot;students&quot; ref=&quot;studentsList&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--配置一个集合类型的bean，需要使用util的约束，也就是util的标签--&gt;&lt;!--util是标签得前缀，用来区分各种list标签--&gt;&lt;util:list id=&quot;studentsList&quot;&gt; &lt;ref bean=&quot;studentOne&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;studentTwo&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;studentThree&quot;&gt;&lt;/ref&gt;&lt;/util:list&gt; test 123456789@Testpublic void testDI2()&#123; //获取ioc容器 ApplicationContext ioc= new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean Clazz clazz = ioc.getBean(&quot;clazzOne&quot;, Clazz.class); System.out.println(clazz);&#125; 为map集合类型的属性赋值 创建一个Teacher类 给Student中添加一个private Map&lt;String,Teacher&gt; teacherMap;对象用来存储老师的map集合 第一种方式： 12345678910111213141516171819202122&lt;bean id=&quot;studentFive&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt; &lt;property name=&quot;sid&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sname&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/property&gt; &lt;property name=&quot;teacherMap&quot;&gt; &lt;!--一个entry表示一个键值对，key如果是字面量就用key属性，如果是对象就用key-ref value也是同理--&gt; &lt;map&gt; &lt;entry key=&quot;10086&quot; value-ref=&quot;teacherOne&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;10010&quot; value-ref=&quot;teacherTwo&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;teacherOne&quot; class=&quot;com.atguigu.spring.pojo.Teacher&quot;&gt; &lt;property name=&quot;tid&quot; value=&quot;10086&quot;&gt;&lt;/property&gt; &lt;property name=&quot;tname&quot; value=&quot;大宝&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;teacherTwo&quot; class=&quot;com.atguigu.spring.pojo.Teacher&quot;&gt; &lt;property name=&quot;tid&quot; value=&quot;10011&quot;&gt;&lt;/property&gt; &lt;property name=&quot;tname&quot; value=&quot;小宝&quot;&gt;&lt;/property&gt;&lt;/bean&gt; test 123456789@Testpublic void testDI()&#123; //获取ioc容器 ApplicationContext ioc= new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean Student student = ioc.getBean(&quot;studentFive&quot;, Student.class); System.out.println(student);&#125; 第二种方式： 设置一个map类型的bean，然后直接进行引用赋值 1234567891011121314151617181920212223 &lt;bean id=&quot;studentFive&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt; &lt;property name=&quot;sid&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sname&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/property&gt; &lt;!--直接对map类型的bean进行引用--&gt; &lt;property name=&quot;teacherMap&quot; ref=&quot;teacherMap&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--创建一个map类型的bean--&gt;&lt;util:map id=&quot;teacherMap&quot;&gt; &lt;entry key=&quot;10086&quot; value-ref=&quot;teacherOne&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;10010&quot; value-ref=&quot;teacherTwo&quot;&gt;&lt;/entry&gt;&lt;/util:map&gt; &lt;bean id=&quot;teacherOne&quot; class=&quot;com.atguigu.spring.pojo.Teacher&quot;&gt; &lt;property name=&quot;tid&quot; value=&quot;10086&quot;&gt;&lt;/property&gt; &lt;property name=&quot;tname&quot; value=&quot;大宝&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;teacherTwo&quot; class=&quot;com.atguigu.spring.pojo.Teacher&quot;&gt; &lt;property name=&quot;tid&quot; value=&quot;10011&quot;&gt;&lt;/property&gt; &lt;property name=&quot;tname&quot; value=&quot;小宝&quot;&gt;&lt;/property&gt; &lt;/bean&gt; test 12345678910@Testpublic void testDI()&#123; //获取ioc容器 ApplicationContext ioc= new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean Student student = ioc.getBean(&quot;studentFive&quot;, Student.class); System.out.println(student);&#125; 依赖注入之p命名空间12&lt;bean id=&quot;studentSix&quot; class=&quot;com.atguigu.spring.pojo.Student&quot; p:sid=&quot;1005&quot; p:sname=&quot;张三&quot; p:teacherMap-ref=&quot;teacherMap&quot;&gt;&lt;/bean&gt; p属性中每一个类的属性都由两种选项，p:属性名 p:属性名-ref 第一种是直接给字面量类型的属性赋值 第二种是给对象类型的属性赋值，引入bean，给list或者map集合类型赋值也用到这个 test 123456789@Testpublic void testDI()&#123; //获取ioc容器 ApplicationContext ioc= new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean Student student = ioc.getBean(&quot;studentSix&quot;, Student.class); System.out.println(student);&#125; Spring管理数据源合引入外部属性文件（spring连接数据库）说白了就是用spring去连接数据库 ①加入依赖 123456789101112&lt;!-- MySQL驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 数据源 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.31&lt;/version&gt;&lt;/dependency&gt; 创建jdbc.properties存储连接数据库的信息 1234jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=UTCjdbc.username=rootjdbc.password=root spring-datasource.xml 1234567891011&lt;!--引入jdbc.properties文件,之后可以通过$&#123;key&#125;的方式进行访问--&gt;&lt;!--在同一个文件下，可以直接访问--&gt;&lt;context:property-placeholder location=&quot;jdbc.properties&quot;&gt;&lt;/context:property-placeholder&gt;&lt;!--这个class是DataSource接口的实现类--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt;&lt;/bean&gt; test 12345678@Testpublic void testDataSource() throws SQLException &#123; ApplicationContext ioc= new ClassPathXmlApplicationContext(&quot;spring-datasource.xml&quot;); //创建了一个dataSource类型对象 DruidDataSource bean = ioc.getBean(DruidDataSource.class); //获取连接并输出 System.out.println(bean.getConnection());&#125; bean的作用域在Spring中可以通过配置bean标签的scope属性来指定bean的作用域范围，各取值含义参加下表： 默认是单例模式 就是通过同一个bean得到的对象都是同一个对象 新创建了一个spring-scope.xml 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;student&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt; &lt;property name=&quot;sid&quot; value=&quot;1001&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sname&quot; value=&quot;张三&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; test 输出结果是true所以就是单例模式 12345678910111213141516/*验证spring所管理的bean默认是单例模式，就是每次 */@Testpublic void testScope()&#123; ApplicationContext ioc=new ClassPathXmlApplicationContext(&quot;spring-scope.xml&quot;); Student student1 = ioc.getBean(Student.class); Student student2=ioc.getBean(Student.class); /* 正常==和equals方法都是相同的都是比较地址 但String中重写了equals方法变成了比较内容 */ System.out.println(student1.equals(student2));//true&#125; 现在要把这个bean改为多例模式，就是同一个bean每次获取的对象都不一样 在bean中加一个属性scope设置多例就可以 12345678910&lt;!--scope来设置bean的作用域--&gt;&lt;!--scope=singleton/prototype 单例模式/多例模式singleton（单例）:表示获取该bean所对应的对象都是同一个prototype（多例）:表示获取bean所对应的对象都不是同一个--&gt;&lt;bean id=&quot;student&quot; class=&quot;com.atguigu.spring.pojo.Student&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;sid&quot; value=&quot;1001&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sname&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;&lt;/bean&gt; test 12345678910111213@Testpublic void testScope()&#123; ApplicationContext ioc=new ClassPathXmlApplicationContext(&quot;spring-scope.xml&quot;); Student student1 = ioc.getBean(Student.class); Student student2=ioc.getBean(Student.class); /* 正常==和equals方法都是相同的都是比较地址 但String中重写了equals方法变成了比较内容 */ System.out.println(student1.equals(student2));&#125; 输出是false 除了singleton和prototype还有两种不常用的 bean的生命周期创建User对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.atguigu.spring.pojo;public class User &#123; private Integer id; private String username; private String password; private Integer age; public User() &#123; System.out.println(&quot;生命周期：1、创建对象&quot;); &#125; public User(Integer id, String username, String password, Integer age) &#123; this.id = id; this.username = username; this.password = password; this.age = age; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; System.out.println(&quot;生命周期：2、依赖注入&quot;); this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void initMethod() &#123; System.out.println(&quot;生命周期：3、初始化&quot;); &#125; public void destroyMethod() &#123; System.out.println(&quot;生命周期：5、销毁&quot;); &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 1.实例化 2.依赖注入 3.初始化，需要通过bean的init-method属性指定初始化方法 4.可以使用创建的对象 5.ioc容器关闭时销毁，需要通过bean的destroy-method属性指定销毁方法 1init-method=&quot;initMethod&quot; destroy-method=&quot;destroyMethod&quot; 123456&lt;bean id=&quot;user&quot; class=&quot;com.atguigu.spring.pojo.User&quot; init-method=&quot;initMethod&quot; destroy-method=&quot;destroyMethod&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;admin&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;&lt;/bean&gt; test 123456789@Testpublic void test()&#123; //ConfigurableApplicationContext是ApplicationContext的子接口扩展了刷新和关闭容器的方法，所以这地方用它关闭ioc ConfigurableApplicationContext ioc= new ClassPathXmlApplicationContext(&quot;spring-lifecycle.xml&quot;); User user = ioc.getBean(User.class); System.out.println(&quot;生命周期：4.使用对象&quot;); ioc.close();&#125; 不同作用域对bean的生命周期的影响注意： 若bean的作用域为单例时，生命周期的前三个步骤会在获取ioc容器的时候执行 因为如果是单例，直接就能知道要获取什么对象可以提前创建出来 若bean的作用域为多例时，生命周期的前三个步骤会在获取bean时执行 多例的话，每次都是创建新的对象，所以不会提前创建，而且销毁方法也不由ioc绝顶 bean的后置处理器在java下新建com.atguigu.spring.process包下创建BeanpostProfessor 要实现BeanPostProcessor接口，才能做后置处理器，实现两个方法 可以利用这两个方法对要获取的bean对象进行操作 1234567891011121314151617181920package com.atguigu.spring.process;import org.springframework.beans.BeansException;public class BeanPostProcessor implements org.springframework.beans.factory.config.BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; //此方法在bean的生命周期初始化之前执行 //这个参数bean就是那个要获得的对象，你可以在这里面对它进行一些操作 System.out.println(&quot;后置处理器---&gt;postProcessBeforeInitialization&quot;); return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; //此方法在bean的生命周期初始化之后执行 System.out.println(&quot;后置处理器---&gt;postProcessAfterInitialization&quot;); return bean; &#125;&#125; 在ioc中配置也就是spring-lifecycle.xml中配置后置处理器 注意：这个后置处理器对ioc中的每一个bean都生效 1&lt;bean class=&quot;com.atguigu.spring.process.BeanPostProcessor&quot;&gt;&lt;/bean&gt; test 12345678@Testpublic void test()&#123; //ConfigurableApplicationContext是ApplicationContext的子接口扩展了刷新和关闭容器的方法，所以这地方用它关闭ioc ConfigurableApplicationContext ioc= new ClassPathXmlApplicationContext(&quot;spring-lifecycle.xml&quot;); User user = ioc.getBean(User.class); System.out.println(&quot;生命周期：4.使用对象&quot;); ioc.close();&#125; 结果： 生命周期：1、创建对象生命周期：2、依赖注入：为属性赋值后置处理器—&gt;postProcessBeforeInitialization生命周期：3、初始化后置处理器—&gt;postProcessAfterInitialization生命周期：4.使用对象生命周期：5、销毁 具体的生命周期的所有过程 FactoryBean原本是BeanFactory是先获得工厂，在获取工厂所提供的bean FactoryBean是一个接口：需要创建一个类实现接口 其中三个方法： getObject():提供一个对象交给ioc容器管理 getObjectType():设置所提供对象的类型 isSingleton():所提供的对象是否单例 当我们把FactoryBean的实现类配置为bean时，会将我们当前类中的getObject()方法所返回的对象交给ioc容器管理 现在是把FactoryBean配置到ioc直接获得FactoryBean所提供的bean，节省了获取工厂这个环节 UserFactoryBean实现了FactoryBean接口 1234567891011121314151617package com.atguigu.spring.factory;import com.atguigu.spring.pojo.User;import org.springframework.beans.factory.FactoryBean;public class UserFactoryBean implements FactoryBean&lt;User&gt; &#123; @Override public User getObject() throws Exception &#123; return new User(); &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return User.class; &#125;&#125; 在spring-factory中配置 12&lt;!--其实真正交给ioc来管理的是getObject方法中返回的对象--&gt;&lt;bean class=&quot;com.atguigu.spring.factory.UserFactoryBean&quot;&gt;&lt;/bean&gt; test 1234567@Testpublic void testFactoryBean()&#123; ApplicationContext ioc=new ClassPathXmlApplicationContext(&quot;spring-factory.xml&quot;); User user=ioc.getBean(User.class); System.out.println(user);&#125; 普通工厂需要先把工厂配置成一个bean，然后获取ioc容器，获取工厂对应的对象，再获取工厂所提供的对象 基于xml的自动装配之场景模拟自动装配： 根据指定的策略，在IOC容器中匹配某一个bean，自动为指定的bean中所依赖的类类型或接口类型属性赋值 控制层（javaweb中是servlet，现在是controller）调用service进行业务逻辑，service层调用dao实现持久化操作 UserController（相当于Servlet） 123456789101112131415161718192021package com.atguigu.spring.Controller;import com.atguigu.spring.service.UserService;public class UserController &#123; private UserService userService; public UserService getUserService() &#123; return userService; &#125; public void setUserService(UserService userService) &#123; this.userService = userService; &#125; public void saveuser()&#123; userService.saveUser(); &#125;&#125; UserDao 123456789package com.atguigu.spring.dao;public interface UserDao &#123; /* 保存用户信息 */ void saveUser();&#125; UserDaoImpl 12345678910package com.atguigu.spring.dao.Impl;import com.atguigu.spring.dao.UserDao;public class UserDaoImpl implements UserDao &#123; @Override public void saveUser() &#123; System.out.println(&quot;保存成功&quot;); &#125;&#125; UserService 123456789package com.atguigu.spring.service;public interface UserService &#123; /* 保存用户信息 */ void saveUser();&#125; UserServiceImpl 123456789101112131415161718192021222324package com.atguigu.spring.service.impl;import com.atguigu.spring.dao.UserDao;import com.atguigu.spring.service.UserService;public class UserServiceImpl implements UserService &#123;private UserDao userDao; public UserDao getUserDao() &#123; return userDao; &#125; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; /* 保存用户信息 */ @Override public void saveUser() &#123; userDao.saveUser(); &#125;&#125; spring配置文件 spring-autowire-xml.xml 控制层（javaweb中是servlet，现在是controller）调用service进行业务逻辑，service层调用dao实现持久化操作 实现controller层依赖service层，service层依赖dao层 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;userController&quot; class=&quot;com.atguigu.spring.Controller.UserController&quot;&gt; &lt;property name=&quot;userService&quot; ref=&quot;userService&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.atguigu.spring.service.impl.UserServiceImpl&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.atguigu.spring.dao.Impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; UserController中有用到userService对象属性，这里可以给他进行赋值 UserService中用到userDao对象属性，这里可以给它赋值 这样如果userService属性要改变的话，可以直接在这里改bean，而不是去改源代码 test 12345678910111213141516package com.atguigu.spring.test;import com.atguigu.spring.Controller.UserController;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AutowireByXMLTest &#123; @Test public void testAutowire()&#123; ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;spring-autowire-xml.xml&quot;); UserController userController = ioc.getBean(UserController.class); userController.saveuser(); &#125;&#125; 基于xml自动装配值自动装配必须要有这个属性的get和set方法，主要set方法 其实自动装配用得很多，但是基于xml的自动装配用的很少，因为用了xml的自动装配，你所有的类类型属性的赋值都会遵循自动装配，所以很难用 所以常用的是注解类型的自动装配 12345678910111213自动装配： 根据指定的策略，在ioc容器中匹配某一个bean，为当前设置了自动装配的bean中的类类型的属性或者接口类型的属性赋值 自动装配的策略： no，default：表示不装配，即设置策略的bean中的属性不会自动匹配某个ioc中的bean为属性赋值，此时属性使用默认值（默认值也就是类中用代码的死赋值，如果没有就是null） byType:根据当前要进行赋值的属性的类型去ioc容器中匹配一个类型相同(接口的实现类或者子类)的bean进行赋值 注意：若在ioc一个类型匹配的bean都找不到，此时不装配，属性使用的是默认值 若在ioc中有多个类型匹配的bean就会报错，NoUniqueBeanDefinitionException 总结：当使用byType实现自动装配的时候，ioc容器有且只有一个类型匹配的bean能够为属性赋值 byName:根据要赋值的属性的属性名作为id来匹配日ioc中的bean，如果二者相同，则可以为属性赋值 如果没有匹配的bean，属性就会使用默认值（默认值也就是类中用代码的死赋值，如果没有就是null） 总结byName一般用在就是byType用不了的时候，比如有多个bean都是同一个类型的情况 byType 用了byType之后，会自动给UserController中的userService属性赋值，只要ioc中有类型相同的bean 1autowire=&quot;byType&quot; spring-autowire-xml.xml 123456789&lt;bean id=&quot;userController&quot; class=&quot;com.atguigu.spring.Controller.UserController&quot; autowire=&quot;byType&quot;&gt; &lt;!--&lt;property name=&quot;userService&quot; ref=&quot;userService&quot;&gt;&lt;/property&gt;--&gt;&lt;/bean&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.atguigu.spring.service.impl.UserServiceImpl&quot; autowire=&quot;byType&quot;&gt; &lt;!--&lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;--&gt;&lt;/bean&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.atguigu.spring.dao.Impl.UserDaoImpl&quot;&gt;&lt;/bean&gt; byName 12345678910111213&lt;bean id=&quot;userController&quot; class=&quot;com.atguigu.spring.Controller.UserController&quot; autowire=&quot;byName&quot;&gt; &lt;!--&lt;property name=&quot;userService&quot; ref=&quot;userService&quot;&gt;&lt;/property&gt;--&gt;&lt;/bean&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.atguigu.spring.service.impl.UserServiceImpl&quot; autowire=&quot;byName&quot;&gt; &lt;!--&lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;--&gt;&lt;/bean&gt;&lt;bean id=&quot;userService1&quot; class=&quot;com.atguigu.spring.service.impl.UserServiceImpl&quot; autowire=&quot;byName&quot;&gt; &lt;!--&lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;--&gt;&lt;/bean&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.atguigu.spring.dao.Impl.UserDaoImpl&quot;&gt;&lt;/bean&gt; test 1234567891011121314151617package com.atguigu.spring.test;import com.atguigu.spring.Controller.UserController;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AutowireByXMLTest &#123; @Test public void testAutowire()&#123; ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;spring-autowire-xml.xml&quot;); UserController userController = ioc.getBean(UserController.class); userController.saveuser(); &#125;&#125; 基于注解管理bean注解：和xml配置文件一样，注解本身并不能运行，注解本身仅仅是做一个标记，具体的功能是框架检测 到注解标记的位置，然后针对这个位置按照注解标记的功能来执行具体操作。 本质上：所有一切的操作都是Java代码来完成的，XML和注解只是告诉框架中的Java代码如何执行。 扫描： Spring 为了知道程序员在哪些地方标记了什么注解，就需要通过扫描的方式，来进行检测。然后根据注 解进行后续操作。 注解和扫描新建Module spring_ioc_annotation pom.xml中 添加依赖 123456789101112131415&lt;dependencies&gt; &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建spring配置文件 创建三层架构dao，service，controller 然后分别在这些实现类和controller上加上对应的注解 加上注解的类就相当于在ioc容器中加上了一个这个类的bean，所以注解是要加到实现类上的 标识组件的常用注解： @Component：将类标识为普通组件 @Controller:将类标识为控制层组件 @Service:将类标识为业务层组件 @Repository:将类标识为持久层组件 通过查看源码我们得知，@Controller、@Service、@Repository这三个注解只是在@Component注解 的基础上起了三个新的名字。 对于Spring使用IOC容器管理这些组件来说没有区别。所以@Controller、@Service、@Repository这 三个注解只是给开发人员看的，让我们能够便于分辨组件的作用。 注意：虽然它们本质上一样，但是为了代码的可读性，为了程序结构严谨我们肯定不能随便胡乱标记。 扫描 Spring 为了知道程序员在哪些地方标记了什么注解，就需要通过扫描的方式，来进行检测。然后根据注解进行后续操作。 com.atguigu.spring下的所有文件都要进行扫描 123&lt;!--扫描组件--&gt; &lt;!--base-package属性是规定扫描的包--&gt;&lt;context:component-scan base-package=&quot;com.atguigu.spring&quot;&gt;&lt;/context:component-scan&gt; 扫描组件排除扫描规定包下的某个类，或者只扫描规定包下的某个类 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!--扫描组件--&gt; &lt;!--排除和包含两个标签不能一起用--&gt; &lt;!--base-package属性是规定扫描的包--&gt;&lt;context:component-scan base-package=&quot;com.atguigu.spring&quot; use-default-filters=&quot;false&quot;&gt; &lt;!--这个context:exclude-filter是用来排除规定包下的某一些类的--&gt; &lt;!--expression中用的是注解的全类名或者类的全类名--&gt; &lt;!--type是annotation是根据注解来排除类，排除expression中的注解类型标记过的类--&gt; &lt;!-- &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;--&gt; &lt;!--type是assignable是根据类来排除，排出的是expression中所对应的类--&gt; &lt;!--&lt;context:exclude-filter type=&quot;assignable&quot; expression=&quot;com.atguigu.spring.controller.UserController&quot;/&gt;--&gt; &lt;!--这是规定只引入包下的哪个类--&gt; &lt;!--expression type和上面的都一样--&gt; &lt;!--将外面标签的use-default-filters设置为false，默认是设置为true，表示扫描包下所有组件，所以要设为false--&gt; &lt;!--这种情况是只扫描Controller注解的类--&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt; &lt;/beans&gt; bean的id通过注解+扫描所配置的bean的id，默认值为类的小驼峰，即类名的首字母为小写的结果 比如说UserController类通过注解+扫描所配置的bean的id为userController test 123456@Testpublic void test()&#123; ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;spring-ioc-annotation.xml&quot;); UserController userController = ioc.getBean(&quot;userController&quot;,UserController.class); System.out.println(userController);&#125; 自定义id UserController 12345678910package com.atguigu.spring.controller;import org.springframework.stereotype.Controller;/*给注解的value赋值就是给这个类注解加扫描得到的bean自己定义的id */@Controller(&quot;controller&quot;)public class UserController &#123;&#125; test 123456@Testpublic void test()&#123; ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;spring-ioc-annotation.xml&quot;); UserController userController = ioc.getBean(&quot;controller&quot;,UserController.class); System.out.println(userController);&#125; 基于注解的自动装配①场景模拟 参考基于xml的自动装配 在UserController中声明UserService对象 在UserServiceImpl中声明UserDao对象 这个场景模拟和xml的自动装配一致 UserServiceImpl 用 @Autowired标记要被自动装配的属性 123456789101112131415161718package com.atguigu.spring.service.impl;import com.atguigu.spring.dao.UserDao;import com.atguigu.spring.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowiredprivate UserDao userDao; @Override public void saveUser() &#123; userDao.saveUser(); &#125;&#125; UserService 给userService加上@Autowired标记 123456789101112131415161718package com.atguigu.spring.controller;import com.atguigu.spring.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;/*给注解的value赋值就是给这个类注解加扫描得到的bean自己定义的id */@Controllerpublic class UserController &#123; @Autowired private UserService userService; public void savaUser()&#123; userService.saveUser(); &#125;&#125; @Autowired：实现自动装配功能的注解 1.@Autowired注解能够标识的位置 ​ 成员变量上，此时不需要设置成员变量的set方法（最常用的） ​ 标识在set方法 ​ 为当前成员变量赋值的有参构造上 @Autowired原理 1.默认通过byType的方式，在IOC容器中通过类型匹配某个bean为属性赋值 2.若有多个类型匹配的bean，此时会自动转换为byName的方式实现自动装配的效果 即将要赋值的属性的属性名去匹配某个bean的id，用匹配到的bean为属性赋值 3.若byType和byName的方式都无法实现自动匹配，即ioc容器中有多个类型匹配的bean（byType不能用），且这些bean的id和要赋值的属性的属性名都不一致（byName不能用）或报错：NoUniqueBeanDefinitionException 此时可以在要赋值的属性上，添加一个注解 1234567 /* 给@Qualifier的value值赋值 这个是指定id为UserDao的bean为userDao属性赋值 */ @Autowired @Qualifier(&quot;UserDao&quot;)private UserDao userDao; 这个时候这个自动装配的@Autowired需要写在属性的上面 @Autowired注意事项用注解实现的自动装配，如果没有匹配的bean则会报NoSuchBeanDefinitionException没有这个值，就是它不会找不到匹配的bean就给它赋默认值 在@Autowired注解中有个属性required，默认值为true，要求必须完成自动装配 可以将required设置为false，此时能装配则装配，无法装配则使用默认值 1@Autowired(required = false) test 1234567891011121314151617package com.atguigu.spring.test;import com.atguigu.spring.controller.UserController;import com.atguigu.spring.service.UserService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class IOCByAnnotationTest &#123; @Test public void test()&#123; ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;spring-ioc-annotation.xml&quot;); UserController userController = ioc.getBean(UserController.class); userController.savaUser(); &#125;&#125; AOP场景模拟计算器 1234567891011121314151617181920212223242526272829303132333435363738394041package com.atguigu.spring.proxy;public class CalculatorImpl implements Calculator &#123; @Override public int add(int i, int j) &#123; System.out.println(&quot;[日志] add 方法开始了，参数是：&quot; + i + &quot;,&quot; + j); int result=i+j; System.out.println(&quot;方法内部，result:&quot;+result); System.out.println(&quot;[日志] add 方法结束了，结果是：&quot; + result); return result; &#125; @Override public int sub(int i, int j) &#123; System.out.println(&quot;[日志] sub 方法开始了，参数是：&quot; + i + &quot;,&quot; + j); int result=i-j; System.out.println(&quot;方法内部，result:&quot;+result); System.out.println(&quot;[日志] sub 方法结束了，结果是：&quot; + result); return result; &#125; @Override public int mul(int i, int j) &#123; System.out.println(&quot;[日志] mul 方法开始了，参数是：&quot; + i + &quot;,&quot; + j); int result=i*j; System.out.println(&quot;方法内部，result:&quot;+result); System.out.println(&quot;[日志] mul 方法结束了，结果是：&quot; + result); return result; &#125; @Override public int div(int i, int j) &#123; System.out.println(&quot;[日志] div 方法开始了，参数是：&quot; + i + &quot;,&quot; + j); int result=i/j; System.out.println(&quot;方法内部，result:&quot;+result); System.out.println(&quot;[日志] div 方法结束了，结果是：&quot; + result); return result; &#125;&#125; 问题： 1.以下这些代码在每个方法中是重复的，正常应该封装，但它不是连续的，封装只能封装连续的代码，所以不能封装，所以这个地方就用到了代理模式 1234System.out.println(&quot;[日志] mul 方法开始了，参数是：&quot; + i + &quot;,&quot; + j);System.out.println(&quot;方法内部，result:&quot;+result);System.out.println(&quot;[日志] mul 方法结束了，结果是：&quot; + result); 2.int result&#x3D;i运算符j才是核心业务，但每个方法中既实现了日志业务又实现了运算，分散程序员重心 3.日志这种附加代码在各个方法中重复，不好维护 ③困难 解决问题的困难：要抽取的代码在方法内部，不连续分布，靠以前把子类中的重复代码抽取到父类的方式没法解决。 所以需要引入新的技术。 代理模式它的作用就是提供一个代理类，当我们去调用一个方法的时候，不是直接调用这个方法，而是通过代理类间接的来调用这个方法，这样可以把程序中非核心代码剥离出来到代理类中这个叫解耦，方便了非核心代码的维护，减少了对核心方法的打扰 代理之前 代理之后 就是调用add方法先调用代理对象的add方法，代理对象调用目标方法（add方法），目标方法返回给代理对象，代理对象把返回值返回给最初调用者 ③相关术语 代理：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法。（） 目标：被代理“套用”了非核心逻辑代码的类、对象、方法。（CalculatorImpl） 静态代理的实现特点：一对一：当前这个代理类只能作为这个目标类的代理 创建一个代理类 CalculatorStaticProxy 因为代理和目标类（CalculatorImpl）必须实现一样的功能，所以CalculatorImpl实现Calculator接口，代理类也实现Calculator接口 并重写方法， private CalculatorImpl target;定义一个目标类属性，用来在代理类中间接调用目标方法，同时代理类中的方法还可以加上一些日志操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.atguigu.spring.proxy;import jdk.nashorn.internal.ir.CallNode;public class CalculatorStaticProxy implements Calculator &#123; private CalculatorImpl target; @Override public int add(int i, int j) &#123; System.out.println(&quot;日志 方法：add，参数：&quot;+i+&quot;,&quot;+j); int result=target.add(i,j); System.out.println(&quot;日志 方法：add，参数：&quot;+i+&quot;,&quot;+j+&quot;=&quot;+result); return 0; &#125; public CalculatorStaticProxy(CalculatorImpl target) &#123; this.target = target; &#125; @Override public int sub(int i, int j) &#123; System.out.println(&quot;日志 方法：add，参数：&quot;+i+&quot;,&quot;+j); int result=target.sub(i,j); System.out.println(&quot;日志 方法：add，参数：&quot;+i+&quot;-&quot;+j+&quot;=&quot;+result); return 0; &#125; @Override public int mul(int i, int j) &#123; System.out.println(&quot;日志 方法：add，参数：&quot;+i+&quot;,&quot;+j); int result=target.mul(i,j); System.out.println(&quot;日志 方法：add，参数：&quot;+i+&quot;*&quot;+j+&quot;=&quot;+result); return 0; &#125; @Override public int div(int i, int j) &#123; System.out.println(&quot;日志 方法：add，参数：&quot;+i+&quot;,&quot;+j); int result=target.div(i,j); System.out.println(&quot;日志 方法：add，参数：&quot;+i+&quot;/&quot;+j+&quot;=&quot;+result); return 0; &#125;&#125; CalculatorImpl 12345678910111213141516171819202122232425262728package com.atguigu.spring.proxy;public class CalculatorImpl implements Calculator &#123; @Override public int add(int i, int j) &#123; int result=i+j; return result; &#125; @Override public int sub(int i, int j) &#123; int result=i-j; return result; &#125; @Override public int mul(int i, int j) &#123; int result=i*j; return result; &#125; @Override public int div(int i, int j) &#123; int result=i/j; return result; &#125;&#125; test 12345678910111213141516package com.atguigu.proxy;import com.atguigu.spring.proxy.CalculatorImpl;import com.atguigu.spring.proxy.CalculatorStaticProxy;import org.junit.Test;public class ProxyTest &#123; @Test public void testProxy()&#123; CalculatorStaticProxy calculatorStaticProxy=new CalculatorStaticProxy(new CalculatorImpl()); calculatorStaticProxy.add(1,2); calculatorStaticProxy.sub(1,2); calculatorStaticProxy.div(1,2); calculatorStaticProxy.mul(1,2); &#125;&#125; 代理中的add方法 1234567891011121314151617@Overridepublic int add(int i, int j) &#123; try &#123; //目标方法执行前 System.out.println(&quot;日志 方法：add，参数：&quot; + i + &quot;,&quot; + j); int result = target.add(i, j); //目标方法执行后 System.out.println(&quot;日志 方法：add，参数：&quot; + i + &quot;,&quot; + j + &quot;=&quot; + result); &#125; catch(Exception e)&#123; //报错之后 &#125; finally &#123; //无论怎样都要执行 &#125; return 0;&#125; 加上trycatchfinally除了目标方法执行前和目标方法执行后又多了报错之后 和 无论怎样都要执行（finally） 静态代理的缺陷：实现的接口和目标类都是固定的，没有灵活性，如果有别的类要实现日志功能，还是无法复用日志功能的代码 提出进一步的需求：将日志功能集中到一个代理类中，将来有任何日志需求，都通过这一个代理 类来实现。这就需要使用动态代理技术了。 动态代理的实现设置一个生成代理类的工程（它不是代理类，但它getProxy()方法的返回值是代理类对象） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.atguigu.spring.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Arrays;public class ProxyFactory &#123; public ProxyFactory(Object target) &#123; this.target = target; &#125; private Object target; public Object getProxy()&#123; /* newProxyInstance:三个参数 ClassLoader loader：指定加载动态生成的代理类（当前所在类）的类加载器 Class&lt;?&gt;[] interfaces：获取目标对象实现的所有接口的class对象的数组 InvocationHandler h：设置代理类中的抽象方法如何重写 */ ClassLoader classLoader = this.getClass().getClassLoader(); Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces(); /* 用匿名内部类来创建 */ InvocationHandler h=new InvocationHandler() &#123; //这个方法设置的是代理类中的抽象方法如何重写 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result=null; try &#123; System.out.println(&quot;日志，方法，&quot; + method.getName() + &quot;,参数：&quot; + Arrays.toString(args)); //proxy表示代理对象，method表示要执行的方法，args表示要执行的方法的参数列表 //这个调用目标对象的方法,method方法在代理中和目标中都是一样因为实现的都是一个接口 result = method.invoke(target, args); System.out.println(&quot;日志，方法，&quot; + method.getName() + &quot;,结果：&quot; + result); &#125; catch(Exception e)&#123; e.printStackTrace(); System.out.println(&quot;日志，方法，&quot; + method.getName() + &quot;,异常：&quot; + e); &#125;finally&#123; System.out.println(&quot;日志，方法&quot;+method.getName()+&quot;,方法执行完毕&quot;); &#125; return result; &#125; &#125;; return Proxy.newProxyInstance(classLoader,interfaces,h); &#125;&#125; test 12345678910111213141516171819202122232425262728package com.atguigu.proxy;import com.atguigu.spring.proxy.Calculator;import com.atguigu.spring.proxy.CalculatorImpl;import com.atguigu.spring.proxy.CalculatorStaticProxy;import com.atguigu.spring.proxy.ProxyFactory;import org.junit.Test;public class ProxyTest &#123; /* 动态代理有两种： 1，jdk动态代理，要求必须有接口，最终生成的代理类和目标类实现相同的接口在com.sun.proxy包下类名为$proxy2 2.cglib动态代理，最终生成的代理类会继承目标类，并且和目标类在相同的包下 */ @Test public void testProxy()&#123; ProxyFactory proxyFactory=new ProxyFactory(new CalculatorImpl()); /* 不知道当前动态代理类生成的类型，但是可以通过用接口类型来进行向上转型，赋值给一个接口变量 */ Calculator proxy = (Calculator) proxyFactory.getProxy(); int add = proxy.div(1, 2); &#125;&#125; AOP概念以及相关术语aop是面向切面变成，oop是面向对象编程，aop是oop的一种补充和完善 aop作用 1.aop用来抽取非核心业务代码，交给切面进行管理 2.实现在不修改源代码的情况 下给程序动态统一添加额外功能的一种技术。 相关术语 横切关注点： 从每个方法中抽取出来的同一类非核心业务 通知： 每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。 非核心代码在目标对象中叫横切关注点，你把它拿出来在切面中进行封装那它就是一个通知方法 通知分类 前置通知：在被代理的目标方法前执行 返回通知：在被代理的目标方法成功结束后执行（寿终正寝） 异常通知：在被代理的目标方法异常结束后执行（死于非命） 后置通知：在被代理的目标方法最终结束后执行（盖棺定论） 环绕通知：使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置 一个环绕通知，等于上面这四种通知 切面： 封装通知方法的类。 目标： 被代理的目标对象，被抽取非核心业务代码的对象 代理： 为当前的目标对象所创建的代理对象 连接点： 横切关注点是从哪切出来的，哪里就是连接点 切入点： 用于定位连接点的方式 Spring 的 AOP 技术可以通过切入点定位到特定的连接点。 切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条 件。 aop作用 自己：抽横切关注点，封装到切面中，他就是一个通知，再通过切入点定位到连接点，然后套用就ok，然后就可以在不改变原来代码的基础上，用切入点表达式把这些通知套用在原本抽取的地方（连接点），实现功能增强 简化代码：把方法中固定位置的重复的代码抽取出来，让被抽取的方法更专注于自己的核心功能， 提高内聚性。 代码增强：把特定的功能封装到切面类中，看哪里有需要，就往上套，被套用了切面逻辑的方法就 被切面给增强了。 基于注解AOP实现的准备工作 动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因 为这个技术要求代理对象和目标对象实现同样的接口（兄弟两个拜把子模式）。 cglib：通过继承被代理的目标类（认干爹模式）实现代理，所以不需要目标类实现接口。 AspectJ：本质上是静态代理，将代理逻辑“织入”被代理的目标类编译得到的字节码文件，所以最 终效果是动态的。weaver就是织入器。Spring只是借用了AspectJ中的注解。 1.添加依赖 在原本ioc基础上添加依赖 123456&lt;!-- spring-aspects会帮我们传递过来aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt; 2.创建目标对象的实现类和接口 计算器接口 1234567public interface Calculator &#123; int add(int i, int j); int sub(int i, int j); int mul(int i, int j); int div(int i, int j);&#125; 计算器实现类 12345678910111213141516171819202122232425262728package com.atguigu.spring.aop.annotation;public class CalculatorImpl implements Calculator &#123; @Override public int add(int i, int j) &#123; int result=i+j; return result; &#125; @Override public int sub(int i, int j) &#123; int result=i-j; return result; &#125; @Override public int mul(int i, int j) &#123; int result=i*j; return result; &#125; @Override public int div(int i, int j) &#123; int result=i/j; return result; &#125;&#125; 3.创建切面类并配置 抽取横切关注点，封装成通知方法，放在切面类中 将目标对象实现类和切面类交给ioc容器管理 CalculatorImpl 加上一个@Component 12345678910111213141516171819202122232425262728293031package com.atguigu.spring.aop.annotation;import org.springframework.stereotype.Component;@Componentpublic class CalculatorImpl implements Calculator &#123; @Override public int add(int i, int j) &#123; int result=i+j; return result; &#125; @Override public int sub(int i, int j) &#123; int result=i-j; return result; &#125; @Override public int mul(int i, int j) &#123; int result=i*j; return result; &#125; @Override public int div(int i, int j) &#123; int result=i/j; return result; &#125;&#125; LoggerAspect 加上@Component 和@Aspect 1234567891011package com.atguigu.spring.aop.annotation;import org.aspectj.lang.annotation.Aspect;import org.springframework.stereotype.Component;@Component@Aspect //将当前组件标识为切面public class LoggerAspect &#123;&#125; aop-annotation.xml 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- AOP的注意事项： 切面类和目标类都需要交给ioc容器管理 切面类必须通过@Aspect注解标识为一个切面 --&gt; &lt;!--进行扫描--&gt; &lt;context:component-scan base-package=&quot;com.atguigu.spring.aop.annotation&quot;&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 基于注解的aop之前置通知在aop-annotation.xml中设置 12&lt;!--开启基于注解的aop功能--&gt;&lt;aop:aspectj-autoproxy/&gt; LoggerAspect 切面类 1234567891011121314151617181920212223242526package com.atguigu.spring.aop.annotation;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.stereotype.Component;@Component@Aspect //将当前组件标识为切面public class LoggerAspect &#123; /* 前置通知 */ /* 在切面中，需要通过指定的注解将方法标识为通知方法 @Before:前置通知，在目标对象方法执行之前执行 参数是 execution 切入点表达式就是连接点的位置，也就是下面这个方法在执行参数中这个方法之前执行 参数:方法类型 返回值类型 方法的全方法名(参数类型...) */ @Before(&quot;execution(public int com.atguigu.spring.aop.annotation.CalculatorImpl.add(int,int))&quot;) public void beforeAdviceMethod()&#123; System.out.println(&quot;LoggerAspect,前置通知&quot;); &#125;&#125; test 123456789101112131415161718192021package com.atguigu.spring.test;import com.atguigu.spring.aop.annotation.Calculator;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AOPTest &#123; @Test public void testAOPByAnnotation()&#123; ApplicationContext ioc=new ClassPathXmlApplicationContext(&quot;aop-annotation.xml&quot;); /* 这个地方获取的应该是代理对象，创建了代理对象之后，只能通过代理对象来访问目标对象，如果用getBean直接获取目标对象就会报错 不知道代理对象的类型，但是它一定实现了Calculator接口，所以用Calculator接口来获取bean 疑问：目标对象和代理对象都实现这个接口，为什么获取的是目标对象？ 因为：目标对象无法获取，获取时报错，所以这个地方只能获取代理对象 */ Calculator calculator = ioc.getBean(Calculator.class); calculator.add(1,2); &#125;&#125; 切入点表达式语法和获取连接点方法信息切入点表达式：execcution中的参数 LoggerAspect 1234567/*第一个*是指方法的类型和返回值任意，后面是包名，中间也可以用到*，代表这个包下所有的类，第二个*是指这个类下所有的方法，(..)是指任意参数类型 */@Before(&quot;execution(* com.atguigu.spring.aop.annotation.CalculatorImpl.*(..))&quot;)public void beforeAdviceMethod()&#123; System.out.println(&quot;LoggerAspect,前置通知&quot;);&#125; 获取连接点方法信息 加了一个joinPoint参数 12345678910111213141516171819/*第一个*是指方法的类型和返回值任意，后面是包名，中间也可以用到*，代表这个包下所有的类，第二个*是指这个类下所有的方法，(..)是指任意参数类型 */@Before(&quot;execution(* com.atguigu.spring.aop.annotation.CalculatorImpl.*(..))&quot;)//加一个joinPoint参数用来获取连接点对应方法的信息public void beforeAdviceMethod(JoinPoint joinPoint)&#123; //获取连接点所对应的方法的签名信息(方法名，返回值类型，修饰符，参数) Signature signature=joinPoint.getSignature(); //获取连接点对应方法的方法名 String name = signature.getName(); //获取连接点所对应方法的参数 Object[] args = joinPoint.getArgs(); System.out.println(&quot;LoggerAspect 方法&quot;+signature.getName()+&quot;:参数:&quot;+ Arrays.toString(args)); System.out.println(&quot;LoggerAspect,前置通知&quot;);&#125; 切入点表达式的重用 @Pointcut声明一个公共的切入点表达式 12@Pointcut(&quot;execution(* com.atguigu.spring.aop.annotation.CalculatorImpl.*(..))&quot;) public void pointCut()&#123; &#125; 使用方式： @After中写的是当前那个声明一个公共的切入点表达式的方法的方法名 12345//切入点表达式的重用 @After(&quot;pointCut()&quot;) public void afterAdviceMethod()&#123; &#125; LoggerAspect 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.atguigu.spring.aop.annotation;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.Signature;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;import java.util.Arrays;@Component@Aspect //将当前组件标识为切面public class LoggerAspect &#123; /* 前置通知 */ /* 在切面中，需要通过指定的注解将方法标识为通知方法 @Before:前置通知，在目标对象方法执行之前执行 参数是 execution 切入点表达式就是连接点的位置，也就是下面这个方法在执行参数中这个方法之前执行 参数:方法类型 返回值类型 方法的全方法名(参数类型...) */ @Pointcut(&quot;execution(* com.atguigu.spring.aop.annotation.CalculatorImpl.*(..))&quot;) public void pointCut()&#123; &#125; /* 第一个*是指方法的类型和返回值任意，后面是包名，中间也可以用到*，代表这个包下所有的类，第二个*是指这个类下所有的方法，(..)是指任意参数类型 */ @Before(&quot;pointCut()&quot;) //加一个joinPoint参数用来获取连接点对应方法的信息 public void beforeAdviceMethod(JoinPoint joinPoint)&#123; //获取连接点所对应的方法的签名信息(方法名，返回值类型，修饰符，参数) Signature signature=joinPoint.getSignature(); //获取连接点对应方法的方法名 String name = signature.getName(); //获取连接点所对应方法的参数 Object[] args = joinPoint.getArgs(); System.out.println(&quot;LoggerAspect 方法&quot;+signature.getName()+&quot;:参数:&quot;+ Arrays.toString(args)); System.out.println(&quot;LoggerAspect,前置通知&quot;); &#125; //切入点表达式的重用 @After(&quot;pointCut()&quot;) public void afterAdviceMethod()&#123; &#125;&#125; 测试 123456789101112131415161718192021package com.atguigu.spring.test;import com.atguigu.spring.aop.annotation.Calculator;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AOPTest &#123; @Test public void testAOPByAnnotation()&#123; ApplicationContext ioc=new ClassPathXmlApplicationContext(&quot;aop-annotation.xml&quot;); /* 这个地方获取的应该是代理对象，创建了代理对象之后，只能通过代理对象来访问目标对象，如果用getBean直接获取目标对象就会报错 不知道代理对象的类型，但是它一定实现了Calculator接口，所以用Calculator接口来获取bean 疑问：目标对象和代理对象都实现这个接口，为什么获取的是目标对象？ 因为：目标对象无法获取，获取时报错，所以这个地方只能获取代理对象 */ Calculator calculator = ioc.getBean(Calculator.class); calculator.div(12,0); &#125;&#125; AOP各种通知的使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.atguigu.spring.aop.annotation;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.Signature;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;import sun.reflect.annotation.ExceptionProxy;import java.util.Arrays;@Component@Aspect //将当前组件标识为切面public class LoggerAspect &#123; /* 前置通知 */ /* 在切面中，需要通过指定的注解将方法标识为通知方法 @Before:前置通知，在目标对象方法执行之前执行 参数是 execution 切入点表达式就是连接点的位置，也就是下面这个方法在执行参数中这个方法之前执行 参数:方法类型 返回值类型 方法的全方法名(参数类型...) */ @Pointcut(&quot;execution(* com.atguigu.spring.aop.annotation.CalculatorImpl.*(..))&quot;) public void pointCut()&#123; &#125; /* 第一个*是指方法的类型和返回值任意，后面是包名，中间也可以用到*，代表这个包下所有的类，第二个*是指这个类下所有的方法，(..)是指任意参数类型 */ @Before(&quot;pointCut()&quot;) //加一个joinPoint参数用来获取连接点对应方法的信息 public void beforeAdviceMethod(JoinPoint joinPoint)&#123; //获取连接点所对应的方法的签名信息(方法名，返回值类型，修饰符，参数) Signature signature=joinPoint.getSignature(); //获取连接点对应方法的方法名 String name = signature.getName(); //获取连接点所对应方法的参数 Object[] args = joinPoint.getArgs(); System.out.println(&quot;LoggerAspect 方法&quot;+signature.getName()+&quot;:参数:&quot;+ Arrays.toString(args)); System.out.println(&quot;LoggerAspect,前置通知&quot;); &#125;//@After:后置通知，在目标对象方法的finally子句中执行 //切入点表达式的重用 @After(&quot;pointCut()&quot;) public void afterAdviceMethod(JoinPoint joinPoint)&#123; //获取连接点所对应的方法的签名信息(方法名，返回值类型，修饰符，参数) Signature signature=joinPoint.getSignature(); //获取连接点对应方法的方法名 String name = signature.getName(); System.out.println(&quot;LoggerAspect，方法后置通知&quot;+signature.getName()+&quot;,执行完毕&quot;); &#125; //@AfterReturning是：返回通知：在当前目标方法返回值之后执行，如果报错，无法返回，则也无法执行 //在返回通知中若要获取目标对象方法的返回值 //只需要通过@AfterReturning注解的returning属性 //就可以将通知方法的某个参数指定为接受目标对象方法的返回值的参数（就是保证returning中的值和方法中那个参数名字一样，就可以，另外切入点表达式得用value=） @AfterReturning(value=&quot;pointCut()&quot;,returning=&quot;result&quot;) public void afterReturningAdviceMethod(JoinPoint joinPoint,Object result)&#123; //获取连接点所对应的方法的签名信息(方法名，返回值类型，修饰符，参数) Signature signature=joinPoint.getSignature(); //获取连接点对应方法的方法名 String name = signature.getName(); System.out.println(&quot;LoggerAspect:方法返回通知&quot;+signature.getName()+&quot;，结果:&quot;+result); &#125; //@AfterThrowing:异常通知，在目标对象方法的catch子句中执行 //在异常通知中若要获取目标对象方法的异常 //只需要通过AfterThrowing注解的returning属性 //就可以将通知方法的某个参数指定为接收目标对象方法的返回值的参数 //就是用throwing接受目标对象方法中的异常信息，只要下面方法参数和throwing中的内容相同就可以@AfterThrowing(value=&quot;pointCut()&quot;,throwing=&quot;ex&quot;)public void afterThrowingAdviceMethod(JoinPoint joinPoint, Exception ex)&#123; //获取连接点所对应的方法的签名信息(方法名，返回值类型，修饰符，参数) Signature signature=joinPoint.getSignature(); //获取连接点对应方法的方法名 String name = signature.getName(); System.out.println(&quot;LoggerAspect,方法异常通知&quot;+signature.getName()+&quot;,异常信息&quot;+ex);&#125;&#125; 测试 123456789101112131415161718192021package com.atguigu.spring.test;import com.atguigu.spring.aop.annotation.Calculator;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AOPTest &#123; @Test public void testAOPByAnnotation()&#123; ApplicationContext ioc=new ClassPathXmlApplicationContext(&quot;aop-annotation.xml&quot;); /* 这个地方获取的应该是代理对象，创建了代理对象之后，只能通过代理对象来访问目标对象，如果用getBean直接获取目标对象就会报错 不知道代理对象的类型，但是它一定实现了Calculator接口，所以用Calculator接口来获取bean 疑问：目标对象和代理对象都实现这个接口，为什么获取的是目标对象？ 因为：目标对象无法获取，获取时报错，所以这个地方只能获取代理对象 */ Calculator calculator = ioc.getBean(Calculator.class); calculator.div(12,0); &#125;&#125; 环绕通知的使用 LoggerAspect切面类 1234567891011121314151617181920212223242526/*环绕通知： @Around(&quot;pointCut()&quot;)通过这个注解 环绕通知是代替了目标对象的方法，所以返回值是Object和目标对象方法的返回值相同，result的类型 添加一个ProceedingJoinPoint类型的参数，通过参数中proceed()方法表示目标对象方法的执行 然后就可以增加在方法执行过程中进行额外的操作 */ @Around(&quot;pointCut()&quot;) public Object aroundAdviceMethod(ProceedingJoinPoint joinPoint)&#123; Object result=null; try &#123; System.out.println(&quot;环绕通知---&gt;前置通知的位置&quot;); //表示目标对象方法的执行 result = joinPoint.proceed(); System.out.println(&quot;环绕通知---&gt;返回通知的位置&quot;); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); System.out.println(&quot;环绕通知---&gt;异常通知的位置&quot;); &#125; finally&#123; System.out.println(&quot;环绕通知---&gt;后置通知的位置&quot;); &#125; return result; &#125; test 1234567891011121314151617181920212223package com.atguigu.spring.test;import com.atguigu.spring.aop.annotation.Calculator;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AOPTest &#123; @Test public void testAOPByAnnotation1()&#123; ApplicationContext ioc=new ClassPathXmlApplicationContext(&quot;aop-annotation.xml&quot;); /* 这个地方获取的应该是代理对象，创建了代理对象之后，只能通过代理对象来访问目标对象，如果用getBean直接获取目标对象就会报错 不知道代理对象的类型，但是它一定实现了Calculator接口，所以用Calculator接口来获取bean 疑问：目标对象和代理对象都实现这个接口，为什么获取的是目标对象？ 因为：目标对象无法获取，获取时报错，所以这个地方只能获取代理对象 */ Calculator calculator = ioc.getBean(Calculator.class); calculator.div(12,1); &#125;&#125; 切面的优先级新建的切面类为ValidateAspect 12345678910111213141516171819202122232425262728package com.atguigu.spring.aop.annotation;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;@Component@Aspect@Order(1)//通过Order来设置切面的优先级，Order的value值越大，优先级越小，value值越小，优先级越大，而且切面类默认order的value为Integer的最大值//所以这里把Order的value设置为1就可以让ValidateAspect的优先级增高public class ValidateAspect &#123; public void cutPoint()&#123; &#125; //@Before(&quot;execution(* com.atguigu.spring.aop.annotation.CalculatorImpl.*(..))&quot;) /* 引入LoggerAspect类中定义的公共方法 */ @Before(&quot;com.atguigu.spring.aop.annotation.LoggerAspect.pointCut()&quot;) public void beforeMethod()&#123; System.out.println(&quot;ValidateAspect---&gt;前置通知&quot;); &#125;&#125; test 1234567891011121314151617181920212223package com.atguigu.spring.test;import com.atguigu.spring.aop.annotation.Calculator;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AOPTest &#123; @Test public void testAOPByAnnotation1()&#123; ApplicationContext ioc=new ClassPathXmlApplicationContext(&quot;aop-annotation.xml&quot;); /* 这个地方获取的应该是代理对象，创建了代理对象之后，只能通过代理对象来访问目标对象，如果用getBean直接获取目标对象就会报错 不知道代理对象的类型，但是它一定实现了Calculator接口，所以用Calculator接口来获取bean 疑问：目标对象和代理对象都实现这个接口，为什么获取的是目标对象？ 因为：目标对象无法获取，获取时报错，所以这个地方只能获取代理对象 */ Calculator calculator = ioc.getBean(Calculator.class); calculator.div(12,1); &#125;&#125; 结果：ValidateAspect—&gt;前置通知 基于xml的aop实现(用不上)声明式事务（JDBCTemplate）简介： Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作 准备工作1.添加依赖 添加模块 spring_transcation 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring 持久化层支持jar包 --&gt; &lt;!-- Spring 在执行持久化层操作、与持久化层技术进行整合过程中，需要使用orm、jdbc、tx三个 jar包 --&gt; &lt;!-- 导入 orm 包就可以通过 Maven 的依赖传递性把其他两个也导入 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring 测试相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据源 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.31&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建jdbc.properties 1234jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=UTCjdbc.username=rootjdbc.password=root spring整合jdbc spring-jdbc.xml spring配置文件 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--引入jdbc.properties文件引入--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;&gt;&lt;/context:property-placeholder&gt; &lt;!--引入数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--JdbcTemplate类中有dataSource属性用上面那个bean赋值给dataSource,dataSource是数据源对象，用来和数据库建立连接--&gt; &lt;bean class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 实现添加功能test 1234567891011121314151617181920212223242526272829package com.atguigu.spring.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;//指定当前测试类在spring的测试环境中执行，也就是Junit环境，此时就可以通过注入的方式直接获取ioc容器中的bean//这个也就是实现了一个当前类的属性如果匹配ioc中的bean就可以给赋值@RunWith(SpringJUnit4ClassRunner.class)//用来设置当前spring测试环境的配置文件//classpath就是类路径，target/classes/@ContextConfiguration(&quot;classpath:spring-jdbc.xml&quot;)public class JdbcTemplateTest &#123; //自动装配jdbcTemplate @Autowiredprivate JdbcTemplate jdbcTemplate; @Test public void testInsert()&#123; String sql=&quot;insert into t_user values(null,?,?,?,?,?)&quot;; //既能实现增加也能实现修改和删除 //第一个参数是sql语句，，第二个参数是sql占位符的内容 jdbcTemplate.update(sql,&quot;root&quot;,&quot;123&quot;,&quot;23&quot;,&quot;女&quot;,&quot;123@qq.com&quot;); &#125;&#125; 实现查询功能添加了一个pojo类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.atguigu.spring.pojo;public class User &#123; private Integer id; private String username; private String password; public Integer getId() &#123; return id; &#125; public User() &#123; &#125; public void setId(Integer id) &#123; this.id = id; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; + &quot;, email=&#x27;&quot; + email + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; private Integer age; private String gender; private String email;&#125; 查询的时候类型的属性名和查询的字段名必须相同，或者用起列名来保持相同，而且User类必须要有无参构造方法 123456789101112131415161718192021222324252627//根据id查找用户信息 @Test public void testGetUserById()&#123; String sql=&quot;select *from t_user where id=?&quot;; //这个也是字段名和属性名一致才能赋值,第二个参数是要映射的实体类类型,第三个参数是sql语句的占位符 //必须得有无参构造方法，要不然无法创建对象 User user = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(User.class),1); System.out .println(user); &#125; //查找全部的用户信息 @Test public void testGetAllUser()&#123; String sql=&quot;select *from t_user&quot;; List&lt;User&gt; query = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(User.class)); query.forEach(System.out::println); &#125; //查询单个数据 @Test public void testGetCount()&#123; String sql=&quot;select count(*) from t_user&quot;; //第二个参数指定查询出来的数据转换为什么类型 Integer integer = jdbcTemplate.queryForObject(sql, Integer.class); System.out.println(integer); &#125; 声明式事务的概念编程式事务 所有的事务操作都是通过自己编程操作实现的 123456789101112131415 Connection conn = ...;try &#123;// 开启事务：关闭事务的自动提交 conn.setAutoCommit(false);// 核心操作// 提交事务 conn.commit(); &#125;catch(Exception e)&#123;// 回滚事务 conn.rollBack(); &#125;finally&#123; // 释放数据库连接conn.close();&#125; 编程式的实现方式存在缺陷： 细节没有被屏蔽：具体操作过程中，所有细节都需要程序员自己来完成，比较繁琐。 代码复用性不高：如果没有有效抽取出来，每次实现功能都需要自己编写代码，代码就没有得到复 用。 声明式事务 事务控制的代码都是差不多的，可以用框架进行封装，消除了冗余的代码 封装起来后，我们只需要在配置文件中进行简单的配置即可完成操作。 基于注解的声明式事务引入依赖 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring 持久化层支持jar包 --&gt; &lt;!-- Spring 在执行持久化层操作、与持久化层技术进行整合过程中，需要使用orm、jdbc、tx三个 jar包 --&gt; &lt;!-- 导入 orm 包就可以通过 Maven 的依赖传递性把其他两个也导入 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring 测试相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据源 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.31&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; jdbc.properties 1234jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=UTCjdbc.username=rootjdbc.password=root 创建Spring-jdbc.xml 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--引入jdbc.properties文件引入--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;&gt;&lt;/context:property-placeholder&gt; &lt;!--引入数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--JdbcTemplate类中有dataSource属性用上面那个bean赋值给dataSource,dataSource是数据源对象，用来和数据库建立连接--&gt; &lt;bean class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 创建表 12345678910111213141516CREATE TABLE `t_book` (`book_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;,`book_name` varchar(20) DEFAULT NULL COMMENT &#x27;图书名称&#x27;,`price` int(11) DEFAULT NULL COMMENT &#x27;价格&#x27;,`stock` int(10) unsigned DEFAULT NULL COMMENT &#x27;库存（无符号）&#x27;,PRIMARY KEY (`book_id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;insert into `t_book`(`book_id`,`book_name`,`price`,`stock`) values (1,&#x27;斗破苍穹&#x27;,80,100),(2,&#x27;斗罗大陆&#x27;,50,100);CREATE TABLE `t_user` (`user_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;,`username` varchar(20) DEFAULT NULL COMMENT &#x27;用户名&#x27;,`balance` int(10) unsigned DEFAULT NULL COMMENT &#x27;余额（无符号）&#x27;,PRIMARY KEY (`user_id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;insert into `t_user`(`user_id`,`username`,`balance`) values (1,&#x27;admin&#x27;,50); 为了让余额和库存都保证大于零，可以给这个字段加一个关键字unsigned，如果余额不足或者库存不足就可以从mysql层面直接抛出一个异常 BookDao 123456789101112131415161718package com.atguigu.spring.dao;public interface BookDao &#123; /* 根据图书的id查询图书的价格 */ Integer getPriceByBookId(); /* 更新图书的库存 */ void updateStock(Integer bookId); /* 更新用户的余额 */ void updateBalance(Integer userId,Integer price);&#125; BookDaoImpl 123456789101112131415161718192021222324252627282930313233package com.atguigu.spring.dao.Impl;import com.atguigu.spring.dao.BookDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;@Repositorypublic class BookDaoImpl implements BookDao &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public Integer getPriceByBookId() &#123; String sql=&quot;select price from t_book where book_id=?&quot;; //第一个参数sql语句，第二个参数是要得到的类型，第三个参数是占位符 return jdbcTemplate.queryForObject(sql,Integer.class,1); &#125; @Override public void updateStock(Integer bookId) &#123;String sql=&quot;update t_book set stock=stock-1 where book_id=?&quot;;//第一个参数是sql语句，第二个参数是id占位符jdbcTemplate.update(sql, bookId); &#125; @Override public void updateBalance(Integer userId,Integer price) &#123; String sql=&quot;update t_user set balance-? where user_id=?&quot;; jdbcTemplate.update(sql,price,userId); &#125;&#125; BookService 12345package com.atguigu.spring.service;public interface BookService &#123; void buyBook(Integer userId, Integer bookId);&#125; BookServiceImpl 1234567891011121314151617181920212223package com.atguigu.spring.service.impl;import com.atguigu.spring.dao.BookDao;import com.atguigu.spring.service.BookService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class BookServiceImpl implements BookService &#123; //自动装配 @Autowired private BookDao bookDao; @Override public void buyBook(Integer userId, Integer bookId) &#123; //查询图书的价格 Integer price=bookDao.getPriceByBookId(); //更新图书的库存 bookDao.updateStock(bookId); //更新用户的余额 bookDao.updateBalance(userId,price); &#125;&#125; BookController 123456789101112131415161718package com.atguigu.spring.controller;import com.atguigu.spring.service.BookService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;@Controllerpublic class BookController &#123; @Autowired private BookService bookService; //实现买书功能 public void buyBook(Integer userId,Integer bookId)&#123; bookService.buyBook(userId,bookId); &#125;&#125; 在配置文件中实现的注解ioc和jdbcTemplate 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--引入jdbc.properties文件引入--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;&gt;&lt;/context:property-placeholder&gt; &lt;!--引入数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--JdbcTemplate类中有dataSource属性用上面那个bean赋值给dataSource,dataSource是数据源对象，用来和数据库建立连接--&gt; &lt;bean class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--扫描组件--&gt; &lt;context:component-scan base-package=&quot;com.atguigu.spring&quot;&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; test 123456789101112131415161718192021222324252627package com.atguigu.spring.test;import com.atguigu.spring.controller.BookController;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.awt.print.Book;//为了让bookController能够自动装配ioc中的bean@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:tx-annotation.xml&quot;)public class TxByAnnotationTest &#123; @Autowired private BookController bookController; @Test public void testBuyBook()&#123; //这种情况，用户余额不足无法购买，但还是减少了库存，所以应该用事务 bookController.buyBook(1,1); &#125;&#125; 第三个报错（余额不足），第二行还会执行提交，所以要用事务，保证三个都一起执行成功才能提交 public void buyBook(Integer userId, Integer bookId) &#123; //查询图书的价格 Integer price=bookDao.getPriceByBookId(); //更新图书的库存 bookDao.updateStock(bookId); //更新用户的余额 bookDao.updateBalance(userId,price); &#125; 实现事务功能声明式事务配置步骤： 1.在Spring配置文件中配置事务管理器 2.开启事务的注解驱动 3.在需要被事务管理的方法上，添加@Transactional注解，该方法就会被事务管理，还可以用在类上，对当前类的所有方法进行事务管理 tx-annotation.xml 12345678910111213141516&lt;!--配置事务管理器--&gt; &lt;!--这里面放的是切面类--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--设置数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 开启事务的注解驱动 将使用@Transactional注解所标识的方法或类中所有的方法（连接点）使用事务进行管理 transactionManaget属性设置事务管理器的id 若事务管理器bean的id默认为transactionManager，则该属性可以不写 --&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;​ &lt;!--引入jdbc.properties文件引入--&gt;​ &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;&gt;&lt;/context:property-placeholder&gt;​ &lt;!--引入数据源--&gt;​ &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;​ &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt;​ &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt;​ &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt;​ &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt;​ &lt;/bean&gt;​ &lt;!--JdbcTemplate类中有dataSource属性用上面那个bean赋值给dataSource,dataSource是数据源对象，用来和数据库建立连接--&gt;​ &lt;bean class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;​ &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;​ &lt;/bean&gt;​ &lt;!--扫描组件--&gt;​ &lt;context:component-scan base-package=&quot;com.atguigu.spring&quot;&gt;&lt;/context:component-scan&gt;​ &lt;!--配置事务管理器--&gt;​ &lt;!--这里面放的是切面类--&gt;​ &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;​ &lt;!--设置数据源--&gt;​ &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;​ &lt;/bean&gt;​ &lt;!--​ 开启事务的注解驱动​ 将使用@Transactional注解所标识的方法或类中所有的方法（连接点）使用事务进行管理​ transactionManaget属性设置事务管理器的id​ 若事务管理器bean的id默认为transactionManager，则该属性可以不写​ --&gt;​ &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;&lt;/beans&gt; 在Service类的buyBook方法加上事务管理的注解 123456789101112131415161718192021222324252627package com.atguigu.spring.service.impl;import com.atguigu.spring.dao.BookDao;import com.atguigu.spring.service.BookService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;@Servicepublic class BookServiceImpl implements BookService &#123; //自动装配 @Autowired private BookDao bookDao; //事务管理的注解 @Transactional @Override public void buyBook(Integer userId, Integer bookId) &#123; //查询图书的价格 Integer price=bookDao.getPriceByBookId(); //更新图书的库存 bookDao.updateStock(bookId); //更新用户的余额 bookDao.updateBalance(userId,price); &#125;&#125; test 1234567891011121314151617181920212223242526package com.atguigu.spring.test;import com.atguigu.spring.controller.BookController;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.awt.print.Book;//为了让bookController能够自动装配ioc中的bean@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:tx-annotation.xml&quot;)public class TxByAnnotationTest &#123; @Autowired private BookController bookController; @Test public void testBuyBook()&#123; bookController.buyBook(1,1); &#125;&#125; 事物的属性只读 对于一个查询操作来说，如果把它设置为只读，就能够明确告诉数据库，这个操作不涉及写操作。这样数据库就能够针对查询操作来进行优化 1@Transactional(readOnly = true) 1234567891011//事务管理的注解@Transactional(readOnly = true)@Overridepublic void buyBook(Integer userId, Integer bookId) &#123; //查询图书的价格 Integer price=bookDao.getPriceByBookId(); //更新图书的库存 bookDao.updateStock(bookId); //更新用户的余额 bookDao.updateBalance(userId,price);&#125; 如果当前事务出现增删改操作的时候就会报这个错 Caused by: java.sql.SQLException:Connection is read-only. Queries leading to data modification are not allowed 超时 事务在执行的过程中，遇到了问题，导致程序卡住，始终占用数据库的资源，此时这个很可能出现问题的事务就应该被回滚，让出资源，让其他事务正常进行 1234567891011121314151617181920//事务管理的注解//如果事务三秒钟没有执行完，就强制回滚并抛出异常@Transactional(timeout=3)@Overridepublic void buyBook(Integer userId, Integer bookId) &#123; Integer price=null; try &#123; //中间是SECONDS就是休眠五秒，中间是MINUTES就是休眠五分钟 TimeUnit.SECONDS.sleep(5); //查询图书的价格 price = bookDao.getPriceByBookId(); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; //更新图书的库存 bookDao.updateStock(bookId); //更新用户的余额 bookDao.updateBalance(userId,price);&#125; 报错，如果事务3秒没执行完就会报的错 org.springframework.transaction.TransactionTimedOutException: Transaction timed out: deadline was Thu Oct 27 16:57:05 CST 2022 回滚策略 声明式事务默认对于所有的运行时异常都回滚 就是设置当前事务遇到什么异常的时候会回滚，遇到什么异常的时候不会回滚 前两个是因为什么异常会回滚，后两个是什么异常不会回滚 rollbackFor属性：需要设置一个Class类型的对象 rollbackForClassName属性：需要设置一个字符串类型的全类名 noRollbackFor属性：需要设置一个Class类型的对象 norollbackFor属性：需要设置一个字符串类型的全类名 后两个常用，默认对于所有运行时异常都回滚，要想有一些异常不回滚就得设置后两个 123456789101112131415161718192021//事务管理的注解//这些运行时异常出现时，不回滚@Transactional(noRollbackFor = &#123;ArithmeticException.class&#125;)@Overridepublic void buyBook(Integer userId, Integer bookId) &#123; Integer price=null; try &#123; //中间是SECONDS就是休眠五秒，中间是MINUTES就是休眠五分钟 TimeUnit.SECONDS.sleep(5); //查询图书的价格 price = bookDao.getPriceByBookId(); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; //更新图书的库存 bookDao.updateStock(bookId); //更新用户的余额 bookDao.updateBalance(userId,price); System.out.println(12/0);&#125; 这个能实先下面说的，{ }在只排除一个异常的时候 不是非要有，但是多个的话就得有{} 1@Transactional(noRollbackFor = &#123;ArithmeticException.class&#125;) 出现下面这种12&#x2F;0错误的时候依然能够买书成功 1System.out.println(12/0); 隔离级别 使用方法 123456789@Transactional(isolation = Isolation.DEFAULT)//使用数据库默认的隔离级别 @Transactional(isolation = Isolation.READ_UNCOMMITTED)//读未提交 @Transactional(isolation = Isolation.READ_COMMITTED)//读已提交 @Transactional(isolation = Isolation.REPEATABLE_READ)//可重复读 @Transactional(isolation = Isolation.SERIALIZABLE)//串行化 脏读：一个事务读取到另外一个事务还没有提交的数据 不可重复读：一个事务前后读取同一条记录，但两次读取的数据不同，称之为不可重复读 幻读：幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样. 在mysql中的默认隔离级别（REPEATABLE READ）也不会发生幻读 传播行为 当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。 结账方法调用买书方法，比如说买两本书，如果有一本书买不了，那这个结账方法应该全部回滚，所以买书方法应该用结账方法的事务，但如果想要实现，一本书买不了但另一本书能买，就设置用买书方法自己的回滚，两种设置方式完全不同 默认是使用结账的事务，就是两本书如果有一本买不成，都会回滚 12345678910111213141516171819202122//事务管理的注解//阻止事务的传播，结账的时候如果第一本买了，第二本买不成，那么就回滚第二次买书@Transactional( propagation = Propagation.REQUIRES_NEW)@Overridepublic void buyBook(Integer userId, Integer bookId) &#123; Integer price=null; try &#123; //中间是SECONDS就是休眠五秒，中间是MINUTES就是休眠五分钟 TimeUnit.SECONDS.sleep(5); //查询图书的价格 price = bookDao.getPriceByBookId(); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; //更新图书的库存 bookDao.updateStock(bookId); //更新用户的余额 bookDao.updateBalance(userId,price);&#125; 结账 123456789101112131415161718192021222324package com.atguigu.spring.service.impl;import com.atguigu.spring.service.BookService;import com.atguigu.spring.service.CheckoutService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;@Servicepublic class CheckoutServiceImpl implements CheckoutService &#123; @Autowired private BookService bookService; @Override @Transactional //事务管理 public void checkout(Integer userId, Integer[] bookIds) &#123; for (Integer bookId : bookIds) &#123; bookService.buyBook(userId,bookId); &#125; &#125;&#125; 基于xml的声明式事务（用的少）引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt; 符和tx:attributes中间规定的方法才能被事务管理，其他的不能被事务管理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--引入jdbc.properties文件引入--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;&gt;&lt;/context:property-placeholder&gt; &lt;!--引入数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--JdbcTemplate类中有dataSource属性用上面那个bean赋值给dataSource,dataSource是数据源对象，用来和数据库建立连接--&gt; &lt;bean class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--扫描组件--&gt; &lt;context:component-scan base-package=&quot;com.atguigu.spring&quot;&gt;&lt;/context:component-scan&gt; &lt;!--配置事务管理器--&gt; &lt;!--这里面放的是切面类--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--设置数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置事务通知--&gt; &lt;!-- tx:advice标签：配置事务通知 --&gt; &lt;!-- id属性：给事务通知标签设置唯一标识，便于引用 --&gt; &lt;!-- transaction-manager属性：关联事务管理器 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- tx:method标签：配置具体的事务方法 --&gt; &lt;!-- name属性：指定方法名，可以使用星号代表多个字符 --&gt; &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;query*&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt; &lt;!-- read-only属性：设置只读属性 --&gt; &lt;!-- rollback-for属性：设置回滚的异常 --&gt; &lt;!-- no-rollback-for属性：设置不回滚的异常 --&gt; &lt;!-- isolation属性：设置事务的隔离级别 --&gt; &lt;!-- timeout属性：设置事务的超时属性 --&gt; &lt;!-- propagation属性：设置事务的传播行为 --&gt; &lt;tx:method name=&quot;save*&quot; read-only=&quot;false&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt; &lt;tx:method name=&quot;update*&quot; read-only=&quot;false&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt; &lt;tx:method name=&quot;delete*&quot; read-only=&quot;false&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt; &lt;!--如果有方法不符合上面这些规则的，是不会被事务管理的--&gt; &lt;!--所以加一个下面这个--&gt; &lt;tx:method name=&quot;*&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref=&quot;tx&quot; pointcut=&quot;execution(* com.atguigu.spring.service.impl.*.*(..))&quot;&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt;&lt;/beans&gt;","categories":[],"tags":[]},{"title":"jdbc","slug":"jdbc","date":"2022-09-29T15:31:35.000Z","updated":"2022-09-30T03:42:39.522Z","comments":true,"path":"2022/09/29/jdbc/","link":"","permalink":"http://example.com/2022/09/29/jdbc/","excerpt":"","text":"JDBC核心技术 讲师：宋红康 微博：尚硅谷-宋红康 第1章：JDBC概述1.1 数据的持久化 持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。 持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。 用数据库存储大量数据，方便快捷高效 1.2 Java中的数据存储技术 在Java中，数据库存取技术可分为如下几类： JDBC直接访问数据库 JDO (Java Data Object )技术 第三方O&#x2F;R工具，如Hibernate, Mybatis 等 JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。 1.3 JDBC介绍 JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口（一组API），定义了用来访问数据库的标准Java类库，（java.sql,javax.sql）使用这些类库可以以一种标准的方法、方便地访问数据库资源。 JDBC为访问不同的数据库提供了一种统一的途径，为开发者屏蔽了一些细节问题。 JDBC的目标是使Java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。 如果没有JDBC，那么Java程序访问数据库时是这样的： 有了JDBC，Java程序访问数据库时是这样的： 总结如下： 1.4 JDBC体系结构 JDBC接口（API）包括两个层次： 面向应用的API：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。 面向数据库的API：Java Driver API，供开发商开发数据库驱动程序用。 JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。 不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。 ————面向接口编程 1.5 JDBC程序编写步骤 补充：ODBC(Open Database Connectivity，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。 第2章：获取数据库连接2.1 要素一：Driver接口实现类2.1.1 Driver接口介绍 java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。 在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。 Oracle的驱动：oracle.jdbc.driver.OracleDriver mySql的驱动： com.mysql.jdbc.Driver 导入这些驱动的方法在csdn的收藏里有 2.1.2 加载与注册JDBC驱动 加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名 Class.forName(“com.mysql.jdbc.Driver”); 注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序 使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动 通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码： 2.2 要素二：URL JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。 JDBC URL的标准由三部分组成，各部分间用冒号分隔。 jdbc:子协议:子名称 协议：JDBC URL中的协议总是jdbc 子协议：子协议用于标识一个数据库驱动程序 子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了定位数据库提供足够的信息。包含主机名(对应服务端的ip地址)，端口号，数据库名 举例： 几种常用数据库的 JDBC URL MySQL的连接URL编写方式： jdbc:mysql:&#x2F;&#x2F;主机名称:mysql服务端口号&#x2F;数据库名称?参数&#x3D;值&amp;参数&#x3D;值 jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;atguigu jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;atguigu**?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集） jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;atguigu?user&#x3D;root&amp;password&#x3D;123456 Oracle 9i的连接URL编写方式： jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称 jdbc:oracle:thin:@localhost:1521:atguigu SQLServer的连接URL编写方式： jdbc:sqlserver:&#x2F;&#x2F;主机名称:sqlserver服务端口号:DatabaseName&#x3D;数据库名称 jdbc:sqlserver:&#x2F;&#x2F;localhost:1433:DatabaseName&#x3D;atguigu 2.3 要素三：用户名和密码 user,password可以用“属性名&#x3D;属性值”方式告诉数据库 可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接 2.4 数据库连接方式举例2.4.1 连接方式一12345678910111213141516171819202122@Test public void testConnection1() &#123; try &#123; //1.提供java.sql.Driver接口实现类的对象 Driver driver = null; driver = new com.mysql.jdbc.Driver(); //2.提供url，指明具体操作的数据 String url = &quot;jdbc:mysql://localhost:3306/test&quot;; //3.提供Properties的对象，指明用户名和密码 Properties info = new Properties(); info.setProperty(&quot;user&quot;, &quot;root&quot;); info.setProperty(&quot;password&quot;, &quot;root&quot;); //4.调用driver的connect()，获取连接 Connection conn = driver.connect(url, info); System.out.println(conn); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; 说明：上述代码中显式出现了第三方数据库的API Class.forName的介绍Class 类加载的形式常见类加载的方式 执行一个类自己的main方法这个类也会被加载 1 类名.Class2 new 对象3 Class.forName(“类的全路径”) ps(有个点注意一下)在执行的时候加上以下一句JVM的运行参数，可以观看类加载过程-XX:+TraceClassLoading例，用idea就这样添加来吧，小伙子们，上代码~ 第一种形式，类名.Classclass ClassTest{ static { System.out.println(“执行了静态代码块”); }}public class ClassLoderTest { public static void main(String[] args) throws ClassNotFoundException { Class&lt;?&gt; aClass2 &#x3D; ClassTest.class; }} 运行结果如下 ClassTest 这个类有被加载器加载，但是并没有输出语句，所以并没有被执行。 第二种形式， new 对象new 一个对象，以及利用这个对象调用成员变量方法等，就不在一一赘述。 class ClassTest{ static { System.out.println(“执行了静态代码块”); }}public class ClassLoderTest { public static void main(String[] args) throws ClassNotFoundException { new ClassTest(); }} 运行结果如下 ClassTest 这个 类有被加载，并且静态块语句有被输出，所以，这种方式会执行静态代码块。 第三种形式 ，Class.forName(“类的全路径”)class ClassTest{ static { System.out.println(“执行了静态代码块”); }}public class ClassLoderTest { public static void main(String[] args) throws ClassNotFoundException { Class&lt;?&gt; aClass3 &#x3D; Class.forName(“com.management.JavassistTest.ClassTest”); }} 运行结果如下 ClassTest 这个 类有被加载，并且静态块语句有被输出，所以，这种方式会执行静态代码块。 第三种形式的特殊用法但是第三种的形式有另一种方式使得它不执行。如下： class ClassTest{ static { System.out.println(“执行了静态代码块”); }}public class ClassLoderTest { public static void main(String[] args) throws ClassNotFoundException { Class&lt;?&gt; aClass3 &#x3D; Class.forName(“com.management.JavassistTest.ClassTest”, false,&#x2F;&#x2F;true的时候会执行 ClassLoader.getSystemClassLoader()); }} 2.4.2 连接方式二方式二，对方式一的迭代：在如下的程序中不出现第三方的api，使得程序具有更好的可移植性 123456789101112131415public void testConnection2() throws Exception &#123; //1.获取Driver实现类对象，使用反射 Class clazz = Class.forName(&quot;com.mysql.jdbc.Driver&quot;); Driver driver= (Driver) clazz.newInstance(); //2.提供要链接的数据库 String url=&quot;jdbc:mysql://localhost:3306/test&quot;; //3.提供连接需要的用户名和密码 Properties info=new Properties(); info.setProperty(&quot;user&quot;,&quot;root&quot;); info.setProperty(&quot;password&quot;,&quot;root&quot;); //4.获取连接 Connection connect = driver.connect(url, info); System.out.println(connect);&#125; 说明：相较于方式一，这里使用反射实例化Driver，不在代码中体现第三方数据库的API。体现了面向接口编程思想。 2.4.3 连接方式三12345678910111213141516171819202122@Test public void testConnection3() &#123; try &#123; //1.数据库连接的4个基本要素： String url = &quot;jdbc:mysql://localhost:3306/test&quot;; String user = &quot;root&quot;; String password = &quot;root&quot;; String driverName = &quot;com.mysql.jdbc.Driver&quot;; //2.实例化Driver Class clazz = Class.forName(driverName); Driver driver = (Driver) clazz.newInstance(); //3.注册驱动 DriverManager.registerDriver(driver); //4.获取连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 说明：使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。 2.4.4 连接方式四但这个地方最好不要用这个，mysql好使可能其他的就不好使了 123456789101112131415161718192021222324252627282930313233343536373839@Test public void testConnection4() &#123; try &#123; //1.数据库连接的4个基本要素： String url = &quot;jdbc:mysql://localhost:3306/test&quot;; String user = &quot;root&quot;; String password = &quot;root&quot;; String driverName = &quot;com.mysql.jdbc.Driver&quot;; //下面这一步是把com.mysql.jdbc.Driver类加载到内存中，一加载就执行静态代码块，进行了注册驱动和实例化 //2.加载驱动 （①实例化Driver ②注册驱动） Class.forName(driverName); //Driver driver = (Driver) clazz.newInstance(); //3.注册驱动 //DriverManager.registerDriver(driver); /* 可以注释掉上述代码的原因，是因为在mysql的Driver类中声明有： Driver类中的静态代码块 static &#123; try &#123; DriverManager.registerDriver(new Driver()); &#125; catch (SQLException var1) &#123; throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;); &#125; &#125; */ //3.获取连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 说明：不必显式的注册驱动了。因为在DriverManager的源码中已经存在静态代码块，实现了驱动的注册。 当类加载的时候会执行静态代码块 2.4.5 连接方式五(最终版)将数据库连接需要的四个基本信息声明在配置文件中，通过读取配置文件的格式，获取连接 123456789101112131415161718192021222324252627282930313233343536import java.io.File;import java.io.FileInputStream;import java.io.InputStream;import java.sql.Connection;import java.sql.Driver;import java.sql.DriverManager;import java.sql.SQLException;import java.util.Properties;class Main&#123; public static void main(String[] args) throws Exception &#123; testConnection5(); &#125; public static void testConnection5() throws Exception &#123; //1.加载配置文件 InputStream is=JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); Properties pros = new Properties(); pros.load(is); //2.读取配置信息 String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); String url = pros.getProperty(&quot;url&quot;); String driverClass = pros.getProperty(&quot;driverClass&quot;); //3.加载驱动 Class.forName(driverClass); //4.获取连接 Connection conn = DriverManager.getConnection(url, user, password); return conn; &#125;&#125; 其中，配置文件声明在工程的src目录下：【jdbc.properties】 1234user=rootpassword=abc123url=jdbc:mysql://localhost:3306/testdriverClass=com.mysql.jdbc.Driver 说明：使用配置文件的方式保存配置信息，在代码中加载配置文件 使用配置文件的好处： ①实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码②如果修改了配置信息，省去重新编译的过程也就是避免程序重新打包。 第3章：使用PreparedStatement实现CRUD操作crud就是增删改查 PreparedStatement是Statement的子接口 3.1 操作和访问数据库 数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。 在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式： Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。 CallableStatement：用于执行 SQL 存储过程 3.2 使用Statement操作数据表的弊端 通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。 Statement 接口中定义了下列方法用于执行 SQL 语句： 12int excuteUpdate(String sql)：执行更新操作INSERT、UPDATE、DELETEResultSet executeQuery(String sql)：执行查询操作SELECT 但是使用Statement操作数据表存在弊端： 问题一：存在拼串操作，繁琐 问题二：存在SQL注入问题 SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user&#x3D;’a’ OR 1 &#x3D; ‘ AND password &#x3D; ‘ OR ‘1’ &#x3D; ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。 对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public class StatementTest &#123; // 使用Statement的弊端：需要拼写sql语句，并且存在SQL注入的问题 @Test public void testLogin() &#123; Scanner scan = new Scanner(System.in); System.out.print(&quot;用户名：&quot;); String userName = scan.nextLine(); System.out.print(&quot;密 码：&quot;); String password = scan.nextLine(); // SELECT user,password FROM user_table WHERE USER = &#x27;1&#x27; or &#x27; AND PASSWORD = &#x27;=&#x27;1&#x27; or &#x27;1&#x27; = &#x27;1&#x27;; //上面这个是一个sql注入的语句让AND条件失效，or满足一个即可执行，最后一个恒能执行 String sql = &quot;SELECT user,password FROM user_table WHERE user = &#x27;&quot; + userName + &quot;&#x27; AND password = &#x27;&quot; + password+ &quot;&#x27;&quot;; User user = get(sql, User.class); if (user != null) &#123; System.out.println(&quot;登陆成功!&quot;); &#125; else &#123; System.out.println(&quot;用户名或密码错误！&quot;); &#125; &#125; // 使用Statement实现对数据表的查询操作 public &lt;T&gt; T get(String sql, Class&lt;T&gt; clazz) &#123; T t = null; Connection conn = null; Statement st = null; ResultSet rs = null; try &#123; // 1.加载配置文件 InputStream is = StatementTest.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); Properties pros = new Properties(); pros.load(is); // 2.读取配置信息 String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); String url = pros.getProperty(&quot;url&quot;); String driverClass = pros.getProperty(&quot;driverClass&quot;); // 3.加载驱动 Class.forName(driverClass); // 4.获取连接 conn = DriverManager.getConnection(url, user, password); st = conn.createStatement(); rs = st.executeQuery(sql); // 获取结果集的元数据 ResultSetMetaData rsmd = rs.getMetaData(); // 获取结果集的列数 int columnCount = rsmd.getColumnCount(); if (rs.next()) &#123; t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) &#123; // //1. 获取列的名称 // String columnName = rsmd.getColumnName(i+1); // 1. 获取列的别名 String columnName = rsmd.getColumnLabel(i + 1); // 2. 根据列名获取对应数据表中的数据 Object columnVal = rs.getObject(columnName); // 3. 将数据表中得到的数据，封装进对象 Field field = clazz.getDeclaredField(columnName); field.setAccessible(true); field.set(t, columnVal); &#125; return t; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭资源 if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (st != null) &#123; try &#123; st.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return null; &#125;&#125; User类 12345678910111213141516171819202122232425262728293031323334package com.atguigu2.statement.crud;public class User &#123; private String user; private String password; public User() &#123; &#125; public User(String user, String password) &#123; this.user = user; this.password = password; &#125; public String toString() &#123; return &quot;User [user=&quot; + this.user + &quot;, password=&quot; + this.password + &quot;]&quot;; &#125; public String getUser() &#123; return this.user; &#125; public void setUser(String user) &#123; this.user = user; &#125; public String getPassword() &#123; return this.password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 综上： 3.3 PreparedStatement的使用3.3.1 PreparedStatement介绍 可以通过调用 Connection 对象的 preparedStatement(String sql) 方法获取 PreparedStatement 对象 PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句 PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值 3.3.2 PreparedStatement vs Statement 代码的可读性和可维护性。 PreparedStatement 能最大可能提高性能： DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。 在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样每执行一次都要对传入的语句编译一次。 (语法检查，语义检查，翻译成二进制命令，缓存) PreparedStatement 可以防止 SQL 注入 3.3.3 Java与SQL对应数据类型转换表 Java类型 SQL类型 boolean BIT byte TINYINT short SMALLINT int INTEGER long BIGINT String CHAR,VARCHAR,LONGVARCHAR byte array BINARY , VAR BINARY java.sql.Date DATE java.sql.Time TIME java.sql.Timestamp TIMESTAMP 获取连接和关闭资源很常用所以进行封装 InputStream is&#x3D;JDBCUtils.class.getClassLoader().getResourceAsStream(“jdbc.properties”); 这个方法是用来锁定src目录下的内容 如果jdbc.properties在基础目录下，参数就应该变为 基础&#x2F;jdbc.properties 在idea java中路径都是使用&#x2F; 做斜杠，只有用到io用到整个windows系统的绝对路径时用\\斜杠来表示路径，而此时也不要用相对路径了，直接用绝对路径 在idea中文件中相对路径都用&#x2F; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124package 基础;import org.apache.commons.dbutils.DbUtils;import com.alibaba.druid.pool.DruidDataSource;import java.io.InputStream;import java.sql.*;import java.util.Properties;public class JDBCUtils &#123; /* 封装的是获取连接的操作 */ public static Connection getConnection() throws Exception&#123; //1.加载配置文件 InputStream is=JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); Properties pros = new Properties(); pros.load(is); //2.读取配置信息 String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); String url = pros.getProperty(&quot;url&quot;); String driverClass = pros.getProperty(&quot;driverClass&quot;); //3.加载驱动 Class.forName(driverClass); //4.获取连接 Connection conn = DriverManager.getConnection(url, user, password); return conn; &#125; /* 封装的是关闭资源的操作 */ public static void closeResource(Connection conn, Statement ps)&#123; //这个地方就不仅仅一定是mysql了所以用Statement try &#123; if (ps != null) &#123; ps.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(conn!=null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /* 封装的是查询时关闭资源的操作 */ public static void closeResource(Connection conn, Statement ps,ResultSet rs)&#123; //这个地方就不仅仅一定是mysql了所以用Statement try &#123; if (ps != null) &#123; ps.close(); &#125; &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; try &#123; if(conn!=null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; try &#123; if (rs != null) &#123; rs.close(); &#125; &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; //用DBUtils关闭资源 public static void closeResource1(Connection conn,Statement ps,ResultSet rs)&#123; DbUtils.closeQuietly(conn); DbUtils.closeQuietly(ps); DbUtils.closeQuietly(rs); &#125; private static DruidDataSource dataSource; /*static &#123; try&#123; Properties properties=new Properties(); //奇怪的是这个地方不能用绝对路径 InputStream inputStream=JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); properties.load(inputStream); dataSource= (DruidDataSource) DruidDataSourceFactory.createDataSource(properties); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;*/ //获取数据库连接池中的连接，如果返回null就是获取失败，有值就是获取成功 public static Connection getConnection3()&#123; Connection conn=null; try &#123; conn=dataSource.getConnection(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return conn; &#125;&#125; 3.3.4 使用PreparedStatement实现增、删、改操作更新数据 123456789101112131415161718import java.sql.*;public class ConnectionTest &#123; public void testupdate() throws Exception &#123; //获取数据库连接 Connection conn = JDBCUtils.getConnection(); //预编译sql语句，返回PreparedStarement实例 String sql=&quot;update customers set name= ? where id = ?&quot;; PreparedStatement ps=conn.prepareStatement(sql); //填充占位符 ps.setString(1,&quot;莫扎特&quot;); ps.setInt(2,18); //执行 ps.execute(); //资源的关闭 JDBCUtils.closeResource(conn,ps); &#125;&#125; 增加数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//向customers表中添加一条记录//没用自己封装的方法public void testInsert() &#123; Connection conn=null; PreparedStatement ps=null;try &#123; //一.获取连接 //1.加载配置文件 InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); Properties pros = new Properties(); pros.load(is); //2.读取配置信息 String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); String url = pros.getProperty(&quot;url&quot;); String driverClass = pros.getProperty(&quot;driverClass&quot;); //3.加载驱动 Class.forName(driverClass); //4.获取连接 conn = DriverManager.getConnection(url, user, password); System.out.println(conn); //5.预编译sql语句，返回PreparedStatement的实例 String sql = &quot;insert into customers(name,email,birth)values(?,?,?)&quot;;//?占位符 ps = conn.prepareStatement(sql); //6.填充占位符,第一个参数索引是从1开始的 ps.setString(1, &quot;哪吒&quot;); ps.setString(2, &quot;nezha&quot;); ps.setDate(3, new Date(32235235325L)); //7.执行操作 ps.execute();&#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; //8.关闭资源 try &#123; if (ps != null) &#123; ps.close(); &#125; &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; try &#123; conn.close(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125;&#125;&#125; 1234567891011121314151617181920212223242526272829//增删改通用方法 //用到了自己封装的方法//通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表）//可变形参args的个数应该和sql语句中的占位符数量相等 public void update(String sql,Object ... args)&#123; Connection conn = null; PreparedStatement ps = null; try &#123; //1.获取数据库的连接 conn = JDBCUtils.getConnection(); //2.获取PreparedStatement的实例 (或：预编译sql语句) ps = conn.prepareStatement(sql); //3.填充占位符 for(int i = 0;i &lt; args.length;i++)&#123; ps.setObject(i + 1, args[i]); &#125; //4.执行sql语句 ps.execute(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; //5.关闭资源 JDBCUtils.closeResource(conn, ps); &#125; &#125; 增删改通用方法的测试 123456789public static void main(String[] args) &#123; String sql=&quot;update `order` set order_name = ? where order_id=?&quot;; try &#123; update(sql,&quot;DD&quot;,&quot;2&quot;); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125;&#125; 3.3.5 使用PreparedStatement实现查询操作更复杂，因为查询之后会返回一个结果集 第一种 这个是针对customers表中的一种操作，并不是通用customers表的通用操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void testQuery1() &#123; Connection conn=null; ResultSet resultSet=null; PreparedStatement ps=null; try &#123; conn = JDBCUtils.getConnection(); //预编译sql语句 String sql = &quot;select id,name,email,birth from customers where id=?&quot;; ps = conn.prepareStatement(sql); //写满填充符 ps.setObject(1,1); //执行,并返回结果集 resultSet = ps.executeQuery(); //处理结果集 if (resultSet.next()) &#123;//判断结果集的下一条是否有数据，如果有数据返回true，并指针下移 //获取当前这条数据的各个字段的值 int id = resultSet.getInt(1); String name = resultSet.getString(2); String email = resultSet.getString(3);//获得当前这条的第三个字段 Date birth = resultSet.getDate(4); //方式一 System.out.println(&quot;id=&quot; + id + &quot;,name=&quot; + name + &quot;,email=&quot; + email + &quot;,birth&quot; + birth); //方式二 Object[] data = new Object[]&#123;id, name, email, birth&#125;; System.out.println(Arrays.toString(data)); //方式三 Customer customer = new Customer(id, name, email, birth); System.out.println(customer); &#125; &#125; catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; //关闭资源 JDBCUtils.closeResource(conn, ps, resultSet); &#125;&#125; 这种根据数据库设计的类就是JavaBean类 Customer类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class Customer &#123; /* ORM编程思想 一个数据表对应一个java类 表中的一条记录对应java类的一个对象 表中的一个字段对应java类的一个属性 */ public Customer(int id, String name, String email, Date birth) &#123; this.id = id; this.name = name; this.email = email; this.birth = birth; &#125; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Date getBirth() &#123; return birth; &#125; public void setBirth(Date birth) &#123; this.birth = birth; &#125; private String email; private Date birth; @Override public String toString() &#123; return &quot;Customer&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, email=&#x27;&quot; + email + &#x27;\\&#x27;&#x27; + &quot;, birth=&quot; + birth + &#x27;&#125;&#x27;; &#125;&#125; 第二种 针对customers表的一个通用操作 123456789101112131415161718192021222324252627282930313233343536373839404142public static Customer queryForCustomers(String sql,Object...args) throws Exception &#123; Connection conn=null; PreparedStatement ps=null; ResultSet rs=null; try &#123; conn = JDBCUtils.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; rs = ps.executeQuery(); //获取结果集的元数据 ResultSetMetaData rsmd = rs.getMetaData(); //得到结果集的列数 int columnCount = rsmd.getColumnCount(); if (rs.next()) &#123;//判断结果集是否还有下一行 Customer cust = new Customer(); //处理结果集一行数据中的每一个列 for (int i = 0; i &lt; columnCount; i++) &#123; Object value = rs.getObject(i + 1); //获取每个列的列名 String columnName = rsmd.getColumnName(i + 1); //给cust对象指定的columnName属性，赋值为value，通过反射 //获得的是Customer的columnName代指这个属性 Field field = Customer.class.getDeclaredField(columnName); field.setAccessible(true);//让这个属性可以被访问 field.set(cust, value); &#125; return cust; &#125; &#125;catch(Exception e)&#123;e.printStackTrace();&#125;finally &#123; JDBCUtils.closeResource(conn,ps,rs); &#125; return null; &#125; 这个地方如果字段名和Customer类中的属性名不一致将字段名起别名这样结果集就的字段名就和属性名一致了 用order表做例子 1String sql=&quot;select order_id orderId,order_name orderName,order_date orderDate from `order` where id=?&quot;; 这样就将order_id字段起别名为orderId 同时要将getColumnName()换成getColumnLabel()获取列的别名 getColumnName()不推荐使用 测试： 12345678910public static void main(String[] args) throws Exception &#123; String sql=&quot;select id,name,birth,email from customers where id = ?&quot;; Customer customer=queryForCustomers(sql,13); System.out.println(customer); String sql1=&quot;select name,email from customers where name=?&quot;; Customer customer1=queryForCustomers(sql1,&quot;周杰伦&quot;); System.out.println(customer1);&#125; 第三种 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 // 通用的针对于不同表的查询:返回表中的一条记录//这是一个泛型方法 public &lt;T&gt; T getInstance(Class&lt;T&gt; clazz, String sql, Object... args) &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; // 1.获取数据库连接 conn = JDBCUtils.getConnection(); // 2.预编译sql语句，得到PreparedStatement对象 ps = conn.prepareStatement(sql); // 3.填充占位符 for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; // 4.执行executeQuery(),得到结果集：ResultSet rs = ps.executeQuery(); // 5.得到结果集的元数据：ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); // 6.1通过ResultSetMetaData得到columnCount(列数),columnLabel(列标签)；通过ResultSet得到列值 int columnCount = rsmd.getColumnCount(); if (rs.next()) &#123;//判断结果集的下一条是否有数据，如果有数据返回true，并指针下移 //如果返回false指针不会下移 T t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) &#123;// 遍历每一个列 // 获取列值 Object columnVal = rs.getObject(i + 1); // 获取列的别名:列的别名，使用类的属性名充当 String columnLabel = rsmd.getColumnLabel(i + 1); // 6.2使用反射，给对象的相应属性赋值 Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columnVal); &#125; return t; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 7.关闭资源 JDBCUtils.closeResource(conn, ps, rs); &#125; return null; &#125; 说明：使用PreparedStatement实现的查询操作可以替换Statement实现的查询操作，解决Statement拼串和SQL注入问题。 测试 12345public static void main(String[] args) &#123; String sql=&quot;select id,name,email from customers where id=?&quot;; Customer instance = getInstance(Customer.class, sql, 12); System.out.println(instance);&#125; 第四种情况 当结果集有多行的时候使用集合来存储 这个不是查询好多次，是一次查询出来很多的时候用 1234567891011121314151617181920212223242526272829303132333435363738394041424344public static&lt;T&gt; List&lt;T&gt; getInstance(Class&lt;T&gt; clazz, String sql, Object...args)&#123; Connection conn=null; PreparedStatement ps=null; ResultSet rs=null; try &#123; conn = JDBCUtils.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; rs = ps.executeQuery(); //获取结果集的元数据 ResultSetMetaData rsmd = rs.getMetaData(); //得到结果集的列数 int columnCount = rsmd.getColumnCount(); //创建集合 ArrayList&lt;T&gt; list = new ArrayList&lt;T&gt;(); while (rs.next()) &#123;//判断结果集是否还有下一行 T t = clazz.newInstance(); //处理结果集一行数据中的每一个列 for (int i = 0; i &lt; columnCount; i++) &#123; Object value = rs.getObject(i + 1); //获取每个列的列名 String columnName = rsmd.getColumnName(i + 1); //给t对象指定的columnName属性，赋值为value，通过反射 Field field = clazz.getDeclaredField(columnName); field.setAccessible(true);//让这个属性可以被访问 field.set(t, value); &#125; list.add(t); &#125; return list; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; JDBCUtils.closeResource(conn,ps,rs); &#125; return null;&#125; 测试 1234567public static void main(String[] args) &#123; String sql=&quot;select id,name,email from customers where id&lt;?&quot;; List&lt;Customer&gt; instance = getInstance(Customer.class, sql, 12); for (Customer customer : instance) &#123; System.out.println(customer); &#125;&#125; PreparedStatement防止了sql注入 主要是对sql语句进行了预编译，and关系就是and关系不可能再变成是or关系 其他好处：1.PreparedStatement操作Blob数据，而Statement做不到 ​ 2.PreparedStatement可以实现更高效的批量操作 3.4 ResultSet与ResultSetMetaData3.4.1 ResultSet 查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象 ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现 ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。 ResultSet 对象维护了一个指向当前数据行的游标，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。 当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。 例如: getInt(1), getString(“name”) 注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。 ResultSet 接口的常用方法： boolean next() getString() … 3.4.2 ResultSetMetaData 可用于获取关于 ResultSet 对象中列的类型和属性信息的对象 ResultSetMetaData meta &#x3D; rs.getMetaData(); getColumnName(int column)：获取指定列的名称 getColumnLabel(int column)：获取指定列的别名 getColumnCount()：返回当前 ResultSet 对象中的列数。 getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。 getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。 isNullable(int column)：指示指定列中的值是否可以为 null。 isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。 问题1：得到结果集后, 如何知道该结果集中有哪些列 ？ 列名是什么？ ​ 需要使用一个描述 ResultSet 的对象， 即 ResultSetMetaData 问题2：关于ResultSetMetaData 如何获取 ResultSetMetaData： 调用 ResultSet 的 getMetaData() 方法即可 获取 ResultSet 中有多少列：调用 ResultSetMetaData 的 getColumnCount() 方法 获取 ResultSet 每一列的列的别名是什么：调用 ResultSetMetaData 的getColumnLabel() 方法 3.5 资源的释放 释放ResultSet, Statement,Connection。 数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是尽量晚创建，尽量早的释放。 可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。 3.6 JDBC API小结 两种思想 面向接口编程的思想 ORM思想(object relational mapping) 一个数据表对应一个java类 表中的一条记录对应java类的一个对象 表中的一个字段对应java类的一个属性 sql是需要结合列名和表的属性名来写。注意起别名。 两种技术 JDBC结果集的元数据：ResultSetMetaData 获取列数：getColumnCount() 获取列的别名：getColumnLabel() 通过反射，创建指定类的对象，获取指定的属性并赋值 章节练习练习题1：从控制台向数据库的表customers中插入一条数据，表结构如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class ConnectionTest &#123; public static void main(String[] args) &#123; Scanner scanner =new Scanner(System.in); System.out.println(&quot;请输入用户名&quot;); String name=scanner.next(); System.out.println(&quot;请输入邮箱&quot;); String email=scanner.next(); System.out.println(&quot;请输入生日&quot;); String birthday=scanner.next();//可以用字符串但是格式一定要正确 String sql=&quot;insert into customers(name,email,birth)values(?,?,?)&quot;; int insertCount=update(sql,name,email,birthday); if(insertCount&gt;0)&#123; System.out.println(&quot;添加成功&quot;); &#125; else &#123; System.out.println(&quot;添加失败&quot;); &#125; &#125; public static int update(String sql,Object...args)&#123; Connection conn=null; PreparedStatement ps=null; try&#123; conn=JDBCUtils.getConnection(); ps=conn.prepareStatement(sql); for(int i=0;i&lt;args.length;i++)&#123; ps.setObject(i+1,args[i]); &#125; //如果执行的是查询操作有返回结果，则此方法返回true //如果执行的是增删改操作，没有返回结果，则此方法返回false //方式一 //return ps.execute(); //方式二 return ps.executeUpdate();//返回的是影响的行数,增删改都可以是这个，同时也可以执行sql语句 &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; finally&#123; JDBCUtils.closeResource(conn,ps); &#125; return 0; &#125;//这种id是递增的可以默认不添加也会自增一个，也可以指定id但不能够指定与原表中重复的id， 练习题2：创立数据库表 examstudent，表结构如下： 向数据表中添加如下数据： 代码实现1：插入一个新的student 信息 请输入考生的详细信息 Type:IDCard:ExamCard:StudentName:Location:Grade: 信息录入成功! 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Main&#123; public static int update(String sql,Object ... args)&#123; Connection conn = null; PreparedStatement ps = null; try &#123; //1.获取数据库的连接 conn = JDBCUtils.getConnection(); //2.获取PreparedStatement的实例 (或：预编译sql语句) ps = conn.prepareStatement(sql); //3.填充占位符 for(int i = 0;i &lt; args.length;i++)&#123; ps.setObject(i + 1, args[i]); &#125; return ps.executeUpdate(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; //5.关闭资源 JDBCUtils.closeResource(conn, ps); return 0; &#125; &#125; public static void main(String[] args) throws Exception &#123;//问题一，向examstudent表中添加一条记录 Scanner in=new Scanner(System.in); System.out.print(&quot;四级/六级:&quot;); int type=in.nextInt(); System.out.println(&quot;身份证号&quot;); String IDCard=in.next(); System.out.println(&quot;准考证号&quot;); String examCard=in.next(); System.out.print(&quot;学生姓名：&quot;); String studentName=in.next(); System.out.println(&quot;所在城市&quot;); String location=in.next(); System.out.println(&quot;考试成绩&quot;); int grade=in.nextInt(); String sql=&quot;insert into examstudent(Type,IDCard,ExamCard,StudentName,Location,Grade)values(?,?,?,?,?,?)&quot;; int insertCount=update(sql,type,IDCard,examCard,studentName,location,grade); if(insertCount&gt;0)&#123; System.out.println(&quot;添加成功&quot;); &#125; else &#123; System.out.println(&quot;添加失败&quot;); &#125; &#125;&#125; 代码实现2：在 eclipse中建立 java 程序：输入身份证号或准考证号可以查询到学生的基本信息。结果如下： 代码实现3：完成学生信息的删除功能 第4章 操作BLOB类型字段4.1 MySQL BLOB类型 MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。 插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。 MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的) 实际使用中根据需要存入的数据大小定义不同的BLOB类型。 需要注意的是：如果存储的文件过大，数据库的性能会下降。 如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： max_allowed_packet&#x3D;16M。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。 4.2 向数据表中插入大数据类型12345678910111213141516171819//获取连接Connection conn = JDBCUtils.getConnection(); String sql = &quot;insert into customers(name,email,birth,photo)values(?,?,?,?)&quot;;PreparedStatement ps = conn.prepareStatement(sql);// 填充占位符ps.setString(1, &quot;徐海强&quot;);ps.setString(2, &quot;xhq@126.com&quot;);ps.setDate(3, new Date(new java.util.Date().getTime()));// 操作Blob类型的变量FileInputStream fis = new FileInputStream(&quot;xhq.png&quot;);ps.setBlob(4, fis);//执行ps.execute(); fis.close();JDBCUtils.closeResource(conn, ps); 4.3 修改数据表中的Blob类型字段1234567891011121314Connection conn = JDBCUtils.getConnection();String sql = &quot;update customers set photo = ? where id = ?&quot;;PreparedStatement ps = conn.prepareStatement(sql);// 填充占位符// 操作Blob类型的变量FileInputStream fis = new FileInputStream(&quot;coffee.png&quot;);ps.setBlob(1, fis);ps.setInt(2, 25);ps.execute();fis.close();JDBCUtils.closeResource(conn, ps); 4.4 从数据表中读取大数据类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import com.mysql.jdbc.JDBC4PreparedStatement;import java.io.*;import java.sql.*;import java.util.*;import java.util.Date;public class Main &#123; public static void main(String[] args) throws Exception &#123; testQueryBlob(); &#125; public static void testQueryBlob() &#123; Connection conn=null; PreparedStatement ps=null; FileOutputStream fos = null; InputStream is = null; try &#123; conn = JDBCUtils.getConnection(); String sql = &quot;select id,name,email,birth,photo from customers where id=?&quot;; ps = conn.prepareStatement(sql); ps.setInt(1, 27); ResultSet rs = ps.executeQuery(); if (rs.next()) &#123; /* 方式一 int id=rs.getInt(1); String name=rs.getString(2); String email=rs.getString(3); Date date=rs.getDate(4); */ int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); String email = rs.getString(&quot;email&quot;); Date birth = rs.getDate(&quot;birth&quot;); Customer cust = new Customer(id, name, email, birth); System.out.println(cust); //将Blob类型的字段下载下来，以文件的方式保存在本地 Blob photo = rs.getBlob(&quot;photo&quot;); is = photo.getBinaryStream(); fos = new FileOutputStream(&quot;D:\\\\同步空间\\\\新建文件夹\\\\java\\\\zz.jpg&quot;); byte[] buffer = new byte[1024]; int len; while ((len = is.read(buffer)) != -1) &#123; fos.write(buffer, 0, len); &#125; &#125; &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; finally &#123; try &#123; if(is!=null) &#123; is.close(); &#125; &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; try &#123; if(fos!=null) &#123; fos.close(); &#125; &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; JDBCUtils.closeResource(conn, ps); &#125; &#125;&#125; 第5章 批量插入5.1 批量执行SQL语句当需要成批插入或者更新记录时，可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率 JDBC的批量处理语句包括下面三个方法： addBatch(String)：添加需要批量处理的SQL语句或是参数； executeBatch()：执行批量处理语句； clearBatch():清空缓存的数据 通常我们会遇到两种批量执行SQL语句的情况： 多条SQL语句的批量处理； 一个SQL语句的批量传参； 5.2 高效的批量插入举例：向数据表中插入20000条数据 数据库中提供一个goods表。创建如下： 1234CREATE TABLE goods(id INT PRIMARY KEY AUTO_INCREMENT,NAME VARCHAR(20)); 5.2.1 实现层次一：使用Statement123456Connection conn = JDBCUtils.getConnection();Statement st = conn.createStatement();for(int i = 1;i &lt;= 20000;i++)&#123; String sql = &quot;insert into goods(name) values(&#x27;name_&#x27; + &quot;+ i +&quot;)&quot;; st.executeUpdate(sql);&#125; 5.2.2 实现层次二：使用PreparedStatement123456789101112131415161718192021222324252627282930313233343536373839import com.mysql.jdbc.JDBC4PreparedStatement;import java.io.*;import java.sql.*;import java.util.*;import java.util.Date;public class Main &#123; public static void main(String[] args) throws Exception &#123; testInsearch(); &#125; public static void testInsearch() &#123; Connection conn=null; PreparedStatement ps=null; try&#123; long start = System.currentTimeMillis(); conn = JDBCUtils.getConnection(); String sql=&quot;insert into goods(name)value(?)&quot;;//预编译sql语句，缓存下来之后每次只需要该改变占位符的值， ps=conn.prepareStatement(sql); for(int i=1;i&lt;=20000;i++) &#123; ps.setObject(1,&quot;name_&quot;+i); ps.execute(); &#125; long end = System.currentTimeMillis(); System.out.println(&quot;花费的时间&quot;+(end-start)); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; finally&#123; JDBCUtils.closeResource(conn,ps); &#125; &#125;&#125; 5.2.3 实现层次三12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * 修改1： 使用 addBatch() / executeBatch() / clearBatch() * 修改2：mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。 * ?rewriteBatchedStatements=true 写在配置文件的url后面 * 修改3：使用更新的mysql 驱动：mysql-connector-java-5.1.37-bin.jar * */import com.mysql.jdbc.JDBC4PreparedStatement;import java.io.*;import java.sql.*;import java.util.*;import java.util.Date;public class Main &#123; public static void main(String[] args) throws Exception &#123; testInsearch(); &#125; public static void testInsearch() &#123; Connection conn=null; PreparedStatement ps=null; try&#123; long start = System.currentTimeMillis(); conn = JDBCUtils.getConnection(); String sql=&quot;insert into goods(name)value(?)&quot;;//预编译sql语句，缓存下来之后每次只需要该改变占位符的值， ps=conn.prepareStatement(sql); for(int i=1;i&lt;=20000;i++) &#123; ps.setObject(1,&quot;name_&quot;+i); //1.攒sql ps.addBatch(); if(i%500==0)&#123; //2.执行batch,每五百次执行一次 ps.executeBatch(); //3.清空batch ps.clearBatch(); &#125; &#125; long end = System.currentTimeMillis(); System.out.println(&quot;花费的时间&quot;+(end-start)); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; finally&#123; JDBCUtils.closeResource(conn,ps); &#125; &#125;&#125; 5.2.4 实现层次四1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** 层次四：在层次三的基础上操作* 使用Connection 的 setAutoCommit(false) / commit()*/import com.mysql.jdbc.JDBC4PreparedStatement;import java.io.*;import java.sql.*;import java.util.*;import java.util.Date;public class Main &#123; public static void main(String[] args) throws Exception &#123; testInsearch(); &#125; public static void testInsearch() &#123; Connection conn=null; PreparedStatement ps=null; try&#123; long start = System.currentTimeMillis(); conn = JDBCUtils.getConnection(); //设置不允许自动提交数据 conn.setAutoCommit(false);//就是那些数据不是立马提交的 String sql=&quot;insert into goods(name)value(?)&quot;;//预编译sql语句，缓存下来之后每次只需要该改变占位符的值， ps=conn.prepareStatement(sql); for(int i=1;i&lt;=20000;i++) &#123; ps.setObject(1,&quot;name_&quot;+i); //1.攒sql ps.addBatch(); if(i%500==0)&#123; //2.执行batch,每五百次执行一次 ps.executeBatch(); //3.清空batch ps.clearBatch(); &#125; &#125; //提交数据 conn.commit();//统一提交所有的数据 long end = System.currentTimeMillis(); System.out.println(&quot;花费的时间&quot;+(end-start)); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; finally&#123; JDBCUtils.closeResource(conn,ps); &#125; &#125;&#125; 第6章： 数据库事务6.1 数据库事务介绍 事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。(一个或多个DML操作) 事务处理（事务操作）：保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都**被提交(commit)，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务回滚(rollback)**到最初状态。 为确保数据库中数据的一致性，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。 6.2 JDBC事务处理 数据一旦提交，就不可回滚。 数据什么时候意味着提交？ 当一个连接对象被创建时，默认情况下是自动提交事务：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。 关闭数据库连接，数据就会自动的提交。如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。 JDBC程序中为了让多个 SQL 语句作为一个事务执行： 调用 Connection 对象的 setAutoCommit(false); 以取消自动提交事务 在所有的 SQL 语句都成功执行后，调用 commit(); 方法提交事务 在出现异常时，调用 rollback(); 方法回滚事务 若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。 【案例：用户AA向用户BB转账100】 AA的账户余额减100，BB的账户余额加100 同时要保证这两个操作要么都进行，要么都不进行 错误案例 123456789101112131415161718192021222324252627282930313233343536import java.sql.Connection;import java.sql.PreparedStatement;class Main &#123; public static void main(String []args)&#123; String sql1=&quot;update user_table set balance=balance-100 where user = ?&quot;;update(sql1,&quot;AA&quot;);//模拟网络异常 System.out.println(10/0);//这个地方出现了异常的话只有AA的钱减100，BB不会增加 String sql2=&quot;update user_table set balance=balance+100 where user = ?&quot;; update(sql2,&quot;BB&quot;); System.out.println(&quot;转账成功&quot;); &#125; //update version1.0 public static int update(String sql, Object... args) &#123; Connection conn = null; PreparedStatement ps = null; try &#123; conn = JDBCUtils.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; return ps.executeUpdate();//返回的是影响的行数,增删改都可以是这个，同时也可以执行sql语句 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(conn, ps); &#125; return 0; &#125;&#125; 正确的方法 原理：1.数据一旦提交，就不可回滚 ​ 哪些操作会导致数据的自动提交 1.DDL操作一旦执行，都会自动提交 2.DML默认情况下，一旦执行，就会自动提交，我们可以通过set autocommit&#x3D;false的方式取消DML操作的自动提交 3.默认在关闭连接的时候，会自动提交数据 正确案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;class Main &#123; public static void main(String []args) &#123; Connection conn = null; try &#123; conn = JDBCUtils.getConnection(); System.out.println(conn.getAutoCommit()); //取消数据的自动提交 conn.setAutoCommit(false);//让他不能自动提交 String sql1 = &quot;update user_table set balance=balance-100 where user = ?&quot;; update(conn, sql1, &quot;AA&quot;);//模拟网络异常 System.out.println(10 / 0); String sql2 = &quot;update user_table set balance=balance+100 where user = ?&quot;; update(conn, sql2, &quot;BB&quot;); System.out.println(&quot;转账成功&quot;); //提交数据 conn.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; conn.rollback();//回滚数据，保证了如果有异常两个都不执行成功 &#125; catch (SQLException ex) &#123; ex.printStackTrace(); &#125; &#125; finally &#123; conn.setAutoCommit(true); JDBCUtils.closeResource(conn, null); &#125; &#125; //update version2.0 public static int update(Connection conn,String sql, Object... args) &#123;//conn作为参数是因为要让几次操作都用一个连接 PreparedStatement ps = null; try &#123; ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; return ps.executeUpdate();//返回的是影响的行数,增删改都可以是这个，同时也可以执行sql语句 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(null, ps); &#125; return 0; &#125;&#125; 6.3 事务的ACID属性 原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency）事务必须使数据库从一个一致性状态变换到另外一个一致性状态。 隔离性（Isolation）事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。 6.3.1 数据库的并发问题 对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题: 脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。 不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段。之后, T1再次读取同一个字段, 值就不同了。 幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。 数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。 一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。 6.3.2 四种隔离级别 数据库提供的4种事务隔离级别： Oracle 支持的 2 种事务隔离级别：READ COMMITED, SERIALIZABLE。 Oracle 默认的事务隔离级别为: READ COMMITED 。 Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: REPEATABLE READ。 6.3.3 在MySql中设置隔离级别 每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。 查看当前的隔离级别: 1SELECT @@tx_isolation; 设置当前 mySQL 连接的隔离级别: 1set transaction isolation level read committed; 设置数据库系统的全局的隔离级别: 1set global transaction isolation level read committed; 补充操作： 创建mysql数据库用户： 1create user tom identified by &#x27;abc123&#x27;; 授予权限 123456#授予通过网络方式登录的tom用户，对所有库所有表的全部权限，密码设为abc123.grant all privileges on *.* to tom@&#x27;%&#x27; identified by &#x27;abc123&#x27;; #给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。grant select,insert,delete,update on atguigudb.* to tom@localhost identified by &#x27;abc123&#x27;; 设置隔离级别演示 （有报错） 防止脏读 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import jdk.nashorn.internal.scripts.JD;import src.User;import java.lang.reflect.Field;import java.sql.*;class Main &#123; public static void main(String []args) throws Exception &#123; testTranscationSelect(); &#125; public static void testTranscationSelect() throws Exception &#123; Connection conn= JDBCUtils.getConnection(); //获得当前的隔离级别 System.out.println(conn.getTransactionIsolation()); //设计数据库的隔离级别 conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED); //取消自动提交 conn.setAutoCommit(false); String sql=&quot;select user,password,balance from user_table where user=?&quot;; Main main=new Main(); User user=main.getInstance(conn, User.class,sql,&quot;CC&quot;); System.out.println(user); &#125; public static void testTranscationUpdate() throws Exception &#123; Connection conn= JDBCUtils.getConnection(); //取消自动提交 conn.setAutoCommit(false); String sql=&quot;update user_table set balance=? where user=?&quot;; update(conn,sql,5000,&quot;CC&quot;); &#125; //考虑上事务的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz, String sql, Object... args) &#123; PreparedStatement ps = null; ResultSet rs = null; try &#123; // 2.预编译sql语句，得到PreparedStatement对象 ps = conn.prepareStatement(sql); // 3.填充占位符 for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; // 4.执行executeQuery(),得到结果集：ResultSet rs = ps.executeQuery(); // 5.得到结果集的元数据：ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); // 6.1通过ResultSetMetaData得到columnCount(列数),columnLabel(列标签)；通过ResultSet得到列值 int columnCount = rsmd.getColumnCount(); if (rs.next()) &#123;//判断结果集的下一条是否有数据，如果有数据返回true，并指针下移 //如果返回false指针不会下移 T t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) &#123;// 遍历每一个列 // 获取列值 Object columnVal = rs.getObject(i + 1); // 获取列的别名:列的别名，使用类的属性名充当 String columnLabel = rsmd.getColumnLabel(i + 1); // 6.2使用反射，给对象的相应属性赋值 Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columnVal); &#125; return t; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 7.关闭资源 JDBCUtils.closeResource(null, ps, rs); &#125; return null; &#125; public static int update(Connection conn,String sql, Object... args) &#123;//conn作为参数是因为要让几次操作都用一个连接 PreparedStatement ps = null; try &#123; ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; return ps.executeUpdate();//返回的是影响的行数,增删改都可以是这个，同时也可以执行sql语句 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(null, ps); &#125; return 0; &#125;&#125; 小结这是关于增删改查询的几种方法，是在外面用conn 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132import java.lang.reflect.Field;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.ResultSetMetaData;import java.util.ArrayList;import java.util.List;public class BaseDao &#123;//增删改通用方法 public static int update(Connection conn, String sql, Object... args) &#123;//conn作为参数是因为要让几次操作都用一个连接 PreparedStatement ps = null; try &#123; ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; return ps.executeUpdate();//返回的是影响的行数,增删改都可以是这个，同时也可以执行sql语句 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(null, ps); &#125; return 0; &#125; //查询返回一条数据的方法 //version2.0 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz, String sql, Object... args) &#123; PreparedStatement ps = null; ResultSet rs = null; try &#123; // 2.预编译sql语句，得到PreparedStatement对象 ps = conn.prepareStatement(sql); // 3.填充占位符 for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; // 4.执行executeQuery(),得到结果集：ResultSet rs = ps.executeQuery(); // 5.得到结果集的元数据：ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); // 6.1通过ResultSetMetaData得到columnCount(列数),columnLabel(列标签)；通过ResultSet得到列值 int columnCount = rsmd.getColumnCount(); if (rs.next()) &#123;//判断结果集的下一条是否有数据，如果有数据返回true，并指针下移 //如果返回false指针不会下移 T t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) &#123;// 遍历每一个列 // 获取列值 Object columnVal = rs.getObject(i + 1); // 获取列的别名:列的别名，使用类的属性名充当 String columnLabel = rsmd.getColumnLabel(i + 1); // 6.2使用反射，给对象的相应属性赋值 Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columnVal); &#125; return t; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 7.关闭资源 JDBCUtils.closeResource(null, ps, rs); &#125; return null; &#125; //查询返回多条数据的方法 //version2.0 public &lt;T&gt; List&lt;T&gt; getForList(Connection conn,Class&lt;T&gt; clazz, String sql, Object...args)&#123; PreparedStatement ps=null; ResultSet rs=null; try &#123; conn = JDBCUtils.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; rs = ps.executeQuery(); //获取结果集的元数据 ResultSetMetaData rsmd = rs.getMetaData(); //得到结果集的列数 int columnCount = rsmd.getColumnCount(); //创建集合 ArrayList&lt;T&gt; list = new ArrayList&lt;T&gt;(); while (rs.next()) &#123;//判断结果集是否还有下一行 T t = clazz.newInstance(); //处理结果集一行数据中的每一个列 for (int i = 0; i &lt; columnCount; i++) &#123; Object value = rs.getObject(i + 1); //获取每个列的列名 String columnName = rsmd.getColumnName(i + 1); //给t对象指定的columnName属性，赋值为value，通过反射 Field field = clazz.getDeclaredField(columnName); field.setAccessible(true);//让这个属性可以被访问 field.set(t, value); &#125; list.add(t); &#125; return list; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; JDBCUtils.closeResource(null,ps,rs); &#125; return null; &#125;&#125; DAO类BaseDAO这是一个封装的所有的查询和增删改的方法的类用作抽象类，提供方法 封装了针对数据表的通用操作，具体表具体实现 BaseDao.class 封装起来，用来给具体的数据表处理类来做父类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153import java.lang.reflect.Field;import java.sql.*;import java.util.ArrayList;import java.util.List;public abstract class BaseDao &#123; public static void main(String[] args) throws Exception &#123; &#125; public static int update(Connection conn, String sql, Object... args) &#123;//conn作为参数是因为要让几次操作都用一个连接 PreparedStatement ps = null; try &#123; ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; return ps.executeUpdate();//返回的是影响的行数,增删改都可以是这个，同时也可以执行sql语句 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(null, ps); &#125; return 0; &#125; //version2.0 public &lt;T&gt; T getInstance(Connection conn, Class&lt;T&gt; clazz, String sql, Object... args) &#123; PreparedStatement ps = null; ResultSet rs = null; try &#123; // 2.预编译sql语句，得到PreparedStatement对象 ps = conn.prepareStatement(sql); // 3.填充占位符 for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; // 4.执行executeQuery(),得到结果集：ResultSet rs = ps.executeQuery(); // 5.得到结果集的元数据：ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); // 6.1通过ResultSetMetaData得到columnCount(列数),columnLabel(列标签)；通过ResultSet得到列值 int columnCount = rsmd.getColumnCount(); if (rs.next()) &#123;//判断结果集的下一条是否有数据，如果有数据返回true，并指针下移 //如果返回false指针不会下移 T t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) &#123;// 遍历每一个列 // 获取列值 Object columnVal = rs.getObject(i + 1); // 获取列的别名:列的别名，使用类的属性名充当 String columnLabel = rsmd.getColumnLabel(i + 1); // 6.2使用反射，给对象的相应属性赋值 Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columnVal); &#125; return t; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 7.关闭资源 JDBCUtils.closeResource(null, ps, rs); &#125; return null; &#125; //version2.0 public &lt;T&gt; List&lt;T&gt; getForList(Connection conn, Class&lt;T&gt; clazz, String sql, Object... args) &#123; PreparedStatement ps = null; ResultSet rs = null; try &#123; conn = JDBCUtils.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; rs = ps.executeQuery(); //获取结果集的元数据 ResultSetMetaData rsmd = rs.getMetaData(); //得到结果集的列数 int columnCount = rsmd.getColumnCount(); //创建集合 ArrayList&lt;T&gt; list = new ArrayList&lt;T&gt;(); while (rs.next()) &#123;//判断结果集是否还有下一行 T t = clazz.newInstance(); //处理结果集一行数据中的每一个列 for (int i = 0; i &lt; columnCount; i++) &#123; Object value = rs.getObject(i + 1); //获取每个列的列名 String columnName = rsmd.getColumnName(i + 1); //给t对象指定的columnName属性，赋值为value，通过反射 Field field = clazz.getDeclaredField(columnName); field.setAccessible(true);//让这个属性可以被访问 field.set(t, value); &#125; list.add(t); &#125; return list; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(null, ps, rs); &#125; return null; &#125; //用于查询一些特殊值的通用方法，就只有一行一列的时候一般用这个 public &lt;E&gt; E getValue(Connection conn, String sql, Object... args) &#123; PreparedStatement ps = null; ResultSet rs = null; try &#123; ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; rs = ps.executeQuery(); if (rs.next()) &#123; return (E) rs.getObject(1); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally&#123; JDBCUtils.closeResource(null, ps, rs); &#125;return null; &#125; CustomerDAO针对Customer接口来设计一个API 具体的类实现的接口 123456789101112131415161718192021222324252627import java.sql.Connection;import java.util.List;import java.sql.Date;//此接口用于规范针对于customers表的常用操作public interface CustomerDAO &#123; //将cust对象添加到数据库中 void insert(Connection conn, Customer cust); //针对指定的id，删除表中的一条记录 void deleteById(Connection conn,int id); //针对内存中的cust对象，去修改数据表中的指定的记录 void update(Connection conn,Customer cust); //针对指定的id查询得到对应的Customer对象 void getCustomerById(Connection conn,int id); //查询表中的所有记录构成的集合 List&lt;Customer&gt; getAll(Connection conn); //返回数据表中数据的条目数 Long getCount(Connection conn); //返回数据表中最大的生日 Date getMaxBirth(Connection conn);&#125; CustomerDAOImpl 针对一个表具体的类，继承了上面的类，实现了上面的接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.sql.Connection;import java.sql.Date;import java.util.List;public class CustomerDAOImpl extends BaseDao implements CustomerDAO&#123; @Override public void insert(Connection conn, Customer cust) &#123; String sql=&quot;insert into customers(name,email,birth)values(?,?,?)&quot;; update(conn,sql,cust.getName(),cust.getEmail(),cust.getBirth()); &#125; @Override public void deleteById(Connection conn, int id) &#123; String sql=&quot;delete from customers where id=?&quot;;update(conn,sql,id); &#125; @Override public void update(Connection conn, Customer cust) &#123; String sql=&quot;update customers set name=?,email=?,birth=? where id=?&quot;; update(conn,sql,cust.getName(),cust.getEmail(),cust.getBirth(),cust.getBirth()); &#125; @Override public Customer getCustomerById(Connection conn, int id) &#123; String sql=&quot;select id,name,email,birth from customers where id=?&quot;; Customer customer=getInstance(conn,Customer.class,sql,id); return customer; &#125; @Override public List&lt;Customer&gt; getAll(Connection conn) &#123; String sql=&quot;select id,name,email,birth from customers&quot;; List&lt;Customer&gt; list=getForList(conn,Customer.class,sql); return list; &#125; @Override public Long getCount(Connection conn) &#123; String sql=&quot;select count(*) from customers&quot;; return getValue(conn,sql); &#125; @Override public Date getMaxBirth(Connection conn) &#123; String sql=&quot;select max(birth) from customers&quot;; return getValue(conn,sql); &#125;&#125; 升级后的DAO在IDEA优化文件夹中写好了,报错 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package 优化;import 基础.BaseDao;import 基础.Customer;import 基础.CustomerDAO;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.sql.Connection;import java.sql.Date;import java.util.List;public class CustomerDAOImpl extends BaseDao&lt;Customer&gt; implements CustomerDAO &#123; @Override public void insert(Connection conn, Customer cust) &#123; String sql=&quot;insert into customers(name,email,birth)values(?,?,?)&quot;; update(conn,sql,cust.getName(),cust.getEmail(),cust.getBirth()); &#125; @Override public void deleteById(Connection conn, int id) &#123; String sql=&quot;delete from customers where id=?&quot;;update(conn,sql,id); &#125; @Override public void update(Connection conn, Customer cust) &#123; String sql=&quot;update customers set name=?,email=?,birth=? where id=?&quot;; update(conn,sql,cust.getName(),cust.getEmail(),cust.getBirth(),cust.getBirth()); &#125; @Override public Customer getCustomerById(Connection conn, int id) &#123; String sql=&quot;select id,name,email,birth from customers where id=?&quot;; Customer customer= getInstance(conn,sql,id); return customer; &#125; @Override public List&lt;Customer&gt; getAll(Connection conn) &#123; String sql=&quot;select id,name,email,birth from customers&quot;; List&lt;Customer&gt; list= getForList(conn,sql); return list; &#125; @Override public Long getCount(Connection conn) &#123; String sql=&quot;select count(*) from customers&quot;; return getValue(conn,sql); &#125; @Override public Date getMaxBirth(Connection conn) &#123; String sql=&quot;select max(birth) from customers&quot;; return getValue(conn,sql); &#125;&#125; DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO 作用：为了实现功能的模块化，更有利于代码的维护和升级。 下面是尚硅谷JavaWeb阶段书城项目中DAO使用的体现： 层次结构： 【BaseDAO.java】下面是用的那个DBUtils来操作的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.atguigu.bookstore.dao;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.sql.Connection;import java.sql.SQLException;import java.util.List;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.apache.commons.dbutils.handlers.ScalarHandler;/** * 定义一个用来被继承的对数据库进行基本操作的Dao * * @author HanYanBing * * @param &lt;T&gt; */public abstract class BaseDao&lt;T&gt; &#123; private QueryRunner queryRunner = new QueryRunner(); // 定义一个变量来接收泛型的类型 private Class&lt;T&gt; type; // 获取T的Class对象，获取泛型的类型，泛型是在被子类继承时才确定 public BaseDao() &#123; // 获取子类的类型 Class clazz = this.getClass(); // 获取父类的类型 // getGenericSuperclass()用来获取当前类的父类的类型 // ParameterizedType表示的是带泛型的类型 ParameterizedType parameterizedType = (ParameterizedType) clazz.getGenericSuperclass(); // 获取具体的泛型类型 getActualTypeArguments获取具体的泛型的类型 // 这个方法会返回一个Type的数组 Type[] types = parameterizedType.getActualTypeArguments(); // 获取具体的泛型的类型· this.type = (Class&lt;T&gt;) types[0]; &#125; /** * 通用的增删改操作 * * @param sql * @param params * @return */ public int update(Connection conn,String sql, Object... params) &#123; int count = 0; try &#123; count = queryRunner.update(conn, sql, params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return count; &#125; /** * 获取一个对象 * * @param sql * @param params * @return */ public T getBean(Connection conn,String sql, Object... params) &#123; T t = null; try &#123; t = queryRunner.query(conn, sql, new BeanHandler&lt;T&gt;(type), params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return t; &#125; /** * 获取所有对象 * * @param sql * @param params * @return */ public List&lt;T&gt; getBeanList(Connection conn,String sql, Object... params) &#123; List&lt;T&gt; list = null; try &#123; list = queryRunner.query(conn, sql, new BeanListHandler&lt;T&gt;(type), params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return list; &#125; /** * 获取一个但一值得方法，专门用来执行像 select count(*)...这样的sql语句 * * @param sql * @param params * @return */ public Object getValue(Connection conn,String sql, Object... params) &#123; Object count = null; try &#123; // 调用queryRunner的query方法获取一个单一的值 count = queryRunner.query(conn, sql, new ScalarHandler&lt;&gt;(), params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return count; &#125;&#125; 【BookDAO.java】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.atguigu.bookstore.dao;import java.sql.Connection;import java.util.List;import com.atguigu.bookstore.beans.Book;import com.atguigu.bookstore.beans.Page;public interface BookDao &#123; /** * 从数据库中查询出所有的记录 * * @return */ List&lt;Book&gt; getBooks(Connection conn); /** * 向数据库中插入一条记录 * * @param book */ void saveBook(Connection conn,Book book); /** * 从数据库中根据图书的id删除一条记录 * * @param bookId */ void deleteBookById(Connection conn,String bookId); /** * 根据图书的id从数据库中查询出一条记录 * * @param bookId * @return */ Book getBookById(Connection conn,String bookId); /** * 根据图书的id从数据库中更新一条记录 * * @param book */ void updateBook(Connection conn,Book book); /** * 获取带分页的图书信息 * * @param page：是只包含了用户输入的pageNo属性的page对象 * @return 返回的Page对象是包含了所有属性的Page对象 */ Page&lt;Book&gt; getPageBooks(Connection conn,Page&lt;Book&gt; page); /** * 获取带分页和价格范围的图书信息 * * @param page：是只包含了用户输入的pageNo属性的page对象 * @return 返回的Page对象是包含了所有属性的Page对象 */ Page&lt;Book&gt; getPageBooksByPrice(Connection conn,Page&lt;Book&gt; page, double minPrice, double maxPrice);&#125; 【UserDAO.java】12345678910111213141516171819202122232425262728293031package com.atguigu.bookstore.dao;import java.sql.Connection;import com.atguigu.bookstore.beans.User;public interface UserDao &#123; /** * 根据User对象中的用户名和密码从数据库中获取一条记录 * * @param user * @return User 数据库中有记录 null 数据库中无此记录 */ User getUser(Connection conn,User user); /** * 根据User对象中的用户名从数据库中获取一条记录 * * @param user * @return true 数据库中有记录 false 数据库中无此记录 */ boolean checkUsername(Connection conn,User user); /** * 向数据库中插入User对象 * * @param user */ void saveUser(Connection conn,User user);&#125; 【BookDaoImpl.java】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.atguigu.bookstore.dao.impl;import java.sql.Connection;import java.util.List;import com.atguigu.bookstore.beans.Book;import com.atguigu.bookstore.beans.Page;import com.atguigu.bookstore.dao.BaseDao;import com.atguigu.bookstore.dao.BookDao;public class BookDaoImpl extends BaseDao&lt;Book&gt; implements BookDao &#123; @Override public List&lt;Book&gt; getBooks(Connection conn) &#123; // 调用BaseDao中得到一个List的方法 List&lt;Book&gt; beanList = null; // 写sql语句 String sql = &quot;select id,title,author,price,sales,stock,img_path imgPath from books&quot;; beanList = getBeanList(conn,sql); return beanList; &#125; @Override public void saveBook(Connection conn,Book book) &#123; // 写sql语句 String sql = &quot;insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)&quot;; // 调用BaseDao中通用的增删改的方法 update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(),book.getImgPath()); &#125; @Override public void deleteBookById(Connection conn,String bookId) &#123; // 写sql语句 String sql = &quot;DELETE FROM books WHERE id = ?&quot;; // 调用BaseDao中通用增删改的方法 update(conn,sql, bookId); &#125; @Override public Book getBookById(Connection conn,String bookId) &#123; // 调用BaseDao中获取一个对象的方法 Book book = null; // 写sql语句 String sql = &quot;select id,title,author,price,sales,stock,img_path imgPath from books where id = ?&quot;; book = getBean(conn,sql, bookId); return book; &#125; @Override public void updateBook(Connection conn,Book book) &#123; // 写sql语句 String sql = &quot;update books set title = ? , author = ? , price = ? , sales = ? , stock = ? where id = ?&quot;; // 调用BaseDao中通用的增删改的方法 update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getId()); &#125; @Override public Page&lt;Book&gt; getPageBooks(Connection conn,Page&lt;Book&gt; page) &#123; // 获取数据库中图书的总记录数 String sql = &quot;select count(*) from books&quot;; // 调用BaseDao中获取一个单一值的方法 long totalRecord = (long) getValue(conn,sql); // 将总记录数设置都page对象中 page.setTotalRecord((int) totalRecord); // 获取当前页中的记录存放的List String sql2 = &quot;select id,title,author,price,sales,stock,img_path imgPath from books limit ?,?&quot;; // 调用BaseDao中获取一个集合的方法 List&lt;Book&gt; beanList = getBeanList(conn,sql2, (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE); // 将这个List设置到page对象中 page.setList(beanList); return page; &#125; @Override public Page&lt;Book&gt; getPageBooksByPrice(Connection conn,Page&lt;Book&gt; page, double minPrice, double maxPrice) &#123; // 获取数据库中图书的总记录数 String sql = &quot;select count(*) from books where price between ? and ?&quot;; // 调用BaseDao中获取一个单一值的方法 long totalRecord = (long) getValue(conn,sql,minPrice,maxPrice); // 将总记录数设置都page对象中 page.setTotalRecord((int) totalRecord); // 获取当前页中的记录存放的List String sql2 = &quot;select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? limit ?,?&quot;; // 调用BaseDao中获取一个集合的方法 List&lt;Book&gt; beanList = getBeanList(conn,sql2, minPrice , maxPrice , (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE); // 将这个List设置到page对象中 page.setList(beanList); return page; &#125;&#125; 【UserDaoImpl.java】123456789101112131415161718192021222324252627282930313233343536373839package com.atguigu.bookstore.dao.impl;import java.sql.Connection;import com.atguigu.bookstore.beans.User;import com.atguigu.bookstore.dao.BaseDao;import com.atguigu.bookstore.dao.UserDao;public class UserDaoImpl extends BaseDao&lt;User&gt; implements UserDao &#123; @Override public User getUser(Connection conn,User user) &#123; // 调用BaseDao中获取一个对象的方法 User bean = null; // 写sql语句 String sql = &quot;select id,username,password,email from users where username = ? and password = ?&quot;; bean = getBean(conn,sql, user.getUsername(), user.getPassword()); return bean; &#125; @Override public boolean checkUsername(Connection conn,User user) &#123; // 调用BaseDao中获取一个对象的方法 User bean = null; // 写sql语句 String sql = &quot;select id,username,password,email from users where username = ?&quot;; bean = getBean(conn,sql, user.getUsername()); return bean != null; &#125; @Override public void saveUser(Connection conn,User user) &#123; //写sql语句 String sql = &quot;insert into users(username,password,email) values(?,?,?)&quot;; //调用BaseDao中通用的增删改的方法 update(conn,sql, user.getUsername(),user.getPassword(),user.getEmail()); &#125;&#125; 【Book.java】1234567891011121314151617package com.atguigu.bookstore.beans;/** * 图书类 * @author songhongkang * */public class Book &#123; private Integer id; private String title; // 书名 private String author; // 作者 private double price; // 价格 private Integer sales; // 销量 private Integer stock; // 库存 private String imgPath = &quot;static/img/default.jpg&quot;; // 封面图片的路径 //构造器，get()，set()，toString()方法略&#125; 【Page.java】12345678910111213141516package com.atguigu.bookstore.beans;import java.util.List;/** * 页码类 * @author songhongkang * */public class Page&lt;T&gt; &#123; private List&lt;T&gt; list; // 每页查到的记录存放的集合 public static final int PAGE_SIZE = 4; // 每页显示的记录数 private int pageNo; // 当前页// private int totalPageNo; // 总页数，通过计算得到 private int totalRecord; // 总记录数，通过查询数据库得到 【User.java】12345678910111213package com.atguigu.bookstore.beans;/** * 用户类 * @author songhongkang * */public class User &#123; private Integer id; private String username; private String password; private String email; 第8章：数据库连接池8.1 JDBC数据库连接池的必要性 在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤： 在主程序（如servlet、beans）中建立数据库连接 进行sql操作 断开数据库连接 这种模式开发，存在的问题: 普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。数据库的连接资源并没有得到很好的重复利用。若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。 对于每一次数据库连接，使用完后都得断开。否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？） 这种开发不能控制被创建的连接对象数，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 8.2 数据库连接池技术 为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。 数据库连接池的基本思想：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。 数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。 工作原理： 数据库连接池技术的优点 1. 资源重用 由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。 2. 更快的系统反应速度 数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间 3. 新的资源分配手段 对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源 4. 统一的连接管理，避免数据库连接泄漏 在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露 8.3 多种开源的数据库连接池 JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现： DBCP 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。速度相对c3p0较快，但因自身存在BUG，Hibernate3已不再提供支持。 C3P0 是一个开源组织提供的一个数据库连接池，速度相对较慢，稳定性还可以。hibernate官方推荐使用 Proxool 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点 BoneCP 是一个开源组织提供的数据库连接池，速度快 Druid 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快 DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池 DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。 特别注意： 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。 8.3.1 C3P0数据库连接池 获取连接方式一 12345678910111213//使用C3P0数据库连接池的方式，获取数据库的连接：不推荐public static Connection getConnection1() throws Exception&#123; ComboPooledDataSource cpds = new ComboPooledDataSource(); cpds.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); cpds.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;); cpds.setUser(&quot;root&quot;); cpds.setPassword(&quot;abc123&quot;); // cpds.setMaxPoolSize(100); Connection conn = cpds.getConnection(); return conn;&#125; 获取连接方式二 123456//使用C3P0数据库连接池的配置文件方式，获取数据库的连接：推荐private static DataSource cpds = new ComboPooledDataSource(&quot;helloc3p0&quot;);public static Connection getConnection2() throws SQLException&#123; Connection conn = cpds.getConnection(); return conn;&#125; 其中，src下的配置文件为：【c3p0-config.xml】 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;c3p0-config&gt; &lt;named-config name=&quot;helloc3p0&quot;&gt; &lt;!-- 获取连接的4个基本信息 --&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;abc123&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql:///test&lt;/property&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!-- 涉及到数据库连接池的管理的相关属性的设置 --&gt; &lt;!-- 若数据库中连接数不足时, 一次向数据库服务器申请多少个连接 --&gt; &lt;property name=&quot;acquireIncrement&quot;&gt;5&lt;/property&gt; &lt;!-- 初始化数据库连接池时连接的数量 --&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;5&lt;/property&gt; &lt;!-- 数据库连接池中的最小的数据库连接数 --&gt; &lt;property name=&quot;minPoolSize&quot;&gt;5&lt;/property&gt; &lt;!-- 数据库连接池中的最大的数据库连接数 --&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;10&lt;/property&gt; &lt;!-- C3P0 数据库连接池可以维护的 Statement 的个数 --&gt; &lt;property name=&quot;maxStatements&quot;&gt;20&lt;/property&gt; &lt;!-- 每个连接同时可以使用的 Statement 对象的个数 --&gt; &lt;property name=&quot;maxStatementsPerConnection&quot;&gt;5&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; 8.3.2 DBCP数据库连接池 DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件： Commons-dbcp.jar：连接池的实现 Commons-pool.jar：连接池实现的依赖库 Tomcat 的连接池正是采用该连接池来实现的。该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。 配置属性说明 属性 默认值 说明 initialSize 0 连接池启动时创建的初始化连接数量 maxActive 8 连接池中可同时连接的最大的连接数 maxIdle 8 连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制 minIdle 0 连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。 maxWait 无限制 最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待 poolPreparedStatements false 开启池的Statement是否prepared maxOpenPreparedStatements 无限制 开启池的prepared 后的同时最大连接数 minEvictableIdleTimeMillis 连接池中连接，在时间段内一直空闲， 被逐出连接池的时间 removeAbandonedTimeout 300 超过时间限制，回收没有用(废弃)的连接 removeAbandoned false 超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收 获取连接方式一： 1234567891011121314public static Connection getConnection3() throws Exception &#123; BasicDataSource source = new BasicDataSource(); source.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); source.setUrl(&quot;jdbc:mysql:///test&quot;); source.setUsername(&quot;root&quot;); source.setPassword(&quot;abc123&quot;); // source.setInitialSize(10); Connection conn = source.getConnection(); return conn;&#125; 获取连接方式二： 12345678910111213141516171819202122//使用dbcp数据库连接池的配置文件方式，获取数据库的连接：推荐private static DataSource source = null;static&#123; try &#123; Properties pros = new Properties(); InputStream is = DBCPTest.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;); pros.load(is); //根据提供的BasicDataSourceFactory创建对应的DataSource对象 source = BasicDataSourceFactory.createDataSource(pros); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;public static Connection getConnection4() throws Exception &#123; Connection conn = source.getConnection(); return conn;&#125; 其中，src下的配置文件为：【dbcp.properties】 1234567driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&amp;useServerPrepStmts=falseusername=rootpassword=abc123initialSize=10#... 8.3.3 Druid（德鲁伊）数据库连接池（报错了）Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，可以说是目前最好的连接池之一。 这个是放在JDBCUtils文件里的，这一块的静态代码块有问题 12345678910111213141516private static DataSource source1=null;static&#123; try&#123; Properties pros=new Properties(); InputStream is= new FileInputStream(&quot;D:\\\\IDEAjava工程\\\\JDBC\\\\src\\\\基础\\\\druid.properties&quot;); pros.load(is); source1= DruidDataSourceFactory.createDataSource(pros); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125;&#125;public static Connection getConnection3()throws Exception&#123; Connection conn=source1.getConnection(); return conn;&#125; 测试 123456789101112131415public class DruidTest &#123; public static void main(String[] args) &#123; CustomerDAOImpl dao=new CustomerDAOImpl(); Connection conn=null; try&#123; conn=JDBCUtils.getConnection3(); Customer cust=dao.getCustomerById(conn,3); System.out.println(cust); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 其中，src下的配置文件为：【druid.properties】 123456789url=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=trueusername=rootpassword=rootdriverClassName=com.mysql.jdbc.DriverinitialSize=10maxActive=20maxWait=1000filters=wall 详细配置参数： 配置 缺省 说明 name 配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是：”DataSource-” + System.identityHashCode(this) url 连接数据库的url，不同数据库不一样。例如：mysql : jdbc:mysql:&#x2F;&#x2F;10.20.153.104:3306&#x2F;druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto username 连接数据库的用户名 password 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter driverClassName 根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下) initialSize 0 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 maxActive 8 最大连接池数量 maxIdle 8 已经不再使用，配置了也没效果 minIdle 最小连接池数量 maxWait 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 poolPreparedStatements false 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 maxOpenPreparedStatements -1 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 validationQuery 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 testOnBorrow true 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 testOnReturn false 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testWhileIdle false 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 timeBetweenEvictionRunsMillis 有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明 numTestsPerEvictionRun 不再使用，一个DruidDataSource只支持一个EvictionRun minEvictableIdleTimeMillis connectionInitSqls 物理连接初始化的时候执行的sql exceptionSorter 根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接 filters 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall proxyFilters 类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系 第9章：Apache-DBUtils实现CRUD操作9.1 Apache-DBUtils简介 commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。 API介绍： org.apache.commons.dbutils.QueryRunner org.apache.commons.dbutils.ResultSetHandler 工具类：org.apache.commons.dbutils.DbUtils API包说明： 9.2 主要API的使用9.2.1 DbUtils DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下： public static void close(…) throws java.sql.SQLException： DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。 public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。 public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接 public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断 public static void rollbackAndClose(Connection conn)throws SQLException rollbackAndCloseQuietly(Connection) public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。 9.2.2 QueryRunner类 该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。 QueryRunner类提供了两个构造器： 默认的构造器 需要一个 javax.sql.DataSource 来作参数的构造器 QueryRunner类的主要方法： 更新 public int update(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。 …… 插入 public T insert(Connection conn,String sql,ResultSetHandler rsh, Object… params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys. 返回值: An object generated by the handler.即自动生成的键值 …. 批处理 public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句 public T insertBatch(Connection conn,String sql,ResultSetHandler rsh,Object[][] params)throws SQLException：只支持INSERT语句 ….. 查询 public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。 …… update方法测试 update方法能执行delete update insert语句 123456789101112131415161718192021222324252627282930313233//添加数据import org.apache.commons.dbutils.QueryRunner;import java.sql.Connection;import java.sql.SQLException;public class DbUtilsTest &#123; public static void main(String[] args) &#123;DbUtilsTest list=new DbUtilsTest();list.testInsert(); &#125; public void testInsert() &#123; QueryRunner runner = new QueryRunner(); Connection conn= null; try &#123; conn = JDBCUtils.getConnection(); String sql = &quot;insert into customers(name,email,birth)values(?,?,?)&quot;; int insertCount = runner.update(conn, sql, &quot;易烊千玺&quot;, &quot;3241525035@qq.com&quot;, &quot;1997-09-08&quot;); System.out.println(&quot;添加了&quot; + insertCount + &quot;记录&quot;); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; finally&#123; JDBCUtils.closeResource(conn,null); &#125; &#125;&#125; 12345678910111213// 测试删除@Testpublic void testDelete() throws Exception &#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection(); String sql = &quot;delete from customers where id &lt; ?&quot;; int count = runner.update(conn, sql,3); System.out.println(&quot;删除了&quot; + count + &quot;条记录&quot;); JDBCUtils.closeResource(conn, null);&#125; 9.2.3 ResultSetHandler接口及实现类 该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。 ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。 接口的主要实现类： ArrayHandler：把结果集中的第一行数据转成对象数组。 ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。 BeanHandler：将结果集中的第一行数据封装到一个对应的JavaBean实例中。 BeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。 ColumnListHandler：将结果集中某一列的数据存放到List中。 KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。 MapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。 MapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List ScalarHandler：查询单个值对象 测试 BeanHandler是ResultSetHandler接口的实现类 12345678910111213141516171819/* * 测试查询:查询一条记录 * * 使用ResultSetHandler的实现类：BeanHandler */@Testpublic void testQueryInstance() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection(); String sql = &quot;select id,name,email,birth from customers where id = ?&quot;; // BeanHandler&lt;Customer&gt; handler = new BeanHandler&lt;&gt;(Customer.class); Customer customer = runner.query(conn, sql, handler, 23); System.out.println(customer); JDBCUtils.closeResource(conn, null);&#125; 12345678910111213141516171819/* * 测试查询:查询多条记录构成的集合 * * 使用ResultSetHandler的实现类：BeanListHandler，用于封装表中的多条记录构成的集合 */@Testpublic void testQueryList() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection(); String sql = &quot;select id,name,email,birth from customers where id &lt; ?&quot;; // BeanListHandler&lt;Customer&gt; handler = new BeanListHandler&lt;&gt;(Customer.class); List&lt;Customer&gt; list = runner.query(conn, sql, handler, 23); list.forEach(System.out::println); JDBCUtils.closeResource(conn, null);&#125; 12345678910111213141516171819202122232425262728293031323334353637/* * 自定义ResultSetHandler的实现类 */@Testpublic void testQueryInstance1() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection(); String sql = &quot;select id,name,email,birth from customers where id = ?&quot;; ResultSetHandler&lt;Customer&gt; handler = new ResultSetHandler&lt;Customer&gt;() &#123;//这个地方必须要写后面那个Customer @Override public Customer handle(ResultSet rs) throws SQLException &#123; System.out.println(&quot;handle&quot;);// return new Customer(1,&quot;Tom&quot;,&quot;tom@126.com&quot;,new Date(123323432L)); if(rs.next())&#123; int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); String email = rs.getString(&quot;email&quot;); Date birth = rs.getDate(&quot;birth&quot;); return new Customer(id, name, email, birth); &#125; return null; &#125; &#125;; Customer customer = runner.query(conn, sql, handler, 23); System.out.println(customer); JDBCUtils.closeResource(conn, null);&#125; 1234567891011121314151617181920212223242526/* * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据， * 使用ScalarHandler 这个就是用来返回一些特殊的熟知的和那个BASEDAO中的getValue方法有些类似 * */@Testpublic void testQueryValue() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection(); //测试一：// String sql = &quot;select count(*) from customers where id &lt; ?&quot;;// ScalarHandler handler = new ScalarHandler();// long count = (long) runner.query(conn, sql, handler, 20);// System.out.println(count); //测试二： String sql = &quot;select max(birth) from customers&quot;; ScalarHandler handler = new ScalarHandler(); Date birth = (Date) runner.query(conn, sql, handler); System.out.println(birth); JDBCUtils.closeResource(conn, null);&#125; 12345678910111213用MapHandler这个实现类，返回的是一个map形式的对象将字段及相应字段的值作为map的key和valuepublic void testQuery() throws SQLException &#123; QueryRunner runner = new QueryRunner(); Connection conn=JDBCUtils.getConnection(); String sql=&quot;select id,name,email,birth from customers where id&lt;?&quot;; MapHandler handler=new MapHandler(); Map&lt;String,Object&gt; map=runner.query(conn,sql,handler,23); System.out.println(map);&#125;// &#123;name=汪峰, birth=2010-02-02, id=1, email=wf@126.com&#125;结果 12345678910111213141516打印多个Map，对应表中的多条记录public void testQueryList() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection(); String sql = &quot;select id,name,email,birth from customers where id &lt; ?&quot;; // MapListHandler handler = new MapListHandler(); List&lt;Map&lt;String,Object&gt;&gt; list = runner.query(conn, sql, handler, 23); list.forEach(System.out::println); JDBCUtils.closeResource(conn, null);&#125; 关闭连接，可以放在JDBCUtils类中当作关闭方法 123456//用DBUtils关闭资源public static void closeResource1(Connection conn,Statement ps,ResultSet rs)&#123; DbUtils.closeQuietly(conn); DbUtils.closeQuietly(ps); DbUtils.closeQuietly(rs);&#125; 用 自己用DBUtils实现的BaseDao1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.atguigu.dao.impl;import com.atguigu.utils.JdbcUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.apache.commons.dbutils.handlers.ScalarHandler;import java.sql.Connection;import java.sql.SQLException;import java.util.List;public class BaseDao &#123; //使用DbUtils操作数据库private QueryRunner queryRunner=new QueryRunner();/*update()方法用来执行：insert update delete语句如果返回-1说明执行失败， 否则返回其他表示影响的行数 */ public int update(String sql,Object...args)&#123; Connection conn= JdbcUtils.getConnection(); try &#123; return queryRunner.update(conn, sql, args); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; return -1; &#125; /* 查询返回一个javaBean的sql语句 type为返回对象类型，args是sql对应的参数值，sql是执行的sql语句 &lt;T&gt;返回的类型和泛型 */ public &lt;T&gt; T queryForOne(Class&lt;T&gt; type,String sql,Object...args) &#123; Connection con=JdbcUtils.getConnection(); try &#123; return queryRunner.query(con,sql,new BeanHandler&lt;T&gt;(type),args); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; finally&#123; JdbcUtils.close(con); &#125; return null; &#125; public &lt;T&gt; List&lt;T&gt; queryForList(Class&lt;T&gt; type,String sql,Object...args)&#123; Connection con=JdbcUtils.getConnection(); try &#123; return queryRunner.query(con,sql,new BeanListHandler&lt;T&gt;(type),args); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; return null; &#125; public Object queryForSingleValue(String sql,Object...args)&#123; Connection conn=JdbcUtils.getConnection(); try &#123; return queryRunner.query(conn, sql,new ScalarHandler(), args); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; return null; &#125;&#125; JDBC总结12345678910111213141516171819202122232425262728293031323334353637总结@Testpublic void testUpdateWithTx() &#123; Connection conn = null; try &#123; //1.获取连接的操作（ //① 手写的连接：JDBCUtils.getConnection(); //② 使用数据库连接池：C3P0;DBCP;Druid //2.对数据表进行一系列CRUD操作 //① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \\ version 2.0)//version2.0的增删改public void update(Connection conn,String sql,Object ... args)&#123;&#125;//version2.0的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql,Object ... args)&#123;&#125; //② 使用dbutils提供的jar包中提供的QueryRunner类 //提交数据 conn.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; //回滚数据 conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125;finally&#123; //3.关闭连接等操作 //① JDBCUtils.closeResource(); //② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作 &#125;&#125;","categories":[],"tags":[]},{"title":"javaweb","slug":"javaweb","date":"2022-09-29T11:22:42.000Z","updated":"2022-10-13T07:32:36.113Z","comments":true,"path":"2022/09/29/javaweb/","link":"","permalink":"http://example.com/2022/09/29/javaweb/","excerpt":"","text":"Javaweb HTML.CSS,Javascript前端三刺客HTML是超文本标记语言，是一个网站页面的主要内容和主体框架（主要是实现内容） CSS是层叠样式表，主要用来控制调整网页的样式，它与网页的结构和内容没有关系，仅仅是通过不同语义的标签来调整网页内容的不同表现样式。(主要是实现表现，一种呈现的效果) JavaScript是一种完整的网页脚本语言，有自己独立的语法，可以完成复杂的程序逻辑，而HTML和CSS仅仅是标记语言，不具备编程语言的程序逻辑。(行为，指的是页面中元素与输入设备交互的响应，一般使用javascript技术实现) B&#x2F;S软件结构： 客户端：浏览器 服务器端：web服务器 HTMLhtml书写规范1234567891011&lt;!DOCTYPE html&gt;&lt;!--约束，声明--&gt;&lt;html lang=&quot;zh_CN&quot;&gt;&lt;!--html标签表示html的开始 lang=&quot;zh_CN表示中文&quot;--&gt;&lt;!--html标签中一般分为两部分，head和body--&gt;&lt;head&gt; &lt;!--表示头部信息，一般包含三部分内容，title标签，css样式，js代码--&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;!--表示当前页面使用UTF-8字符集--&gt; &lt;title&gt;标题&lt;/title&gt;&lt;!--表示标题--&gt;&lt;/head&gt;&lt;body&gt;&lt;!--body标签是整个html页面显示的主体内容--&gt;hello&lt;/body&gt;&lt;/html&gt; html标签1.标签名大小写不敏感 2.标签名有自己的属性 基本属性：bgcolor&#x3D;“red” 可以修改简单的样式 12&lt;!--背景颜色属性--&gt;&lt;body bgcolor=&quot;green&quot;&gt;&lt;!--body标签是整个html页面显示的主体内容--&gt; 事件属性： onclick&#x3D;“alert(‘你好’);” 点击body主题内容触发 12&lt;!--onclick表示点击事件--&gt;&lt;body onclick=&quot;alert(1)&quot;&gt;&lt;!--body标签是整个html页面显示的主体内容--&gt; 3.分为单标签和双标签 &lt;标签名 &#x2F;&gt; 和&lt;标签名&gt; &lt;&#x2F;标签名&gt; 1&lt;br /&gt;换行 &lt;hr /&gt; 标签语法 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;0-标签语法.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- ①标签不能交叉嵌套 --&gt; 正确：&lt;div&gt;&lt;span&gt;早安，尚硅谷&lt;/span&gt;&lt;/div&gt; 错误：&lt;div&gt;&lt;span&gt;早安，尚硅谷&lt;/div&gt;&lt;/span&gt; &lt;hr /&gt; &lt;!-- ②标签必须正确关闭(闭合) --&gt; &lt;!-- i.有文本内容的标签： --&gt; 正确：&lt;div&gt;早安，尚硅谷&lt;/div&gt; 错误：&lt;div&gt;早安，尚硅谷 &lt;hr /&gt; &lt;!-- ii.没有文本内容的标签： --&gt; 正确：&lt;br /&gt;1 错误：&lt;br &gt;2 &lt;hr /&gt; &lt;!-- ③属性必须有值，属性值必须加引号 --&gt; 正确：&lt;font color=&quot;blue&quot;&gt;早安，尚硅谷&lt;/font&gt; 错误：&lt;font color=blue&gt;早安，尚硅谷&lt;/font&gt; 错误：&lt;font color&gt;早安，尚硅谷&lt;/font&gt; &lt;hr /&gt; &lt;!-- ④注释不能嵌套 --&gt; 正确：&lt;!-- 注释内容 --&gt; &lt;br/&gt; 错误：&lt;!-- 注释内容 &lt;!-- 注释内容 --&gt;--&gt; &lt;hr /&gt;&lt;/body&gt;&lt;/html&gt; font标签 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;1.font标签.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 字体标签 需求1：在网页上显示 我是字体标签 ，并修改字体为 宋体，颜色为红色。 font标签是字体标签,它可以用来修改文本的字体,颜色,大小(尺寸) color属性修改颜色 face属性修改字体 size属性修改文本大小 --&gt; &lt;font color=&quot;red&quot; face=&quot;宋体&quot; size=&quot;7&quot;&gt;我是字体标签&lt;/font&gt;&lt;/body&gt;&lt;/html&gt; 特殊字符 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;2.特殊字符.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 特殊字符 需求1：把 &lt;br&gt; 换行标签 变成文本 转换成字符显示在页面上 常用的特殊字符: &lt; ===&gt;&gt;&gt;&gt; &amp;lt; &gt; ===&gt;&gt;&gt;&gt; &amp;gt; 空格 ===&gt;&gt;&gt;&gt; &amp;nbsp;如果在html文件中出现多个空白字符，那么就只保留一个，必须用特殊字符才可以出现多个空格 --&gt; 我是&amp;lt;br&amp;gt;标签&lt;br/&gt; 国哥好&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;帅啊!&lt;/body&gt;&lt;/html&gt; 标题标签 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;3.标题标签.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 标题标签 需求1：演示标题1到 标题6的 h1 - h6 都是标题标签 h1 最大 h6 最小 align 属性是对齐属性 left 左对齐(默认) center 剧中 right 右对齐 --&gt; &lt;h1 align=&quot;left&quot;&gt;标题1&lt;/h1&gt; &lt;h2 align=&quot;center&quot;&gt;标题2&lt;/h2&gt; &lt;h3 align=&quot;right&quot;&gt;标题3&lt;/h3&gt; &lt;h4&gt;标题4&lt;/h4&gt; &lt;h5&gt;标题5&lt;/h5&gt; &lt;h6&gt;标题6&lt;/h6&gt; &lt;h7&gt;标题7&lt;/h7&gt;&lt;/body&gt;&lt;/html&gt; 超链接标签 网页中点击跳转的内容就是超链接 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;4.超链接.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- a标签是 超链接 href属性设置连接的地址 target属性设置哪个目标进行跳转 _self 表示当前页面(默认值) _blank 表示打开新页面来进行跳转 --&gt; &lt;a href=&quot;http://localhost:8080&quot;&gt;百度&lt;/a&gt;&lt;br/&gt; &lt;a href=&quot;http://localhost:8080&quot; target=&quot;_self&quot;&gt;百度_self&lt;/a&gt;&lt;br/&gt; &lt;a href=&quot;http://localhost:8080&quot; target=&quot;_blank&quot;&gt;百度_blank&lt;/a&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 列表标签 和浏览器有关的或多或少都会有一些兼容问题，所以换了个浏览器可能会不一样比如下面的type 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--需求1：使用无序，列表方式，把东北F4，赵四，刘能，小沈阳，宋小宝，展示出来 ul 是无序列表 type属性可以修改列表项前面的符号 li 是列表项 --&gt; &lt;!--无序列表--&gt; &lt;ul type=&quot;none&quot;&gt; &lt;li&gt;赵四&lt;/li&gt; &lt;li&gt;刘能&lt;/li&gt; &lt;li&gt;小沈阳&lt;/li&gt; &lt;li&gt;宋小宝&lt;/li&gt; &lt;/ul&gt; &lt;!--有序列表,前面会加上序号--&gt; &lt;ol type=&quot;none&quot;&gt; &lt;li&gt;赵四&lt;/li&gt; &lt;li&gt;刘能&lt;/li&gt; &lt;li&gt;小沈阳&lt;/li&gt; &lt;li&gt;宋小宝&lt;/li&gt; &lt;/ol&gt;&lt;/body&gt;&lt;/html&gt; img标签 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;5.img标签.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--需求1：使用img标签显示一张美女的照片。并修改宽高，和边框属性 img标签是图片标签,用来显示图片 src属性可以设置图片的路径 width属性设置图片的宽度 height属性设置图片的高度 border属性设置图片边框大小 alt属性设置当指定路径找不到图片时,用来代替显示的文本内容 在JavaSE中路径也分为相对路径和绝对路径. 相对路径:从工程名开始算 绝对路径:盘符:/目录/文件名 在web中路径分为相对路径和绝对路径两种 相对路径: . 表示当前文件所在的目录 .. 表示当前文件所在的上一级目录 文件名 表示当前文件所在目录的文件,相当于 ./文件名 ./ 可以省略 绝对路径: 正确格式是: http://ip:port/工程名/资源路径 错误格式是: 盘符:/目录/文件名 --&gt; &lt;!--下面这些值的单位是像素--&gt; &lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;260&quot; border=&quot;1&quot; alt=&quot;美女找不到&quot;/&gt; &lt;img src=&quot;../../2.jpg&quot; width=&quot;200&quot; height=&quot;260&quot; alt=&quot;美女找不到&quot; /&gt; &lt;img src=&quot;../imgs/3.jpg&quot; width=&quot;200&quot; height=&quot;260&quot; /&gt; &lt;img src=&quot;../imgs/4.jpg&quot; width=&quot;200&quot; height=&quot;260&quot; /&gt; &lt;img src=&quot;../imgs/5.jpg&quot; width=&quot;200&quot; height=&quot;260&quot; /&gt; &lt;img src=&quot;../imgs/6.jpg&quot; width=&quot;200&quot; height=&quot;260&quot; /&gt;&lt;/body&gt;&lt;/html&gt; 表格标签 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;表格标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 需求1：做一个 带表头的 ，三行，三列的表格，并显示边框 需求2：修改表格的宽度，高度，表格的对齐方式，单元格间距。 table 标签是表格标签 border 设置表格标框 width 设置表格宽度 height 设置表格高度 align 设置表格相对于页面的对齐方式 cellspacing 设置单元格间距 tr 是行标签 th 是表头标签 td 是单元格标签 align 设置单元格文本对齐方式 b 是加粗标签 --&gt;&lt;table align=&quot;center&quot; border=&quot;1&quot; width=&quot;300&quot; height=&quot;300&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;th&gt;1.1&lt;/th&gt; &lt;!--注释上面和下面的两个标签是等价的--&gt; &lt;td align=&quot;center&quot;&gt;&lt;b&gt;1.1&lt;/b&gt;&lt;/td&gt; &lt;th&gt;1.2&lt;/th&gt; &lt;th&gt;1.3&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2.1&lt;/td&gt; &lt;td&gt;2.2&lt;/td&gt; &lt;td&gt;2.3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3.1&lt;/td&gt; &lt;td&gt;3.2&lt;/td&gt; &lt;td&gt;3.3&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 表格跨行跨列标签 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;7.表格的跨行跨列&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;!-- 需求1： 新建一个五行，五列的表格， 第一行，第一列的单元格要跨两列， 第二行第一列的单元格跨两行， 第四行第四列的单元格跨两行两列。 colspan 属性设置跨列，被作用的单元格横向合并一个 rowspan 属性设置跨行,指的是被作用的单元格向下合并一个 --&gt; &lt;table width=&quot;500&quot; height=&quot;500&quot; cellspacing=&quot;0&quot; border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;1.1&lt;/td&gt; &lt;td&gt;1.3&lt;/td&gt; &lt;td&gt;1.4&lt;/td&gt; &lt;td&gt;1.5&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspqn=&quot;2&quot;&gt;2.1&lt;/td&gt; &lt;td&gt;2.2&lt;/td&gt; &lt;td&gt;2.3&lt;/td&gt; &lt;td&gt;2.4&lt;/td&gt; &lt;td&gt;2.5&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3.2&lt;/td&gt; &lt;td&gt;3.3&lt;/td&gt; &lt;td&gt;3.4&lt;/td&gt; &lt;td&gt;3.5&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;4.1&lt;/td&gt; &lt;td&gt;4.2&lt;/td&gt; &lt;td&gt;4.3&lt;/td&gt; &lt;td colspan=&quot;2&quot; rowspan=&quot;2&quot;&gt;4.4&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;5.1&lt;/td&gt; &lt;td&gt;5.2&lt;/td&gt; &lt;td&gt;5.3&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; iframe标签 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;8.iframe标签.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 我是一个单独的完整的页面&lt;br/&gt;&lt;br/&gt; &lt;!--ifarme标签可以在页面上开辟一个小区域显示一个单独的页面 ifarme和a标签组合使用的步骤: 1 在iframe标签中使用name属性定义一个名称 2 在a标签的target属性上设置iframe的name的属性值 --&gt; &lt;iframe src=&quot;3.标题标签.html&quot; width=&quot;200&quot; height=&quot;200&quot; name=&quot;abc&quot;&gt;&lt;/iframe&gt; &lt;br/&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;0-标签语法.html&quot; target=&quot;abc&quot;&gt;0-标签语法.html&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;1.font标签.html&quot; target=&quot;abc&quot;&gt;1.font标签.html&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;2.特殊字符.html&quot; target=&quot;abc&quot;&gt;2.特殊字符.html&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 表单显示 什么是表单，表单就是html页面中用来收集用户信息的所有元素的集合，然后把这些信息发送给服务器 同时用标签让表单像表格一样的形式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;表单的显示&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--需求1:创建一个个人信息注册的表单界面。包含用户名，密码，确认密码。性别（单选），兴趣爱好（多选），国籍（下拉列表）。隐藏域，自我评价（多行文本域）。重置，提交。--&gt; &lt;!-- form标签就是表单 input type=text 是文件输入框 value设置默认显示内容 input type=password 是密码输入框 value设置默认显示内容 input type=radio 是单选框 name属性可以对其进行分组 checked=&quot;checked&quot;表示默认选中 input type=checkbox 是复选框 checked=&quot;checked&quot;表示默认选中 input type=reset 是重置按钮 value属性修改按钮上的文本 input type=submit 是提交按钮 value属性修改按钮上的文本 input type=button 是按钮 value属性修改按钮上的文本 input type=file 是文件上传域 input type=hidden 是隐藏域 当我们要发送某些信息，而这些信息，不需要用户参与，就可以使用隐藏域（提交的时候同时发送给服务器） select 标签是下拉列表框 option 标签是下拉列表框中的选项 selected=&quot;selected&quot;设置默认选中 textarea 表示多行文本输入框 （起始标签和结束标签中的内容是默认值） rows 属性设置可以显示几行的高度 cols 属性设置每行可以显示几个字符宽度 --&gt; &lt;form&gt; &lt;h1 align=&quot;center&quot;&gt;用户注册&lt;/h1&gt; &lt;table align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td&gt; 用户名称：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; value=&quot;默认值&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 用户密码：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; value=&quot;abc&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;确认密码：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; value=&quot;abc&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot;/&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked=&quot;checked&quot; /&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 兴趣爱好：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; /&gt;Java &lt;input type=&quot;checkbox&quot; /&gt;JavaScript &lt;input type=&quot;checkbox&quot; /&gt;C++ &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;国籍：&lt;/td&gt; &lt;td&gt; &lt;select&gt; &lt;option&gt;--请选择国籍--&lt;/option&gt; &lt;option selected=&quot;selected&quot;&gt;中国&lt;/option&gt; &lt;option&gt;美国&lt;/option&gt; &lt;option&gt;小日本&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;自我评价：&lt;/td&gt; &lt;td&gt;&lt;textarea rows=&quot;10&quot; cols=&quot;20&quot;&gt;我才是默认值&lt;/textarea&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;reset&quot; /&gt;&lt;/td&gt; &lt;td align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;文件上传&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;file&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 表单提交的细节 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;表单的显示&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- form标签是表单标签 action属性设置提交的服务器地址 method属性设置提交的方式GET(默认值)或POST 表单提交的时候，数据没有发送给服务器的三种情况： 1、表单项没有name属性值(可是我测试的真实情况是没有也可以) 2、单选、复选（下拉列表中的option标签）都需要添加value属性，以便发送给服务器 3、表单项不在提交的form标签中 GET请求的特点是： 1、浏览器地址栏中的地址是：action属性[+?+请求参数] 请求参数的格式是：name=value&amp;name=value 2、不安全 3、它有数据长度的限制 POST请求的特点是： 1、浏览器地址栏中只有action属性值 2、相对于GET请求要安全 3、理论上没有数据长度的限制 --&gt; &lt;form action=&quot;http://www.baidu.com&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;login&quot; /&gt; &lt;h1 align=&quot;center&quot;&gt;用户注册&lt;/h1&gt; &lt;table align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td&gt; 用户名称：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;默认值&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 用户密码：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;abc&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;boy&quot;/&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked=&quot;checked&quot; value=&quot;girl&quot; /&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 兴趣爱好：&lt;/td&gt; &lt;td&gt; &lt;input name=&quot;hobby&quot; type=&quot;checkbox&quot; checked=&quot;checked&quot; value=&quot;java&quot;/&gt;Java &lt;input name=&quot;hobby&quot; type=&quot;checkbox&quot; value=&quot;js&quot;/&gt;JavaScript &lt;input name=&quot;hobby&quot; type=&quot;checkbox&quot; value=&quot;cpp&quot;/&gt;C++ &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;国籍：&lt;/td&gt; &lt;td&gt; &lt;select name=&quot;country&quot;&gt; &lt;option value=&quot;none&quot;&gt;--请选择国籍--&lt;/option&gt; &lt;option value=&quot;cn&quot; selected=&quot;selected&quot;&gt;中国&lt;/option&gt; &lt;option value=&quot;usa&quot;&gt;美国&lt;/option&gt; &lt;option value=&quot;jp&quot;&gt;小日本&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;自我评价：&lt;/td&gt; &lt;td&gt;&lt;textarea name=&quot;desc&quot; rows=&quot;10&quot; cols=&quot;20&quot;&gt;我才是默认值&lt;/textarea&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;reset&quot; /&gt;&lt;/td&gt; &lt;td align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 其他标签div span p等等 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;其他标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--需求1：div、span、p标签的演示 div标签 默认独占一行 span标签 它的长度是封装数据的长度 p段落标签 默认会在段落的上方和下方各空出一行来（如果已有就不再空） --&gt; &lt;div&gt;div标签1&lt;/div&gt; &lt;div&gt;div标签2&lt;/div&gt; &lt;span&gt;span标签1&lt;/span&gt; &lt;span&gt;span标签2&lt;/span&gt; &lt;p&gt;p段落标签1&lt;/p&gt; &lt;p&gt;p段落标签2&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; CSScss是层叠样式表单，是用于控制网页样式并允许将样式信息与网页内容分割的一种标记性语言 选择器：1.浏览器根据选择器绝顶受css样式影响的html元素&lt;标签&gt; 属性：是你要改变的样式名，并且每一个属性都有一个值，属性和值被冒号分开，并由花括号包裹，这样就是一个完整的声明，例如 p{color:blue} 多个声明：如果要定义不止一个声明，则需要用分号将每个声明分开，虽然最后一条声明的最后可以不加分号，但尽量在每条声明的末尾加上分号 例如： p{ color:red; font-size:30px; } 不过一般一行只写一个属性 css注释&#x2F;* *&#x2F; CSS和HTML的结合方式结合方式一 在标签的属性上设置“key:value value”,修改标签样式 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--需求1：分别定义两个 div、span标签，分别修改每个 div 标签的样式为：边框1个像素，实线，红色。--&gt; &lt;div style=&quot;border: 1px solid red;&quot;&gt;div标签1&lt;/div&gt; &lt;div style=&quot;border: 1px solid red;&quot;&gt;div标签2&lt;/div&gt; &lt;span style=&quot;border: 1px solid red;&quot;&gt;span标签1&lt;/span&gt; &lt;span style=&quot;border: 1px solid red;&quot;&gt;span标签2&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 缺点：1.如果标签写多了，样式多了，代码量太大 ​ 2.可读性非常差 ​ 3.Css代码没有什么复用性可言 结合方式二 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--style标签专门用来定义css样式代码--&gt; &lt;style type=&quot;text/css&quot;&gt; /* 需求1：分别定义两个 div、span标签，分别修改每个 div 标签的样式为：边框1个像素，实线，红色。*/ div&#123; border: 1px solid red; &#125; span&#123; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;div标签1&lt;/div&gt; &lt;div&gt;div标签2&lt;/div&gt; &lt;span&gt;span标签1&lt;/span&gt; &lt;span&gt;span标签2&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 缺点：1.只能在一个页面内复用代码，不能再多个页面中复用css代码 ​ 2.维护起来不方便，实际的项目中会有成千上万的也买你，要到每个页面中去修改，工作量太大了 结合方式三 把css样式写成一个单独的css文件，再通过link标签引入即可复用 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--link标签专门用来引入css样式代码--&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;1.css&quot;/&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;div标签1&lt;/div&gt; &lt;div&gt;div标签2&lt;/div&gt; &lt;span&gt;span标签1&lt;/span&gt; &lt;span&gt;span标签2&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 标签名选择器标签名选择器的格式是 标签名{ 属性:值 } 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;CSS选择器&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123; border: 1px solid yellow; color: blue; font-size: 30px; &#125; span&#123; border: 5px dashed blue; color: yellow; font-size: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 需求1：在所有div标签上修改字体颜色为蓝色，字体大小30个像素。边框为1像素黄色实线。 并且修改所有span 标签的字体颜色为黄色，字体大小20个像素。边框为5像素蓝色虚线。 --&gt; &lt;div&gt;div标签1&lt;/div&gt; &lt;div&gt;div标签2&lt;/div&gt; &lt;span&gt;span标签1&lt;/span&gt; &lt;span&gt;span标签2&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 标签名选择器可以决定哪些标签被动的使用这个样式 id选择器id选择器的格式是： #id 属性值{ 属性:值 } id选择器，可以让我们通过id属性选择性的去使用这个样式 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;ID选择器&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #id001&#123; color: blue; font-size: 30px; border: 1px yellow solid; &#125; #id002&#123; color: red; font-size: 20px; border: 5px blue dotted ; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 需求1：分别定义两个 div 标签， 第一个div 标签定义 id 为 id001 ，然后根据id 属性定义css样式修改字体颜色为蓝色， 字体大小30个像素。边框为1像素黄色实线。 第二个div 标签定义 id 为 id002 ，然后根据id 属性定义css样式 修改的字体颜色为红色，字体大小20个像素。 边框为5像素蓝色点线。 --&gt; &lt;div id=&quot;id002&quot;&gt;div标签1&lt;/div&gt; &lt;div id=&quot;id001&quot;&gt;div标签2&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; class选择器class 类型选择器的格式是 .class属性值{ 属性:值 } class类型选择器可以通过class属性有效的选择地去使用这个样式 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;class类型选择器&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .class01&#123; color: blue; font-size: 30px; border: 1px solid yellow; &#125; .class02&#123; color: grey; font-size: 26px; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 需求1：修改 class 属性值为 class01的 span 或 div 标签，字体颜色为蓝色，字体大小30个像素。边框为1像素黄色实线。 需求2：修改 class 属性值为 class02的 div 标签，字体颜色为灰色，字体大小26个像素。边框为1像素红色实线。 --&gt; &lt;div class=&quot;class01&quot;&gt;div标签class01&lt;/div&gt; &lt;div class=&quot;class02&quot;&gt;div标签&lt;/div&gt; &lt;span class=&quot;class02&quot;&gt;span标签class01&lt;/span&gt; &lt;span&gt;span标签2&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 组合选择器组合选择器的格式是： 选择器1,选择器2,选择器n{ 属性:值 } 让多个选择器或者多种类型的选择器共用同一块代码 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;class类型选择器&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .class01 , #id01&#123; color: blue; font-size: 20px; border: yellow 1px solid; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 需求1：修改 class=&quot;class01&quot; 的div 标签 和 id=&quot;id01&quot; 所有的span标签， 字体颜色为蓝色，字体大小20个像素。边框为1像素黄色实线。 --&gt; &lt;div id=&quot;id01&quot;&gt;div标签class01&lt;/div&gt; &lt;br /&gt; &lt;span class=&quot;class01&quot;&gt;span 标签&lt;/span&gt; &lt;br /&gt; &lt;div&gt;div标签&lt;/div&gt; &lt;br /&gt; &lt;div&gt;div标签id01&lt;/div&gt; &lt;br /&gt;&lt;/body&gt;&lt;/html&gt; css常用样式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;06-css常用样式.html&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123; color: red; 红色 border: 1px yellow solid; 边框属性 width: 300px; 宽度 height: 300px; 高度 background-color: green; 背景颜色 font-size: 30px; 字体大小 margin-left: auto; 这个和下面那个两行表示div居中 margin-right: auto; text-align: center; 文字居中 &#125; table&#123; border: 1px red solid; 设置边框 border-collapse: collapse; 将边框合并，就是td单元格的边框和表格的边框合并 &#125; td&#123; border: 1px red solid; &#125; a&#123; text-decoration: none; 超链接去下划线 &#125; ul&#123; list-style: none; 列表去除修饰 &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;11111111111&lt;/li&gt; &lt;li&gt;11111111111&lt;/li&gt; &lt;li&gt;11111111111&lt;/li&gt; &lt;li&gt;11111111111&lt;/li&gt; &lt;li&gt;11111111111&lt;/li&gt; &lt;/ul&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;1.1&lt;/td&gt; &lt;td&gt;1.2&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; &lt;div&gt;我是div标签&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; JavascriptjQueryjQuery就是javascript和查询，他就是辅助javascript开发的js类库 jQuery 的核心思想就是write less ，do more 所以他实现了很多浏览器的兼容问题 基础使用 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; // window.onload = function () &#123; // var btnObj = document.getElementById(&quot;btnId&quot;); // // alert(btnObj);//[object HTMLButtonElement] ====&gt;&gt;&gt; dom对象 // btnObj.onclick = function () &#123; // alert(&quot;js 原生的单击事件&quot;); // &#125; // &#125; $(function () &#123; // 表示页面加载完成 之后，相当 window.onload = function () &#123;&#125; var $btnObj = $(&quot;#btnId&quot;); // 表示按id查询标签对象，jQuery对象变量都加一个$ $btnObj.click(function () &#123; // 绑定单击事件 alert(&quot;jQuery 的单击事件&quot;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btnId&quot;&gt;SayHello&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; jQuery中的$是一个函数 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt; &lt;!--引入jQuery文件--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; //使用$()代替window.onload$(function()&#123; //使用选择器获取按钮对象，随后绑定单击响应函数 //表示按id查询对象 $(&quot;#btnId&quot;).click(function()&#123; //弹出Hello alert(&#x27;Hello&#x27;); &#125;); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btnId&quot;&gt;SayHello&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 为按钮添加响应函数 1.使用jQuery查询到标签对象 2.使用标签对象.click(function(){}); $介绍$是jQuery的核心函数，能完成jQuery的很多功能，$()就是调用$这个函数 1.传入的参数是函数时 表示页面加载完成之后。相当于window.onload&#x3D;function(){}; 2.传入的参数为HTML字符串时，会对我们创建这个html标签对象 3.传入参数为【选择器字符串时】， $(“#id属性值”)：id选择器，根据id查询标签对象 $(“标签名”): 标签名选择器，根据指定的标签名查询标签对象 $(“.class属性值”):类型选择器，根据class属性查询标签对象 4.传入的参数是dom对象，将这个dom对象转换为jQuery对象 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; //核心函数的4个作用 $(function () &#123; // alert(&quot;页面加载完成之后，自动调用&quot;);//将生成的html标签对象直接加给了body标签，这样就可以显示 $(&quot; &lt;div&gt;&quot; + &quot; &lt;span&gt;div-span1&lt;/span&gt;&quot; + &quot; &lt;span&gt;div-span2&lt;/span&gt;&quot; + &quot; &lt;/div&gt;&quot;).appendTo(&quot;body&quot;); // alert($(&quot;button&quot;).length); var btnObj = document.getElementById(&quot;btn01&quot;); // alert(btnObj); // alert( $(btnObj) ); // alert( $(&quot;&lt;h1&gt;&lt;/h1&gt;&quot;) ); alert($(&quot;button&quot;)); &#125;); //传入参数为[函数]时：在文档加载完成后执行这个函数 //传入参数为[HTML字符串]时：根据这个字符串创建元素节点对象，创建的是jQuery对象 //传入参数为[选择器字符串]时：根据这个字符串查找元素节点对象，创建的是jQuery对象 //传入参数为[DOM对象]时：将DOM对象包装为jQuery对象返回&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn01&quot;&gt;按钮1&lt;/button&gt; &lt;button&gt;按钮2&lt;/button&gt; &lt;button&gt;按钮3&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; jQuery对象和dom对象区分DOM对象 1.通过各种方法查询出来的标签对象是dom对象 jQuery对象 1.通过jQuery提供的API创建的对象，是jQuery对象 alert( $(““) ); 2.通过JQuery包装的Dom对象，也是JQuery对象 alert( $(btnObj) ); btnObj是一个dom对象 3.它通过JQuery提供的API查询到的对象，是JQuery对象 alert($(“button”)); JQuery对象alert出来的效果是[Object Object] jQuery对象的本质jQuery对象是 dom对象的数组+jQuery提供的一系列功能函数 jQuery对象和Dom对象的使用区别jQuery对象不能使用dom对象的属性和方法 dom对象也不能使用jQuery对象的属性和方法 Dom对象和JQuery对象之间的相互转换1.dom对象转化为jQUery对象 现有Dom对象，然后 $(Dom)对象就可以转换为jQuery对象 2.jQuery对象转为dom对象 现有jQuery对象，jQuery对象[下标]取出相应的dom对象 Insert title here ​ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 //jQuery对象的本质的演示 $(function()&#123; //testDiv.css(&quot;color&quot;,&quot;red&quot;) //testDiv.style.color = &quot;blue&quot;; // var arr = [12,&quot;abc&quot;,true]; // // var $btns = $(&quot;button&quot;); // // for (var i = 0; i &lt; $btns.length; i++)&#123; // alert($btns[i]); // &#125; //jQuery和Dom的使用区别的演示 //document.getElementById(&quot;testDiv&quot;).innerHTML = &quot;这是dom对象的属性InnerHTML&quot;; //$(&quot;#testDiv&quot;).innerHTML = &quot;这是dom对象的属性InnerHTML&quot;; //$(&quot;#testDiv&quot;).click(function () &#123; //alert(&quot;click()是jQuery对象的方法&quot;); //&#125;); //document.getElementById(&quot;testDiv&quot;).click(function () &#123; //alert(&quot;click()是jQuery对象的方法&quot;); //&#125;); //下面是jQuery对象转换为dom对象的演示，用下标来取出 // alert( $(document.getElementById(&quot;testDiv&quot;))[0] ); alert( $(&quot;button:first&quot;) ); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;testDiv&quot;&gt;Atguigu is Very Good!&lt;/div&gt; &lt;button id=&quot;dom2dom&quot;&gt;使用DOM对象调用DOM方法&lt;/button&gt; &lt;button id=&quot;dom2jQuery&quot;&gt;使用DOM对象调用jQuery方法&lt;/button&gt; &lt;button id=&quot;jQuery2jQuery&quot;&gt;使用jQuery对象调用jQuery方法&lt;/button&gt; &lt;button id=&quot;jQuery2dom&quot;&gt;使用jQuery对象调用DOM方法&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; jQuery基本选择器基本选择器 #ID 选择器：根据id查找标签对象 .class 选择器：根据class查找标签对象 element 选择器：根据标签名查找标签对象 *选择器：表示任意的，所有的元素 selector1,selector2 组合器：合并选择器1,选择器2的结果并返回 特殊的 p.myClass表示标签名必须是p标签，而且class类型还要是myClass 基本选择器的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; &lt;!--应该是div标签且class为mini--&gt; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; //1.选择 id 为 one 的元素 &quot;background-color&quot;,&quot;#bbffaa&quot; $(&quot;#btn1&quot;).click(function () &#123; // css() 方法 可以设置和获取样式,第二个参数是颜色属性的值 $(&quot;#one&quot;).css(&quot;background-color&quot;,&quot;#bbffaa&quot;); &#125;); //2.选择 class 为 mini 的所有元素 $(&quot;#btn2&quot;).click(function () &#123; $(&quot;.mini&quot;).css(&quot;background-color&quot;,&quot;#bbffaa&quot;); &#125;); //3.选择 元素名是 div 的所有元素 $(&quot;#btn3&quot;).click(function () &#123; $(&quot;div&quot;).css(&quot;background-color&quot;,&quot;#bbffaa&quot;); &#125;); //4.选择所有的元素 $(&quot;#btn4&quot;).click(function () &#123; $(&quot;*&quot;).css(&quot;background-color&quot;,&quot;#bbffaa&quot;); &#125;); //5.选择所有的 span 元素和id为two的元素 $(&quot;#btn5&quot;).click(function () &#123; $(&quot;span,#two&quot;).css(&quot;background-color&quot;,&quot;#bbffaa&quot;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;!-- &lt;div&gt; &lt;h1&gt;基本选择器&lt;/h1&gt; &lt;/div&gt; --&gt; &lt;input type=&quot;button&quot; value=&quot;选择 id 为 one 的元素&quot; id=&quot;btn1&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择 class 为 mini 的所有元素&quot; id=&quot;btn2&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择 元素名是 div 的所有元素&quot; id=&quot;btn3&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择 所有的元素&quot; id=&quot;btn4&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择 所有的 span 元素和id为two的元素&quot; id=&quot;btn5&quot; /&gt; &lt;br&gt; &lt;div class=&quot;one&quot; id=&quot;one&quot;&gt; id 为 one,class 为 one 的div &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot; id=&quot;two&quot; title=&quot;test&quot;&gt; id为two,class为one,title为test的div &lt;div class=&quot;mini&quot; title=&quot;other&quot;&gt;class为mini,title为other&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;test&quot;&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;tesst&quot;&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;!--display:none就是不显示--&gt; &lt;div style=&quot;display:none;&quot; class=&quot;none&quot;&gt;style的display为&quot;none&quot;的div&lt;/div&gt; &lt;div class=&quot;hide&quot;&gt;class为&quot;hide&quot;的div&lt;/div&gt; &lt;div&gt; 包含input的type为&quot;hidden&quot;的div&lt;input type=&quot;hidden&quot; size=&quot;8&quot;&gt; &lt;/div&gt; &lt;span class=&quot;one&quot; id=&quot;span&quot;&gt;^^span元素^^&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; jQuery层级选择器ancestor descendant 后代选择器 ：在给定的祖先元素下匹配所有的后代元素 parent &gt; child 子元素选择器：在给定的父元素下匹配所有的子元素 prev + next 相邻元素选择器：匹配所有紧接在 prev 元素后的 next 元素 prev ~ sibings 之后的兄弟元素选择器：匹配 prev 元素之后的所有 siblings 元素 儿子元素和孙子元素是有区别的，而且后代元素包括所有的后代包括儿子孙子 $(“lable + input”) 所有紧跟在lable标签后面的input标签，必须是紧跟 $(“form &gt; input”)匹配表单中所有的子级input元素，只有儿子辈的，没有孙子辈的 $(“form input”)匹配form后代的所有的input元素 $(“form ~input”)找到form后面所有与form同辈的input元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; //$(function()&#123;&#125;);的全写 //1.选择 body 内的所有 div 元素 $(&quot;#btn1&quot;).click(function()&#123; $(&quot;body div&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //2.在 body 内, 选择div子元素 $(&quot;#btn2&quot;).click(function()&#123; $(&quot;body &gt; div&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //3.选择 id 为 one 的下一个 div 元素 $(&quot;#btn3&quot;).click(function()&#123; $(&quot;#one+div&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //4.选择 id 为 two 的元素后面的所有 div 兄弟元素 $(&quot;#btn4&quot;).click(function()&#123; $(&quot;#two~div&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- &lt;div&gt; &lt;h1&gt;层级选择器:根据元素的层级关系选择元素&lt;/h1&gt; ancestor descendant ： parent &gt; child ： prev + next ： prev ~ siblings ： &lt;/div&gt; --&gt; &lt;input type=&quot;button&quot; value=&quot;选择 body 内的所有 div 元素&quot; id=&quot;btn1&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;在 body 内, 选择div子元素&quot; id=&quot;btn2&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择 id 为 one 的下一个 div 元素&quot; id=&quot;btn3&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择 id 为 two 的元素后面的所有 div 兄弟元素&quot; id=&quot;btn4&quot; /&gt; &lt;br&gt;&lt;br&gt; &lt;div class=&quot;one&quot; id=&quot;one&quot;&gt; id 为 one,class 为 one 的div &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot; id=&quot;two&quot; title=&quot;test&quot;&gt; id为two,class为one,title为test的div &lt;div class=&quot;mini&quot; title=&quot;other&quot;&gt;class为mini,title为other&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;test&quot;&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;tesst&quot;&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;display:none;&quot; class=&quot;none&quot;&gt;style的display为&quot;none&quot;的div&lt;/div&gt; &lt;div class=&quot;hide&quot;&gt;class为&quot;hide&quot;的div&lt;/div&gt; &lt;div&gt; 包含input的type为&quot;hidden&quot;的div&lt;input type=&quot;hidden&quot; size=&quot;8&quot;&gt; &lt;/div&gt; &lt;span id=&quot;span&quot;&gt;^^span元素^^&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; jQuery基本过滤选择器:first 获取第一个元素 :last 获取最后个元素 :not(selector) 去除所有与给定选择器匹配的元素 :even 匹配所有索引值为偶数的元素，从 0 开始计数 :odd 匹配所有索引值为奇数的元素，从 0 开始计数 :eq(index) 匹配一个给定索引值的元素 :gt(index) 匹配所有大于给定索引值的元素 :lt(index) 匹配所有小于给定索引值的元素 :header 匹配如 h1, h2, h3 之类的标题元素 :animated 匹配所有正在执行动画效果的元 :hidden匹配被隐藏起来的元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; //这是一个动画的代码 $(document).ready(function()&#123; function anmateIt()&#123; $(&quot;#mover&quot;).slideToggle(&quot;slow&quot;, anmateIt); &#125; anmateIt(); &#125;); $(document).ready(function()&#123; //1.选择第一个 div 元素 $(&quot;#btn1&quot;).click(function()&#123; $(&quot;div:first&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //2.选择最后一个 div 元素 $(&quot;#btn2&quot;).click(function()&#123; $(&quot;div:last&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //3.选择class不为 one 的所有 div 元素 $(&quot;#btn3&quot;).click(function()&#123; $(&quot;div:not(.one)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //4.选择索引值为偶数的 div 元素 $(&quot;#btn4&quot;).click(function()&#123; $(&quot;div:even&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //5.选择索引值为奇数的 div 元素 $(&quot;#btn5&quot;).click(function()&#123; $(&quot;div:odd&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //6.选择索引值为大于 3 的 div 元素 $(&quot;#btn6&quot;).click(function()&#123; $(&quot;div:gt(3)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //7.选择索引值为等于 3 的 div 元素 $(&quot;#btn7&quot;).click(function()&#123; $(&quot;div:eq(3)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //8.选择索引值为小于 3 的 div 元素 $(&quot;#btn8&quot;).click(function()&#123; $(&quot;div:lt(3)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //9.选择所有的标题元素 $(&quot;#btn9&quot;).click(function()&#123; $(&quot;:header&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //10.选择当前正在执行动画的所有元素 $(&quot;#btn10&quot;).click(function()&#123; $(&quot;:animated&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //11.选择没有执行动画的最后一个div $(&quot;#btn11&quot;).click(function()&#123; $(&quot;div:not(:animated):last&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;选择第一个 div 元素&quot; id=&quot;btn1&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择最后一个 div 元素&quot; id=&quot;btn2&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择class不为 one 的所有 div 元素&quot; id=&quot;btn3&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择索引值为偶数的 div 元素&quot; id=&quot;btn4&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择索引值为奇数的 div 元素&quot; id=&quot;btn5&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择索引值为大于 3 的 div 元素&quot; id=&quot;btn6&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择索引值为等于 3 的 div 元素&quot; id=&quot;btn7&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择索引值为小于 3 的 div 元素&quot; id=&quot;btn8&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择所有的标题元素&quot; id=&quot;btn9&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择当前正在执行动画的所有元素&quot; id=&quot;btn10&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择没有执行动画的最后一个div&quot; id=&quot;btn11&quot; /&gt; &lt;h3&gt;基本选择器.&lt;/h3&gt; &lt;br&gt;&lt;br&gt; &lt;div class=&quot;one&quot; id=&quot;one&quot;&gt; id 为 one,class 为 one 的div &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot; id=&quot;two&quot; title=&quot;test&quot;&gt; id为two,class为one,title为test的div &lt;div class=&quot;mini&quot; title=&quot;other&quot;&gt;class为mini,title为other&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;test&quot;&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;tesst&quot;&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;display:none;&quot; class=&quot;none&quot;&gt;style的display为&quot;none&quot;的div&lt;/div&gt; &lt;div class=&quot;hide&quot;&gt;class为&quot;hide&quot;的div&lt;/div&gt; &lt;div&gt; 包含input的type为&quot;hidden&quot;的div&lt;input type=&quot;hidden&quot; size=&quot;8&quot;&gt; &lt;/div&gt; &lt;div id=&quot;mover&quot;&gt;正在执行动画的div元素.&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; jQuery内容过滤器文本也算是子元素 :contains(text) 匹配包含给定文本的元素 :empty 匹配所有不包含子元素或者文本的空元素 :parent 匹配含有子元素或者文本的元素 :has(selector) 匹配含有选择器所匹配的元素的元 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; function anmateIt()&#123; $(&quot;#mover&quot;).slideToggle(&quot;slow&quot;, anmateIt); &#125; anmateIt(); &#125;); /** :contains(text) :empty :has(selector) :parent */ $(document).ready(function()&#123; //1.选择 含有文本 &#x27;di&#x27; 的 div 元素 $(&quot;#btn1&quot;).click(function()&#123; $(&quot;div:contains(&#x27;di&#x27;)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //2.选择不包含子元素(包括文本元素) 的 div 空元素 $(&quot;#btn2&quot;).click(function()&#123; $(&quot;div:empty&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //3.选择含有 class 为 mini 元素的 div 元素 $(&quot;#btn3&quot;).click(function()&#123; $(&quot;div:has(.mini)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //4.选择含有子元素(包括文本元素)的div元素 $(&quot;#btn4&quot;).click(function()&#123; $(&quot;div:parent&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;选择 含有文本 &#x27;di&#x27; 的 div 元素&quot; id=&quot;btn1&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择不包含子元素(或者文本元素) 的 div 空元素&quot; id=&quot;btn2&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择含有 class 为 mini 元素的 div 元素&quot; id=&quot;btn3&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择含有子元素(或者文本元素)的div元素&quot; id=&quot;btn4&quot; /&gt; &lt;br&gt;&lt;br&gt; &lt;div class=&quot;one&quot; id=&quot;one&quot;&gt; id 为 one,class 为 one 的div &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot; id=&quot;two&quot; title=&quot;test&quot;&gt; id为two,class为one,title为test的div &lt;div class=&quot;mini&quot; title=&quot;other&quot;&gt;class为mini,title为other&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;test&quot;&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;tesst&quot;&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;display:none;&quot; class=&quot;none&quot;&gt;style的display为&quot;none&quot;的div&lt;/div&gt; &lt;div class=&quot;hide&quot;&gt;class为&quot;hide&quot;的div&lt;/div&gt; &lt;div&gt; 包含input的type为&quot;hidden&quot;的div&lt;input type=&quot;hidden&quot; size=&quot;8&quot;&gt; &lt;/div&gt; &lt;div id=&quot;mover&quot;&gt;正在执行动画的div元素.&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; jQuery属性过滤选择器[attribute] 匹配包含给定属性的元素。 [attribute&#x3D;value] 匹配给定的属性是某个特定值的元素 [attribute!&#x3D;value] 匹配所有不含有指定的属性，或者属性不等于特定值的元素。 [attribute^&#x3D;value] 匹配给定的属性是以某些值开始的元素 [attribute$&#x3D;value] 匹配给定的属性是以某些值结尾的元素 [attribute*&#x3D;value] 匹配给定的属性是以包含某些值的元素 [attrSel1][attrSel2][attrSelN] 复合属性选择器，需要同时满足多个条件时使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Untitled Document&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;div,span,p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana;&#125;div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px;&#125;div.hide &#123; display: none;&#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; /**[attribute] [attribute=value] [attribute!=value] [attribute^=value] [attribute$=value] [attribute*=value] [attrSel1][attrSel2][attrSelN] */ $(function() &#123; //1.选取含有 属性title 的div元素 $(&quot;#btn1&quot;).click(function() &#123; $(&quot;div[title]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //2.选取 属性title值等于&#x27;test&#x27;的div元素 $(&quot;#btn2&quot;).click(function() &#123; $(&quot;div[title=&#x27;test&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //3.选取 属性title值不等于&#x27;test&#x27;的div元素(*没有属性title的也将被选中) $(&quot;#btn3&quot;).click(function() &#123; $(&quot;div[title!=&#x27;test&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //4.选取 属性title值 以&#x27;te&#x27;开始 的div元素 $(&quot;#btn4&quot;).click(function() &#123; $(&quot;div[title^=&#x27;te&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //5.选取 属性title值 以&#x27;est&#x27;结束 的div元素 $(&quot;#btn5&quot;).click(function() &#123; $(&quot;div[title$=&#x27;est&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //6.选取 属性title值 含有&#x27;es&#x27;的div元素 $(&quot;#btn6&quot;).click(function() &#123; $(&quot;div[title*=&#x27;es&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //7.首先选取有属性id的div元素，然后在结果中 选取属性title值 含有&#x27;es&#x27;的 div 元素 $(&quot;#btn7&quot;).click(function() &#123; $(&quot;div[id][title*=&#x27;es&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //8.选取 含有 title 属性值, 且title 属性值不等于 test 的 div 元素 $(&quot;#btn8&quot;).click(function() &#123; $(&quot;div[title][title!=&#x27;test&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;选取含有 属性title 的div元素.&quot; id=&quot;btn1&quot; style=&quot;display: none;&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;选取 属性title值等于&#x27;test&#x27;的div元素.&quot; id=&quot;btn2&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选取 属性title值不等于&#x27;test&#x27;的div元素(没有属性title的也将被选中).&quot; id=&quot;btn3&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选取 属性title值 以&#x27;te&#x27;开始 的div元素.&quot; id=&quot;btn4&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选取 属性title值 以&#x27;est&#x27;结束 的div元素.&quot; id=&quot;btn5&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选取 属性title值 含有&#x27;es&#x27;的div元素.&quot; id=&quot;btn6&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;组合属性选择器,首先选取有属性id的div元素，然后在结果中 选取属性title值 含有&#x27;es&#x27;的 div 元素.&quot; id=&quot;btn7&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选取 含有 title 属性值, 且title 属性值不等于 test 的 div 元素.&quot; id=&quot;btn8&quot; /&gt; &lt;br&gt; &lt;br&gt; &lt;div class=&quot;one&quot; id=&quot;one&quot;&gt; id 为 one,class 为 one 的div &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot; id=&quot;two&quot; title=&quot;test&quot;&gt; id为two,class为one,title为test的div &lt;div class=&quot;mini&quot; title=&quot;other&quot;&gt;class为mini,title为other&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;test&quot;&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;tesst&quot;&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;display: none;&quot; class=&quot;none&quot;&gt;style的display为&quot;none&quot;的div&lt;/div&gt; &lt;div class=&quot;hide&quot;&gt;class为&quot;hide&quot;的div&lt;/div&gt; &lt;div&gt; 包含input的type为&quot;hidden&quot;的div&lt;input type=&quot;hidden&quot; value=&quot;123456789&quot; size=&quot;8&quot;&gt; &lt;/div&gt; &lt;div id=&quot;mover&quot;&gt;正在执行动画的div元素.&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; jQuery表单过滤选择器:input 匹配所有 input, textarea, select 和 button 元素 :text 匹配所有 文本输入框 :password 匹配所有的密码输入框 :radio 匹配所有的单选框 :checkbox 匹配所有的复选框 :submit 匹配所有提交按钮 :image 匹配所有 img 标签 :reset 匹配所有重置按钮 :button 匹配所有 input type&#x3D;button 按钮 :file 匹配所有 input type&#x3D;file 文件上传 :hidden 匹配所有不可见元素 display:none :enabled 匹配所有可用元素 :disabled 匹配所有不可用元素 :checked 匹配所有选中的单选，复选，和下拉列表中选中的 option 标签对象 :selected 匹配所有选中的 option 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; /** :input :text :password :radio :checkbox :submit :image :reset :button :file :hidden 表单对象的属性 :enabled :disabled :checked :selected */ //1.对表单内 可用input 赋值操作 $(&quot;#btn1&quot;).click(function()&#123; // val()可以操作表单项的value属性值 //表单项是那个form标签里面的那些 // 它可以设置和获取 $(&quot;:text:enabled&quot;).val(&quot;我是万能的程序员&quot;); &#125;); //2.对表单内 不可用input 赋值操作 $(&quot;#btn2&quot;).click(function()&#123; $(&quot;:text:disabled&quot;).val(&quot;管你可用不可用，反正我是万能的程序员&quot;); &#125;); //3.获取多选框选中的个数 使用size()方法获取选取到的元素集合的元素个数 $(&quot;#btn3&quot;).click(function()&#123; alert( $(&quot;:checkbox:checked&quot;).length ); &#125;); //4.获取多选框，每个选中的value值 $(&quot;#btn4&quot;).click(function()&#123; // 获取全部选中的复选框标签对象 var $checkboies = $(&quot;:checkbox:checked&quot;); // 老式遍历 // for (var i = 0; i &lt; $checkboies.length; i++)&#123; // alert( $checkboies[i].value ); // &#125; // each方法是jQuery对象提供用来遍历元素的方法 // 在遍历的function函数中，有一个this对象，这个this对象，就是当前遍历到的dom对象 $checkboies.each(function () &#123; alert( this.value ); &#125;); &#125;); //5.获取下拉框选中的内容 $(&quot;#btn5&quot;).click(function()&#123; // 选中select后代的option标签且被选中的 var $options = $(&quot;select option:selected&quot;); // 遍历，获取option标签中的文本内容 $options.each(function () &#123; // 在each遍历的function函数中，有一个this对象。这个this对象是当前正在遍历到的dom对象 alert(this.innerHTML); &#125;); &#125;); &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;表单对象属性过滤选择器&lt;/h3&gt; &lt;button id=&quot;btn1&quot;&gt;对表单内 可用input 赋值操作.&lt;/button&gt; &lt;button id=&quot;btn2&quot;&gt;对表单内 不可用input 赋值操作.&lt;/button&gt;&lt;br /&gt;&lt;br /&gt; &lt;button id=&quot;btn3&quot;&gt;获取多选框选中的个数.&lt;/button&gt; &lt;button id=&quot;btn4&quot;&gt;获取多选框选中的内容.&lt;/button&gt;&lt;br /&gt;&lt;br /&gt; &lt;button id=&quot;btn5&quot;&gt;获取下拉框选中的内容.&lt;/button&gt;&lt;br /&gt;&lt;br /&gt; &lt;form id=&quot;form1&quot; action=&quot;#&quot;&gt; 可用元素: &lt;input name=&quot;add&quot; value=&quot;可用文本框1&quot;/&gt;&lt;br&gt; &lt;!--diabled=&quot;disabled就是让文本框不可选&quot;--&gt; 不可用元素: &lt;input name=&quot;email&quot; disabled=&quot;disabled&quot; value=&quot;不可用文本框&quot;/&gt;&lt;br&gt; 可用元素: &lt;input name=&quot;che&quot; value=&quot;可用文本框2&quot;/&gt;&lt;br&gt; 不可用元素: &lt;input name=&quot;name&quot; disabled=&quot;disabled&quot; value=&quot;不可用文本框&quot;/&gt;&lt;br&gt; &lt;br&gt; 多选框: &lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;newsletter&quot; checked=&quot;checked&quot; value=&quot;test1&quot; /&gt;test1 &lt;input type=&quot;checkbox&quot; name=&quot;newsletter&quot; value=&quot;test2&quot; /&gt;test2 &lt;input type=&quot;checkbox&quot; name=&quot;newsletter&quot; value=&quot;test3&quot; /&gt;test3 &lt;input type=&quot;checkbox&quot; name=&quot;newsletter&quot; checked=&quot;checked&quot; value=&quot;test4&quot; /&gt;test4 &lt;input type=&quot;checkbox&quot; name=&quot;newsletter&quot; value=&quot;test5&quot; /&gt;test5 &lt;br&gt;&lt;br&gt; 下拉列表1: &lt;br&gt; &lt;!--multiple属性决定了这个下拉表可以多选--&gt; &lt;select name=&quot;test&quot; multiple=&quot;multiple&quot; style=&quot;height: 100px&quot; id=&quot;sele1&quot;&gt; &lt;option&gt;浙江&lt;/option&gt; &lt;option selected=&quot;selected&quot;&gt;辽宁&lt;/option&gt; &lt;option&gt;北京&lt;/option&gt; &lt;option selected=&quot;selected&quot;&gt;天津&lt;/option&gt; &lt;option&gt;广州&lt;/option&gt; &lt;option&gt;湖北&lt;/option&gt; &lt;/select&gt; &lt;br&gt;&lt;br&gt; 下拉列表2: &lt;br&gt; &lt;select name=&quot;test2&quot;&gt; &lt;option&gt;浙江&lt;/option&gt; &lt;option&gt;辽宁&lt;/option&gt; &lt;option selected=&quot;selected&quot;&gt;北京&lt;/option&gt; &lt;option&gt;天津&lt;/option&gt; &lt;option&gt;广州&lt;/option&gt; &lt;option&gt;湖北&lt;/option&gt; &lt;/select&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; jQuery元素的筛选eq() 获取给定索引的元素 功能跟 :eq() 一样 first() 获取第一个元素 功能跟 :first 一样 last() 获取最后一个元素 功能跟 :last 一样 filter(exp) 留下匹配的元素 is(exp) 判断是否匹配给定的选择器，只要有一个匹配就返回，true has(exp) 返回包含有匹配选择器的元素的元素 功能跟 :has 一样 not(exp) 删除匹配选择器的元素 功能跟 :not 一样 children(exp) 返回匹配给定选择器的子元素 功能跟 parent&gt;child 一样 find(exp) 返回匹配给定选择器的后代元素 功能跟 ancestor descendant 一样 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;DOM查询&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; function anmateIt()&#123; $(&quot;#mover&quot;).slideToggle(&quot;slow&quot;, anmateIt); &#125; anmateIt(); /** 过滤 eq(index|-index) first() last() hasClass(class) filter(expr|obj|ele|fn) is(expr|obj|ele|fn)1.6* has(expr|ele) not(expr|ele|fn) slice(start,[end]) 查找 children([expr]) closest(expr,[con]|obj|ele)1.6* find(expr|obj|ele) next([expr]) nextall([expr]) nextUntil([exp|ele][,fil])1.6* parent([expr]) parents([expr]) parentsUntil([exp|ele][,fil])1.6* prev([expr]) prevall([expr]) prevUntil([exp|ele][,fil])1.6* siblings([expr]) 串联 add(expr|ele|html|obj[,con]) */ //(1)eq() 选择索引值为等于 3 的 div 元素 $(&quot;#btn1&quot;).click(function()&#123; $(&quot;div&quot;).eq(3).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(2)first()选择第一个 div 元素 $(&quot;#btn2&quot;).click(function()&#123; //first() 选取第一个元素 $(&quot;div&quot;).first().css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(3)last()选择最后一个 div 元素 $(&quot;#btn3&quot;).click(function()&#123; //last() 选取最后一个元素 $(&quot;div&quot;).last().css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(4)filter()在div中选择索引为偶数的 $(&quot;#btn4&quot;).click(function()&#123; //filter() 过滤 传入的是选择器字符串 $(&quot;div&quot;).filter(&quot;:even&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(5)is()判断#one是否为:empty或:parent //is用来检测jq对象是否符合指定的选择器 $(&quot;#btn5&quot;).click(function()&#123; alert( $(&quot;#one&quot;).is(&quot;:empty&quot;) ); &#125;); //(6)has()选择div中包含.mini的 $(&quot;#btn6&quot;).click(function()&#123; //has(selector) 选择器字符串 是否包含selector $(&quot;div&quot;).has(&quot;.mini&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(7)not()选择div中class不为one的 $(&quot;#btn7&quot;).click(function()&#123; //not(selector) 选择不是selector的元素 $(&quot;div&quot;).not(&#x27;.one&#x27;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(8)children()在body中选择所有class为one的div子元素 $(&quot;#btn8&quot;).click(function()&#123; //children() 选出所有的子元素 $(&quot;body&quot;).children(&quot;div.one&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(9)find()在body中选择所有class为mini的div元素 $(&quot;#btn9&quot;).click(function()&#123; //find() 选出所有的后代元素 $(&quot;body&quot;).find(&quot;div.mini&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(10)next() #one的下一个div $(&quot;#btn10&quot;).click(function()&#123; //next() 选择下一个兄弟元素 $(&quot;#one&quot;).next(&quot;div&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(11)nextAll() #one后面所有的span元素 $(&quot;#btn11&quot;).click(function()&#123; //nextAll() 选出后面所有的元素 $(&quot;#one&quot;).nextAll(&quot;span&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(12)nextUntil() #one和span之间的元素，不算两边 $(&quot;#btn12&quot;).click(function()&#123; // $(&quot;#one&quot;).nextUntil(&quot;span&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;) &#125;); //(13)parent() .mini的父元素 $(&quot;#btn13&quot;).click(function()&#123; $(&quot;.mini&quot;).parent().css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(14)prev() #two的上一个div $(&quot;#btn14&quot;).click(function()&#123; //prev() $(&quot;#two&quot;).prev(&quot;div&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;) &#125;); //(15)prevAll() span前面所有的div $(&quot;#btn15&quot;).click(function()&#123; //prevAll() 选出前面所有的元素 $(&quot;span&quot;).prevAll(&quot;div&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;) &#125;); //(16)prevUntil() span向前直到#one的元素，都不算两个边界 $(&quot;#btn16&quot;).click(function()&#123; //prevUntil(exp) 找到之前所有的兄弟元素直到找到exp停止 $(&quot;span&quot;).prevUntil(&quot;#one&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;) &#125;); //(17)siblings() #two的所有兄弟元素 $(&quot;#btn17&quot;).click(function()&#123; //siblings() 找到所有的兄弟元素，包括前面的和后面的 $(&quot;#two&quot;).siblings().css(&quot;background-color&quot;,&quot;#bfa&quot;) &#125;); //(18)add()选择所有的 span 元素和id为two的元素 $(&quot;#btn18&quot;).click(function()&#123; // $(&quot;span,#two,.mini,#one&quot;) $(&quot;span&quot;).add(&quot;#two&quot;).add(&quot;#one&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;eq()选择索引值为等于 3 的 div 元素&quot; id=&quot;btn1&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;first()选择第一个 div 元素&quot; id=&quot;btn2&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;last()选择最后一个 div 元素&quot; id=&quot;btn3&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;filter()在div中选择索引为偶数的&quot; id=&quot;btn4&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;is()判断#one是否为:empty或:parent&quot; id=&quot;btn5&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;has()选择div中包含.mini的&quot; id=&quot;btn6&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;not()选择div中class不为one的&quot; id=&quot;btn7&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;children()在body中选择所有class为one的div子元素&quot; id=&quot;btn8&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;find()在body中选择所有class为mini的div后代元素&quot; id=&quot;btn9&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;next()#one的下一个div&quot; id=&quot;btn10&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;nextAll()#one后面所有的span元素&quot; id=&quot;btn11&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;nextUntil()#one和span之间的元素&quot; id=&quot;btn12&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;parent().mini的父元素&quot; id=&quot;btn13&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;prev()#two的上一个div&quot; id=&quot;btn14&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;prevAll()span前面所有的div&quot; id=&quot;btn15&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;prevUntil()span向前直到#one的元素&quot; id=&quot;btn16&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;siblings()#two的所有兄弟元素&quot; id=&quot;btn17&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;add()选择所有的 span 元素和id为two的元素&quot; id=&quot;btn18&quot; /&gt; &lt;h3&gt;基本选择器.&lt;/h3&gt; &lt;br /&gt;&lt;br /&gt; 文本框&lt;input type=&quot;text&quot; name=&quot;account&quot; disabled=&quot;disabled&quot; /&gt; &lt;br&gt;&lt;br&gt; &lt;div class=&quot;one&quot; id=&quot;one&quot;&gt; id 为 one,class 为 one 的div &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot; id=&quot;two&quot; title=&quot;test&quot;&gt; id为two,class为one,title为test的div &lt;div class=&quot;mini&quot; title=&quot;other&quot;&gt;&lt;b&gt;class为mini,title为other&lt;/b&gt;&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;test&quot;&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;tesst&quot;&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;display:none;&quot; class=&quot;none&quot;&gt;style的display为&quot;none&quot;的div&lt;/div&gt; &lt;div class=&quot;hide&quot;&gt;class为&quot;hide&quot;的div&lt;/div&gt; &lt;span id=&quot;span1&quot;&gt;^^span元素 111^^&lt;/span&gt; &lt;div&gt; 包含input的type为&quot;hidden&quot;的div&lt;input type=&quot;hidden&quot; size=&quot;8&quot;&gt; &lt;/div&gt; &lt;span id=&quot;span2&quot;&gt;^^span元素 222^^&lt;/span&gt; &lt;div id=&quot;mover&quot;&gt;正在执行动画的div元素.&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; jQuery属性操作html() 它可以设置和获取起始标签和结束标签中的内容，根dom属性innerHTML一样 不传参数是获取，传入参数是设置 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh_CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;$(function()&#123; alert($(&quot;div&quot;).html());//获取 $(&quot;div&quot;).html(&quot;&lt;h1&gt;我是赵梓皓&lt;/h1&gt;&quot;);//设置&#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;我是div标签&lt;span&gt;我是div中的spqn&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; text() 它可以设置和获取起始标签和结束标签中的文本，根dom属性innerText一样 不传参数是获取，传入参数是设置 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh_CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;$(function()&#123; alert($(&quot;div&quot;).text()); $(&quot;div&quot;).text(&quot;&lt;h1&gt;我是赵梓皓&lt;/h1&gt;&quot;);&#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;我是div标签&lt;span&gt;我是div中的spqn&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; text()方法只能让内容全部以文本形式显示，不能识别标签，但html标签可以 val() 它可以设置和获取表单项的value属性值 跟dom属性value一样 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh_CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123;$(&quot;button&quot;).click(function()&#123;alert($(&quot;#username&quot;).val());&#125;);$(&quot;#username&quot;).val(&quot;超级程序员&quot;);&#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;我是div标签&lt;span&gt;我是div中的spqn&lt;/span&gt;&lt;/div&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; /&gt;&lt;button&gt;操作输入框&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 表单选择器练习 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh_CN&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Title&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;$(function () &#123;/*// 批量操作单选$(&quot;:radio&quot;).val([&quot;radio2&quot;]);// 批量操作筛选框的选中状态$(&quot;:checkbox&quot;).val([&quot;checkbox3&quot;,&quot;checkbox2&quot;]);// 批量操作多选的下拉框选中状态$(&quot;#multiple&quot;).val([&quot;mul2&quot;,&quot;mul3&quot;,&quot;mul4&quot;]);// 操作单选的下拉框选中状态$(&quot;#single&quot;).val([&quot;sin2&quot;]);*/$(&quot;#multiple,#single,:radio,:checkbox&quot;).val([&quot;radio2&quot;,&quot;checkbox1&quot;,&quot;checkbox3&quot;,&quot;mul1&quot;,&quot;mul4&quot;,&quot;sin3&quot;]);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;body&gt;单选：&lt;input name=&quot;radio&quot; type=&quot;radio&quot; value=&quot;radio1&quot; /&gt;radio1&lt;input name=&quot;radio&quot; type=&quot;radio&quot; value=&quot;radio2&quot; /&gt;radio2&lt;br/&gt;多选：&lt;input name=&quot;checkbox&quot; type=&quot;checkbox&quot; value=&quot;checkbox1&quot; /&gt;checkbox1&lt;input name=&quot;checkbox&quot; type=&quot;checkbox&quot; value=&quot;checkbox2&quot; /&gt;checkbox2&lt;input name=&quot;checkbox&quot; type=&quot;checkbox&quot; value=&quot;checkbox3&quot; /&gt;checkbox3&lt;br/&gt;下拉多选 ：&lt;select id=&quot;multiple&quot; multiple=&quot;multiple&quot; size=&quot;4&quot;&gt;&lt;option value=&quot;mul1&quot;&gt;mul1&lt;/option&gt;&lt;option value=&quot;mul2&quot;&gt;mul2&lt;/option&gt;&lt;option value=&quot;mul3&quot;&gt;mul3&lt;/option&gt;&lt;option value=&quot;mul4&quot;&gt;mul4&lt;/option&gt;&lt;/select&gt;&lt;br/&gt;下拉单选 ：&lt;select id=&quot;single&quot;&gt;&lt;option value=&quot;sin1&quot;&gt;sin1&lt;/option&gt;&lt;option value=&quot;sin2&quot;&gt;sin2&lt;/option&gt;&lt;option value=&quot;sin3&quot;&gt;sin3&lt;/option&gt;&lt;/select&gt;&lt;/body&gt;&lt;/body&gt;&lt;/html&gt; attr() 可以设置和获取属性的值，不推荐操作checked，readOnly，selected，disabled等等 还不可以操作非标准的属性，比如自定义属性：abc什么的 prop() 可以设置和获取属性的值，只推荐操作上面不操作的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh_CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;$(function () &#123;//attralert($(&quot;:checkbox:first&quot;).attr(&quot;name&quot;));//获取属性的值$(&quot;:checkbox:first&quot;).attr(&quot;name&quot;,&quot;abc&quot;);alert($(&quot;:checkbox:first&quot;).attr(&quot;checked&quot;));//会返回undefined，但是这个时候没办法判断是没被选还是没有这个属性，所以用到prop()alert($(&quot;:checkbox:first&quot;).prop(&quot;checked&quot;));//返回的是false$(&quot;:checkbox&quot;).prop(&quot;checked&quot;,true);//让所有多选框都选中$(&quot;:checkbox:first&quot;).attr(&quot;abc&quot;,&quot;abcvalue&quot;);//设置自定义属性alert($(&quot;:checkbox:first&quot;).attr(&quot;abc&quot;));//查看自定义属性//&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;body&gt;单选：&lt;input name=&quot;radio&quot; type=&quot;radio&quot; value=&quot;radio1&quot; /&gt;radio1&lt;input name=&quot;radio&quot; type=&quot;radio&quot; value=&quot;radio2&quot; /&gt;radio2&lt;br/&gt;多选：&lt;input name=&quot;checkbox&quot; type=&quot;checkbox&quot; value=&quot;checkbox1&quot; /&gt;checkbox1&lt;input name=&quot;checkbox&quot; type=&quot;checkbox&quot; value=&quot;checkbox2&quot; /&gt;checkbox2&lt;input name=&quot;checkbox&quot; type=&quot;checkbox&quot; value=&quot;checkbox3&quot; /&gt;checkbox3&lt;br/&gt;下拉多选 ：&lt;select id=&quot;multiple&quot; multiple=&quot;multiple&quot; size=&quot;4&quot;&gt; &lt;option value=&quot;mul1&quot;&gt;mul1&lt;/option&gt; &lt;option value=&quot;mul2&quot;&gt;mul2&lt;/option&gt; &lt;option value=&quot;mul3&quot;&gt;mul3&lt;/option&gt; &lt;option value=&quot;mul4&quot;&gt;mul4&lt;/option&gt;&lt;/select&gt;&lt;br/&gt;下拉单选 ：&lt;select id=&quot;single&quot;&gt; &lt;option value=&quot;sin1&quot;&gt;sin1&lt;/option&gt; &lt;option value=&quot;sin2&quot;&gt;sin2&lt;/option&gt; &lt;option value=&quot;sin3&quot;&gt;sin3&lt;/option&gt;&lt;/select&gt;&lt;/body&gt;&lt;/body&gt;&lt;/html&gt; jQuery练习（全选全不选）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; //给全选绑定单击事件 $(&quot;#checkedAllBtn&quot;).click(function()&#123; $(&quot;:checkbox&quot;).prop(&quot;checked&quot;,true);//这个地方checked的属性值是true，且属性名checked也要加双引号 &#125;); //给全不选绑定单击事件 $(&quot;#checkedNoBtn&quot;).click(function()&#123; $(&quot;:checkbox&quot;).prop(&quot;checked&quot;,false); &#125;); //给反选绑定单击事件 $(&quot;#checkedRevBtn&quot;).click(function()&#123; //查询全部球类的复选框 $(&quot;:checkbox[name=&#x27;items&#x27;]&quot;).each(function()&#123; //each方法中这个this就是每一个dom对象，也就是jQuery数组中的一个元素 this.checked=!this.checked; &#125;); //要检查是否满选 //获取球类运动总数 var length=$(&quot;:checkbox[name=&#x27;items&#x27;]&quot;).length; //获取被选中的球类运动总数 var length2=$(&quot;:checkbox[name=&#x27;items&#x27;]:checked&quot;).length; //比较,两种 /* if(length==length2)&#123; $(&quot;#checkedAllBox&quot;).prop(&quot;checked&quot;,true); &#125;*/ $(&quot;#checkedAllBox&quot;).prop(&quot;checked&quot;,length==length2); &#125;); //给提交按钮绑定事件 $(&quot;#sendBtn&quot;).click(function()&#123; $(&quot;:checkbox[name=&#x27;items&#x27;]:checked&quot;).each(function()&#123; alert(this.value); &#125;); &#125;);//给全选或者全不选那个框框榜单机事件$(&quot;#checkedAllBox&quot;).click(function()&#123;//再事件的function函数中，有一个this对象，这个this对象是当前正在响应事件的dom对象$(&quot;:checkbox[name=&#x27;items&#x27;]&quot;).prop(&quot;checked&quot;,this.checked);&#125;);//给全部球类绑定单击事件,让所有框被选上之后也可以让全选框被选$(&quot;[name=items]&quot;).click(function()&#123; var length=$(&quot;:checkbox[name=&#x27;items&#x27;]&quot;).length; //获取被选中的球类运动总数 var length2=$(&quot;:checkbox[name=&#x27;items&#x27;]:checked&quot;).length; $(&quot;#checkedAllBox&quot;).prop(&quot;checked&quot;,length==length2); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form method=&quot;post&quot; action=&quot;&quot;&gt; 你爱好的运动是？&lt;input type=&quot;checkbox&quot; id=&quot;checkedAllBox&quot; /&gt;全选/全不选 &lt;br /&gt; &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;足球&quot; /&gt;足球 &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;篮球&quot; /&gt;篮球 &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;羽毛球&quot; /&gt;羽毛球 &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;乒乓球&quot; /&gt;乒乓球 &lt;br /&gt; &lt;input type=&quot;button&quot; id=&quot;checkedAllBtn&quot; value=&quot;全 选&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;checkedNoBtn&quot; value=&quot;全不选&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;checkedRevBtn&quot; value=&quot;反 选&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;sendBtn&quot; value=&quot;提 交&quot; /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; jQuery 对标签的增删改内部插入 用jQuery对象的方法来操作标签的增删改 appendTo a.appendTo(b) 把a插入到b子元素末尾，成为最后一个子元素 prependTo() a.prependTo(b) 把a插入到b所有子元素之前，成为第一个子元素 外部插入 insertAfter() a.insertAfter(b) 得到ba insertBefore() a.insertBefore(b) 得到ab 替换 replaceWith() a.replaceWith(b) 用b替换掉a replaceAll() a.replaceAll(b) 用a替换掉所有b 删除 remove() a.remove(); 删除a标签 empty() a.empty(); 清空标签里的内容 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh_CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;//$(&quot;&lt;h1&gt;标题&lt;/h1&gt;&quot;).appendTo(&quot;div&quot;);//$(&quot;&lt;h1&gt;标题&lt;/h1&gt;&quot;).prependTo(&quot;div&quot;);//$(&quot;&lt;h1&gt;标题&lt;/h1&gt;&quot;).insertAfter(&quot;div&quot;);//$(&quot;&lt;h1&gt;标题&lt;/h1&gt;&quot;).insertBefore($(&quot;div&quot;));//$(&quot;&lt;h1&gt;标题&lt;/h1&gt;&quot;).replaceWith(&quot;div&quot;);//$(&quot;div&quot;).replaceWith(&quot;&lt;h1&gt;标题&lt;/h1&gt;&quot;);//$(&quot;&lt;h1&gt;标题&lt;/h1&gt;&quot;).replaceAll&quot;div&quot;);//$(&quot;div&quot;).remove();//$(&quot;div&quot;).empty(); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;1234&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; jQuery练习从左到右从右到左 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; select &#123; width: 100px; height: 140px; &#125; div &#123; width: 130px; float: left; text-align: center; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; //实现左边的可以添加到右边 $(function()&#123; $(&quot;button:first&quot;).click(function()&#123;//这个就是叫先找标签select的第一个然后找他后代的所有option中被选中的 $(&quot;select:eq(0) option:selected&quot;).appendTo($(&quot;select:eq(1)&quot;)); &#125;); //实现将左边的全部添加到右边 $(&quot;button:eq(1)&quot;).click(function()&#123; $(&quot;select:eq(0) option&quot;).appendTo($(&quot;select:eq(1)&quot;)); &#125;); //将右边的添加到左边 $(&quot;button:eq(2)&quot;).click(function()&#123;//这个就是叫先找标签select的第一个然后找他后代的所有option中被选中的 $(&quot;select:eq(1) option:selected&quot;).appendTo($(&quot;select:eq(0)&quot;)); &#125;); //将右边的全部添加到左边 $(&quot;button:eq(3)&quot;).click(function()&#123; $(&quot;select:eq(1) option&quot;).appendTo($(&quot;select:eq(0)&quot;)); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;left&quot;&gt; &lt;select multiple=&quot;multiple&quot; name=&quot;sel01&quot;&gt; &lt;option value=&quot;opt01&quot;&gt;选项1&lt;/option&gt; &lt;option value=&quot;opt02&quot;&gt;选项2&lt;/option&gt; &lt;option value=&quot;opt03&quot;&gt;选项3&lt;/option&gt; &lt;option value=&quot;opt04&quot;&gt;选项4&lt;/option&gt; &lt;option value=&quot;opt05&quot;&gt;选项5&lt;/option&gt; &lt;option value=&quot;opt06&quot;&gt;选项6&lt;/option&gt; &lt;option value=&quot;opt07&quot;&gt;选项7&lt;/option&gt; &lt;option value=&quot;opt08&quot;&gt;选项8&lt;/option&gt; &lt;/select&gt; &lt;button&gt;选中添加到右边&lt;/button&gt; &lt;button&gt;全部添加到右边&lt;/button&gt; &lt;/div&gt; &lt;div id=&quot;rigth&quot;&gt; &lt;select multiple=&quot;multiple&quot; name=&quot;sel02&quot;&gt; &lt;/select&gt; &lt;button&gt;选中删除到左边&lt;/button&gt; &lt;button&gt;全部删除到左边&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; jQuery练习，删除添加记录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Untitled Document&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styleB/css.css&quot; /&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; $(&quot;#addEmpButton&quot;).click(function()&#123; //获取输入框的内容 var name=$(&quot;#empName&quot;).val(); var email=$(&quot;#email&quot;).val(); var salary=$(&quot;#salary&quot;).val(); //创建一个行标签对象，添加到显示数据的表格中 var $tobr=$(&quot;&lt;tr&gt;&quot;+ &quot;&lt;td&gt;&quot;+name+&quot;&lt;/td&gt;&quot;+ &quot;&lt;td&gt;&quot;+email+&quot;&lt;/td&gt;&quot;+ &quot;&lt;td&gt;&quot;+salary+&quot;&lt;/td&gt;&quot;+ &quot;&lt;td&gt;&lt;a href=\\&quot;deleteEmp?id=002\\&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt;&quot;+ &quot;&lt;/tr&gt;&quot;); //添加到显示数据的表格中 $tobr.appendTo($(&quot;#employeeTable&quot;)); //这里是每次添加新的信息之后，给他绑定删除事件，防止新添加的这些无法删除 $tobr.find(&quot;a&quot;).click(function()&#123; //在事件响应function的时候会有一个this对象，这个this对象是当前正在响应事件的dom对象 //得到a标签对象的父亲的父亲 var $tbr=$(this).parent().parent(); //获取第一个td标签的内容 var name=$tbr.find(&quot;td:first&quot;).text(); //confirm是js提供的一个确认提示框，你给他传什么它就提示什么，用户点击确定就返回true，点击取消就返回false if(confirm(&quot;你确定要删除&quot;+name+&quot;么&quot;))&#123; $tbr.remove(); &#125; //return false; 可以阻止，元素的默认行为 return false;//可以点击标签时不跳转 &#125;); &#125;); //给删除a标签绑定单机事件 $(&quot;a&quot;).click(function()&#123; //在事件响应function的时候会有一个this对象，这个this对象是当前正在响应事件的dom对象 //得到a标签对象的父亲的父亲 var $tbr=$(this).parent().parent(); //获取第一个td标签的内容 var name=$tbr.find(&quot;td:first&quot;).text(); //confirm是js提供的一个确认提示框，你给他传什么它就提示什么，用户点击确定就返回true，点击取消就返回false if(confirm(&quot;你确定要删除&quot;+name+&quot;么&quot;))&#123; $tbr.remove(); &#125; //return false; 可以阻止，元素的默认行为 return false;//可以点击标签时不跳转 &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;table id=&quot;employeeTable&quot;&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Email&lt;/th&gt; &lt;th&gt;Salary&lt;/th&gt; &lt;th&gt;&amp;nbsp;&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Tom&lt;/td&gt; &lt;td&gt;tom@tom.com&lt;/td&gt; &lt;td&gt;5000&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteEmp?id=001&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Jerry&lt;/td&gt; &lt;td&gt;jerry@sohu.com&lt;/td&gt; &lt;td&gt;8000&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteEmp?id=002&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Bob&lt;/td&gt; &lt;td&gt;bob@tom.com&lt;/td&gt; &lt;td&gt;10000&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteEmp?id=003&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div id=&quot;formDiv&quot;&gt; &lt;h4&gt;添加新员工&lt;/h4&gt; &lt;table&gt; &lt;tr&gt; &lt;td class=&quot;word&quot;&gt;name: &lt;/td&gt; &lt;td class=&quot;inp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;empName&quot; id=&quot;empName&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;word&quot;&gt;email: &lt;/td&gt; &lt;td class=&quot;inp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot; id=&quot;email&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;word&quot;&gt;salary: &lt;/td&gt; &lt;td class=&quot;inp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;salary&quot; id=&quot;salary&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt; &lt;button id=&quot;addEmpButton&quot; value=&quot;abc&quot;&gt; Submit &lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 优化后，封装函数复用的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Untitled Document&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styleB/css.css&quot; /&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; var deleteFun=function()&#123; //在事件响应function的时候会有一个this对象，这个this对象是当前正在响应事件的dom对象 //得到a标签对象的父亲的父亲 var $tbr=$(this).parent().parent(); //获取第一个td标签的内容 var name=$tbr.find(&quot;td:first&quot;).text(); //confirm是js提供的一个确认提示框，你给他传什么它就提示什么，用户点击确定就返回true，点击取消就返回false if(confirm(&quot;你确定要删除&quot;+name+&quot;么&quot;))&#123; $tbr.remove(); &#125; //return false; 可以阻止，元素的默认行为 return false;//可以点击标签时不跳转 &#125;; $(&quot;#addEmpButton&quot;).click(function()&#123; //获取输入框的内容 var name=$(&quot;#empName&quot;).val(); var email=$(&quot;#email&quot;).val(); var salary=$(&quot;#salary&quot;).val(); //创建一个行标签对象，添加到显示数据的表格中 var $tobr=$(&quot;&lt;tr&gt;&quot;+ &quot;&lt;td&gt;&quot;+name+&quot;&lt;/td&gt;&quot;+ &quot;&lt;td&gt;&quot;+email+&quot;&lt;/td&gt;&quot;+ &quot;&lt;td&gt;&quot;+salary+&quot;&lt;/td&gt;&quot;+ &quot;&lt;td&gt;&lt;a href=\\&quot;deleteEmp?id=002\\&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt;&quot;+ &quot;&lt;/tr&gt;&quot;); //添加到显示数据的表格中 $tobr.appendTo($(&quot;#employeeTable&quot;)); //这里是每次添加新的信息之后，给他绑定删除事件，防止新添加的这些无法删除 $tobr.find(&quot;a&quot;).click(deleteFun);&#125;); //给删除a标签绑定单机事件 $(&quot;a&quot;).click(deleteFun); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;table id=&quot;employeeTable&quot;&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Email&lt;/th&gt; &lt;th&gt;Salary&lt;/th&gt; &lt;th&gt;&amp;nbsp;&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Tom&lt;/td&gt; &lt;td&gt;tom@tom.com&lt;/td&gt; &lt;td&gt;5000&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteEmp?id=001&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Jerry&lt;/td&gt; &lt;td&gt;jerry@sohu.com&lt;/td&gt; &lt;td&gt;8000&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteEmp?id=002&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Bob&lt;/td&gt; &lt;td&gt;bob@tom.com&lt;/td&gt; &lt;td&gt;10000&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteEmp?id=003&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div id=&quot;formDiv&quot;&gt; &lt;h4&gt;添加新员工&lt;/h4&gt; &lt;table&gt; &lt;tr&gt; &lt;td class=&quot;word&quot;&gt;name: &lt;/td&gt; &lt;td class=&quot;inp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;empName&quot; id=&quot;empName&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;word&quot;&gt;email: &lt;/td&gt; &lt;td class=&quot;inp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot; id=&quot;email&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;word&quot;&gt;salary: &lt;/td&gt; &lt;td class=&quot;inp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;salary&quot; id=&quot;salary&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt; &lt;button id=&quot;addEmpButton&quot; value=&quot;abc&quot;&gt; Submit &lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; jQuery中css样式操作addClass() 添加样式 removeClass() 删除样式 toggleClass() 有就删除，没有就添加样式 offset() 获取和设置元素的坐标，下面是这个的样例显示 top: 10.777777671813965, left: 118.55555725097656} 这两个参数top是符合条件的标签到浏览器顶上的距离，left是到左边框距离 123div.whiteborder&#123; border: 2px white solid;&#125; 这个div是指这个样式只能给div这个标签使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt; div&#123; width:100px; height:260px; &#125; div.whiteborder&#123; border: 2px white solid; &#125; div.redDiv&#123; background-color: red; &#125; div.blueBorder&#123; border: 5px blue solid; &#125; &lt;/style&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; var $divEle = $(&#x27;div:first&#x27;); $(&#x27;#btn01&#x27;).click(function()&#123; //addClass() - 向被选元素添加一个或多个类 $divEle.addClass(&quot;redDiv blueBorder&quot;); &#125;); $(&#x27;#btn02&#x27;).click(function()&#123; //removeClass() - 从被选元素删除一个或多个类 $divEle.removeClass(&quot;redDiv blueBorder&quot;); //$divEle.removeClass();全部删除 &#125;); $(&#x27;#btn03&#x27;).click(function()&#123; //toggleClass() - 对被选元素进行添加/删除类的切换操作 $divEle.toggleClass(&#x27;redDiv&#x27;); &#125;); $(&#x27;#btn04&#x27;).click(function()&#123; //offset() - 返回第一个匹配元素相对于文档的位置。 var pos=$divEle.offset(); //得到top和left console.log(pos); //还可以自己设置top和left，不一定是自己输入的值，按照当前屏幕大小给的值 $divEle.offset(&#123; top:100, left:50 &#125;); &#125;); &#125;)&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;table align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td&gt; &lt;div class=&quot;border&quot;&gt; &lt;/div&gt; &lt;/td&gt; &lt;td&gt; &lt;div class=&quot;btn&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;addClass()&quot; id=&quot;btn01&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;removeClass()&quot; id=&quot;btn02&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;toggleClass()&quot; id=&quot;btn03&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;offset()&quot; id=&quot;btn04&quot;/&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;/body&gt;&lt;/html&gt; jQuery动画基本动画 show() 将隐藏的元素显示 hide() 将可见的元素隐藏 toggle() 可见就隐藏，不可见就显示 以上动画方法都可以添加参数 这七个函数的参数都是这俩，只有fadeTo是不一样的，因为fadeTo多一个透明度的参数 ​ 1.第一个参数是动画执行的时常，以毫秒为单位 ​ 2.第二个参数是动画的回调函数（动画完成后自动调用的函数） 淡入淡出动画 fadeln() 淡入 慢慢可见 fadeOut() 淡出 慢慢消失 fadeTo() 在指定时常内慢慢的将透明度修改到指定的值 0透明 0.5半透明 1不透明 fadeToggle() 淡入淡出切换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;link href=&quot;css/style.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; /* 基本 show([speed,[easing],[fn]]) hide([speed,[easing],[fn]]) toggle([speed],[easing],[fn]) 滑动 slideDown([spe],[eas],[fn]) slideUp([speed,[easing],[fn]]) slideToggle([speed],[easing],[fn]) 淡入淡出 fadeIn([speed],[eas],[fn]) fadeOut([speed],[eas],[fn]) fadeTo([[spe],opa,[eas],[fn]]) fadeToggle([speed,[eas],[fn]]) */ $(function()&#123; //显示 show() $(&quot;#btn1&quot;).click(function()&#123; $(&quot;#div1&quot;).show(1000,function()&#123; alert(&quot;show动画完成&quot;) &#125;); &#125;); //隐藏 hide() $(&quot;#btn2&quot;).click(function()&#123; $(&quot;#div1&quot;).hide(1000,function()&#123; alert(&quot;hide动画执行完成&quot;) &#125;); &#125;); //切换 toggle() $(&quot;#btn3&quot;).click(function()&#123; $(&quot;#div1&quot;).toggle(1000,function()&#123; alert(&quot;toggle动画执行完成&quot;) &#125;); &#125;); //动画的演示方式，就是不断的调用他自己 /*var abc=function()&#123; $(&quot;#div1&quot;).toggle(1000,abc); &#125; abc();*/ //淡入 fadeIn() $(&quot;#btn4&quot;).click(function()&#123; $(&#x27;#div1&#x27;).fadeIn(2000,function()&#123; alert(&quot;淡入完成&quot;); &#125;); &#125;); //淡出 fadeOut() $(&quot;#btn5&quot;).click(function()&#123; $(&#x27;#div1&#x27;).fadeOut(2000,function()&#123; alert(&quot;淡出完成&quot;); &#125;); &#125;); //淡化到 fadeTo() $(&quot;#btn6&quot;).click(function()&#123; $(&quot;#div1&quot;).fadeTo(2000,0.5,function()&#123; alert(&quot;fadeTo完成&quot;); &#125;); &#125;); //淡化切换 fadeToggle() $(&quot;#btn7&quot;).click(function()&#123; $(&#x27;#div1&#x27;).fadeToggle(2000,function()&#123; alert(&quot;切换完成&quot;); &#125;); &#125;); &#125;)&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;table style=&quot;float: left;&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;button id=&quot;btn1&quot;&gt;显示show()&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button id=&quot;btn2&quot;&gt;隐藏hide()&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button id=&quot;btn3&quot;&gt;显示/隐藏切换 toggle()&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button id=&quot;btn4&quot;&gt;淡入fadeIn()&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button id=&quot;btn5&quot;&gt;淡出fadeOut()&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button id=&quot;btn6&quot;&gt;淡化到fadeTo()&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button id=&quot;btn7&quot;&gt;淡化切换fadeToggle()&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div id=&quot;div1&quot; style=&quot;float:left;border: 1px solid;background-color: blue;width: 300px;height: 200px;&quot;&gt; jquery动画定义了很多种动画效果，可以很方便的使用这些动画效果 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; jQuery动画练习1234.showmore a span &#123; padding-left: 15px; background: url(img/down.gif) no-repeat 0 0;&#125; 这个css选择器的意思是 类选择器 且用这个选择器的标签子代必须有一个a，a的子代必须有一个span 添加cssclass样式的时候既可以用prop也可以用addClass 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;品牌展示练习&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;* &#123; margin: 0; padding: 0;&#125;body &#123; font-size: 12px; text-align: center;&#125;a &#123; color: #04D; text-decoration: none;&#125;a:hover &#123; color: #F50; text-decoration: underline;&#125;.SubCategoryBox &#123; width: 600px; margin: 0 auto; text-align: center; margin-top: 40px;&#125;.SubCategoryBox ul &#123; list-style: none;&#125;.SubCategoryBox ul li &#123; display: block; float: left; width: 200px; line-height: 20px;&#125;.showmore , .showless&#123; clear: both; text-align: center; padding-top: 10px;&#125;.showmore a , .showless a&#123; display: block; width: 120px; margin: 0 auto; line-height: 24px; border: 1px solid #AAA;&#125;.showmore a span &#123; padding-left: 15px; background: url(img/down.gif) no-repeat 0 0;&#125;.showless a span &#123; padding-left: 15px; background: url(img/up.gif) no-repeat 0 0;&#125;.promoted a &#123; color: #F50;&#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function() &#123; //基本初始状态$(&quot;li:gt(5):not(:last)&quot;).hide();//hide是动画操作//给功能的按钮绑定单击事件$(&quot;div div a&quot;).click(function()&#123;$(&quot;li:gt(5):not(:last)&quot;).toggle();//切换回显示//按钮上的文本，1.显示全部品牌，角标向下，文字显示全部品牌if( $(&quot;li:gt(5):not(:last)&quot;).is(&quot;:hidden&quot;))&#123;$(&quot;div div a span&quot;).text(&quot;显示全部品牌&quot;);$(&quot;div div&quot;).removeClass();$(&quot;div div&quot;).addClass(&quot;showmore&quot;);//$(&quot;div div&quot;).prop(&quot;class&quot;,&quot;showmore&quot;);,添加自己定义的css类的时候也可以用prop//高亮取消$(&quot;li:contains(&#x27;索尼&#x27;)&quot;).removeClass(&quot;promoted&quot;);&#125;else&#123;//显示精简品牌，角标向上，且文字是显示精简品牌$(&quot;div div a span&quot;).text(&quot;显示精简品牌&quot;);$(&quot;div div&quot;).removeClass();$(&quot;div div&quot;).addClass(&quot;showless&quot;);//$(&quot;div div&quot;).prop(&quot;class&quot;,&quot;showless&quot;);//高亮取消$(&quot;li:contains(&#x27;索尼&#x27;)&quot;).addClass(&quot;promoted&quot;);&#125;return false;&#125;); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;SubCategoryBox&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;佳能&lt;/a&gt;&lt;i&gt;(30440) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;索尼&lt;/a&gt;&lt;i&gt;(27220) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;三星&lt;/a&gt;&lt;i&gt;(20808) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;尼康&lt;/a&gt;&lt;i&gt;(17821) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;松下&lt;/a&gt;&lt;i&gt;(12289) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;卡西欧&lt;/a&gt;&lt;i&gt;(8242) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;富士&lt;/a&gt;&lt;i&gt;(14894) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;柯达&lt;/a&gt;&lt;i&gt;(9520) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;宾得&lt;/a&gt;&lt;i&gt;(2195) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;理光&lt;/a&gt;&lt;i&gt;(4114) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;奥林巴斯&lt;/a&gt;&lt;i&gt;(12205) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;明基&lt;/a&gt;&lt;i&gt;(1466) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;爱国者&lt;/a&gt;&lt;i&gt;(3091) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;其它品牌相机&lt;/a&gt;&lt;i&gt;(7275) &lt;/i&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;showmore&quot;&gt; &lt;a href=&quot;more.html&quot;&gt;&lt;span&gt;显示全部品牌&lt;/span&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 原生js和jQuery页面加载完成之后的区别$( function(){} ); 和 window.onload &#x3D; function(){} 的区别？ 他们分别是在什么时候触发？ 1、jQuery 的页面加载完成之后是浏览器的内核解析完页面的标签创建好 DOM 对象之后就会马上执行。 2、原生 js 的页面加载完成之后，除了要等浏览器内核解析完标签创建好 DOM 对象，还要等标签显示时需要的内容加载 完成。 他们触发的顺序？ 1、jQuery 页面加载完成之后先执行 2、原生 js 的页面加载完成之后 他们执行的次数？ 1、原生 js 的页面加载完成之后，只会执行最后一次的赋值函数。 2、jQuery 的页面加载完成之后是全部把注册的 function 函数，依次顺序全部执行 jQuery中常用的事件处理方法click() 可以绑定单击事件，以及触发单击事件 mouseover() 鼠标移入事件 mouseout() 鼠标移出事件 bind() 可以给元素一次性绑定一个或多个事件 one() 使用上和bind一样，但是one方法绑定的事件只会触发一次 unbind () 和bind方法相反的操作，解除事件的绑定 live() 也是用来绑定事件的，可以用来绑定选择器匹配的所有元素的事件，哪怕这个元素是后面动态创建出来的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;link href=&quot;css/style.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; //1.通常绑定事件的方式 //3.合并“鼠标移入”和“鼠标移出”事件 //4.合并单击事件 //5.切换元素可见状态 //6.只绑定一次 // 触发事件的讲解 $(&quot;h5&quot;).click(function()&#123;//传function是绑定事件 alert(&quot;h5单击事件&quot;); &#125;); /*$(&quot;button&quot;).click(function()&#123; $(&quot;h5&quot;).click();//不传function是触发事件，就是调用了h5的绑定事件 &#125;);*/ //鼠标移入事件 /*$(&quot;h5&quot;).mouseover(function()&#123; console.log(&quot;你进来了&quot;); &#125;);*/ //鼠标移除事件 /*$(&quot;h5&quot;).mouseout(function()&#123; console.log(&quot;你出来了&quot;); &#125;);*/ //jQuery提供的绑定方式：bind()函数 /*$(&quot;h5&quot;).bind(&quot;click mouseover mouseout&quot;,function()&#123; console.log(&quot;这是bind绑定的事件&quot;); &#125;);*/ //one()函数 /* $(&quot;h5&quot;).one(&quot;click mouseover mouseout&quot;,function()&#123; console.log(&quot;这是one绑定的事件&quot;); &#125;);*/ //unbind()函数,不加参数就全删了 /*$(&quot;h5&quot;).unbind(&quot;click mouseover&quot;);*/ //live()函数 //正常的绑定函数就是只有一开始那个被绑定的标签有效果，现在后来添加的标签依然是有效果的 $(&quot;h5&quot;).live(&quot;click&quot;,function()&#123; alert(&#x27;h5单击事件==live方法绑定&#x27;); &#125;); $(&#x27;&lt;h5 class=&quot;head&quot;&gt;什么是jQuery?&lt;/h5&gt;&#x27;).appendTo($(&quot;#panel&quot;)); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;panel&quot;&gt; &lt;h5 class=&quot;head&quot;&gt;什么是jQuery?&lt;/h5&gt; &lt;div class=&quot;content&quot;&gt; jQuery是继Prototype之后又一个优秀的JavaScript库，它是一个由 John Resig 创建于2006年1月的开源项目。jQuery凭借简洁的语法和跨平台的兼容性，极大地简化了JavaScript开发人员遍历HTML文档、操作DOM、处理事件、执行动画和开发Ajax。它独特而又优雅的代码风格改变了JavaScript程序员的设计思路和编写程序的方式。 &lt;/div&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; jQuery事件的冒泡事件冒泡是指父子元素同时监听一个事件，当触发子元素事件的时候，同一个事件也被传递到了父元素的事件里去响应 在子元素事件函数体内，return false 可以阻止事件的冒泡传递 简单来说就是，如果父子元素绑定同一个事件，子元素的事件被触发的时候，父元素的这个事件也会被触发 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0; padding: 0; &#125; body&#123; font-size: 13px; line-height: 130%; padding: 60px; &#125; #content&#123; width: 220px; border: 1px solid #0050D0; background: #96E555; &#125; span&#123; width: 200px; margin: 10px; background: #666666; cursor: pointer; color: white; display: block; &#125; p&#123; width: 200px; background: #888; color: white; height: 16px; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; $(&quot;#content&quot;).click(function()&#123; alert(&quot;这是div&quot;); &#125;); $(&quot;span&quot;).click(function()&#123; alert(&quot;这是span&quot;); //return false; &#125;); &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;content&quot;&gt; 外层div元素 &lt;span&gt;内层span元素&lt;/span&gt; 外层div元素 &lt;/div&gt; &lt;div id=&quot;msg&quot;&gt;&lt;/div&gt; &lt;br&gt;&lt;br&gt; &lt;a href=&quot;http://www.hao123.com&quot;&gt;WWW.HAO123.COM&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; jQuery事件对象事件对象，是封装有触发的事件信息的一个javascript对象 我们重点关心的是怎么拿到这个javasccript的事件对象 再给元素绑定事件的时候，在事件的function参数列表中添加一个参数，这个event就是javasccript传递参事件处理函数的事件对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt; #areaDiv &#123; border: 1px solid black; width: 300px; height: 50px; margin-bottom: 10px; &#125; #showMsg &#123; border: 1px solid black; width: 300px; height: 20px; &#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; //1.原生javascript获取 事件对象 /*window.onload=function()&#123; document.getElementById(&quot;areaDiv&quot;).onclick=function(event)&#123; console.log(event); &#125; &#125;;*/ //2.JQuery代码获取 事件对象 /*$(function()&#123; $(&quot;#areaDiv&quot;).click(function(event)&#123; console.log(event); &#125;); &#125;);*/ //3.使用bind同时对多个事件绑定同一个函数。怎么获取当前操作是什么事件。 //这个操作可以让bind绑定的多个事件做不一样的事情 $(function()&#123; $(&quot;#areaDiv&quot;).bind(&quot;mouseout mouseover&quot;,function(event)&#123; if(event.type==&quot;mouseover&quot;)&#123; console.log(&quot;鼠标移入&quot;); &#125; else if(event.type==&quot;mouseout&quot;) &#123; console.log(&quot;鼠标移出&quot;); &#125; &#125;); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;areaDiv&quot;&gt;&lt;/div&gt; &lt;div id=&quot;showMsg&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; jQuery练习，图片跟随123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt; body &#123; text-align: center; &#125; #small &#123; margin-top: 150px; &#125; #showBig &#123; position: absolute; display: none; &#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; $(&quot;#small&quot;).bind(&quot;mouseover mouseout mousemove&quot;,function(event)&#123; if(event.type==&quot;mouseover&quot;)&#123; $(&quot;#showBig&quot;).show(); &#125; else if(event.type==&quot;mouseout&quot;)&#123; $(&quot;#showBig&quot;).hide(); &#125; else if(event.type==&quot;mousemove&quot;)&#123; $(&quot;#showBig&quot;).offset(&#123; left:event.pageX+10, top:event.pageY+10 &#125;); &#125; &#125;); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;img id=&quot;small&quot; src=&quot;img/small.jpg&quot; /&gt; &lt;div id=&quot;showBig&quot;&gt; &lt;img src=&quot;img/big.jpg&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 书城项目的第一个阶段表单验证规定了注册时用户名密码的格式，以及错误提示等等， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;尚硅谷会员注册页面&lt;/title&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;../../static/css/style.css&quot; &gt; &lt;script src=&quot;../../static/script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; //1.验证用户名，必须由数字字母下划线组成，并且长度为5到12位 $(&quot;#sub_btn&quot;).click(function()&#123; //1.获取用户名输入框中的内容 var username=$(&quot;#username&quot;).val(); //2.创建正则表达式对象 var pattern=/^\\w&#123;5,12&#125;$/; //3.使用test方法进行验证 if(!pattern.test(username))&#123; $(&quot;span.errorMsg&quot;).text(&quot;用户名不合法&quot;); //有了return false不会跳转 return false; &#125;//2.验证密码 //1.获取用户名输入框中的内容 var password=$(&quot;#password&quot;).val(); //2.创建正则表达式对象 var pspattern=/^\\w&#123;5,12&#125;$/; //3.使用test方法进行验证 if(!pspattern.test(password))&#123; $(&quot;span.errorMsg&quot;).text(&quot;密码不合法&quot;); //有了return false不会跳转 return false; &#125;//3.确认密码 //1.获取确认密码内容 var repassword =$(&quot;#repwd&quot;).val(); if(repassword!=password)&#123; $(&quot;span.errorMsg&quot;).text(&quot;确认密码与密码不一致&quot;); return false; &#125;//4.验证邮箱 //1.获取邮箱当中的内容 var emailText=$(&quot;#email&quot;).val(); var emailpt=/^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]&#123;2,6&#125;)$/; if(!emailpt.test(emailText))&#123; $(&quot;span.errorMsg&quot;).text(&quot;邮箱格式不合法&quot;); return false; &#125;//5.验证码，验证由输入内容即可 var codeText=$(&quot;#code&quot;).val(); //去掉验证码前后空格 codeText=$.trim(codeText); if(codeText==null||codeText==&quot;&quot;)&#123; $(&quot;span.errorMsg&quot;).text(&quot;无验证码&quot;); return false; &#125; $(&quot;span.errorMsg&quot;).text(&quot;&quot;);//如果用户名密码邮箱又合法了再给他改过来&#125;); &#125;); &lt;/script&gt;&lt;style type=&quot;text/css&quot;&gt; .login_form&#123; height:420px; margin-top: 25px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;login_header&quot;&gt; &lt;img class=&quot;logo_img&quot; alt=&quot;&quot; src=&quot;../../static/img/logo.gif&quot; &gt; &lt;/div&gt; &lt;div class=&quot;login_banner&quot;&gt; &lt;div id=&quot;l_content&quot;&gt; &lt;span class=&quot;login_word&quot;&gt;欢迎注册&lt;/span&gt; &lt;/div&gt; &lt;div id=&quot;content&quot;&gt; &lt;div class=&quot;login_form&quot;&gt; &lt;div class=&quot;login_box&quot;&gt; &lt;div class=&quot;tit&quot;&gt; &lt;h1&gt;注册尚硅谷会员&lt;/h1&gt; &lt;span class=&quot;errorMsg&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;form&quot;&gt; &lt;form action=&quot;regist_success.html&quot;&gt; &lt;label&gt;用户名称：&lt;/label&gt; &lt;input class=&quot;itxt&quot; type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; autocomplete=&quot;off&quot; tabindex=&quot;1&quot; name=&quot;username&quot; id=&quot;username&quot; /&gt; &lt;br /&gt; &lt;br /&gt; &lt;label&gt;用户密码：&lt;/label&gt; &lt;input class=&quot;itxt&quot; type=&quot;password&quot; placeholder=&quot;请输入密码&quot; autocomplete=&quot;off&quot; tabindex=&quot;1&quot; name=&quot;password&quot; id=&quot;password&quot; /&gt; &lt;br /&gt; &lt;br /&gt; &lt;label&gt;确认密码：&lt;/label&gt; &lt;input class=&quot;itxt&quot; type=&quot;password&quot; placeholder=&quot;确认密码&quot; autocomplete=&quot;off&quot; tabindex=&quot;1&quot; name=&quot;repwd&quot; id=&quot;repwd&quot; /&gt; &lt;br /&gt; &lt;br /&gt; &lt;label&gt;电子邮件：&lt;/label&gt; &lt;input class=&quot;itxt&quot; type=&quot;text&quot; placeholder=&quot;请输入邮箱地址&quot; autocomplete=&quot;off&quot; tabindex=&quot;1&quot; name=&quot;email&quot; id=&quot;email&quot; /&gt; &lt;br /&gt; &lt;br /&gt; &lt;label&gt;验证码：&lt;/label&gt; &lt;input class=&quot;itxt&quot; type=&quot;text&quot; style=&quot;width: 150px;&quot; id=&quot;code&quot;/&gt; &lt;img alt=&quot;&quot; src=&quot;../../static/img/code.bmp&quot; style=&quot;float: right; margin-right: 40px&quot;&gt; &lt;br /&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot; id=&quot;sub_btn&quot; /&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;bottom&quot;&gt; &lt;span&gt; 尚硅谷书城.Copyright &amp;copy;2015 &lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; XML什么是XML？ xml是可扩展性标记性语言 XML的作用 ​ 1.用来保存数据，而且这些数据具有自我描述性 ​ 2.它还可以做为项目或者模块的配置文件 ​ 3.还可以作为网络传输数据的格式(JSON为主) 示例 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;以上内容就是xml文件的声明version=&quot;1.0&quot; encoding=&quot;utf-8&quot; version表示xml的版本 encoding表示xml文件本身的编码--&gt;&lt;books&gt; &lt;book sb=&quot;SN123412123412&quot;&gt;&lt;!--book表示一个图书信息 sn属性表示图书序列号--&gt; &lt;name&gt;时间监视&lt;/name&gt;&lt;!--name标签表示书名--&gt; &lt;author&gt;霍金&lt;/author&gt;&lt;!--author表示作者--&gt; &lt;price&gt;75&lt;/price&gt;&lt;!--price表示图书价格--&gt; &lt;/book&gt; &lt;book sb=&quot;SN123412123411&quot;&gt;&lt;!--book表示一个图书信息 sn属性表示图书序列号--&gt; &lt;name&gt;java入门&lt;/name&gt;&lt;!--name标签表示书名--&gt; &lt;author&gt;沙老师&lt;/author&gt;&lt;!--author表示作者--&gt; &lt;price&gt;9.9&lt;/price&gt;&lt;!--price表示图书价格--&gt; &lt;/book&gt;&lt;/books&gt; XML文件的写法 1-2 xml 发明的目的： 传输和 存储数据。 **xml 发明的*目的*： *传输和 存储数据。* xml 发明的目的： 传输和 存储数据。 **xml 发明的*目的*： *传输和 存储数据。* xml 不是为了展示数据， html 才是为了展示数据用的。 所有的xml 必须要有一个根节点： 这种写法是错误的 正确的写法： 浏览器展示 第二章： xml的 基本语法。 Xml的头声明， 可以有，也可以省略 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&quot;&quot;&quot;version参数是版本号&quot;&quot;&quot; encoding是编码&lt;!--&lt;a&gt;ddd &lt;b&gt;hh&lt;/a&gt;&lt;/b&gt;--&gt;&quot;&quot;&quot;这里是一个xml文件的一个注释&quot;&quot;&quot;&lt;root&gt; &lt;shuibian&gt;....&lt;/shuibian&gt; &lt;xie&gt;...&lt;/xie&gt;&lt;/root&gt; 标签交叉，在xml 是不允许的。 属性：就是描述这个标签额外的信息。 例子：比如img 标签，必须要有 src属性 。 Img 标签，本身的目的：就是个图片标签 。 Src 属性 的作用是： 告诉你要展示的图片 在哪里 属性规则： 但是在xml中，我们不需要额外的信息进行展示。 因为我们是自定义标签的 。 Html标签，必须要用到属性，因为我们不能自定义html标签。 Xml 中，属性就是鸡肋。 属性，在xml中可以用。但是用的真不多 CDATA的写法 展示效果： DTD简介 1.对xml文件的格式进行约束，保证xml是一个有效的xml 2.dtd可以分为两种，内部dtd(你在写xml代码的时候就把内部dtd写好了)，外部dtd(他是一个外部的单独的dtd文件，需要引入进来) 使用 内部的dtd的定义，语法如下： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--声明dtd--&gt;&lt;!DOCTYPE scores [&lt;!ELEMENT scores (student*)&gt;&lt;!--这里的星号表示出现任意次--&gt;&lt;!ELEMENT student (name,course,score)&gt;&lt;!ATTLIST student id CDATA #REQUIRED&gt;&lt;!ELEMENT name (#PCDATA)&gt;&lt;!ELEMENT score (#PCDATA)&gt;&lt;!ELEMENT course (#PCDATA)&gt;&lt;!--让name标签里面只能写文本而不能写其他的标签之类的--&gt;&lt;!--PCDATA 是会被解析器解析的文本。. 这些文本将被解析器检查实体以及标记。. 文本中的标签会被当作标记来处理，而实体会被展开。. 不过，被解析的字符数据不应当包含任何 &amp; &lt; &gt; 字符；需要使用 &amp; &lt; &gt; 实体来分别替换它们--&gt;&lt;!ENTITY jt &quot;Joe Test&quot;&gt;&lt;!--实例--&gt;&lt;!ENTITY % jtt &quot;Joe Test&quot;&gt;&lt;!--这相当于声明了一个对象，只能在dtd文件中使用,用的时候就是%jjt;--&gt;&lt;scores&gt; &lt;student id=&quot;1&quot;&gt; &lt;name&gt;王同&lt;/name&gt; &lt;course&gt;java&lt;/course&gt; &lt;score&gt;89&lt;/score&gt; &lt;/student&gt; &lt;student id=&quot;2&quot;&gt; &lt;name&gt;李佳&lt;/name&gt; &lt;course&gt;sql&lt;/course&gt; &lt;score&gt;58&lt;/score&gt; &lt;test&gt;&amp;jt;&lt;/test&gt; &lt;!--实例，这里的;不会显示--&gt; &lt;/student&gt;&lt;/scores&gt;]&gt;&lt;!--加入了dtd之后，写xml文件之后就有模板有提示了--&gt; 12345678910111213141516171819202122这就是&lt;!ATTLIST student id CDATA #REQUIRED&gt;条代码的解释基本语法：&lt;!ATTLIST 元素名称 属性名称 属性类型 默认值&gt;上面对id属性的限制的最后一个参数类型有#REQUIRED 表示属性值必须#IMPLIED 表示属性值不是必须的#FIXED value 属性值是固定的值 默认值上面对id属性的限制倒数第二个参数类型有CDATA 字符或数字(en1|en2|……) 枚举类型 ID 属性唯一IDREF 对某个唯一属性进行引用 123456789101112131415&lt;!ELEMENT 元素名称 类别&gt; 或&lt;!ELEMENT 元素名称 (元素内容)&gt;类别：约束标签的内容EMPTY：空标签(#PCDATA)：普通字符串（没有子标签）ANY ： 可以是任何内容（包含子标签）(元素内容)： 标签包含子标签的情况顺序问题：(A,B,C,D): 按顺序依次出现(A|B|C|D): 任意出现一个(枚举式出现) 数量词 + 表示出现一次或者多次，至少一次 ?表示出现0次或1次 *表示出现任意次 外部dtd 1.创建一个外部的dtd文件 这是一个文件的格式 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--声明dtd--&gt;&lt;!ELEMENT scores (student*)&gt;&lt;!--上面的空格是必须要有的--&gt;&lt;!--这里的星号表示出现任意次--&gt;&lt;!ELEMENT student (name,course,score)&gt;&lt;!ATTLIST student id CDATA #REQUIRED&gt;&lt;!ELEMENT name (#PCDATA)&gt;&lt;!ELEMENT score (#PCDATA)&gt;&lt;!ELEMENT course (#PCDATA)&gt; 2.在xml中引入一个外部的dtd文件 1&lt;!DPCTYPE scores SYSTEM “scores.dtd&quot;&gt; 这有的浏览器对其可能不支持 第二个是根标签，scores.dtd是一个要引入的文件，SYSTEM也是必要的 ENTITY的使用实例 关于ENTITY的讲解，在xxe漏洞当中介绍 XML解析技术介绍xml 可扩展的标记语言。 不管是 html 文件还是 xml 文件它们都是标记型文档，都可以使用 w3c 组织制定的 dom 技术来解析 document 对象表示的是整个文档（可以是 html 文档，也可以是 xml 文档） 使用dom4j读取xml文件得到document对象dom4j的使用直接看pdf 被用来解析的xml文件 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;books&gt; &lt;book sn=&quot;SN12341232&quot;&gt; &lt;name&gt;辟邪剑谱&lt;/name&gt; &lt;price&gt;9.9&lt;/price&gt; &lt;author&gt;班主任&lt;/author&gt; &lt;/book&gt; &lt;book sn=&quot;SN12341231&quot;&gt; &lt;name&gt;葵花宝典&lt;/name&gt; &lt;price&gt;99.99&lt;/price&gt; &lt;author&gt;班长&lt;/author&gt; &lt;/book&gt;&lt;/books&gt; 解析xml文件的代码 @Test是指一个测试方法，这个方法使用需要导包导关于junit4的包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import com.atguigu.pojo.Book;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;import org.junit.Test;import java.util.List;import static java.lang.Double.parseDouble;public class Dom4jTest &#123; @Test//是指这是一个测试方法，可以不用主方法来调用 public void test1() throws DocumentException &#123; //创建一个SaxReader输入流，去读取xml配置文件，生成Document对象 SAXReader saxReader=new SAXReader(); Document document = saxReader.read(&quot;src/books.xml&quot;); System.out.println(document); &#125; @Test public void test2() throws DocumentException &#123; //1.读取books.xml文件 SAXReader reader= new SAXReader(); // 2.通过Document对象获取根元素 //在Junit测试中，相对路径是从模块开始的也就是从xml模块开始的，所以路径中第一个是src Document read = reader.read(&quot;src/books.xml&quot;); //3.通过根元素获取book标签对象 Element element = read.getRootElement(); //element()和elements()都是通过标签名查找子元素，elements()返回多个，element()返回一个 List&lt;Element&gt; books = element.elements(&quot;book&quot;); //4.遍历，处理每个book标签转化为Book类 for(Element book:books)&#123; //asXML()把标签对象转换为标签字符串 Element nameElement=book.element(&quot;name&quot;); //getText()获取标签文本内容 String nameText=nameElement.getText(); //直接获取指定标签名的文本内容 String priceText=book.elementText(&quot;price&quot;); String authorText=book.elementText(&quot;author&quot;); //获取属性值 String snValue=book.attributeValue(&quot;sn&quot;); System.out.println(new Book(snValue,nameText,parseDouble(priceText),authorText)); &#125; &#125;&#125; Idea文件结构项目-&gt;模块-&gt;包 src文件夹中放置你的源代码，out目录放置src文件夹里面的java程序 Tomcatjavaweb概念javaweb是指所有通过java语言编写的可以通过浏览器访问的程序的总成称叫javaweb java是基于请求和响应来开发的 什么是请求 请求是指客户端发给服务器发送数据，叫请求request 什么是响应 相应是指服务器给客户端回传数据，叫响应reponse 请求和响应的关系 成对出现的，有请求就有回应 2.Web 资源的分类 web 资源按实现的技术和呈现的效果的不同，又分为静态资源和动态资源两种。 静态资源： html、css、js、txt、mp4 视频 , jpg 图片 动态资源： jsp 页面、Servlet 程序 3.常用的 Web 服务器 Tomcat：由 Apache 组织提供的一种 Web 服务器，提供对 jsp 和 Servlet 的支持。它是一种轻量级的 javaWeb 容器（服务 器），也是当前应用最广的 JavaWeb 服务器（免费）。 Jboss：是一个遵从 JavaEE 规范的、开放源代码的、纯 Java 的 EJB 服务器，它支持所有的 JavaEE 规范（免费）。 GlassFish： 由 Oracle 公司开发的一款 JavaWeb 服务器，是一款强健的商业服务器，达到产品级质量（应用很少）。 Resin：是 CAUCHO 公司的产品，是一个非常流行的服务器，对 servlet 和 JSP 提供了良好的支持， 性能也比较优良，resin 自身采用 JAVA 语言开发（收费，应用比较多）。 WebLogic：是 Oracle 公司的产品，是目前应用最广泛的 Web 服务器，支持 JavaEE 规范， 而且不断的完善以适应新的开发要求，适合大型项目（收费，用的不多，适合大公司）。 Tomcat服务器和Servelet版本的对应关系 Tomcat使用安装 找到你需要用的 Tomcat 版本对应的 zip 压缩包，解压到需要安装的目录即可。 目录介绍bin 专门用来存放 Tomcat 服务器的可执行程序 conf 专门用来存放 Tocmat 服务器的配置文件 lib 专门用来存放 Tomcat 服务器的 jar 包 logs 专门用来存放 Tomcat 服务器运行时输出的日记信息 temp 专门用来存放 Tomcdat 运行时产生的临时数据 webapps 专门用来存放部署的 Web 工程。 work 是 Tomcat 工作时的目录，用来存放 Tomcat 运行时 jsp 翻译为 Servlet 的源码，和 Session 钝化（序列化）的目录 如何启动tomcat服务器 找到 Tomcat 目录下的 bin 目录下的 startup.bat 文件，双击，就可以启动 Tomcat 服务器 另一种启动Tomcat服务器的方式 1、打开命令行 2、cd 到 你的 Tomcat 的 bin 目录下 3、敲入启动命令： catalina ru 直接在命令行里输入D:就可以进入D盘 Tomcat的停止1、点击 tomcat 服务器窗口的 x 关闭按钮 2、把 Tomcat 服务器窗口置为当前窗口，然后按快捷键 Ctrl+C 3、找到 Tomcat 的 bin 目录下的 shutdown.bat 双击，就可以停止 Tomcat 服务器 如何修改Tomcat默认的端口号Mysql 默认的端口号是：3306 Tomcat 默认的端口号是：8080 找到 Tomcat 目录下的 conf 目录，找到 server.xml 配置文件。 修改port属性来修改服务器端口 如何把web工程部署到tomcat服务器中第一种方法：只需要把web工程的目录拷贝到Tomcat服务器的webapps目录下即可 第二种方法 123http://localhost:8080/abc/index.html 这个xml文件名和那个path不一定非得一样，且这个xml文件在变成xml文件之前必须是UTF-8的记事本文件，然后改名为xml文件 1.让txt文件变成html文件被访问的时候，用ANSI编码格式，否则会出现乱码 Tomcat中创建动态的web工程csdn中记载那样创建 先创建一个java模块，然后右键java模块找到add framework support 再在WEB-INF目录里创建lib目录，存放jar包，将jar复制进去之后，右键jar包，选add as libray Application server 是自己找到那个自己的Tomcat 如何在 IDEA 中部署工程到 Tomcat 上运行看pdf文件即可 如何给Tomcat添加第三方jar包看pdf即可 Servlet路径 什么是·Servlet 1.Servlet是javaEE规范之一，规范就是接口 2.Servlet是javaweb三大组件之一，三大组件分别是servlet程序，filter过滤器，listener监听器 3.Servlet是运行在服务器上的Java小程序，它可以接受客户端发送过来的请求，并响应数据给客户端 手动实现Servlet程序1.编写一个类去实现Servlet接口 2.实现service方法，处理请求，并响应数据 3.到web.xml中配置servlet程序的访问地址 实现servlet接口的程序 12345678910111213141516171819202122232425262728293031package com.atguigu.servlet;import javax.servlet.*;import java.io.IOException;public class HelloServlet implements Servlet &#123; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; /*service方法是专门用来处理请求和响应的*/ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println(&quot;hello servlet访问了&quot;); &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; &#125;&#125; web.xml文件 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;!--servlet标签给Tomcat配置Servlet程序--&gt; &lt;servlet-name&gt; HelloServlet &lt;!--这个名字一般是和类名一样的，但也是别名可以不同，但一定要和下面的servlet-mapping中的name相同，servlet-class是必须和真实类名相同的--&gt; &lt;/servlet-name&gt; &lt;!--servlet-class是Servlet程序的全类名--&gt; &lt;servlet-class&gt; com.atguigu.servlet.HelloServlet &lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;!--servlet-name标签的作用是告诉服务器，我当前配置的地址给那个Servlet程序使用--&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!--servlet-name标签的作用是告诉服务器，我当前配置的地址给那个Servlet程序使用--&gt; &lt;!-- url-pattern标签配置访问地址 / 斜杠在服务器解析的时候，表示地址为http://ip:port/工程路径 /hello 表示地址为:http://ip:port/工程路径/hello --&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;!--这里的这个hello最好是和servlet的名字有点联系，一眼能看出--&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 运行tomcat实例之后，在url后面添加&#x2F;hello就可以访问到这个HelloServlet程序，也就是调用了上面java代码中的service方法 常见的错误 url地址如何定位servlet程序去访问的 Servlet的生命周期一个servlet的执行顺序 1.执行Servlet构造器方法 2.执行init初始化方法 第一二步是在第一次方法的时候创建Servlet程序会调用，就是如果刷新页面再次访问不会再执行1，2 3.执行service方法 每次访问都会调用，每次刷新页面再次访问就会调用 4.执行destroy方法 第四步，在web工程停止的时候会调用 四个方法实现的演示 1234567891011121314151617181920212223242526272829303132333435package com.atguigu.servlet;import javax.servlet.*;import java.io.IOException;public class HelloServlet implements Servlet &#123; public HelloServlet() &#123; System.out.println(&quot;1 构造器方法&quot;); &#125; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; System.out.println(&quot;2.ini方法&quot;); &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; /*service方法是专门用来处理请求和响应的*/ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println(&quot;3 service===hello servlet访问了&quot;); &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; System.out.println(&quot;4.destroy方法&quot;); &#125;&#125; 12345启动服务器之后，访问http://localhost:8080/ab/hello结果：1 构造器方法 2.ini方法 3 service===hello servlet访问了 Servlet请求的分发处理1在模块文件夹下的html文件，可以通过http://localhost:8080/servlet/a.html访问 a.html前面的都是工程路径 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://localhost:8080/servlet/hello&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; method可以有post和get，对应不同的操作，所以应该对Servlet程序进行改良 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.atguigu.servlet;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;public class HelloServlet implements Servlet &#123; public HelloServlet() &#123; System.out.println(&quot;1 构造器方法&quot;); &#125; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; System.out.println(&quot;2.ini方法&quot;); &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; /*service方法是专门用来处理请求和响应的*/ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; //类型转换，HttpServletRequest是ServletRequest的子接口，Servlet没有getMethod方法 HttpServletRequest httpServletRequest= (HttpServletRequest) servletRequest; //获取请求的方式 String method = httpServletRequest.getMethod(); if(&quot;GET&quot;.equals(method))&#123; System.out.println(&quot;get请求&quot;); &#125; else if(&quot;POST&quot;.equals(&quot;post请求&quot;))&#123; System.out.println(&quot;post请求&quot;); &#125; &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; System.out.println(&quot;4.destroy方法&quot;); &#125;&#125; 一个方法中又执行get又执行post不太好，将这两个方法分开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.atguigu.servlet;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;public class HelloServlet implements Servlet &#123; public HelloServlet() &#123; System.out.println(&quot;1 构造器方法&quot;); &#125; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; System.out.println(&quot;2.ini方法&quot;); &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; /*service方法是专门用来处理请求和响应的*/ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; //类型转换，HttpServletRequest是ServletRequest的子接口，Servlet没有getMethod方法 HttpServletRequest httpServletRequest= (HttpServletRequest) servletRequest; //获取请求的方式 String method = httpServletRequest.getMethod(); if(&quot;GET&quot;.equals(method))&#123; doGet(); &#125; else if(&quot;POST&quot;.equals(&quot;post请求&quot;))&#123; doPost(); &#125; &#125; public void doGet()&#123; System.out.println(&quot;get请求&quot;); System.out.println(&quot;get请求&quot;); System.out.println(&quot;get请求&quot;); System.out.println(&quot;get请求&quot;); System.out.println(&quot;get请求&quot;); &#125; public void doPost()&#123; System.out.println(&quot;post请求&quot;); System.out.println(&quot;post请求&quot;); System.out.println(&quot;post请求&quot;); System.out.println(&quot;post请求&quot;); System.out.println(&quot;post请求&quot;); &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; System.out.println(&quot;4.destroy方法&quot;); &#125;&#125; 通过继承HttpServlet实现Servlet程序一般在实际项目中，都是使用继承HttpServlet类的方式去实现Servlet程序 1.编写一个类去继承 HttpServlet类 2.根据业务需要重写doGet或者doPost方法 3.到web.xml中配置Servlet程序的访问地址 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://localhost:8080/servlet/hello2&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class HelloServlet2 extends HttpServlet &#123; /* doGet()方法在Get请求的时候调用 doPost()方法在Post请求的时候调用 */ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;helloservlet2 doget&quot;); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;helloservlet2 dopost&quot;); &#125;&#125; 使用IDEA菜单生成Servlet程序整个Servlet类的继承体系 ServletConfig类ServletConfig从类名上看，就是Servlet程序的配置信息类 servlet程序和servletConfig对象都是由Tomcat负责创建，我们负责使用 Servlet程序默认是第一次访问的时候创建，ServletConfig是每个Servlet程序创建的时候，就创建一个对应的ServletConfig对象 三大作用 1.可以获取Servlet的别名额就是servlet-name的值 2.获取初始化参数init-param 3.获取servletContext对象 init方法体现了ServletConfig的三大作用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.atguigu.servlet;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;public class HelloServlet implements Servlet &#123; public HelloServlet() &#123; System.out.println(&quot;1 构造器方法&quot;); &#125; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; System.out.println(&quot;2.ini方法&quot;); // 1.可以获取Servlet的别名额就是servlet-name的值System.out.println(&quot;servlet的别名是:&quot;+servletConfig.getServletName()); //2.获取初始化参数init-paramSystem.out.println(&quot;初始化参数username的值为&quot;+servletConfig.getInitParameter(&quot;username&quot;));System.out.println(&quot;初始化参数password的值为&quot;+servletConfig.getInitParameter(&quot;password&quot;)); //3.获取servletContext对象 System.out.println(servletConfig.getServletContext()); &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; /*service方法是专门用来处理请求和响应的*/ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; //类型转换，HttpServletRequest是ServletRequest的子接口，Servlet没有getMethod方法 HttpServletRequest httpServletRequest= (HttpServletRequest) servletRequest; //获取请求的方式 String method = httpServletRequest.getMethod(); if(&quot;GET&quot;.equals(method))&#123; doGet(); &#125; else if(&quot;POST&quot;.equals(&quot;post请求&quot;))&#123; doPost(); &#125; &#125; public void doGet()&#123; System.out.println(&quot;get请求&quot;); System.out.println(&quot;get请求&quot;); System.out.println(&quot;get请求&quot;); System.out.println(&quot;get请求&quot;); System.out.println(&quot;get请求&quot;); &#125; public void doPost()&#123; System.out.println(&quot;post请求&quot;); System.out.println(&quot;post请求&quot;); System.out.println(&quot;post请求&quot;); System.out.println(&quot;post请求&quot;); System.out.println(&quot;post请求&quot;); &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; System.out.println(&quot;4.destroy方法&quot;); &#125;&#125; 每个Servlet程序对应一个ServletConfig对象，所以不可能在HelloServlet2中获得的ServletConfig对象来获取给HelloServlet1配置的信息 1234567891011121314151617181920212223242526272829303132package com.atguigu.servlet;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class HelloServlet2 extends HttpServlet &#123; /* doGet()方法在Get请求的时候调用 doPost()方法在Post请求的时候调用 */ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;helloservlet2 doget&quot;); //可以使用getServletConfig()方法来获得servletConfig对象 ServletConfig servletConfig=getServletConfig(); System.out.println(servletConfig); System.out.println(&quot;初始化参数username的值为&quot;+servletConfig.getInitParameter(&quot;username&quot;)); System.out.println(&quot;初始化参数password的值为&quot;+servletConfig.getInitParameter(&quot;password&quot;)); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;helloservlet2 dopost&quot;); &#125;&#125; 重写Servlet程序的init方法的时候一定要就是调用它父类的init方法 123456789public class HelloServlet2 extends HttpServlet &#123; //重写init程序的时候必须有这个super.init(config) @Override public void init(ServletConfig config) throws ServletException &#123; super.init(config);//调用父类的init方法才能让this.config获值 System.out.println(&quot;重写了init初始化方法，做了一些工作&quot;); &#125; /* ServletContext类1.ServletContext是一个接口，它表示servlet上下文对象 2.一个web工程只有一个ServletConText对象实例，不管调用getServletContext()几次，得到的都是一个ServletContext对象 3.ServletContext对象是一个域对象 4.ServletContext是在web工程部署启动的时候创建，在web工程停止的时候销毁 重新部署或者重启服务器之后，存储的数据就会消失 什么是域对象 域对象是可以象Map一样存储数据的对象，叫域对象 这里的域指的是存储数据的操作范围，整个web工程 ​ 存数据 取数据 删除数据 Map put() get() remove() 域对象 setAttribute() getAttribute() removeAttribute() ServletContext对象能向ServletContext域中存储对象 ServletContext类的四个作用 1.获取web.xml中配置的上下文参数context.param 2.获取当前的工程路径，格式:&#x2F;工程路径 3.获取工程部署后在服务器硬盘上的绝对路径 4.像Map一样存储数据 当正常在网址栏输入网址访问基本都是get请求 以下路径是IDEA整合Tomcat之后，Tomcat被拷贝的一些副本内容 C:\\Users#赵梓皓&amp;\\AppData\\Local\\JetBrains\\IntelliJIdea2020.3\\tomcat\\cc813db2-dbda-4294-89c0-505f477c0964 1D:\\IDEAjava工程\\javaweb\\out\\artifacts\\servlet_war_exploded\\ 这个就是项目部署之后在磁盘中的位置 servlet:war exploded就是一个文件夹，里面是项目中的web文件夹中的内容 前三个功能 1234567891011121314151617181920212223242526272829package com.atguigu.servlet;import javax.servlet.ServletConfig;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class ContextServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.获取web.xml中配置的上下文参数context.param ServletContext context= getServletConfig().getServletContext(); String username=context.getInitParameter(&quot;username&quot;); System.out.println(&quot;context-param参数username是&quot;+username); System.out.println(&quot;context-param参数password是&quot;+context.getInitParameter(&quot;password&quot;)); //2.获取当前的工程路径，格式:/工程路径System.out.println(&quot;当前工程的路径&quot;+context.getContextPath()); //3.获取工程部署后在服务器硬盘上的绝对路径 // 斜杠 被服务器解析地址为http://ip:port/工程名/ 映射到IDEA代码的web目录 //就是得到的这个地址访问之后就是web目录下的东西 System.out.println(&quot;工程部书之后的路径&quot;+context.getRealPath(&quot;/&quot;)); //获取web目录下的其他文件的绝对路径 System.out.println(&quot;工程下css目录的绝对路径是&quot;+context.getRealPath(&quot;/css&quot;)); System.out.println(&quot;工程目录下imgs目录1.jpg的绝对路径是&quot;+context.getRealPath(&quot;/imgs/1.jpg&quot;)); &#125;&#125; 第四个功能.像Map一样存储数据， ContextServlet1和ContextServlet2只要有一个存了key1的值，另一个也能获取key1的值，但重新部署或者重启服务器数据就消失了 ContextServlet1 1234567891011121314151617181920212223242526272829package com.atguigu.servlet;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class ContextServlet1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取ServletContext对象 ServletContext context = getServletContext(); //打印context的地址看两个Servlet中的地址相不相同 System.out.println(context); System.out.println(&quot;保存之前：Context1获取key1的值是&quot;+context.getAttribute(&quot;key1&quot;)); context.setAttribute(&quot;key1&quot;,&quot;value&quot;); System.out.println(&quot;context1中获取域数据key1的值为&quot;+context.getAttribute(&quot;key1&quot;)); System.out.println(&quot;context1中获取域数据key1的值为&quot;+context.getAttribute(&quot;key1&quot;)); System.out.println(&quot;context1中获取域数据key1的值为&quot;+context.getAttribute(&quot;key1&quot;)); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; &#125;&#125; ContextServlet2 123456789101112131415161718package com.atguigu.servlet;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class ContextServlet2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException&#123; ServletContext context = getServletContext(); System.out.println(context); System.out.println(&quot;Context2中获取域数据key1的值是&quot;+context.getAttribute(&quot;key1&quot;)); &#125;&#125; 两个文件中context地址相同 org.apache.catalina.core.ApplicationContextFacade@467b6a76 org.apache.catalina.core.ApplicationContextFacade@467b6a76 HTTP协议请求的HTTP协议协议是指双方或者多方约定好，大家都需要遵守的规则，叫协议 所谓HTTP协议就是指，客户端和服务器之间通信时，发送的数据需要遵守的规则，叫http协议 HTTP 协议中的数据又叫报文。 客户端给服务器发送数据叫请求。 服务器给客户端回传数据叫响应。 请求又分为 GET 请求，和 POST 请求两种 GET 请求 getpost都会对url进行url编码 1、请求行(报文行) (1) 请求的方式 GET (2) 请求的资源路径[+?+请求参数] (3) 请求的协议的版本号 HTTP&#x2F;1.1 2、请求头(报文头) key : value 组成 不同的键值对，表示不同的含义 ii. POST 请求 1、请求行 (1)请求的方式 POST (2) 请求的资源路径[+?+请求参数] (3) 请求的协议的版本号 HTTP&#x2F;1.1 2、 2.请求头 key : value 不同的请求头，有不同的含义 空行(请求头和请求体之间有空行) 3、请求体 &#x3D;&#x3D;&#x3D;&gt;&gt;&gt; 就是发送给服务器的数据 iii. 常用请求头的说明 Accept: 表示客户端可以接收的数据类型 Accpet-Languege: 表示客户端可以接收的语言类型 User-Agent: 表示客户端浏览器的信息 Host： 表示请求时的服务器 ip 和端口 iv. 哪些是 GET 请求，哪些是 POST 请求 GET 请求有哪些： 1、form 标签 method&#x3D;get 2、a 标签 3、link 标签引入 css 4、Script 标签引入 js 文件 5、img 标签引入图片 6、iframe 引入 html 页面 7、在浏览器地址栏中输入地址后敲回车 POST 请求有哪些： 8、form 标签 method&#x3D;post 响应的 HTTP 协议格式1、响应行 (1) 响应的协议和版本号 HTTP&#x2F;1.1 ​ (2) 响应状态码 200 ​ (3) 响应状态描述符 2、响应头 (1) key : value 不同的响应头，有其不同含义 空行 3、响应体 —-&gt;&gt;&gt; 就是回传给客户端的数 常见的响应码 200 表示请求成功 302 表示请求重定向（明天讲） 404 表示请求服务器已经收到了，但是你要的数据不存在（请求地址错误） 500 表示服务器已经收到请求，但是服务器内部错误（代码错误） MIME 类型说明 MIME 是 HTTP 协议中数据类型。 MIME 的英文全称是”Multipurpose Internet Mail Extensions” 多功能 Internet 邮件扩充服务。MIME 类型的格式是“大类型&#x2F;小 类型”，并与某一种文件的扩展名相对应 ServletRequest每次只要有请求进入，tomcat服务器就会把请求过来的HTTP协议信息解析好封装到request对象中。 然后传递到service方法，也含有doget dopost方法中给我们使用。我们可以通过HttpServletRequest对象，获取到所有请求的信息 HttpServletRequest 类的常用方法i. getRequestURI() 获取请求的资源路径 ii. getRequestURL() 获取请求的统一资源定位符（绝对路径） iii. getRemoteHost() 获取客户端的 ip 地址 iv. getHeader() 获取请求头 v. getParameter() 获取请求的参数 vi. getParameterValues() 获取请求的参数（多个值的时候使用） vii. getMethod() 获取请求的方式 GET 或 POST viii. setAttribute(key, value); 设置域数据 ，ServletRequest能通过这个方法向request域中存储数据 ix. getAttribute(key); 获取域数据 x. getRequestDispatcher() 获取请求转发对象 1234567891011121314151617181920212223242526272829package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class RequestAPIServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // i. getRequestURI() 获取请求的资源路径System.out.println(&quot;url=&gt;&quot;+req.getRequestURI()); //ii. getRequestURL() 获取请求的统一资源定位符（绝对路径）System.out.println(&quot;ulr=&gt;&quot;+req.getRequestURL()); //iii. getRemoteHost() 获取客户端的 ip 地址System.out.println(&quot;客户端 ip 地址&quot;+req.getRemoteHost());/*在IDEA中，使用使用localhost访问时，得到的客户端ip地址是127.0.0.1在IDEA中，使用使用127.0.0.1访问时，得到的客户端ip地址是127.0.0.1在IDEA中，使用使用真实ip访问时，得到的客户端ip地址是真实ip */ //iv. getHeader() 获取请求头System.out.println(&quot;请求头&quot;+req.getHeader(&quot;User-Agent&quot;)); //vii. getMethod() 获取请求的方式 GET 或 POST System.out.println(&quot;请求的方式&quot;+req.getMethod()); &#125;&#125; Servlet获取请求的参数值用来发送参数的form表单 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://localhost:8086/servlet2/parameterServlet&quot; method=&quot;get&quot;&gt; 用户名 &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt; 密码 &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br/&gt; 兴趣爱好 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;cpp&quot;&gt;c++ &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;java&quot;&gt;java &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;javascript&quot;&gt;javascript&lt;br/&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Arrays;public class ParameterServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求的参数，用name属性的值来作为参数获取 System.out.println(req.getParameter(&quot;username&quot;)); System.out.println(req.getParameter(&quot;password&quot;));//获取有多个参数的请求String []hobby=req.getParameterValues(&quot;hobby&quot;);System.out.println(Arrays.toString(hobby)); &#125;&#125; 解决post请求中的中文乱码问题 req.setCharacterEncoding(“UTF-8”); 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://localhost:8086/servlet2/parameterServlet&quot; method=&quot;post&quot;&gt; 用户名 &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt; 密码 &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br/&gt; 兴趣爱好 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;cpp&quot;&gt;c++ &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;java&quot;&gt;java &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;javascript&quot;&gt;javascript&lt;br/&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Arrays;public class ParameterServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求的参数，用name属性的值来作为参数获取 System.out.println(req.getParameter(&quot;username&quot;)); System.out.println(req.getParameter(&quot;password&quot;));//获取有多个参数的请求String []hobby=req.getParameterValues(&quot;hobby&quot;);System.out.println(Arrays.toString(hobby)); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置请求体的字符集为UTF-8，从而解决post请求的中文乱码问题 //这个方法只有在所有获取请求参数方法之前调用才有效 req.setCharacterEncoding(&quot;UTF-8&quot;); System.out.println(&quot;=-----post----&quot;); //获取请求的参数，用name属性的值来作为参数获取 System.out.println(req.getParameter(&quot;username&quot;)); System.out.println(req.getParameter(&quot;password&quot;));//获取有多个参数的请求 String []hobby=req.getParameterValues(&quot;hobby&quot;); System.out.println(Arrays.toString(hobby)); &#125;&#125; 请求的转发什么是请求的转发? 请求转发是指，服务器收到请求后，从一次资源跳转到另一个资源的操作叫请求转发 请求转发的特点第四条 如果form.html在WEB-INF目录下无法通过http://localhost:8086/servlet2/WEB-INF/form.html访问 但可以通过请求转发访问 下面两种都可以，第一个是绝对路径，第二个是相对路径 1RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;/WEB-INF/form.html&quot;); 1RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;WEB-INF/form.html&quot;); 在web中 &#x2F;斜杠就代表http://ip:port/工程名/ 可以映射到web目录下，可以在后面直接加web目录中的资源访问，但不能直接访问 WEB-INF目录中的资源 这是实现图片中的请求转发的步骤 servlet1 1234567891011121314151617181920212223242526272829303132package com.atguigu.servlet;import javafx.scene.control.TextInputControl;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class servlet1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求参数，(办事的材料)查看 //这个参数也可以用get传参直接传 String username=req.getParameter(&quot;username&quot;); System.out.println(&quot;在servlet1柜台中查看参数(材料)&quot;+username); //给材料盖一个章，并传递到servlet2柜台二去查看 req.setAttribute(&quot;key&quot;,&quot;柜台1的章&quot;); /* 请求转发必须要以斜杠打头，斜杠表示地址为：http://ip:port/工程名/ ,映射到IDEA代码的web目录，然后在后面加这个servlet文件名即可 */ //问路servlet2(柜台二在哪) RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;/servlet2&quot;); //走向servlet2，柜台二 requestDispatcher.forward(req,resp); &#125;&#125; servlet2 1234567891011121314151617181920212223package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class servlet2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求参数，(办事的材料)查看 String username=req.getParameter(&quot;username&quot;); System.out.println(&quot;在servlet1柜台中查看参数(材料)&quot;+username); //查看柜台1 是否有盖章 Object key = req.getAttribute(&quot;key&quot;); System.out.println(&quot;柜台一是否有章&quot;+key); //处理自己的业务 System.out.println(&quot;servlet2处理自己的业务&quot;); &#125;&#125; 关于重定向以及javaweb的路径补充（getResourcAsStream）服务器对服务器(请求转发)发起请求：(也叫服务器对斜杠&#x2F;进行解析的时候 绝对路径：&#x2F; 斜杠代表的是项目根目录 也就是http://ip:port/工程名， 可以映射到web目录下，后面直接跟web目录下内容，除了WEB-INF 浏览器对服务器(重定向)发起请求：(也叫浏览器对斜杠&#x2F;进行解析的时候) 绝对路径：&#x2F; 斜杠代表的是tomcat根目录，也就是http://ip:port 需要自己去加工程名 当这种&#x2F;表示tomcat根目录的时候，绝对路径开头的 &#x2F;工程名 就是自己设置的那个 而不是文件名 不管是哪个相对路径都是看相对位置 这个就是规定了工程的目录 也就是http://ip:port/servlet2 请求转发路径解释： 这个是web.xml文件中规定的Servlet文件的访问路径 等于是在web文件夹中创立一个contextservlet2文件，这也为什么http://ip:port/servlet2/contextservlet2能访问到servlet文件的原因 请求转发 这个地方用servlet2是因为这可以用相对路径，他们访问路径都在web目录下 也可以用&#x2F;servlet2 这是绝对路径，因为servlet2访问路径在web目录下 如果是web文件下有这个form.html文件也可以就是通过请求转发访问 下面两种都可以 1RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;form.html&quot;); 1RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;/form.html&quot;); 12345getResourceAsStream中的路径只有两种写法最前面是&#x27;/&#x27; 说明是工程目录下可以映射到web目录下最前面没有&#x27;/&#x27; 说明是默认从src目录开始 base标签的作用即使文件加上了base标签，也可以使用绝对路径 错误演示 c.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;这是a下的b下的c.html页面&lt;a href=&quot;/servlet2/index.html&quot;&gt;跳回首页&lt;/a&gt;&lt;a href=&quot;../../index.html&quot;&gt;跳回首页&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 这两个a标签中的地址都是index.html的地址一个是相对路径一个是绝对路径 这里因为是浏览器向服务器发起请求所以这里的绝对路径 &#x2F; 斜杠代表的是http://ip:port/ 访问到工程名默认的是访问web文件下的名为index的html或者js的文件 index.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;这是web下的index.html&lt;a href=&quot;a/b/c.html&quot;&gt;a/b/c.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://localhost:8086/servlet2/ForwardC&quot;&gt; 请求转发&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 第二个a标签利用请求转发跳转，是无法在c.html回到首页的 正确版本 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--base标签设置页面相对路径工作时参照的地址 href 属性就是参数的地址值 --&gt;&lt;/head&gt;&lt;body&gt;这是a下的b下的c.html页面&lt;a href=&quot;/servlet2/index.html&quot;&gt;跳回首页&lt;/a&gt;&lt;a href=&quot;../../index.html&quot;&gt;跳回首页&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; http://localhost:8080/servlet2/a/b/c.html就是这个文件中的所有相对路径的地址都是参照这个路径的 HttpServletResponse作用 HttpServletResponse 类和 HttpServletRequest 类一样。每次请求进来，Tomcat 服务器都会创建一个 Response 对象传递给 Servlet 程序去使用。 HttpServletRequest 表示请求过来的信息，HttpServletResponse 表示所有响应的信息， 我们如果需要设置返回给客户端的信息，都可以通过 HttpServletResponse 两个输出流说明字节流 getOutputStream() 常用于下载，传递二进制数据 字符流 getWriter() 常用于回传字符串(常用) 两个流同时只能使用一个，使用了字节流，就不能再使用字符流，否则就会报错 如何往客户端回传数据（乱码解决）要求：往客户端回传字符串数据以及中文乱码的解决方案（将服务器和浏览器统一编码） 1234567891011121314151617181920212223242526package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class ResponseIOServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //查看相应的字符集 默认ISO-8859-1 System.out.println(resp.getCharacterEncoding()); //设置服务器字符集为UTF-8 resp.setCharacterEncoding(&quot;UTF-8&quot;); //同时要自己去改变浏览器的字符集，改为UTF-8 resp.setHeader(&quot;Content-Type&quot;,&quot;text/html;charset=UTF-8&quot;); //要求：往客户端回传字符串数据 PrintWriter writer=resp.getWriter(); writer.write(&quot;我很帅&quot;); &#125;&#125; 第二种解决中文乱码的方案 123456789101112131415161718192021package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class ResponseIOServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //它会同时设置服务器和客户端都使用UTF-8字符集，还设置了响应头 //此方法一定要在获取流之前时使用才有效 resp.setContentType(&quot;text/html; charset=UTF-8&quot;); System.out.println(resp.getCharacterEncoding()); //要求：往客户端回传字符串数据 PrintWriter writer=resp.getWriter(); writer.write(&quot;我很帅&quot;); &#125;&#125; Servlet请求重定向请求重定向，是指客户端给服务器发请求，然后服务器告诉客户端说。我给你一些地址。你去新地址访问。叫请求 重定向（因为之前的地址可能已经被废弃） 重点：两个servlet之间不共享Request域中的数据 其实就是当用HttpServletResponse的setAttribute()方法是不能把把存储的数据给多个Servlet获取的，但ServletContext可以 response1重定向到response2的解析 response1 1234567891011121314151617181920package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class response1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;曾到此一游 Response1&quot;); req.setAttribute(&quot;key&quot;,&quot;value1&quot;); //设置响应状态码，表示重定向(已搬迁) resp.setStatus(302); //设置响应头，说明新的地址在哪里 resp.setHeader(&quot;Location&quot;,&quot;http://localhost:8086/servlet2/response2&quot;); &#125;&#125; response2 123456789101112131415package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class response2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(req.getAttribute(&quot;key&quot;)); resp.getWriter().write(&quot;response2 result&quot;); &#125;&#125; response1重定向到form.html的解析 错误案例：不能够重定向到WEB-INF下的form.html文件 因为重定向也就是第二次的地址是用来浏览器向服务器发起请求，WEB-INF中的文件受保护所以不行 1234567891011121314151617181920package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class response1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;曾到此一游 Response1&quot;); req.setAttribute(&quot;key&quot;,&quot;value1&quot;); //设置响应状态码，表示重定向(已搬迁) resp.setStatus(302); //设置响应头，说明新的地址在哪里 resp.setHeader(&quot;Location&quot;,&quot;http://localhost:8086/WEB-INF/form.html&quot;); &#125;&#125; 正确案例：访问web目录下的form.html 新地址使用绝对路径的方法，下面两个都是绝对路径 1234567891011121314151617181920package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class response1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;曾到此一游 Response1&quot;); req.setAttribute(&quot;key&quot;,&quot;value1&quot;); //设置响应状态码，表示重定向(已搬迁) resp.setStatus(302); //设置响应头，说明新的地址在哪里 resp.setHeader(&quot;Location&quot;,&quot;http://localhost:8086/servlet2/form.html&quot;); &#125;&#125; 1234567891011121314151617181920package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class response1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;曾到此一游 Response1&quot;); req.setAttribute(&quot;key&quot;,&quot;value1&quot;); //设置响应状态码，表示重定向(已搬迁) resp.setStatus(302); //设置响应头，说明新的地址在哪里 resp.setHeader(&quot;Location&quot;,&quot;/servlet2/form.html&quot;); &#125;&#125; 相对路径 1234567891011121314151617181920package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class response1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;曾到此一游 Response1&quot;); req.setAttribute(&quot;key&quot;,&quot;value1&quot;); //设置响应状态码，表示重定向(已搬迁) resp.setStatus(302); //设置响应头，说明新的地址在哪里 resp.setHeader(&quot;Location&quot;,&quot;form.html&quot;); &#125;&#125; 因为这里的重定向的地址是浏览器会向服务器发起的请求，所以绝对路径的 &#x2F;表示的是tomcat根目录下的内容 重定向也可以访问外部地址，只要把location换成一个网站的网址就可以 第二种请求重定向的方法第二种方法 123456789101112131415package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class response1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.sendRedirect(&quot;/servlet2/response2&quot;); &#125;&#125; 书城项目的第二个阶段用户的注册和登录 javaEE项目的三层架构 分层的目的是为了解耦。解耦就是为了降低代码的耦合度。方便项目后期的维护和升级 下面的斜杠是或者的意思 web 层 com.atguigu.web&#x2F;servlet&#x2F;controller service 层 com.atguigu.service Service 接口包 ​ com.atguigu.service.impl Service 接口实现类 dao 持久层 com.atguigu.dao Dao 接口包 ​ com.atguigu.dao.impl Dao 接口实现类 实体 bean 对象 com.atguigu.pojo&#x2F;entity&#x2F;domain&#x2F;bean JavaBean 类 测试包 com.atguigu.test&#x2F;junit 工具类 com.atguigu.utils 创建数据库和User用户表一般创建一个表都需要有一个id这样自增的主键 1234567891011121314create database book;use book;create table t_user(id int PRIMARY KEY auto_increment,username varchar(20) not null unique,password varchar(20) not null,email varchar(200));insert into t_user(username,password,email) values(&#x27;admin&#x27;,&#x27;admin&#x27;,&#x27;admin@guigu.com&#x27;);select *from t_user; 编写数据库表对应的javaBean对象所谓的javaBean对象就是一个和数据库中储存数据一样类型的java类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.atguigu.pojo;public class User &#123; private Integer id; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &quot;, email=&#x27;&quot; + email + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public User(Integer id, String username, String password, String email) &#123; this.id = id; this.username = username; this.password = password; this.email = email; &#125; public User() &#123; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; private String username; private String password; private String email; &#125; 编写工具类JDBCUtils 导入这两个包才能用@test JdbcUtils类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.atguigu.utils;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.pool.DruidDataSourceFactory;import java.io.InputStream;import java.sql.Connection;import java.sql.SQLException;import java.util.Properties;public class JdbcUtils &#123; private static DruidDataSource dataSource;static &#123; try&#123; Properties properties=new Properties(); //奇怪的是这个地方不能用绝对路径 InputStream inputStream=JdbcUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); properties.load(inputStream); dataSource= (DruidDataSource) DruidDataSourceFactory.createDataSource(properties); System.out.println(dataSource.getConnection()); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125;&#125;//获取数据库连接池中的连接，如果返回null就是获取失败，有值就是获取成功public static Connection getConnection()&#123; Connection conn=null; try &#123; conn=dataSource.getConnection(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return conn;&#125;//关闭连接 public static void close(Connection conn)&#123; if(conn!=null)&#123; try&#123; conn.close(); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 测试类 123456789101112131415161718package com.atguigu.test;import com.atguigu.utils.JdbcUtils;import org.junit.Test;import java.sql.Connection;public class JdbcUtilsTest &#123; @Testpublic void testJdbcUtils()&#123; for (int i = 0; i &lt;100 ; i++) &#123; Connection conn=JdbcUtils.getConnection(); System.out.println(conn); JdbcUtils.close(conn); &#125; &#125;&#125; 因为数据库连接池配置文件中有最大连接数为规定数，所以只有每次都释放才能获取连接 BaseDao在使用queryForList和queryForOne来获得javaBean对象的时候，这个javaBean类中属性的名字必须和select后面的列名相同，或者是起名让他相同 封装了增删改和查询方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.atguigu.dao.impl;import com.atguigu.utils.JdbcUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.apache.commons.dbutils.handlers.ScalarHandler;import java.sql.Connection;import java.sql.SQLException;import java.util.List;public class BaseDao &#123; //使用DbUtils操作数据库private QueryRunner queryRunner=new QueryRunner();/*update()方法用来执行：insert update delete语句如果返回-1说明执行失败， 否则返回其他表示影响的行数 */ public int update(String sql,Object...args)&#123; Connection conn= JdbcUtils.getConnection(); try &#123; return queryRunner.update(conn, sql, args); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; return -1; &#125; /* 查询返回一个javaBean的sql语句 type为返回对象类型，args是sql对应的参数值，sql是执行的sql语句 &lt;T&gt;返回的类型和泛型 */ public &lt;T&gt; T queryForOne(Class&lt;T&gt; type,String sql,Object...args) &#123; Connection con=JdbcUtils.getConnection(); try &#123; return queryRunner.query(con,sql,new BeanHandler&lt;T&gt;(type),args); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; finally&#123; JdbcUtils.close(con); &#125; return null; &#125; /* 查询返回多个javaBean的sql语句 */ public &lt;T&gt; List&lt;T&gt; queryForList(Class&lt;T&gt; type,String sql,Object...args)&#123; Connection con=JdbcUtils.getConnection(); try &#123; return queryRunner.query(con,sql,new BeanListHandler&lt;T&gt;(type),args); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; finally&#123; JdbcUtils.close(con); &#125; return null; &#125; /* 执行返回一个单元格的sql */ public Object queryForSingleValue(String sql,Object...args)&#123; Connection conn=JdbcUtils.getConnection(); try &#123; return queryRunner.query(conn, sql,new ScalarHandler(), args); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; finally&#123; JdbcUtils.close(conn); &#125; return null; &#125;&#125; 编写UserDao和测试其实这个Dao可以设计为一个泛型接口，用哪个类时再传递泛型参数，这样就是设计了一个不同数据库类的通用Dao 根据你所需要的方法来设计 UserDao 可以在空白处按ctrl和shift和t得到这个接口的测试 将Destination package换成你想要的位置，勾选好下面三个方法 123456789101112131415161718192021222324252627282930313233package com.atguigu.dao;import com.atguigu.pojo.User;public interface UserDao &#123; /* 根据用户名查询用户信息 username 用户名 如果返回null则说明没有这个用户，返之亦然 */ public User queryByUsername(String username); /** * 保存用户信息 * @param user * @return 返回-1表示操作失败，其他是sql语句影响的行数 */ public int saveUser(User user); /** * 根据用户名和密码查询用户信息 * @param username * @param password * @return 如果返回null则说明用户名或密码错误，返之亦然 */ public User queryUserByUsernameAndPassword(String username,String password);&#125; UserDaoImpl 12345678910111213141516171819202122232425package com.atguigu.dao.impl;import com.atguigu.dao.UserDao;import com.atguigu.pojo.User;public class UserDaoImpl extends BaseDao implements UserDao &#123; @Override public User queryByUsername(String username) &#123; String sql=&quot;select id,username,password,email from t_user where username=?&quot;; return queryForOne(User.class,sql,username); &#125; @Override public int saveUser(User user) &#123; String sql=&quot;insert into t_user(username,password,email) values(?,?,?)&quot;; return update(sql,user.getUsername(),user.getPassword(),user.getEmail()); &#125; @Override public User queryUserByUsernameAndPassword(String username, String password) &#123; String sql=&quot;select id,username,password,email from t_user where username=? and password=?&quot;; return queryForOne(User.class,sql,username,password); &#125;&#125; UserDaoTest 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.atguigu.test;import com.atguigu.dao.UserDao;import com.atguigu.dao.impl.UserDaoImpl;import com.atguigu.pojo.User;import org.junit.Test;import static org.junit.Assert.*;public class UserDaoTest &#123; UserDao userDao=new UserDaoImpl(); @Test public void queryByUsername() &#123; if(userDao.queryByUsername(&quot;admin123&quot;)==null) &#123; System.out.println(&quot;用户名可用&quot;); &#125; else &#123; System.out.println(&quot;用户名已存在&quot;); &#125; &#125; @Test public void saveUser() &#123; if(userDao.queryUserByUsernameAndPassword(&quot;admin&quot;,&quot;admin&quot;)==null)&#123; System.out.println(&quot;用户名或密码错误登陆错误&quot;); &#125; else &#123; System.out.println(&quot;登陆成功&quot;); &#125; &#125; @Test public void queryUserByUsernameAndPassword() &#123; System.out.println(userDao.saveUser(new User(null,&quot;admin&quot;,&quot;123456&quot;,&quot;wzg168@qq.com&quot;))); &#125;&#125; 编写UserService和测试可以在空白处按ctrl和shift和t得到这个接口的测试 将Destination package换成你想要的位置，勾选好下面三个方法 实现业务 UserService 123456789101112131415161718192021222324252627package com.atguigu.service;import com.atguigu.pojo.User;public interface UserService &#123; /** * 注册用户 * @param user */ public void registerUser(User user); /** * 登录 * @param user * @return 如果返回null，说明登录失败，返回有值，是登录成功 */ public User login(User user); /** * 检查用户名是否可用 * @param username * @return 返回true表示用户名已存在，返回false表示用户名可用 */ public boolean existsUsername(String username);&#125; UserServiceImpl 1234567891011121314151617181920212223242526272829package com.atguigu.service.impl;import com.atguigu.dao.UserDao;import com.atguigu.dao.impl.UserDaoImpl;import com.atguigu.pojo.User;import com.atguigu.service.UserService;public class UserServiceImpl implements UserService &#123; private UserDao userDao=new UserDaoImpl(); @Override public void registerUser(User user) &#123; userDao.saveUser(user); &#125; @Override public User login(User user) &#123; return userDao.queryUserByUsernameAndPassword(user.getUsername(),user.getPassword()); &#125; @Override public boolean existsUsername(String username) &#123; if(userDao.queryByUsername(username)==null)&#123; //等于null说明没查到，没查到表示可用 return false; &#125; return true; &#125;&#125; UserServiceTest 123456789101112131415161718192021222324252627282930313233package com.atguigu.test;import com.atguigu.pojo.User;import com.atguigu.service.UserService;import com.atguigu.service.impl.UserServiceImpl;import org.junit.Test;import static org.junit.Assert.*;public class UserServiceTest &#123; UserService userService=new UserServiceImpl(); @Test public void registerUser() &#123; userService.registerUser(new User(null,&quot;bbj168&quot;,&quot;666666&quot;,&quot;6668@qq.com&quot;)); &#125; @Test public void login() &#123; System.out.println(userService.login(new User(null,&quot;bbj168&quot;,&quot;666666&quot;,null))); &#125; @Test public void existsUsername() &#123; if(userService.existsUsername(&quot;bbj168&quot;))&#123; System.out.println(&quot;用户名已存在&quot;); &#125; else &#123; System.out.println(&quot;用户名可用&quot;); &#125; &#125;&#125; 实现用户注册的功能 javaweb阶段用base设定相对路径跳转 框架阶段用绝对路径 在title下面加上base标签，然后改变文件中所有的路径，因为现在的相对路径是以base这个路径为开头的 改变的文件既有register.html也有register_success.html 1&lt;base href=&quot;http://localhost:8087/book2/&quot;&gt; xml文件中配置servlet 把html文件中的表单，action设置为servlet的路径，method改为post 1&lt;form action=&quot;registServlet&quot; method=&quot;post&quot;&gt; 编写RegistServlet程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.atguigu.web;import com.atguigu.pojo.User;import com.atguigu.service.UserService;import com.atguigu.service.impl.UserServiceImpl;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class RegisterServlet extends HttpServlet &#123; //web层和service层交互 UserService userService=new UserServiceImpl(); @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.获取请求的参数 String username=req.getParameter(&quot;username&quot;); String password=req.getParameter(&quot;password&quot;); String email=req.getParameter(&quot;email&quot;); String code=req.getParameter(&quot;code&quot;); //2.检查 验证码是否正确,先把验证码写死，要求为abcde if(&quot;abcde&quot;.equalsIgnoreCase(code))&#123; //验证码正确 //检查用户名是否可用 if(userService.existsUsername(username))&#123; System.out.println(&quot;用户名&quot;+username+&quot;已存在&quot;); //跳回到注册页面 req.getRequestDispatcher(&quot;/pages/user/regist.html&quot;).forward(req,resp); &#125; else &#123; //可用 //调用Sercice保存到数据库 userService.registerUser(new User(null,username,password,email)); //注册成功后，跳转到注册成功页面 req.getRequestDispatcher(&quot;/pages/user/regist_success.html&quot;).forward(req,resp); &#125; &#125;else&#123; System.out.println(&quot;验证码&quot;+code+&quot;错误&quot;); //验证码不正确 //跳回注册页面，因为还是申请服务器中文件所以/还是工程目录下的 req.getRequestDispatcher(&quot;/pages/user/regist.html&quot;).forward(req,resp); &#125; &#125;&#125; IDEA中的Debug调试看pdf文件即可 用户登录功能的实现 操作步骤和用户注册功能差不多 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.atguigu.web;import com.atguigu.pojo.User;import com.atguigu.service.UserService;import com.atguigu.service.impl.UserServiceImpl;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class RegisterServlet extends HttpServlet &#123; //web层和service层交互 UserService userService=new UserServiceImpl(); @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.获取请求的参数 //这个getParameter方法是通过那个属性的name得到的 String username=req.getParameter(&quot;username&quot;); String password=req.getParameter(&quot;password&quot;); String email=req.getParameter(&quot;email&quot;); String code=req.getParameter(&quot;code&quot;); //2.检查 验证码是否正确,先把验证码写死，要求为abcde if(&quot;abcde&quot;.equalsIgnoreCase(code))&#123; //验证码正确 //检查用户名是否可用 if(userService.existsUsername(username))&#123; System.out.println(&quot;用户名&quot;+username+&quot;已存在&quot;); //跳回到注册页面 req.getRequestDispatcher(&quot;/pages/user/regist.html&quot;).forward(req,resp); &#125; else &#123; //可用 //调用Sercice保存到数据库 userService.registerUser(new User(null,username,password,email)); //注册成功后，跳转到注册成功页面 req.getRequestDispatcher(&quot;/pages/user/regist_success.html&quot;).forward(req,resp); &#125; &#125;else&#123; System.out.println(&quot;验证码&quot;+code+&quot;错误&quot;); //验证码不正确 //跳回注册页面，因为还是申请服务器中文件所以/还是工程目录下的 req.getRequestDispatcher(&quot;/pages/user/regist.html&quot;).forward(req,resp); &#125; &#125;&#125; JSP的内容jsp就是既能写java又能写html的文件 jsp 的全换是 java server pages。 Java 的服务器页面。 jsp 的主要作用是代替 Servlet 程序回传 html 页面的数据。 因为 Servlet 程序回传 html 页面数据是一件非常繁锁的事情。开发成本和维护成本都极高。 用servlet回传数据示例 12345678910111213141516171819202122232425262728package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class pringHtml extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 通过响应的回传流回传 html 页面数据 resp.setContentType(&quot;text/html; charset=UTF-8&quot;); PrintWriter writer = resp.getWriter(); writer.write(&quot;&lt;!DOCTYPE html&gt;\\r\\n&quot;); writer.write(&quot; &lt;html lang=\\&quot;en\\&quot;&gt;\\r\\n&quot;); writer.write(&quot; &lt;head&gt;\\r\\n&quot;); writer.write(&quot; &lt;meta charset=\\&quot;UTF-8\\&quot;&gt;\\r\\n&quot;); writer.write(&quot; &lt;title&gt;Title&lt;/title&gt;\\r\\n&quot;); writer.write(&quot; &lt;/head&gt;\\r\\n&quot;); writer.write(&quot; &lt;body&gt;\\r\\n&quot;); writer.write(&quot; 这是 html 页面数据 \\r\\n&quot;); writer.write(&quot; &lt;/body&gt;\\r\\n&quot;); writer.write(&quot;&lt;/html&gt;\\r\\n&quot;); writer.write(&quot;\\r\\n&quot;); &#125;&#125; 一个简单的jsp代码 123456789101112131415161718&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/1 Time: 10:28 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;这是html页面数据&lt;/body&gt;&lt;/html&gt; 2、jsp 如何访问： jsp 页面和 html 页面一样，都是存放在 web 目录下。访问也跟访问 html 页面一样 在 web 目录下有如下的文件： web 目录 a.html 页面 访问地址是 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&gt;&gt;&gt;&gt;&gt; http://ip:port/工程路径/ a.html b.jsp 页面 访问地址是 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&gt;&gt;&gt;&gt;&gt; http://ip:port/工程路径/b.js jsp页面的本质jsp 页面本质上是一个 Servlet 程序 当我们第一次访问 jsp 页面的时候。Tomcat 服务器会帮我们把 jsp 页面翻译成为一个 java 源文件。并且对它进行编译成 为.class 字节码程序。我们打开 java 源文件不难发现其里面的内容是 找java源文件的路径 12C:\\Users\\#赵梓皓&amp;\\AppData\\Local\\JetBrains\\IntelliJIdea2020.3\\tomcat\\a918c083-a48c-4fed-a7cf-4186b397852c\\work\\Catalina\\localhost\\jsp\\org\\apache\\jsp 我们跟踪原代码发现，HttpJspBase 类。它直接地继承了 HttpServlet 类。也就是说。jsp 翻译出来的 java 类，它间接了继 承了 HttpServlet 类。也就是说，翻译出来的是一个 Servlet 程序 总结：通过翻译的 java 源代码我们就可以得到结果：jsp 就是 Servlet 程序。 大家也可以去观察翻译出来的 Servlet 程序的源代码，不难发现。其底层实现，也是通过输出流。把 html 页面数据回传 给客户端 jsp 的三种语法jsp 头部的 page 指令jsp 的 page 指令可以修改 jsp 页面中一些重要的属性，或者行为 1&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; i. language 属性 表示 jsp 翻译后是什么语言文件。暂时只支持 java。 ii. contentType 属性 表示 jsp 返回的数据类型是什么。也是源码中 response.setContentType()参数值 iii. pageEncoding 属性 表示当前 jsp 页面文件本身的字符集。 iv. import 属性 跟 java 源代码中一样。用于导包，导类。 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;两个属性是给 out 输出流使用&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; v. autoFlush 属性 设置当 out 输出流缓冲区满了之后，是否自动刷新冲级区。默认值是 true。 vi. buffer 属性 设置 out 缓冲区的大小。默认是 8kb 如果将autoFlush设为false buffer改为比较小的2kb 然后jsp中页面又很多就会出现这种情况 pageEncoding属性改变的就是这个界面的编码 vii. errorPage 属性 设置当 jsp 页面运行时出错，自动跳转去的错误页面路径。 1errorPage=&quot;/error500.jsp&quot; viii. isErrorPage 属性 设置当前 jsp 页面是否是错误信息页面。默认是 false。如果是 true 可以 获取异常信息。 ix. session 属性 设置访问当前 jsp 页面，是否会创建 HttpSession 对象。默认是 true。 x. extends 属性 设置 jsp 翻译出来的java 类默认继承谁。 12345678910111213141516171819202122232425&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/1 Time: 10:28 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; pageEncoding=&quot;utf-8&quot; import=&quot;java.util.Map&quot; autoFlush=&quot;true&quot; buffer=&quot;8kb&quot; errorPage=&quot;/error500.jsp&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;a.jsp页面&lt;% int i=12/0;%&gt;&lt;/body&gt;&lt;/html&gt; 脚本声明脚本（少用）声明脚本的格式是： &lt;%! 声明 java 代码 % 作用：可以给 jsp 翻译出来的 java 类定义属性和方法甚至是静态代码块。内部类等 这是jsp的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/1 Time: 10:28 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; pageEncoding=&quot;utf-8&quot; import=&quot;java.util.Map&quot; autoFlush=&quot;true&quot; buffer=&quot;8kb&quot; errorPage=&quot;/error500.jsp&quot; language=&quot;java&quot; %&gt;&lt;%@ page import=&quot;java.util.HashMap&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1.声明类属性--&gt;&lt;%! private Integer id; private String name; private static Map&lt;String,Object&gt; map;%&gt;&lt;!--2.定义静态代码块--&gt;&lt;%! static &#123; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;key1&quot;, &quot;value1&quot;); map.put(&quot;key2&quot;, &quot;value2&quot;); map.put(&quot;key3&quot;, &quot;value3&quot;); &#125;%&gt;&lt;!--声明类的方法--&gt;&lt;%! public int abc()&#123; return 12; &#125;%&gt;&lt;!--生成内部类--&gt;&lt;%! public static class A&#123; private Integer id; private String abc=&quot;abc&quot;; &#125;%&gt;&lt;/body&gt;&lt;/html&gt; 上面这个图片是对应的jsp程序在a_jsp.java文件中生成的方法属性和静态代码块的样子 表达式脚本（常用）表达式脚本的格式是：&lt;%&#x3D;表达式%&gt; 表达式脚本的作用是：的 jsp 页面上输出数据。 表达式脚本的特点： 1、所有的表达式脚本都会被翻译到_jspService() 方法中 2、表达式脚本都会被翻译成为 out.print()输出到页面上 _3、由于表达式脚本翻译的内容都在_jspService() 方法中,所以_jspService()方法中的对象都可以直接使用。 4、表达式脚本中的表达式不能以分号结束。 这个就是jspService方法 out就是jsp专用的一个输入输出流 这个_jspService方法中的对象都可以使用 这个是表达式脚本的翻译演示 123456&lt;%=12%&gt;&lt;br/&gt;&lt;%=12.12%&gt;&lt;br/&gt;&lt;%=&quot;我是字符串&quot;%&gt;&lt;br/&gt;&lt;%=map%&gt;&lt;!--使用_jspService方法中的对象--&gt;&lt;%=request.getParameter(&quot;username&quot;)%&gt; 在页面输出12等等 代码脚本代码脚本中用System.out.println输出的都是在控制台中输出的 代码脚本的格式是： &lt;% java 语句 %&gt; 代码脚本的作用是：可以在 jsp 页面中，编写我们自己需要的功能（写的是 java 语句） 代码脚本的特点是： 1、代码脚本翻译之后都在_jspService 方法中 _ _2、代码脚本由于翻译到_jspService()方法中，所以在_jspService()方法中的现有对象都可以直接使用。 3、还可以由多个代码脚本块组合完成一个完整的 java 语句。 4、代码脚本还可以和表达式脚本一起组合使用，在 jsp 页面上输出数 正常的System只能输出在控制台，只有和表达式脚本结合才能输出页面 12345678910111213141516171819202122232425262728293031323334353637&lt;!--代码脚本和表达式脚本组合在一起用--&gt;&lt;% int i=13; if(i==12)&#123;%&gt;&lt;h1&gt;我是赵梓皓&lt;/h1&gt; &lt;% &#125; else &#123;%&gt;&lt;h1&gt;我是张几名&lt;/h1&gt; &lt;% &#125; %&gt;&lt;!--两个代码脚本合成一个，即使会报错，但是运行之后还是可以输出的--&gt;&lt;!--代码脚本还可以和表达式脚本一起组合输出--&gt;&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;% for(int j=0;j&lt;10;j++)&#123; %&gt; &lt;tr&gt; &lt;td&gt;&lt;%=j%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% &#125;%&gt;&lt;/table&gt;&lt;!--用jspService中的对象--&gt;&lt;% String username=request.getParameter(&quot;username&quot;); System.out.println(&quot;用户名的请求参数是&quot;+username);%&gt; jsp中的三种注释i. html 注释 html 注释会被翻译到 java 源代码中。在_jspService 方法里，以 out.writer 输出到客户端。 ii. java 注释 1&lt;% // 单行 java 注释 /* 多行 java 注释 */ %&gt; java 注释会被翻译到 java 源代码中。 iii. jsp 注释 &lt;%– 这是 jsp 注释 –%&gt; jsp 注释可以注掉，jsp 页面中所有代码 jsp九大内置对象 这个第九个内置对象只有 isErrorPage为true的时候才会在java文件中显示出来 java四个域对象的演示这四个域和Servlet中的域是一样的，所以Servlet在request域中存储的数据，其实在jsp中是可以获取的 四个域对象分别是： pageContext (PageContextImpl 类) 当前 jsp 页面范围内有效 request (HttpServletRequest 类)、 一次请求内有效 ，请求转发是一次请求 session (HttpSession 类)、 一个会话范围内有效（打开浏览器访问服务器，直到关闭浏览器） application (ServletContext 类) 整个 web 工程范围内都有效（只要 web 工程不停止，数据都在） 域对象是可以像 Map 一样存取数据的对象。四个域对象功能一样。不同的是它们对数据的存取范围 虽然四个域对象都可以存取数据。在使用上它们是有优先顺序的。 四个域在使用的时候，优先顺序分别是，他们从小到大的范围的顺序。 pageContext &#x3D;&#x3D;&#x3D;&#x3D;&gt;&gt;&gt; request &#x3D;&#x3D;&#x3D;&#x3D;&gt;&gt;&gt; session &#x3D;&#x3D;&#x3D;&#x3D;&gt;&gt;&gt;application score.jsp 123456789101112131415161718192021222324252627282930&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/1 Time: 14:58 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;score.jsp页面&lt;/h1&gt; &lt;% //往四个域中都分别保存了数据 pageContext.setAttribute(&quot;key&quot;,&quot;pageContext&quot;); request.setAttribute(&quot;key&quot;,&quot;request&quot;); session.setAttribute(&quot;key&quot;,&quot;session&quot;); application.setAttribute(&quot;key&quot;,&quot;application&quot;); %&gt; pageContext域是否有值：&lt;%=pageContext.getAttribute(&quot;key&quot;)%&gt; &lt;br&gt; request域是否有值：&lt;%=request.getAttribute(&quot;key&quot;)%&gt; &lt;br&gt; session域是否有值：&lt;%=session.getAttribute(&quot;key&quot;)%&gt; &lt;br&gt; application域是否有值：&lt;%=application.getAttribute(&quot;key&quot;)%&gt; &lt;br&gt;&lt;% request.getRequestDispatcher(&quot;/score2.jsp&quot;).forward(request,response);%&gt;&lt;/body&gt;&lt;/html&gt; score2.jsp 1234567891011121314151617181920&lt;%-- Created by IntelliJ IDEA. User: Administrator Date: 2020/2/23 Time: 21:23 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;scope2.jsp页面&lt;/h1&gt; pageContext域是否有值：&lt;%=pageContext.getAttribute(&quot;key&quot;)%&gt; &lt;br&gt; request域是否有值：&lt;%=request.getAttribute(&quot;key&quot;)%&gt; &lt;br&gt; session域是否有值：&lt;%=session.getAttribute(&quot;key&quot;)%&gt; &lt;br&gt; application域是否有值：&lt;%=application.getAttribute(&quot;key&quot;)%&gt; &lt;br&gt;&lt;/body&gt;&lt;/html&gt; 这种情况pageContext是null，因为请求转发就变了一个jsp页面了，但是依然是一次请求所以request是有的 1如果再专门请求一次score2 http://localhost:8088/jsp/score2.jsp 就可以让request也变成null 如果关闭浏览器，这里指的是关闭浏览器而不是只关闭浏览器的那个页面，然后再访问一次http://localhost:8088/jsp/score2.jsp 这样session就会消失了 重启或者重新部署服务器就会让application变为null jsp中out和response.getWriter输出的区别response 中表示响应，我们经常用于设置返回给客户端的内容（输出） out 也是给用户做输出使用的。 由于 jsp 翻译之后，底层源代码都是使用 out 来进行输出，所以一般情况下。我们在 jsp 页面中统一使用 out 来进行输出。避 免打乱页面输出内容的顺序 out.write() 输出字符串没有问题 out.print() 输出任意数据都没有问题（都转换成为字符串后调用的 write 输出 深入源码，浅出结论：在 jsp 页面中，可以统一使用 out.print()来进行输 这个就是out输出一 out输出二 response输出1 response输出2 12345678&lt;% out.write(&quot;out输出一&quot;); out.write(&quot;out输出二&quot;); out.flush(); response.getWriter().write(&quot;respose输出1&quot;); response.getWriter().write(&quot;response输出2&quot;);%&gt; 下面的这个规则对out的print方法依然适用 就是两个对象的write方法都能把自己分别写入自己的缓冲区 有out.flush方法就把out缓冲区中的追加到response缓冲区，就算没有out.flush，在页面代码执行完成（也就是response write的都写进了response缓冲区）自动把out缓冲区中的追加到response缓冲区 然后执行response刷新，把全部数据给客户端 jsp常用标签jsp静态包含示例说明： &lt;%@ include file&#x3D;””%&gt; 就是静态包含 file 属性指定你要包含的 jsp 页面的路径 地址中第一个斜杠 &#x2F; 表示为 http://ip:port/工程路径/ 映射到代码的 web 目录 1&lt;%@ include file=&quot;/include/foot.jsp&quot;%&gt; 在main.jsp中包含foot.jsp文件 这样访问main.jsp的时候也可以看到foot.jsp中的内容 静态包含的特点： ​ 1、静态包含不会翻译被包含的 jsp 页面。 ​ 2、静态包含其实是把被包含的 jsp 页面的代码拷贝到包含的位置执行输出 jsp动态包含 这是动态包含 1&lt;jsp:include page=&quot;&quot;&gt;&lt;/jsp:include&gt; page 属性是指定你要包含的 jsp 页面的路径 动态包含也可以像静态包含一样。把被包含的内容执行输出到包含位置 动态包含的特点： 1、动态包含会把包含的 jsp 页面也翻译成为 java 代码 2、动态包含底层代码使用如下代码去调用被包含的 jsp 页面执行输出。 ​ JspRuntimeLibrary.include(request, response, “&#x2F;include&#x2F;footer.jsp”, out, false); 3、动态包含，还可以传递参数 动态包含的原理是：main.jsp把自己的对象都传递给了footer.jsp页面，所以而这用的是一个out对象 main.jsp 12345678910111213141516171819202122232425262728&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 13:01 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;头部信息&lt;br/&gt;主体信息&lt;br/&gt;//静态包含&lt;%@ include file=&quot;/include/foot.jsp&quot;%&gt;//动态包含&lt;%--可以向foot.jsp传递参数，在foot.jsp页面中获取，因为都是用的一个request对象--%&gt;&lt;jsp:include page=&quot;/include/foot.jsp&quot;&gt; &lt;jsp:param name=&quot;username&quot; value=&quot;admin&quot;/&gt; &lt;jsp:param name=&quot;password&quot; value=&quot;admin&quot;/&gt;&lt;/jsp:include&gt;&lt;/body&gt;&lt;/html&gt; foot.jsp 1234567891011121314151617181920&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 13:04 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;页脚信息&lt;br/&gt;//获取main.jsp传来的参数&lt;%=request.getParameter(&quot;username&quot;)%&gt;&lt;%=request.getParameter(&quot;password&quot;)%&gt;&lt;/body&gt;&lt;/html&gt; 请求转发1&lt;jsp:forward page=&quot;&quot;&gt;&lt;/jsp:forward&gt; 是请求转发标签，它的功能就是请求转发 page 属性设置请求转发的路径 12&lt;%--请求转发--%&gt;&lt;jsp:forward page=&quot;/score2.jsp&quot;&gt;&lt;/jsp:forward&gt; 跳转到访问score2.jsp，显示score2.jsp内容 jsp练习题总结： &lt;% %&gt;代码脚本中 不要有表达式脚本或者声明脚本，也不要有html标签 html标签中可以有表达式脚本或者代码脚本 而且 到可以是看作一行，就是用来换行的标志 jsp页面中输出九九乘法表123456789101112131415161718192021222324252627282930313233343536&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 13:36 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; table&#123; width:600px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 align=&quot;center&quot;&gt;九九乘法口诀表&lt;/h1&gt;&lt;table border=&quot;1&quot;&gt;&lt;%for(int i=1;i&lt;=9;i++)&#123; %&gt;&lt;tr&gt;&lt;%for(int j=1;j&lt;=i;j++)&#123;%&gt; &lt;td&gt;&lt;%=i+&quot;*&quot;+j+&quot;=&quot;+i*j%&gt;&lt;/td&gt;&lt;%&#125;%&gt; &lt;tr/&gt;&lt;%&#125;%&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 遍历输出10个学生信息到表格中Student类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.atguigu.pojo;public class Student &#123; private Integer id; private String name; private Integer age; private String phone; public Student() &#123; &#125; public Student(Integer id, String name, Integer age, String phone) &#123; this.id = id; this.name = name; this.age = age; this.phone = phone; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, phone=&#x27;&quot; + phone + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;%@ page import=&quot;com.atguigu.pojo.Student&quot; %&gt;&lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt;&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 13:56 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; table&#123; border:1px black solid; width:600px; border-collapse: collapse; &#125; td,th&#123; border:1px black solid; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;% ArrayList&lt;Student&gt; studentArrayList = new ArrayList&lt;Student&gt;(); for(int i=0;i&lt;10;i++)&#123; int t=i+1; studentArrayList.add(new Student(t,&quot;name&quot;,18+t,&quot;phone&quot;+t)); &#125;%&gt;&lt;table border=&quot;1px&quot;&gt; &lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;手机号&lt;/td&gt; &lt;/tr&gt; &lt;%for(int i=0;i&lt;10;i++)&#123; int id=studentArrayList.get(i).getId(); String name=studentArrayList.get(i).getName(); int age=studentArrayList.get(i).getAge(); String phone=studentArrayList.get(i).getPhone(); %&gt; &lt;tr&gt; &lt;td&gt;&lt;%=id%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=name%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=age%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=phone%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;%&#125;%&gt;&lt;/table&gt;&lt;%%&gt;&lt;/body&gt;&lt;/html&gt; 请求转发的使用说明（第二个练习的优化）Servlet不太适合将查到的学生信息回传到客户端，所以改用jsp SearchStudentServlet程序 12345678910111213141516171819202122232425262728package com.atguigu.servlet;import com.atguigu.pojo.Student;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.ArrayList;public class SearchStudentServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求的参数 //发sql语句查询学生的信息 //使用for循环代替前面两步 ArrayList&lt;Student&gt; studentArrayList = new ArrayList&lt;Student&gt;(); for(int i=0;i&lt;10;i++)&#123; int t=i+1; studentArrayList.add(new Student(t,&quot;name&quot;,18+t,&quot;phone&quot;+t)); &#125; //保存查询到的结果到request域中 req.setAttribute(&quot;stuList&quot;,studentArrayList); //请求转发到showStudent.jsp页面 req.getRequestDispatcher(&quot;/test/test2.jsp&quot;).forward(req,resp); &#125;&#125; test2.jsp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;%@ page import=&quot;com.atguigu.pojo.Student&quot; %&gt;&lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt;&lt;%@ page import=&quot;java.util.List&quot; %&gt;&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 13:56 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; table&#123; border:1px black solid; width:600px; border-collapse: collapse; &#125; td,th&#123; border:1px black solid; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;% List&lt;Student&gt; studentList=(List&lt;Student&gt;)request.getAttribute(&quot;stuList&quot;);%&gt;&lt;table border=&quot;1px&quot;&gt; &lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;手机号&lt;/td&gt; &lt;/tr&gt; &lt;%for(int i=0;i&lt;10;i++)&#123; int id=studentList.get(i).getId(); String name=studentList.get(i).getName(); int age=studentList.get(i).getAge(); String phone=studentList.get(i).getPhone(); %&gt; &lt;tr&gt; &lt;td&gt;&lt;%=id%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=name%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=age%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=phone%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;%&#125;%&gt;&lt;/table&gt;&lt;%%&gt;&lt;/body&gt;&lt;/html&gt; Listener监听器1、Listener 监听器它是 JavaWeb 的三大组件之一。JavaWeb 的三大组件分别是：Servlet 程序、Filter 过滤器、Listener 监 听器。 2、Listener 它是 JavaEE 的规范，就是接口 3、监听器的作用是，监听某种事物的变化。然后通过回调函数，反馈给客户（程序）去做一些相应的处理。 ServletContextListener监听器ServletContextListener 它可以监听 ServletContext 对象的创建和销毁 ServletContext 对象在 web 工程启动的时候创建，在 web 工程停止的时候销毁。 监听到创建和销毁之后都会分别调用 两个方法分别是： 1234567891011121314151617181920//// Source code recreated from a .class file by IntelliJ IDEA// (powered by FernFlower decompiler)//package javax.servlet;import java.util.EventListener;public interface ServletContextListener extends EventListener &#123;/*这个方法在ServletContext对象创建之后调用，做初始化*/ void contextInitialized(ServletContextEvent var1);/*这个方法在ServletContext对象销毁之后调用*/ void contextDestroyed(ServletContextEvent var1);&#125; 如何使用 ServletContextListener 监听器监听 ServletContext 对象。 使用步骤如下： ​ 1、编写一个类去实现 ServletContextListener ​ 2、实现其两个回调方法 ​ 3、到 web.xml 中去配置监听器 EL表达式EL 表达式的全称是：Expression Language。是表达式语言。 EL 表达式的什么作用：EL 表达式主要是代替 jsp 页面中的表达式脚本在 jsp 页面中进行数据的输出。 因为 EL 表达式在输出数据的时候，要比 jsp 的表达式脚本要简洁很多 1234567891011121314151617181920212223&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 15:08 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;jsp的用法&lt;% request.setAttribute(&quot;key&quot;,&quot;值&quot;);%&gt;表达式输出key的值是&lt;%=request.getAttribute(&quot;key1&quot;)%&gt;EL表达式输出key的值$&#123;key1&#125;&lt;/body&gt;&lt;/html&gt; EL 表达式的格式是：${表达式} EL 表达式在输出 null 值的时候，输出的是空串。jsp 表达式脚本输出 null 值的时候，输出的是 null 字符串。 EL表达式搜索域数据的顺序EL 表达式主要是在 jsp 页面中输出数据。 主要是输出域对象中的数据。 当四个域中都有相同的 key 的数据的时候，EL 表达式会按照四个域的从小到大的顺序去进行搜索，找到就输出。 pageContext&#x3D;&#x3D;》requst&#x3D;&#x3D;》session&#x3D;&#x3D;》application 123456789101112131415161718192021222324&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 15:17 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% //往四个域中都保存了相同的key的数据 request.setAttribute(&quot;key&quot;,&quot;request&quot;); session.setAttribute(&quot;key&quot;,&quot;session&quot;); application.setAttribute(&quot;key&quot;,&quot;application&quot;); pageContext.setAttribute(&quot;key&quot;,&quot;pageContext&quot;);%&gt;$&#123;key&#125;&lt;/body&gt;&lt;/html&gt; EL 表达式输出 Bean 的普通属性，数组属性。List 集 合属性，map 集合属性i. 需求——输出 Person 类中普通属性，数组属性。list 集合属性和 map Person类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.atguigu.pojo;import java.util.Arrays;import java.util.List;import java.util.Map;public class Person &#123; private int age=18; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String[] getPhones() &#123; return phones; &#125; public void setPhones(String[] phones) &#123; this.phones = phones; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&quot; + name + &quot;, phones=&quot; + Arrays.toString(phones) + &quot;, cities=&quot; + cities + &quot;, map=&quot; + map + &#x27;&#125;&#x27;; &#125; public List&lt;String&gt; getCities() &#123; return cities; &#125; public void setCities(List&lt;String&gt; cities) &#123; this.cities = cities; &#125; public Map&lt;String, Object&gt; getMap() &#123; return map; &#125; public void setMap(Map&lt;String, Object&gt; map) &#123; this.map = map; &#125; private String name; public Person(String name, String[] phones, List&lt;String&gt; cities, Map&lt;String, Object&gt; map) &#123; this.name = name; this.phones = phones; this.cities = cities; this.map = map; &#125; public Person() &#123; &#125; private String[] phones; private List&lt;String&gt; cities; private Map&lt;String,Object&gt; map;&#125; c.jsp文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;%@ page import=&quot;com.atguigu.pojo.Person&quot; %&gt;&lt;%@ page import=&quot;java.util.List&quot; %&gt;&lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt;&lt;%@ page import=&quot;java.util.HashMap&quot; %&gt;&lt;%@ page import=&quot;java.util.Map&quot; %&gt;&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 15:29 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% Person person = new Person(); person.setName(&quot;国哥好帅！&quot;); person.setPhones(new String[]&#123;&quot;18610541354&quot;,&quot;18688886666&quot;,&quot;18699998888&quot;&#125;); List&lt;String&gt; cities = new ArrayList&lt;String&gt;(); cities.add(&quot;北京&quot;); cities.add(&quot;上海&quot;); cities.add(&quot;深圳&quot;); person.setCities(cities); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;key1&quot;,&quot;value1&quot;); map.put(&quot;key2&quot;,&quot;value2&quot;); map.put(&quot;key3&quot;,&quot;value3&quot;); person.setMap(map); pageContext.setAttribute(&quot;p&quot;,person);%&gt;输出 Person $&#123;p&#125;&lt;br/&gt;输出 Person 的 name 属性：$&#123;p.name&#125; &lt;br&gt;输出 Person 的 phones 数组属性值：$&#123;p.phones[2]&#125; &lt;br&gt;输出 Person 的 cities 集合中的元素值：$&#123;p.cities&#125; &lt;br&gt;输出 Person 的 List 集合中个别元素值：$&#123;p.cities[2]&#125; &lt;br&gt;输出 Person 的 Map 集合: $&#123;p.map&#125;&lt;br&gt;输出 Person 的 Map 集合中某个 key 的值: $&#123;p.map.key1&#125; &lt;br&gt;输出 Person 的 age 属性： $&#123;p.age&#125;&lt;br&gt; 输出Person的Map集合中所有的值 :$&#123;p.map.values()&#125;&lt;/body&gt;&lt;/html&gt; EL表达式在查找属性的时候其实是通过get方法来查找，所以即使你没有age属性，只要有getAge()方法就可以了 EL表达式运算关系运算 123456789101112131415161718192021222324252627282930313233&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 15:56 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;12==12&#125;&lt;br/&gt;或$&#123;12 eq 12&#125;&lt;br/&gt;$&#123;12!=12&#125;&lt;br/&gt;$&#123;12 ne 12&#125;&lt;br/&gt;$&#123;12&lt;12&#125;&lt;br/&gt;$&#123;12 lt 12&#125;&lt;br/&gt;$&#123;12&gt;12&#125;&lt;br/&gt;$&#123;12 gt 12&#125;&lt;br/&gt;$&#123;12&gt;=12&#125;&lt;br/&gt;$&#123;12 ge 12&#125;&lt;br/&gt;$&#123;12&lt;=12&#125;&lt;br/&gt;$&#123;12 le 12&#125;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 逻辑运算 1234$&#123;12==12&amp;&amp;12&gt;11&#125;&lt;br/&gt;$&#123;12==12 and 12&gt;11&#125;&lt;br/&gt;$&#123;! true&#125;&lt;br/&gt;$&#123;not true&#125;&lt;br/&gt; 算数运算 empty运算empty 运算可以判断一个数据是否为空，如果为空，则输出 true,不为空输出 false。 以下几种情况为空： 1、值为 null 值的时候，为空 2、值为空串的时候，为空 3、值是 Object 类型数组，长度为零的时候 4、list 集合，元素个数为零 5、map 集合，元素个数为零 12345678910111213141516171819202122232425262728293031323334353637&lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt;&lt;%@ page import=&quot;java.util.List&quot; %&gt;&lt;%@ page import=&quot;java.util.HashMap&quot; %&gt;&lt;%@ page import=&quot;java.util.Map&quot; %&gt;&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 16:52 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% //1、值为 null 值的时候，为空request.setAttribute(&quot;emptyNull&quot;,null); //2、值为空串的时候，为空 request.setAttribute(&quot;emptyStr&quot;,&quot;&quot;); //3、值是 Object 类型数组，长度为零的时候 request.setAttribute(&quot;emptyArr&quot;,new Object[]&#123;&#125;); //4、list 集合，元素个数为零List&lt;String&gt; list=new ArrayList&lt;String&gt;();list.add(&quot;abc&quot;); request.setAttribute(&quot;emptyList&quot;,list); //5、map 集合，元素个数为零 Map&lt;String,Object&gt; map=new HashMap&lt;String,Object&gt;();%&gt;$&#123;empty emptyNull&#125;&lt;br/&gt;$&#123;empty emptyStr&#125;&lt;br/&gt;$&#123;empty emptyArr&#125;&lt;br/&gt;$&#123;empty emptyList&#125;&lt;br/&gt;$&#123;empty emptyMap&#125;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 三元运算表达式 1？表达式 2：表达式 3 如果表达式 1 的值为真，返回表达式 2 的值，如果表达式 1 的值为假，返回表达式 3 的值 实例 1$&#123; 12 != 12 ? &quot;国哥帅呆&quot;:&quot;国哥又骗人啦&quot; &#125; “.”点运算 和 [] 中括号运算.点运算，可以输出 Bean 对象中某个属性的值。 []中括号运算，可以输出有序集合中某个元素的值。 并且[]中括号运算，还可以输出 map 集合中 key 里含有特殊字符的 key 的值。 1234567891011121314151617181920212223242526&lt;%@ page import=&quot;java.util.HashMap&quot; %&gt;&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 17:03 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;a.a.a&quot;,&quot;aaaValue&quot;); map.put(&quot;b+b+b&quot;,&quot;bbbValue&quot;); map.put(&quot;c-c-c&quot;,&quot;cccValue&quot;); request.setAttribute(&quot;map&quot;,map);%&gt;$&#123;map[&quot;a.a.a&quot;]&#125;&lt;br/&gt;$&#123;map[&quot;b+b+b&quot;]&#125;&lt;br/&gt;$&#123;map[&quot;c-c-c&quot;]&#125;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 这两个前面用到过一次输出bean普通属性时 但如果map的key中有.这种特殊字符，就不能用map.key 可以用map[“key”] EL表达式中的11个隐含对象EL 个达式中 11 个隐含对象，是 EL 表达式中自己定义的，可以直接使用 initParam Map&lt;String,String&gt; 它可以获取在 web.xml 中配置的上下文参数 EL获取四个特定域中的属性pageScope &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; pageContext域 requestScope &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; request域 sessionScope &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; session域 applicationScope &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ServletContext域 12345678910111213141516171819202122232425262728293031&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 17:22 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% pageContext.setAttribute(&quot;key1&quot;,&quot;pageContext1&quot;); pageContext.setAttribute(&quot;key2&quot;,&quot;pageContext2&quot;); request.setAttribute(&quot;key2&quot;,&quot;request&quot;); session.setAttribute(&quot;key2&quot;,&quot;session&quot;); application.setAttribute(&quot;key2&quot;,&quot;application&quot;);%&gt;&lt;%--输出pageContext域中的属性--%&gt;&lt;%--如果多个域中只有一个key1，可以直接$&#123;key1&#125; 但是如果两个域中都由key1属性，就可以通过$&#123;内置对象.key1&#125;来调用你想要的--%&gt;$&#123;pageScope.key1&#125;&lt;br/&gt;$&#123;pageScope.key2&#125;&lt;br/&gt;$&#123;requestScope.key2&#125;&lt;br/&gt;$&#123;sessionScope.key2&#125;&lt;br/&gt;$&#123;applicationScope.key2&#125;;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; pageContext演示可以获取jsp中的九大内置对象 协议： 服务器 ip： 服务器端口： 获取工程路径： 获取请求方法： 获取客户端 ip 地址： 获取会话的 id 编号 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 17:35 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--jsp中的内置对象request.getScheme()它可以获取请求的协议--%&gt;&lt;%--request.getScheme() 它可以获取请求的协议request.getServerName() 获取请求的服务器 ip 或域名request.getServerPort() 获取请求的服务器端口号request.getContextPath() 获取当前工程路径request.getMethod() 获取请求的方式（GET 或 POST）request.getRemoteHost() 获取客户端的 ip 地址session.getId() 获取会话的唯一标识--%&gt;&lt;%=request.getScheme()%&gt;&lt;%--用pageContext.request.scheme其实就和调用getScheme方法是一样的--%&gt;1. 协议：$&#123;pageContext.request.scheme&#125;&lt;br/&gt;2. 服务器 ip：$&#123;pageContext.request.serverName&#125;&lt;br/&gt;3. 服务器端口：$&#123;pageContext.request.serverPort&#125;&lt;br/&gt;4. 获取工程路径：$&#123;pageContext.request.contextPath&#125;&lt;br/&gt;5. 获取请求方法：$&#123;pageContext.request.method&#125;&lt;br/&gt;6. 获取客户端 ip 地址： $&#123;pageContext.request.remoteHost&#125;&lt;br/&gt;7. 获取会话的 id 编号 $&#123;pageContext.session.id&#125; &lt;br/&gt;&lt;%--简洁的写法--%&gt;&lt;% pageContext.setAttribute(&quot;req&quot;,request);%&gt;&lt;%--获取协议--%&gt;$&#123;req.scheme&#125;&lt;/body&gt;&lt;/html&gt; 其他EL隐含对象的事例param Map 它可以获取请求参数的值 Map&lt;String,String&gt; paramValues Map&lt;String,String[]&gt; 它也可以获取请求参数的值，获取多个值的时候使用 请求地址 1http://localhost:8084/eljstl/other.jsp?username=1&amp;password=2&amp;hobby=1&amp;hobby=2 123456789101112131415161718192021&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 18:30 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;param.username&#125;&lt;br/&gt;$&#123;param.password&#125;&lt;br/&gt;$&#123;paramValues.username[0]&#125;&lt;br/&gt;$&#123;paramValues.password[0]&#125;&lt;br/&gt;$&#123;paramValues.hobby[0]&#125;&lt;br/&gt;$&#123;paramValues.hobby[1]&#125;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; header Map 它可以获取请求头的信息 headerValues Map 它可以获取请求头的信息，它可以获取多个值的情况 12345678910111213141516171819&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 18:30 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--因为User-Agent的- 是特殊字符--%&gt;$&#123;header[&#x27;User-Agent&#x27;]&#125;&lt;br/&gt;$&#123;header.Connection&#125;&lt;br/&gt;$&#123;headerValues[&#x27;User-Agent&#x27;][0]&#125;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; cookie Map &lt;String,Cookie&gt; 它可以获取当前请求的 Cookie 信息 1234567891011121314151617&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 18:30 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;获取cookie的名称:$&#123;cookie.JSESSIONID.name&#125;&lt;br/&gt;获取Cookie的值：$&#123;cookie.JSESSIONID.value&#125;&lt;/body&gt;&lt;/html&gt; initParam Map&lt;String,String&gt; 它可以获取在web.xml中配置的上下文参数 在web.xml文件中添加这个 修改配置web.xml这种文件需要重新部署才能生效 1234&lt;context-param&gt; &lt;param-name&gt;url&lt;/param-name&gt; &lt;param-value&gt;jdbc:mysql://test&lt;/param-value&gt;&lt;/context-param&gt; 12345678910111213&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;initParam&#125;输出&amp;lt;Context-param&amp;gt;username的值：$&#123;initParam.username&#125;输出&amp;lt;Context-param&amp;gt;url的值：$&#123;initParam.url&#125;&lt;/body&gt;&lt;/html&gt; JSTL标签库JSTL 标签库 全称是指 JSP Standard Tag Library JSP 标准标签库。是一个不断完善的开放源代码的 JSP 标 签库。 EL 表达式主要是为了替换 jsp 中的表达式脚本，而标签库则是为了替换代码脚本。这样使得整个 jsp 页面 变得更佳简洁 JSTL标签库的使用步骤先导入jstl的jar包 1、先导入 jstl 标签库的 jar 包。 taglibs-standard-impl-1.2.1.jar taglibs-standard-spec-1.2.1.jar 2、第二步，使用 taglib 1&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 用自动补全代码的时候，这个会自动导入进来 core核心库的使用i. &lt;c:set &#x2F;&gt;（使用很少） 作用：set 标签可以往域中保存数据 12345678910111213141516171819202122232425262728293031323334&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/3 Time: 15:30 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--i.&lt;c:set /&gt;作用：set 标签可以往域中保存数据以前保存域数据域对象.setAttribute(key,value);scope 属性设置保存到哪个域page 表示 PageContext 域（默认值）request 表示 Request 域session 表示 Session 域application 表示 ServletContext 域var 属性设置 key 是多少value 属性设置值--%&gt;保存之前:$&#123;requestScope.abc&#125;&lt;br/&gt;&lt;c:set scope=&quot;request&quot; var=&quot;abc&quot; value=&quot;abcValue&quot;/&gt;保存之后:$&#123;requestScope.abc&#125;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; ii .&lt;c:if &#x2F;&gt; if 标签用来做 if 判断。 12345678910111213141516ii.&lt;c:if /&gt;if 标签用来做 if 判断。test 属性表示判断的条件（使用 EL 表达式输出）--%&gt;&lt;c:if test=&quot;$&#123;12==12&#125;&quot;&gt; &lt;h1&gt;无敌&lt;/h1&gt;&lt;/c:if&gt;&lt;c:if test=&quot;$&#123;12!=12&#125;&quot;&gt; &lt;h1&gt;无敌&lt;/h1&gt;&lt;/c:if&gt; iii.&lt;c:choose&gt; &lt;c:when&gt; &lt;c:otherwise&gt;标签 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/3 Time: 15:30 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--i.&lt;c:set /&gt;作用：set 标签可以往域中保存数据以前保存域数据域对象.setAttribute(key,value);scope 属性设置保存到哪个域page 表示 PageContext 域（默认值）request 表示 Request 域session 表示 Session 域application 表示 ServletContext 域var 属性设置 key 是多少value 属性设置值--%&gt;保存之前:$&#123;requestScope.abc&#125;&lt;br/&gt;&lt;c:set scope=&quot;request&quot; var=&quot;abc&quot; value=&quot;abcValue&quot;/&gt;保存之后:$&#123;requestScope.abc&#125;&lt;br/&gt;&lt;%--ii.&lt;c:if /&gt;if 标签用来做 if 判断。test 属性表示判断的条件（使用 EL 表达式输出）--%&gt;&lt;c:if test=&quot;$&#123;12==12&#125;&quot;&gt; &lt;h1&gt;无敌&lt;/h1&gt;&lt;/c:if&gt;&lt;c:if test=&quot;$&#123;12!=12&#125;&quot;&gt; &lt;h1&gt;无敌&lt;/h1&gt;&lt;/c:if&gt;&lt;%--iii.&lt;c:choose&gt; &lt;c:when&gt; &lt;c:otherwise&gt;标签作用：多路判断。跟 switch ... case .... default 非常接近choose 标签开始选择判断when 标签表示每一种判断情况test 属性表示当前这种判断情况的值otherwise 标签表示剩下的情况&lt;hr/&gt;&lt;c:choose&gt; &lt;c:when&gt; &lt;c:otherwise&gt;标签使用时需要注意的点：1、标签里不能使用 html 注释，要使用 jsp 注释2、when 标签的父标签一定要是 choose 标签--%&gt;&lt;% request.setAttribute(&quot;height&quot;,178);%&gt;&lt;c:choose&gt; &lt;c:when test=&quot;$&#123;requestScope.height&gt;190&#125;&quot;&gt; &lt;h1&gt;是巨人&lt;/h1&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;requestScope.height&gt;180&#125;&quot;&gt; &lt;h1&gt;小巨人&lt;/h1&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;requestScope.height&gt;170&#125;&quot;&gt; &lt;h1&gt;还行&lt;/h1&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;requestScope.height&gt;160&#125;&quot;&gt; &lt;h1&gt;有点矮&lt;/h1&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;c:choose&gt; &lt;c:when test=&quot;$&#123;requestScope.height&gt;150&#125;&quot;&gt; &lt;h1&gt;xiaoren&lt;/h1&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;requestScope.height&gt;140&#125;&quot;&gt; &lt;h1&gt;xiaoren2&lt;/h1&gt; &lt;/c:when&gt; &lt;/c:choose&gt; &lt;/c:otherwise&gt;&lt;/c:choose&gt;&lt;/body&gt;&lt;/html&gt; test中是要判断的条件，otherwise是这些都不符合之后执行的，这些when标签和otherwise标签执行一个，其他的就不能执行 如果想要在otherwise标签中再使用when标签就要加上choose c：foreach 标签 遍历1到10 12345678910111213&lt;%--1.遍历 1 到 10，输出begin 属性设置开始的索引end 属性设置结束的索引var 属性表示循环的变量(也是当前正在遍历到的数据)for (int i = 1; i &lt; 10; i++)--%&gt;&lt;table border=&quot;1&quot;&gt;&lt;c:forEach begin=&quot;1&quot; end=&quot;100&quot; var=&quot;i&quot;&gt; &lt;tr&gt; &lt;td&gt;第$&#123;i&#125;行&lt;td/&gt; &lt;tr/&gt; &lt;/c:forEach&gt;&lt;/table&gt; 遍历Object类型的数组 1234567891011&lt;%-- 2.遍历 Object 数组for (Object item: arr)items 表示遍历的数据源（遍历的集合）var 表示当前遍历到的数据--%&gt;&lt;% request.setAttribute(&quot;arr&quot;,new String[]&#123;&quot;18888&quot;,&quot;166666&quot;&#125;);%&gt;&lt;c:forEach items=&quot;$&#123;requestScope.arr&#125;&quot; var=&quot;item&quot;&gt; $&#123;item&#125;&lt;br/&gt;&lt;/c:forEach&gt; 遍历Map集合 1234567891011121314&lt;% Map&lt;String,Object&gt; map=new HashMap&lt;String,Object&gt;(); map.put(&quot;key1&quot;,&quot;value1&quot;); map.put(&quot;key2&quot;,&quot;value2&quot;); map.put(&quot;key3&quot;,&quot;value3&quot;); // for ( Map.Entry&lt;String,Object&gt; entry : map.entrySet()) &#123;// &#125; request.setAttribute(&quot;map&quot;,map);%&gt;&lt;c:forEach items=&quot;$&#123;requestScope.map&#125;&quot; var=&quot;entry&quot;&gt; &lt;h1&gt;$&#123;entry&#125;&lt;/h1&gt; &lt;h1&gt;$&#123;entry.key&#125;&lt;/h1&gt; &lt;h2&gt;$&#123;entry.value&#125;&lt;/h2&gt;&lt;/c:forEach&gt; entry是map中的一个元素 entry.key是map中一个元素的key值 entry.value是map中一个元素的value值 遍历List集合–list 中存放 Student 类，有属性：编号，用户名，密码，年龄， 电话信息 1234567891011121314151617181920212223242526272829303132333435&lt;%--4.遍历 List 集合---list 中存放 Student 类，有属性：编号，用户名，密码，年龄，电话信息--%&gt;&lt;% List&lt;Student&gt; studentArraylist = new ArrayList&lt;Student&gt;(); for(int i=0;i&lt;10;i++) studentArraylist.add(new Student(i,i+&quot;username&quot;,i+&quot;password&quot;,i+18,i+&quot;1&quot;)); request.setAttribute(&quot;list&quot;,studentArraylist);%&gt;&lt;table&gt;&lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;username&lt;/td&gt; &lt;td&gt;password&lt;/td&gt; &lt;td&gt;age&lt;/td&gt; &lt;td&gt;phone&lt;/td&gt; &lt;td&gt;step&lt;/td&gt;&lt;/tr&gt; &lt;%--items 表示遍历的集合var 表示遍历到的数据--%&gt;&lt;c:forEach items=&quot;$&#123;requestScope.list&#125;&quot; var=&quot;stu&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;stu.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.username&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.password&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.phone&#125;&lt;/td&gt; &lt;td&gt;删除修改&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt;&lt;/table&gt; foreach标签组合使用 上面的图片是status可以获取到的东西 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;%@ page import=&quot;java.util.HashMap&quot; %&gt;&lt;%@ page import=&quot;java.util.Map&quot; %&gt;&lt;%@ page import=&quot;com.atguigu.pojo.Student&quot; %&gt;&lt;%@ page import=&quot;java.util.List&quot; %&gt;&lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/3 Time: 16:11 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--4.遍历 List 集合---list 中存放 Student 类，有属性：编号，用户名，密码，年龄，电话信息--%&gt;&lt;% List&lt;Student&gt; studentArraylist = new ArrayList&lt;Student&gt;(); for(int i=0;i&lt;10;i++) studentArraylist.add(new Student(i,i+&quot;username&quot;,i+&quot;password&quot;,i+18,i+&quot;1&quot;)); request.setAttribute(&quot;list&quot;,studentArraylist);%&gt;&lt;table&gt;&lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;username&lt;/td&gt; &lt;td&gt;password&lt;/td&gt; &lt;td&gt;age&lt;/td&gt; &lt;td&gt;phone&lt;/td&gt; &lt;td&gt;step&lt;/td&gt;&lt;/tr&gt; &lt;%-- items 表示遍历的集合 var 表示遍历到的数据 begin 表示遍历的开始索引值 end 表示结束的索引值 step 属性表示遍历的步长值 varStatus 属性表示当前遍历到的数据的状态 for（int i = 1; i &lt; 10; i+=2） --%&gt;&lt;c:forEach begin=&quot;2&quot; end=&quot;7&quot; step=&quot;2&quot; varStatus=&quot;status&quot; items=&quot;$&#123;requestScope.list&#125;&quot; var=&quot;stu&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;stu.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.username&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.password&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.phone&#125;&lt;/td&gt; &lt;td&gt;$&#123;status.current&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; varStatus 属性表示当前遍历到的数据的状态 这个是status能够获得的状态 status.current status.first status.end 这样去用 文件的上传和下载文件的上传和下载，是非常常见的功能。 很多的系统中，或者软件中都经常使用文件的上传和下载。 比如：QQ 头像，就使用了上传。 邮箱中也有附件的上传和下载功能。 OA 系统中审批有附件材料的上传。 文件上传的介绍1、要有一个 form 标签，method&#x3D;post 请求 因为get请求有长度限制，所以使用post请求 2、form 标签的 encType 属性值必须为 multipart&#x2F;form-data 值 3、在 form 标签中使用 input type&#x3D;file 添加上传的文件 4、编写服务器代码（Servlet 程序）接收，处理上传的数据。 encType&#x3D;multipart&#x2F;form-data 表示提交的数据，以多段（每一个表单项一个数据段）的形式进行拼 接，然后以二进制流的形式发送给服务器 上传文件的表单 123456789101112131415161718192021&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/3 Time: 20:56 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt; 头像 &lt;input type=&quot;file&quot; name=&quot;photo&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; username是用户名，就是表单中提交的东西，如果还提交了密码或者别的，都会在请求体中以分段的形式出现 请求体中每一个数据段都是一个表单中的项 &#x3D; 要用下面这种流的格式来获取post传的值，基本就是请求体的内容 123456789101112131415161718192021222324252627package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class UploadServlet extends HttpServlet &#123; /** * 用来处理文件上传 * @param req * @param resp * @throws ServletException * @throws IOException */ @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;文件上传&quot;); ServletInputStream inputStream = req.getInputStream(); byte[] buffer=new byte[1024000]; int read=inputStream.read(buffer); System.out.println(new String(buffer,0,read)); &#125;&#125; 文件上传中获取其他表单项也都不能用getParameter的方法 文件上传用到的类和方法commons-fileupload.jar 常用 API 介绍说明 commons-fileupload.jar 需要依赖 commons-io.jar 这个包，所以两个包我们都要引入。 第一步，就是需要导入两个 jar 包： commons-fileupload-1.2.1.jar commons-io-1.4.jar commons-fileupload.jar 和 commons-io.jar 包中，我们常用的类有哪些？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.IOException;import java.util.List;import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.FileItemFactory;import org.apache.commons.fileupload.FileUploadException;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;public class UploadServlet extends HttpServlet &#123; /** * 用来处理文件上传 * @param req * @param resp * @throws ServletException * @throws IOException */ @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.先判断上传的数据是否是多段数据，只有是多端的数据才可能是文件上传的 if(ServletFileUpload.isMultipartContent(req))&#123; //创建FileItemFactory工厂实现类 FileItemFactory fileItemFactory=new DiskFileItemFactory(); //创建用于解析上传数据的工具类ServletFileUpload ServletFileUpload servletFileUpload=new ServletFileUpload(fileItemFactory); try &#123; //解析上传的数据，得到一个表单项FileItem List&lt;FileItem&gt; list=servletFileUpload.parseRequest(req); //循环判断每一个表单项是上传的文件还是普通类型 for(FileItem fileItem:list)&#123; if(fileItem.isFormField())&#123; //普通表单项 System.out.println(&quot;表单项的name属性值&quot;+fileItem.getFieldName()); //UTF-8是为了防止出现乱码 System.out.println(&quot;表单项的value属性&quot;+fileItem.getString(&quot;UTF-8&quot;)); &#125; else &#123; //上传的文件 System.out.println(&quot;表单项的name属性值&quot;+fileItem.getFieldName()); System.out.println(&quot;表单项的value属性&quot;+fileItem.getName()); //将上传的文件写入e盘 fileItem.write(new File(&quot;e:\\\\&quot;+fileItem.getName())); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 文件下载getResourceAsStream中的路径只有两种写法 最前面是’&#x2F;‘ 说明是工程目录下可以映射到web目录下 最前面没有’&#x2F;‘ 说明是默认从src目录开始 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.atguigu.servlet;import org.apache.commons.io.IOUtils;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;public class Download extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.获取要下载的文件名 String downloadFilename=&quot;1.jpg&quot;; //2.读取要下载的文件内容（通过ServletContext对象可以读取） ServletContext servletContext=getServletContext(); // 获取要下载的文件类型 String mimeType = servletContext.getMimeType(&quot;/File/&quot; + downloadFilename); System.out.println(&quot;下载的文件类型&quot;+mimeType); //4.在回传前，通过响应头告诉客户端返回的数据类型 resp.setContentType(mimeType); //5.还要告诉客户端收到的数据是用于下载使用(还是使用响应头) //Content-Disposition响应头，表示收到的数据怎么处理 //attachment表示附件，表示下载使用 //filename=表示指定下载的文件名 //这个filename不一定是源文件名，用自己起的也行 resp.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot;+downloadFilename); InputStream resourceAsStream=servletContext.getResourceAsStream(&quot;/File/&quot;+downloadFilename); //获取响应的输出流 OutputStream outputStream=resp.getOutputStream(); //3.把下载的文件内容回传给客户端 //读取输入流中全部的数据，赋值给输出流，输出给客户端 IOUtils.copy(resourceAsStream,outputStream); &#125;&#125; 火狐浏览器base64编码 因为火狐浏览器有点问题，所以要单独把他拿出来 书城项目第三阶段页面jsp动态化1.在html页面添加page指令 2.修改文件后缀名为.jsp 再次打开服务器访问时，需要先去除浏览器缓存，ctrl+shift+delete 3、使用 IDEA 搜索替换.html 为.jsp(快捷键：Ctrl+Shift+R 用.jsp替换文件中的.html 抽取所有jsp页面中的公共内容将下面的内容放在一个jsp文件中然后使用静态包含，引用到利用它的地方 123456&lt;div&gt; &lt;span&gt;欢迎&lt;span class=&quot;um_span&quot;&gt;韩总&lt;/span&gt;光临尚硅谷书城&lt;/span&gt; &lt;a href=&quot;order/order.jsp&quot;&gt;我的订单&lt;/a&gt; &lt;a href=&quot;index.jsp&quot;&gt;注销&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;index.jsp&quot;&gt;返回&lt;/a&gt;&lt;/div&gt; 静态包含 12 &lt;!--静态包含jsp文件--&gt;&lt;%@ include file=&quot;/pages/common/login_success_menu.jsp&quot;%&gt; 这个也是每一个文件公有的，引入css样式，jQuery库和base标签 1234 &lt;!--写base标签，永远固定相对路径的跳转结果--&gt; &lt;base href=&quot;http://localhost:8087/book2/&quot;&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;static/css/style.css&quot; &gt; &lt;script src=&quot;static/script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; 静态包含 12&lt;!--使用静态包含引入css样式jQuery和base标签--&gt; &lt;%@ include file=&quot;/pages/common/head.jsp&quot;%&gt; 页脚也是完全一样的 12&lt;!--静态包含页脚的代码--&gt;&lt;%@include file=&quot;/pages/common/footer.jsp&quot; %&gt; manager中的下面的也是一样的 12345&lt;div&gt; &lt;a href=&quot;book_manager.jsp&quot;&gt;图书管理&lt;/a&gt; &lt;a href=&quot;order_manager.jsp&quot;&gt;订单管理&lt;/a&gt; &lt;a href=&quot;../../index.jsp&quot;&gt;返回商城&lt;/a&gt;&lt;/div&gt; 动态的base标签值就是让文件的路径根据我们的输入的网址来进行改变 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;!--写base标签，永远固定相对路径的跳转结果--&gt;&lt;% String basePath=request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+request.getContextPath()+&quot;/&quot;;%&gt;&lt;%--这个最后的/是一定不能省去的--%&gt;&lt;%--这写个方法的意思写在PageContext演示标题下--%&gt;&lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt; 登录，注册错误提示，及表单回显在LoginServlet中将信息保存到request域中，方便当用户输入错误时，在jsp页面保留输入的用户名以及出现错误提示 123//把错误信息，和回显的表单项信息，保存到request域中req.setAttribute(&quot;msg&quot;,&quot;用户名或者密码错误&quot;);req.setAttribute(&quot;username&quot;,username); 这个value是为了第一次进入页面没有提交过信息的时候，那个username那一栏是空的 12&lt;input class=&quot;itxt&quot; type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; autocomplete=&quot;off&quot; tabindex=&quot;1&quot; name=&quot;username&quot;value=&quot;&lt;%=request.getAttribute(&quot;username&quot;)==null?&quot;&quot;:request.getAttribute(&quot;username&quot;)%&gt;&quot;/&gt; 这是对报错信息的修改，就是为了刚进去是请输入用户密码和用户名，如果提交信息的错误则输出报错信息 1&lt;span class=&quot;errorMsg&quot;&gt;&lt;%=request.getAttribute(&quot;msg&quot;)==null?&quot;请输入用户密码和用户名&quot;:request.getAttribute(&quot;msg&quot;)%&gt;&lt;/span&gt; 这是对登录页面的修改，在注册页面中也对username email 以及报错信息进行了类似的修改 合并LoginServlet和RegistServlet为UserServlet在实际的项目开发中，一个模块，一般只使用一个 Servlet 程序。 就是在两个jsp页面的表单中添加hidden的表单项，根据Servlet程序获取的表单项的值不同，可以判断是login还是regist继而执行对应的程序，同时两个表单的action属性改为UserServlet 12&lt;form action=&quot;UserServlet&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;login&quot;/&gt; 12&lt;form action=&quot;UserServlet&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;regist&quot;/&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.atguigu.web;import com.atguigu.pojo.User;import com.atguigu.service.UserService;import com.atguigu.service.impl.UserServiceImpl;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class UserServlet extends HttpServlet &#123; private UserService userService=new UserServiceImpl(); protected void login(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;//获取用户名和密码参数 String username=req.getParameter(&quot;username&quot;); String password=req.getParameter(&quot;password&quot;); //如果用户名或密码错误 if(userService.login(new User(null,username,password,null))==null)&#123; //把错误信息，和回显的表单项信息，保存到request域中 req.setAttribute(&quot;msg&quot;,&quot;用户名或者密码错误&quot;); req.setAttribute(&quot;username&quot;,username); req.getRequestDispatcher(&quot;/pages/user/login.jsp&quot;).forward(req,resp); &#125; //如果用户名和密码正确 else &#123; req.getRequestDispatcher(&quot;/pages/user/login_success.jsp&quot;).forward(req,resp); &#125; &#125; protected void regist(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.获取请求的参数 //这个getParameter方法是通过那个属性的name得到的 String username=req.getParameter(&quot;username&quot;); String password=req.getParameter(&quot;password&quot;); String email=req.getParameter(&quot;email&quot;); String code=req.getParameter(&quot;code&quot;); //2.检查 验证码是否正确,先把验证码写死，要求为abcde if(&quot;abcde&quot;.equalsIgnoreCase(code))&#123; //验证码正确 //检查用户名是否可用 if(userService.existsUsername(username))&#123; System.out.println(&quot;用户名&quot;+username+&quot;已存在&quot;); req.setAttribute(&quot;msg&quot;,&quot;用户名已存在&quot;); req.setAttribute(&quot;username&quot;,username); req.setAttribute(&quot;email&quot;,email); //跳回到注册页面 req.getRequestDispatcher(&quot;/pages/user/regist.jsp&quot;).forward(req,resp); &#125; else &#123; //可用 //调用Sercice保存到数据库 userService.registerUser(new User(null,username,password,email)); //注册成功后，跳转到注册成功页面 req.getRequestDispatcher(&quot;/pages/user/regist_success.jsp&quot;).forward(req,resp); &#125; &#125;else&#123; //把回显信息保存到request域中 req.setAttribute(&quot;msg&quot;,&quot;用户验证码错误&quot;); req.setAttribute(&quot;username&quot;,username); req.setAttribute(&quot;email&quot;,email); System.out.println(&quot;验证码&quot;+code+&quot;错误&quot;); //验证码不正确 //跳回注册页面，因为还是申请服务器中文件所以/还是工程目录下的 req.getRequestDispatcher(&quot;/pages/user/regist.jsp&quot;).forward(req,resp); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String parameter=req.getParameter(&quot;action&quot;); if(parameter.equals(&quot;login&quot;))&#123; login(req,resp); &#125; else if(parameter.equals(&quot;regist&quot;))&#123; regist(req,resp); &#125; &#125;&#125; 使用反射优化大量else if代码用户模块的功能，除了登录和注册，还有其他比如：添加用户，修改用户信息，修改密码，绑定手机号，绑定邮箱，注销用户 ….等等这样在UserServlet终究会出现特别多的else if 语句 12345678910111213141516@Overrideprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String parameter=req.getParameter(&quot;action&quot;); try &#123; //通过反射获取对应的方法，因为设定获取的action的参数值和调用方法的名字相同 Method parameter1 = this.getClass().getDeclaredMethod(parameter,HttpServletRequest.class,HttpServletResponse.class); //执行目标业务方法 parameter1.invoke(this,req,resp); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 这个是因为获取的hidden的action参数值是和要调用的业务方法是相同的，所以用反射获取要调用的业务方法然后调用 抽取BaseServlet程序 12345678910111213141516171819202122232425262728293031323334353637package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.Method;public abstract class BaseServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req,resp); &#125; protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(&quot;text/html;charset=UTF-8&quot;); //解决响应乱码问题 String parameter=req.getParameter(&quot;action&quot;); try &#123; //通过反射获取对应的方法，因为设定获取的action的参数值和调用方法的名字相同 //this是指调用该post方法的对象 Method parameter1 = this.getClass().getDeclaredMethod(parameter,HttpServletRequest.class,HttpServletResponse.class); //执行目标业务方法 parameter1.invoke(this,req,resp); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 因为Servlet程序还有好多有UserServlet有BookServlet等等他们上面那些代码都是一致的，所以拿出来形成一个BaseServlet BaseServlet继承HttpServlet ，其他的都继承BaseServlet就可以了 post访问时会自动调用UserServlet中继承的doPost方法 BeanUtils工具的使用BeanUtils 工具类，它可以一次性的把所有请求的参数注入到 JavaBean 中 BeanUtils 工具类，经常用于把 Map 中的值注入到 JavaBean 中，或者是对象属性值的拷贝操作。 BeanUtils 它不是 Jdk 的类。而是第三方的工具类。所以需要导包。 1、导入需要的 jar 包： commons-beanutils-1.8.0.jar commons-logging-1.1.1.jar 2.BeanUtils的使用 12345678User user=new User();try &#123; //将所有请求参数导入user对象，getParameterMap方法是获得Map类型的参数 BeanUtils.populate(user,req.getParameterMap());&#125; catch (Exception e) &#123; e.printStackTrace();&#125;userService.registerUser(user); 这个的使用原理就是 找属性username然后变成setUsername对这个属性进行赋值，然后再对其他每个属性进行这个操作 所以如果这个属性没有对应的正确的set方法是无法注入值的 所以还有一个要求是获取的参数的name一定要和java类中的属性的名字相同 webUtils类 对这个BeanUtils类中的方法使用进行一个封装 1234567891011121314151617181920212223242526272829package com.atguigu.utils;import com.atguigu.pojo.User;import org.apache.commons.beanutils.BeanUtils;import javax.servlet.http.HttpServletRequest;import java.util.Map;public class WebUtils &#123; /** * 把 Map 中的值注入到对应的 JavaBean 属性中。 * @param value * @param bean */ public static&lt;T&gt; T copyParamToBean(Map value, T bean)&#123; /* 将所有的请求参数一次性注入到user对象中 */ try &#123; System.out.println(&quot;注入之前:&quot;+bean); //将所有请求参数导入user对象，getParameterMap方法是获得Map类型的参数 BeanUtils.populate(bean,value); System.out.println(&quot;注入之后&quot;+bean); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return bean; &#125;&#125; webUtils的使用 1234 //可用 //调用Sercice保存到数据库Map map=req.getParameterMap();User user=WebUtils.copyParamToBean(map,new User()); 书城项目第四阶段使用EL修改表单回显这是login.jsp的 将用jsp表达式脚本转变为EL表达式 1234&lt;span class=&quot;errorMsg&quot;&gt; &lt;%--&lt;%=request.getAttribute(&quot;msg&quot;)==null?&quot;请输入用户密码和用户名&quot;:request.getAttribute(&quot;msg&quot;)%&gt;--%&gt; $&#123;empty requestScope.msg?&quot;请输入用户密码和用户名&quot;:requestScope.msg&#125;&lt;/span&gt; 12345&lt;!--省去判断是因为即使是空那么返回的也是空字符串--&gt;&lt;input class=&quot;itxt&quot; type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; autocomplete=&quot;off&quot; tabindex=&quot;1&quot; name=&quot;username&quot;&lt;%--value=&quot;&lt;%=request.getAttribute(&quot;username&quot;)==null?&quot;&quot;:request.getAttribute(&quot;username&quot;)%&gt;&quot;--%&gt; value=&quot;$&#123;requestScope.username&#125;&quot;/&gt; regist.jsp中同样有这种的 ，username ，email 和报错信息 书城项目的第五阶段MVC概念MVC 全称：Model 模型、 View 视图、 Controller 控制器。 MVC 最早出现在 JavaEE 三层中的 Web 层，它可以有效的指导 Web 层的代码如何有效分离，单独工作 View 视图：只负责数据和界面的显示，不接受任何与显示数据无关的代码，便于程序员和美工的分工合作—— JSP&#x2F;HTML Controller 控制器：只负责接收请求，调用业务层的代码处理请求，然后派发页面，是一个“调度者”的角色——Servlet。 转到某个页面。或者是重定向到某个页面。 Model 模型：将与业务逻辑相关的数据封装为具体的 JavaBean 类，其中不掺杂任何与数据处理相关的代码—— JavaBean&#x2F;domain&#x2F;entity&#x2F;pojo。 MVC 是一种思想 MVC 的理念是将软件代码拆分成为组件，单独开发，组合使用（目的还是为了降低耦合度）。 创建图书模块的数据库表123456789create table t_book(id int primary key auto_increment,name varchar(100),price decimal(11,2),author varchar(100),sales int,stock int,img_path varchar(200)); 然后在里面插入数据 123use book;select *from t_book;查询一下里面插入的数据 编写图书模块的JavaBean1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.atguigu.pojo;import java.math.BigDecimal;public class Book &#123; private Integer id; private String name; private String author; private BigDecimal price; private Integer sales; private Integer stock; private String imgPath=&quot;static/img/default.jpg&quot;;//图书的封面 public Book() &#123; &#125; public Book(Integer id, String name, String author, BigDecimal price, Integer sales, Integer stock, String imgPath) &#123; this.id = id; this.name = name; this.author = author; this.price = price; this.sales = sales; this.stock = stock; this.imgPath = imgPath; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Book&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, author=&#x27;&quot; + author + &#x27;\\&#x27;&#x27; + &quot;, price=&quot; + price + &quot;, sales=&quot; + sales + &quot;, stock=&quot; + stock + &quot;, imgPath=&#x27;&quot; + imgPath + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; public BigDecimal getPrice() &#123; return price; &#125; public void setPrice(BigDecimal price) &#123; this.price = price; &#125; public Integer getSales() &#123; return sales; &#125; public void setSales(Integer sales) &#123; this.sales = sales; &#125; public Integer getStock() &#123; return stock; &#125; public void setStock(Integer stock) &#123; this.stock = stock; &#125; public String getImgPath() &#123; return imgPath; &#125; public void setImgPath(String imgPath) &#123; this.imgPath = imgPath; &#125;&#125; 编写图书模块的Dao和测试DaoBookDao 123456789101112131415package com.atguigu.dao;import com.atguigu.pojo.Book;import java.util.List;public interface BookDao &#123; public int addBook(Book book); public int deleteBookById(Integer id); public int updateBook(Book book); public Book queryBookById(Integer id); public List&lt;Book&gt; queryBooks();&#125; BookDaoImpl 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.atguigu.dao.impl;import com.atguigu.dao.BookDao;import com.atguigu.pojo.Book;import java.util.List;public class BookDaoImpl extends BaseDao implements BookDao &#123; @Override public int addBook(Book book) &#123; String sql=&quot;insert into t_book (name,author,price,sales,stock,img_path) values(?,?,?,?,?,?)&quot;; return update(sql,book.getName(),book.getAuthor(),book.getPrice(),book.getSales(),book.getStock(),book.getImgPath()); &#125; @Override public int deleteBookById(Integer id) &#123; String sql=&quot;delete from t_book where id=?&quot;; return update(sql,id); &#125; @Override public int updateBook(Book book) &#123; String sql=&quot;update t_book set name=?,author=?,price=?,sales=?,stock=?,img_path=? where id=?&quot;; return update(sql,book.getName(),book.getAuthor(),book.getPrice(),book.getSales(),book.getStock(),book.getImgPath(),book.getId()); &#125; @Override public Book queryBookById(Integer id) &#123; String sql=&quot;select * from t_book where id=?&quot;; return queryForOne(Book.class,sql,id); &#125; @Override public List&lt;Book&gt; queryBooks() &#123; String sql=&quot;select * from t_book&quot;; return queryForList(Book.class,sql); &#125;&#125; BookDaoTest 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.atguigu.test;import com.atguigu.dao.BookDao;import com.atguigu.dao.impl.BookDaoImpl;import com.atguigu.pojo.Book;import org.junit.Test;import java.math.BigDecimal;public class BookDaoTest &#123;private BookDao bookDao=new BookDaoImpl(); @Test public void addBook() &#123; bookDao.addBook(new Book(null,&quot;国哥为什么这么帅！&quot;, &quot;191125&quot;, new BigDecimal(9999),1100000,0,null )); &#125; @Test public void deleteBookById() &#123; bookDao.deleteBookById(1); &#125; @Test public void updateBook() &#123; bookDao.updateBook(new Book(21,&quot;国哥&quot;, &quot;191125&quot;, new BigDecimal(9999),1100000,0,null )); &#125; @Test public void queryBookById() &#123; System.out.println(bookDao.queryBookById(21)); &#125; @Test public void queryBooks() &#123; for (Book queryBook : bookDao.queryBooks()) &#123; System.out.println(queryBook); &#125; &#125;&#125; 编写图书模块的Service和测试ServiceBookSevice 12345678910111213package com.atguigu.service;import com.atguigu.pojo.Book;import java.util.List;public interface BookService &#123; public void addBook(Book book); public void deleteBookById(Integer id); public void updateBook(Book book); public Book queryBookById(Integer id); public List&lt;Book&gt; queryBooks();&#125; BookService的实现是基于BookDao的 BookServiceImpl 123456789101112131415161718192021222324252627282930313233343536package com.atguigu.service.impl;import com.atguigu.dao.BookDao;import com.atguigu.dao.impl.BookDaoImpl;import com.atguigu.pojo.Book;import com.atguigu.service.BookService;import java.util.List;public class BookServiceImpl implements BookService &#123; private BookDao bookDao=new BookDaoImpl(); @Override public void addBook(Book book) &#123; bookDao.addBook(book); &#125; @Override public void deleteBookById(Integer id) &#123;bookDao.deleteBookById(id); &#125; @Override public void updateBook(Book book) &#123;bookDao.updateBook(book); &#125; @Override public Book queryBookById(Integer id) &#123; return bookDao.queryBookById(id); &#125; @Override public List&lt;Book&gt; queryBooks() &#123; return bookDao.queryBooks(); &#125;&#125; BookServiceImplTest测试 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.atguigu.test;import com.atguigu.pojo.Book;import com.atguigu.service.BookService;import com.atguigu.service.impl.BookServiceImpl;import org.junit.Test;import java.math.BigDecimal;import static org.junit.Assert.*;public class BookServiceImplTest &#123; private BookService bookService=new BookServiceImpl(); @Test public void addBook() &#123; bookService.addBook(new Book(1,&quot;java从入门到放弃&quot;,&quot;国歌&quot;,new BigDecimal(80),9999,9,&quot;static/img/default.jpg&quot;)); &#125; @Test public void deleteBookById() &#123; bookService.deleteBookById(21); &#125; @Test public void updateBook() &#123; bookService.updateBook(new Book(22,&quot;黑涩会国歌&quot;,&quot;122&quot;,new BigDecimal(100000),100000,0,null)); &#125; @Test public void queryBookById() &#123; System.out.println(bookService.queryBookById(22)); &#125; @Test public void queryBooks() &#123; for (Book queryBook : bookService.queryBooks()) &#123; System.out.println(queryBook); &#125; &#125;&#125; 编写图书模块的web层，和页面联调测试流程 这个是manager.jsp页面 点一下这个是进入book_manager.jsp是 步骤 在bookServlet中添加这个方法 123456789protected void list(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.通过BookService查询全部图书 List&lt;Book&gt; books = bookService.queryBooks(); //2.把全部图书保存到request域中 req.setAttribute(&quot;books&quot;,books); System.out.println(1); //3.请求转发到/pages/manager/book_manager.jsp req.getRequestDispatcher(&quot;/pages/manager/book_manager.jsp&quot;).forward(req,resp);&#125; 在book_manager.jsp中进行图书信息遍历输出 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;图书管理&lt;/title&gt; &lt;!--使用静态包含引入css样式jQuery和base标签--&gt; &lt;%@ include file=&quot;/pages/common/head.jsp&quot;%&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;header&quot;&gt; &lt;img class=&quot;logo_img&quot; alt=&quot;&quot; src=&quot;static/img/logo.gif&quot; &gt; &lt;span class=&quot;wel_word&quot;&gt;图书管理系统&lt;/span&gt; &lt;!--引入manager_menu.jsp内容--&gt; &lt;%@include file=&quot;/pages/common/manager_menu.jsp&quot;%&gt; &lt;/div&gt; &lt;div id=&quot;main&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;名称&lt;/td&gt; &lt;td&gt;价格&lt;/td&gt; &lt;td&gt;作者&lt;/td&gt; &lt;td&gt;销量&lt;/td&gt; &lt;td&gt;库存&lt;/td&gt; &lt;td colspan=&quot;2&quot;&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach items=&quot;$&#123;requestScope.books&#125;&quot; var=&quot;book&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;book.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.price&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.author&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.sales&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.stock&#125;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;book_edit.jsp&quot;&gt;修改&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;#&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;book_edit.jsp&quot;&gt;添加图书&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;!--静态包含页脚的代码--&gt; &lt;%@include file=&quot;/pages/common/footer.jsp&quot; %&gt;&lt;/body&gt;&lt;/html&gt; 还有一个改动 在BaseServlet添加doGet方法并在其中调用doPost方法 因为 1&lt;a href=&quot;manager/BookServlet?action=list&quot;&gt;图书管理&lt;/a&gt; 进行的是get传参，来调用list方法，所以得有一个doGet方法来调用doPost 123456789101112131415161718192021222324252627282930313233package com.atguigu.web;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.Method;public abstract class BaseServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req,resp); &#125; protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String parameter=req.getParameter(&quot;action&quot;); try &#123; //通过反射获取对应的方法，因为设定获取的action的参数值和调用方法的名字相同 Method parameter1 = this.getClass().getDeclaredMethod(parameter,HttpServletRequest.class,HttpServletResponse.class); //执行目标业务方法 parameter1.invoke(this,req,resp); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 前后端的简单介绍 添加图书功能的实现 book_edit是这个界面，用来添加图书的 1&lt;td&gt;&lt;a href=&quot;pages/manager/book_edit.jsp&quot;&gt;添加图书&lt;/a&gt;&lt;/td&gt; 党点击添加图书跳转到book_edit界面 先修改book_edit界面的表单，表单项中的name属性一定要和javabean类中的属性名一样，否则不能用BeanUtils注入 将action改为manager&#x2F;BookServlet，添加了一个表单项value为add来调用add方法 123456789101112131415161718192021&lt;form action=&quot;manager/BookServlet&quot; method=&quot;get&quot;&gt; &lt;table&gt; &lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;add&quot;/&gt; &lt;tr&gt; &lt;td&gt;名称&lt;/td&gt; &lt;td&gt;价格&lt;/td&gt; &lt;td&gt;作者&lt;/td&gt; &lt;td&gt;销量&lt;/td&gt; &lt;td&gt;库存&lt;/td&gt; &lt;td colspan=&quot;2&quot;&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input name=&quot;name&quot; type=&quot;text&quot; value=&quot;时间简史&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;price&quot; type=&quot;text&quot; value=&quot;30.00&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;author&quot; type=&quot;text&quot; value=&quot;霍金&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;sales&quot; type=&quot;text&quot; value=&quot;200&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;stock&quot; type=&quot;text&quot; value=&quot;300&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt; 修改BookServlet 1234567891011121314151617protected void add(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //使用BeanUtils生成Book对象 Map parameterMap = req.getParameterMap(); Book book= WebUtils.copyParamToBean(parameterMap,new Book()); //保存图书 bookService.addBook(book); //使用这个方法是有bug的 //造成表单的重复提交，当用户提交完请求，浏览器会记录下最后一次请求的全部信息，当用户按下功能键f5，就会发起浏览器记录的最后一次请求 // req.getRequestDispatcher(&quot;/manager/BookServlet?action=list&quot;).forward(req,resp); //这里要使用重定向resp.sendRedirect(req.getContextPath()+&quot;/manager/BookServlet?action=list&quot;); &#125; 造成表单的重复提交，当用户提交完请求，浏览器会记录下最后一次请求的全部信息，当用户按下功能键f5，就会发起浏览器记录的最后一次请求 请求转发是一次请求，重定向是两次请求，就是如果请求转发则从提交表单开始到最后都是一次请求，但重定向则是两次，第二次是请求那个jsp页面，所以对于重定向来讲，浏览器存储的最后一次请求就是请求那个jsp页面，便不会重复添加 删除图书功能的实现 修改book_editmanager中的 1&lt;td&gt;&lt;a class=&quot;deleteClass&quot; href=&quot;manager/BookServlet?action=delete&amp;id=$&#123;book.id&#125;&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; 在book_editmanager中加一个点击事件，来获取要删除的书的名字，来提醒用户是否删错 1234567891011121314151617181920&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; $(&quot;a.deleteClass&quot;).click(function()&#123; /* confirm是确认提示框函数 参数是他的提示内容 它有两个按扭，一个确认，一个是取消。 返回true表示点击了确认，返回false表示点击了取消 */ //在事件的function函数总有一个this对象是当前正在响应事件的dom对象 //将dom转换为jQuery对象获得父标签的父标签tr再得到子标签td中的第一个里面的文本内容 return confirm(&quot;你确定要删除[&quot;+$(this).parent().parent().find(&quot;td:first&quot;).text()+&quot;]?&quot;); /* return false会阻止元素的默认行为，不提交请求 */ &#125;); &#125;);&lt;/script&gt; 在WebUtils中增加的字符串转数字的方法 123456789101112/** * 将字符串转换成为int类型的数据 * @param strInt 这个是要转换为数字的字符串 * @param defaultValue 如果没有转换成功返回默认值 * @return */public static int parseInt(String strInt,int defaultValue)&#123; if(strInt!=null) return Integer.parseInt(strInt); return defaultValue;&#125; 在BookServlet中增加的delete方法 12345678910 protected void delete(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 1、获取请求的参数 id，图书编程 int id=WebUtils.parseInt(req.getParameter(&quot;id&quot;),0);// 2、调用 bookService.deleteBookById();删除图书 bookService.deleteBookById(id);// 3、重定向回图书列表管理页面// /book/manager/bookServlet?action=list resp.sendRedirect(req.getContextPath() + &quot;/manager/BookServlet?action=list&quot;); &#125; 修改图书功能的实现让修改界面变成要修改的书的信息改变 修改选项的请求信息 1&lt;td&gt;&lt;a href=&quot;manager/BookServlet?action=getBook&amp;id=$&#123;book.id&#125;&quot;&gt;修改&lt;/a&gt;&lt;/td&gt; 在BookServlet中添加了一个getBook的方法 这里使用请求转发，是因为请求是在页面显示要修改的book的内容，即使用户按了f5再次请求也无伤大雅 1234567891011protected void getBook(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取图书编号 int id=WebUtils.parseInt(req.getParameter(&quot;id&quot;),0); //调用BookService中的方法查找到这个book的信息 Book book = bookService.queryBookById(id); //把图书保存到request域中 req.setAttribute(&quot;book&quot;,book); //请求转发 req.getRequestDispatcher(&quot;/pages/manager/book_edit.jsp&quot;).forward(req,resp);&#125; 在book_edit页面中修改显示的信息 12345678&lt;tr&gt; &lt;td&gt;&lt;input name=&quot;name&quot; type=&quot;text&quot; value=&quot;$&#123;requestScope.book.name&#125;&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;price&quot; type=&quot;text&quot; value=&quot;$&#123;requestScope.book.price&#125;&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;author&quot; type=&quot;text&quot; value=&quot;$&#123;requestScope.book.author&#125;&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;sales&quot; type=&quot;text&quot; value=&quot;$&#123;requestScope.book.sales&#125;&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;stock&quot; type=&quot;text&quot; value=&quot;$&#123;requestScope.book.stock&#125;&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/td&gt;&lt;/tr&gt; 提交给服务器保存修改 在BookServlet中添加update方法 12345678910protected void update(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //请求参数，封装为Book对象 Map parameterMap = req.getParameterMap(); Book book=WebUtils.copyParamToBean(parameterMap,new Book()); //调用BookService的方法修改图书 bookService.updateBook(book); //将信息重定向到book_edit页面 resp.sendRedirect(req.getContextPath()+&quot;/manager/BookServlet?action=list&quot;);&#125; 这里使用重定向是因为如果使用请求转发，客户端按下f5则会修改两次 改变修改按钮的指向地址，这是为了点击修改之后book_edit页面中能显示要修改的book的信息 1&lt;td&gt;&lt;a href=&quot;manager/BookServlet?action=getBook&amp;id=$&#123;book.id&#125;&quot;&gt;修改&lt;/a&gt;&lt;/td&gt; 解决book_edit页面既要实现add又要实现update的问题 123&lt;!--通过判断是否存在参数id来绝顶value是add还是update--&gt;&lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;$&#123;empty param.id?&quot;add&quot;:&quot;update&quot;&#125;&quot;/&gt;&lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;$&#123;requestScope.book.id&#125;&quot;/&gt; 第二行代码是因为修改book需要id 图书分页的分析 分页模型page的抽取1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.atguigu.pojo;import java.util.List;/*Page是分页的模型对象&lt;T&gt;是具体的模块的javaBean类 */public class Page &lt;T&gt;&#123; public static final Integer PAGE_SIZE=4; public Integer getPageNo() &#123; return pageNo; &#125; public void setPageNo(Integer pageNo) &#123; this.pageNo = pageNo; &#125; public Integer getPageTotal() &#123; return pageTotal; &#125; @Override public String toString() &#123; return &quot;Page&#123;&quot; + &quot;pageNo=&quot; + pageNo + &quot;, pageTotal=&quot; + pageTotal + &quot;, pageSize=&quot; + pageSize + &quot;, pageTotalCount=&quot; + pageTotalCount + &quot;, items=&quot; + items + &#x27;&#125;&#x27;; &#125; public void setPageTotal(Integer pageTotal) &#123; this.pageTotal = pageTotal; &#125; public Integer getPageSize() &#123; return pageSize; &#125; public void setPageSize(Integer pageSize) &#123; this.pageSize = pageSize; &#125; public Integer getPageTotalCount() &#123; return pageTotalCount; &#125; public void setPageTotalCount(Integer pageTotalCount) &#123; this.pageTotalCount = pageTotalCount; &#125; public List&lt;T&gt; getItems() &#123; return items; &#125; public void setItems(List&lt;T&gt; items) &#123; this.items = items; &#125; //当前页码 private Integer pageNo; //总页码 private Integer pageTotal; //当前页的显示数量 private Integer pageSize=PAGE_SIZE; //总记录数 private Integer pageTotalCount; //当前页数据 private List&lt;T&gt; items; public Page(Integer pageNo, Integer pageTotal, Integer pageSize, Integer pageTotalCount, List&lt;T&gt; items) &#123; this.pageNo = pageNo; this.pageTotal = pageTotal; this.pageSize = pageSize; this.pageTotalCount = pageTotalCount; this.items = items; &#125; public Page() &#123; &#125;&#125; 分页的初步实现图书管理这个地方改成分页操作 1&lt;a href=&quot;manager/BookServlet?action=page&quot;&gt;图书管理&lt;/a&gt; BookServlet 在其中添加了分页功能，利用了bookService的page方法 就是生成页面对象的方法，页面对象包括页面的数据条数，多少页等等 12345678910111213141516/*处理分页功能 */protected void page(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1。获取请求的参数，pageNo和pageSize //用户没有点击第几页，就默认显示第一页，所以第二个参数是1 int pageNo=WebUtils.parseInt(req.getParameter(&quot;pageNo&quot;),1); int pageSize=WebUtils.parseInt(req.getParameter(&quot;pageSize&quot;), Page.PAGE_SIZE); //2。调用BookService.page(pageNo,pageSize):Page对象 Page&lt;Book&gt; page=bookService.page(pageNo,pageSize); //3.保存Page对象到request域中 req.setAttribute(&quot;page&quot;,page); //4.请求转发到pages/manager/book_manager.jsp req.getRequestDispatcher(&quot;/pages/manager/book_manager.jsp&quot;).forward(req,resp);&#125; BookService 在BookService中添加了page方法，生成page对象，用到了BookDao的queryForPageTotalCount()方法和queryFotPageItems()方法 为了得到总记录数和当前页数据 123456789101112131415161718192021222324252627@Overridepublic Page&lt;Book&gt; page(int pageNo, int pageSize) &#123; Page&lt;Book&gt; page=new Page&lt;&gt;(); //设置page对象的当前页 page.setPageNo(pageNo); //设置每页显示的数量 page.setPageSize(pageSize); //求总记录数 Integer pageTotalCount=bookDao.queryForPageTotalCount(); //设置总记录数 page.setPageTotalCount(pageTotalCount); //求总页码 Integer pageTotal=pageTotalCount/pageSize; if(pageTotalCount%pageSize&gt;0)&#123; pageTotal+=1; &#125; //设置总页码 page.setPageTotal(pageTotal); //求当前页面开始的索引 int begin=(page.getPageNo()-1)*pageSize; //求当前页数据 List&lt;Book&gt; items=bookDao.queryForPageItems(begin,pageSize); //设置当前页数据 page.setItems(items); return page;&#125; BookDao 在BookDao中增加了queryForPageItems和queryForPageTotalCount方法 为了得到总记录数和当前页数据 123456789101112@Overridepublic Integer queryForPageTotalCount() &#123; String sql=&quot;select count(*) from t_book&quot;; Number count=(Number)queryForSingleValue(sql); return count.intValue();&#125;@Overridepublic List&lt;Book&gt; queryForPageItems(int begin, int pageSize) &#123; String sql=&quot;select id,name,author,price,sales,stock,img_path from t_book limit ?,? &quot;; return queryForList(Book.class,sql,begin,pageSize);&#125; 1234ScalarHandler用来获得聚合函数的值,返回类型是Object,用Number来接收比较好Number num=qr.query(cntSql.append(whereSql).toString(),new ScalarHandler&lt;&gt;(),params.toArray());然后调用intValue()方法int tr=num.intValue()即可! book_manager.jsp中增加了换页框 1234567891011&lt;div id=&quot;page_nav&quot;&gt; &lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;上一页&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;3&lt;/a&gt; 【$&#123;requestScope.page.pageNo&#125;】 &lt;a href=&quot;#&quot;&gt;5&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;下一页&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;末页&lt;/a&gt; 共$&#123;requestScope.page.pageTotal&#125;页，$&#123;requestScope.page.pageTotalCount&#125;条记录 到第&lt;input value=&quot;4&quot; name=&quot;pn&quot; id=&quot;pn_input&quot;/&gt;页 &lt;input type=&quot;button&quot; value=&quot;确定&quot;&gt;&lt;/div&gt; book_manager.jsp中还改变了遍历的数据项requestScope.page.items 1234567891011&lt;c:forEach items=&quot;$&#123;requestScope.page.items&#125;&quot; var=&quot;book&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;book.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.price&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.author&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.sales&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.stock&#125;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;manager/BookServlet?action=getBook&amp;id=$&#123;book.id&#125;&quot;&gt;修改&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a class=&quot;deleteClass&quot; href=&quot;manager/BookServlet?action=delete&amp;id=$&#123;book.id&#125;&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; 首页上一页，下一页，末页的实现1234567891011121314151617&lt;div id=&quot;page_nav&quot;&gt; &lt;%--大于首页才显示上一页按钮--%&gt; &lt;c:if test=&quot;$&#123;requestScope.page.pageNo&gt;1&#125;&quot;&gt; &lt;a href=&quot;manager/BookServlet?action=page&amp;pageNo=1&quot;&gt;首页&lt;/a&gt; &lt;a href=&quot;manager/BookServlet?action=page&amp;pageNo=$&#123;requestScope.page.pageNo-1&#125;&quot;&gt;上一页&lt;/a&gt; &lt;/c:if&gt; &lt;a href=&quot;manager/BookServlet?action=page&amp;pageNo=$&#123;requestScope.page.pageNo-1&#125;&quot;&gt;$&#123;requestScope.page.pageNo-1&#125;&lt;/a&gt; 【$&#123;requestScope.page.pageNo&#125;】 &lt;a href=&quot;manager/BookServlet?action=page&amp;pageNo=$&#123;requestScope.page.pageNo+1&#125;&quot;&gt;$&#123;requestScope.page.pageNo+1&#125;&lt;/a&gt; &lt;%--如果已经是最后一页则不显示下一页和末页--%&gt; &lt;c:if test=&quot;$&#123;requestScope.page.pageNo&lt;requestScope.page.pageTotal&#125;&quot;&gt; &lt;a href=&quot;manager/BookServlet?action=page&amp;pageNo=$&#123;requestScope.page.pageNo+1&#125;&quot;&gt;下一页&lt;/a&gt; &lt;a href=&quot;manager/BookServlet?action=page&amp;pageNo=$&#123;requestScope.page.pageTotal&#125;&quot;&gt;末页&lt;/a&gt; &lt;/c:if&gt; 共$&#123;requestScope.page.pageTotal&#125;页，$&#123;requestScope.page.pageTotalCount&#125;条记录 到第&lt;input value=&quot;$&#123;requestScope.page.pageNo&#125;&quot; name=&quot;pn&quot; id=&quot;pn_input&quot;/&gt;页 &lt;input type=&quot;button&quot; value=&quot;确定&quot;&gt;&lt;/div&gt; 分页模块中跳转到指定页数功能实现这个是head.jsp文件，把路径保存在pageContext域中，方便在book_manager.jsp文件中获取 1234&lt;% String basePath=request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+request.getContextPath()+&quot;/&quot;; pageContext.setAttribute(&quot;basePath&quot;,basePath);%&gt; 给确定键按钮加了一个点击事件 1234567891011121314151617共$&#123;requestScope.page.pageTotal&#125;页，$&#123;requestScope.page.pageTotalCount&#125;条记录 到第&lt;input value=&quot;$&#123;requestScope.page.pageNo&#125;&quot; name=&quot;pn&quot; id=&quot;pn_input&quot;/&gt;页 &lt;input type=&quot;button&quot; id=&quot;searchPageBtn&quot; value=&quot;确定&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; $(&quot;#searchPageBtn&quot;).click(function()&#123; var pageNo=$(&quot;#pn_input&quot;).val(); //javascript语言中提供了一个location地址栏 //他有一个属性叫href，它可以获取浏览器地址栏中的地址 //href属性可读可写 location.href=&quot;$&#123;pageScope.basePath&#125;manager/BookServlet?action=page&amp;pageNo=&quot;+pageNo; &#125;); &#125;); &lt;/script&gt; 数据有效边境检查前端jsp,加了一个前端的校验，如果当前要转的页码大于最大页码或者小于零就返回false，阻止事件发生 123456789101112131415161718192021&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; $(&quot;#searchPageBtn&quot;).click(function()&#123; var pageNo=$(&quot;#pn_input&quot;).val(); var pageTotal=$&#123;requestScope.page.pageTotal&#125;; if(pageNo&gt;pageTotal||pageNo&lt;=0)&#123; return false; &#125; //javascript语言中提供了一个location地址栏 //他有一个属性叫href，它可以获取浏览器地址栏中的地址 //href属性可读可写 location.href=&quot;$&#123;pageScope.basePath&#125;manager/BookServlet?action=page&amp;pageNo=&quot;+pageNo; &#125;); &#125;);&lt;/script&gt; 服务器端检查数据边界，因为在地址栏中使用get传参可以跳过前端验证 直接在setPageNo的方法中设置，只要pageNo不合法，直接替换 1234567891011public void setPageNo(Integer pageNo) &#123; //设置数据的边界值 if(pageNo&lt;1)&#123; pageNo=1; &#125; if(pageNo&gt;pageTotal)&#123; pageNo=pageTotal; &#125; this.pageNo = pageNo;&#125; 分页条形码的输出分页模块中，页码 1,2,【3】,4,5 的显示，要显示 5 个页 码，并且页码可以点击跳转。 需求：显示 5 个连续的页码，而且当前页码在中间。除了当前页码之外，每个页码都可以点击跳到指定页。 如果总页码 优化后 123456789101112131415161718192021222324252627282930313233343536373839&lt;%--页码输出的开始--%&gt;&lt;c:choose&gt; &lt;%--情况 1：如果总页码小于等于 5 的情况，页码的范围是：1-总页码--%&gt; &lt;c:when test=&quot;$&#123; requestScope.page.pageTotal &lt;= 5 &#125;&quot;&gt; &lt;c:set var=&quot;begin&quot; value=&quot;1&quot;/&gt; &lt;c:set var=&quot;end&quot; value=&quot;$&#123;requestScope.page.pageTotal&#125;&quot;/&gt; &lt;/c:when&gt; &lt;%--情况 2：总页码大于 5 的情况--%&gt; &lt;c:when test=&quot;$&#123;requestScope.page.pageTotal &gt; 5&#125;&quot;&gt; &lt;c:choose&gt; &lt;%--小情况 1：当前页码为前面 3 个：1，2，3 的情况，页码范围是：1-5.--%&gt; &lt;c:when test=&quot;$&#123;requestScope.page.pageNo &lt;= 3&#125;&quot;&gt; &lt;%--记录begin和end--%&gt; &lt;c:set var=&quot;begin&quot; value=&quot;1&quot;/&gt; &lt;c:set var=&quot;end&quot; value=&quot;5&quot;/&gt; &lt;/c:when&gt; &lt;%--小情况 2：当前页码为最后 3 个，8，9，10，页码范围是：总页码减 4 - 总页码--%&gt; &lt;c:when test=&quot;$&#123;requestScope.page.pageNo &gt; requestScope.page.pageTotal-3&#125;&quot;&gt; &lt;%--记录begin和end--%&gt; &lt;c:set var=&quot;begin&quot; value=&quot;$&#123;requestScope.page.pageTotal-4&#125;&quot;/&gt; &lt;c:set var=&quot;end&quot; value=&quot;$&#123;requestScope.page.pageTotal&#125;&quot;/&gt; &lt;/c:when&gt; &lt;%--小情况 3：4，5，6，7，页码范围是：当前页码减 2 - 当前页码加 2--%&gt; &lt;c:otherwise&gt; &lt;c:set var=&quot;begin&quot; value=&quot;$&#123;requestScope.page.pageNo-2&#125;&quot;/&gt; &lt;c:set var=&quot;end&quot; value=&quot;$&#123;requestScope.page.pageNo+2&#125;&quot;/&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/c:when&gt;&lt;/c:choose&gt;&lt;c:forEach begin=&quot;$&#123;begin&#125;&quot; end=&quot;$&#123;end&#125;&quot; var=&quot;i&quot;&gt; &lt;c:if test=&quot;$&#123;i == requestScope.page.pageNo&#125;&quot;&gt; 【$&#123;i&#125;】 &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;i != requestScope.page.pageNo&#125;&quot;&gt; &lt;a href=&quot;manager/BookServlet?action=page&amp;pageNo=$&#123;i&#125;&quot;&gt;$&#123;i&#125;&lt;/a&gt; &lt;/c:if&gt;&lt;/c:forEach&gt;&lt;%--页码输出的结束--%&gt; &lt;c:set var=&quot;begin&quot; value=&quot;1&quot;/&gt; &lt;c:set var=&quot;end&quot; value=&quot;$&#123;requestScope.page.pageTotal&#125;&quot;/&gt; 这个是设置begin和end的value值 然后等到&lt;c:choose&gt;执行完之后再执行forEach 12345678&lt;c:forEach begin=&quot;$&#123;begin&#125;&quot; end=&quot;$&#123;end&#125;&quot; var=&quot;i&quot;&gt; &lt;c:if test=&quot;$&#123;i == requestScope.page.pageNo&#125;&quot;&gt; 【$&#123;i&#125;】 &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;i != requestScope.page.pageNo&#125;&quot;&gt; &lt;a href=&quot;manager/BookServlet?action=page&amp;pageNo=$&#123;i&#125;&quot;&gt;$&#123;i&#125;&lt;/a&gt; &lt;/c:if&gt;&lt;/c:forEach&gt; 修改分页对原来增删改的影响这个是把BookServlet中原本action&#x3D;list都改为action&#x3D;page 1resp.sendRedirect(req.getContextPath()+&quot;/manager/BookServlet?action=page&quot;); 添加图书的影响 book_manager 添加图书的时候带着pageTotal 1&lt;td&gt;&lt;a href=&quot;pages/manager/book_edit.jsp?pageNo=$&#123;requestScope.page.pageTotal&#125;&quot;&gt;添加图书&lt;/a&gt;&lt;/td&gt; book_edit 1加了这一行，来传接收到的pageNo参数 1&lt;input type=&quot;hidden&quot; name=&quot;pageNo&quot; value=&quot;$&#123;param.pageNo&#125;&quot;/&gt;; 123456&lt;form action=&quot;manager/BookServlet&quot; method=&quot;get&quot;&gt; &lt;!--通过判断是否存在参数id来绝顶value是add还是update--&gt; &lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;$&#123;empty param.id?&quot;add&quot;:&quot;update&quot;&#125;&quot;/&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;$&#123;requestScope.book.id&#125;&quot;/&gt; &lt;input type=&quot;hidden&quot; name=&quot;pageNo&quot; value=&quot;$&#123;param.pageNo&#125;&quot;/&gt;; BookServlet中的add方法 12345678910111213141516171819 protected void add(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; int pageNo=WebUtils.parseInt(req.getParameter(&quot;pageNo&quot;),0); pageNo+=1; //使用BeanUtils生成Book对象 Map parameterMap = req.getParameterMap(); Book book= WebUtils.copyParamToBean(parameterMap,new Book()); //保存图书 bookService.addBook(book); //使用这个方法是有bug的 //造成表单的重复提交，当用户提交完请求，浏览器会记录下最后一次请求的全部信息，当用户按下功能键f5，就会发起浏览器记录的最后一次请求 // req.getRequestDispatcher(&quot;/manager/BookServlet?action=list&quot;).forward(req,resp); //这里要使用重定向resp.sendRedirect(req.getContextPath()+&quot;/manager/BookServlet?action=page&amp;pageNo=&quot;+pageNo); &#125; int pageNo=WebUtils.parseInt(req.getParameter(&quot;pageNo&quot;),0); pageNo+=1; 让pageNo为最后一页的下一页（因为永远不会越界，前面有所设定） 然后重定向 1resp.sendRedirect(req.getContextPath()+&quot;/manager/BookServlet?action=page&amp;pageNo=&quot;+pageNo); 删除的影响 book_manager.jsp 带着pageNo参数 1&lt;td&gt;&lt;a class=&quot;deleteClass&quot; href=&quot;manager/BookServlet?action=delete&amp;id=$&#123;book.id&#125;&amp;pageNo=$&#123;requestScope.page.pageNo&#125;&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; BookServlet中的delete方法 带着pageNo请求BookServlet的page方法，来显示删除之后的界面 1resp.sendRedirect(req.getContextPath() + &quot;/manager/BookServlet?action=page&amp;pageNo=&quot;+req.getParameter(&quot;pageNo&quot;)); 修改的影响 修改的影响和删除的影响相同 前台分页的初步实现 所以先将index.jsp的内容复制到client下的index.jsp然后，web下的index.jsp只做一件事就是请求转发Servlet 注意这个jsp:forward和必须是在一行上，要不会报错 123&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%--只负责请求转发--%&gt;&lt;jsp:forward page=&quot;/client/ClientBookServlet?action=page&quot;&gt;&lt;/jsp:forward&gt; 然后是ClientBookServlet，请求转发到client下的index.jsp 12345678910111213141516171819202122232425262728293031package com.atguigu.web;import com.atguigu.pojo.Book;import com.atguigu.pojo.Page;import com.atguigu.service.BookService;import com.atguigu.service.impl.BookServiceImpl;import com.atguigu.utils.WebUtils;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class ClientBookServlet extends BaseServlet&#123; BookService bookService=new BookServiceImpl(); protected void page(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1。获取请求的参数，pageNo和pageSize //用户没有点击第几页，就默认显示第一页，所以第二个参数是1 System.out.println(&quot;经过了前台的Servlet程序&quot;); int pageNo= WebUtils.parseInt(req.getParameter(&quot;pageNo&quot;),1); int pageSize=WebUtils.parseInt(req.getParameter(&quot;pageSize&quot;), Page.PAGE_SIZE); //2。调用BookService.page(pageNo,pageSize):Page对象 Page&lt;Book&gt; page=bookService.page(pageNo,pageSize); //3.保存Page对象到request域中 req.setAttribute(&quot;page&quot;,page); //4.请求转发到pages/manager/book_manager.jsp req.getRequestDispatcher(&quot;/pages/client/index.jsp&quot;).forward(req,resp); &#125;&#125; client下的index.jsp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;书城首页&lt;/title&gt; &lt;!--使用静态包含引入css样式jQuery和base标签--&gt; &lt;%@ include file=&quot;/pages/common/head.jsp&quot;%&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;header&quot;&gt; &lt;img class=&quot;logo_img&quot; alt=&quot;&quot; src=&quot;/img/logo.gif&quot; &gt; &lt;span class=&quot;wel_word&quot;&gt;网上书城&lt;/span&gt; &lt;div&gt; &lt;a href=&quot;pages/user/login.jsp&quot;&gt;登录&lt;/a&gt; | &lt;a href=&quot;pages/user/regist.jsp&quot;&gt;注册&lt;/a&gt; &amp;nbsp;&amp;nbsp; &lt;a href=&quot;pages/cart/cart.jsp&quot;&gt;购物车&lt;/a&gt; &lt;a href=&quot;pages/manager/manager.jsp&quot;&gt;后台管理&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;main&quot;&gt; &lt;div id=&quot;book&quot;&gt; &lt;div class=&quot;book_cond&quot;&gt; &lt;form action=&quot;&quot; method=&quot;get&quot;&gt; 价格：&lt;input id=&quot;min&quot; type=&quot;text&quot; name=&quot;min&quot; value=&quot;&quot;&gt; 元 - &lt;input id=&quot;max&quot; type=&quot;text&quot; name=&quot;max&quot; value=&quot;&quot;&gt; 元 &lt;input type=&quot;submit&quot; value=&quot;查询&quot; /&gt; &lt;/form&gt; &lt;/div&gt; &lt;div style=&quot;text-align: center&quot;&gt; &lt;span&gt;您的购物车中有3件商品&lt;/span&gt; &lt;div&gt; 您刚刚将&lt;span style=&quot;color: red&quot;&gt;时间简史&lt;/span&gt;加入到了购物车中 &lt;/div&gt; &lt;/div&gt; &lt;c:forEach items=&quot;$&#123;requestScope.page.items&#125;&quot; var=&quot;book&quot;&gt; &lt;div class=&quot;b_list&quot;&gt; &lt;div class=&quot;img_div&quot;&gt; &lt;img class=&quot;book_img&quot; alt=&quot;&quot; src=&quot;$&#123;book.imgPath&#125;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;book_info&quot;&gt; &lt;div class=&quot;book_name&quot;&gt; &lt;span class=&quot;sp1&quot;&gt;书名:&lt;/span&gt; &lt;span class=&quot;sp2&quot;&gt;$&#123;book.name&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;book_author&quot;&gt; &lt;span class=&quot;sp1&quot;&gt;作者:&lt;/span&gt; &lt;span class=&quot;sp2&quot;&gt;$&#123;book.author&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;book_price&quot;&gt; &lt;span class=&quot;sp1&quot;&gt;价格:&lt;/span&gt; &lt;span class=&quot;sp2&quot;&gt;$&#123;book.price&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;book_sales&quot;&gt; &lt;span class=&quot;sp1&quot;&gt;销量:&lt;/span&gt; &lt;span class=&quot;sp2&quot;&gt;$&#123;book.sales&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;book_amount&quot;&gt; &lt;span class=&quot;sp1&quot;&gt;库存:&lt;/span&gt; &lt;span class=&quot;sp2&quot;&gt;$&#123;book.stock&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;book_add&quot;&gt; &lt;button&gt;加入购物车&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/c:forEach&gt; &lt;div id=&quot;page_nav&quot;&gt; &lt;%--大于首页才显示上一页按钮--%&gt; &lt;c:if test=&quot;$&#123;requestScope.page.pageNo&gt;1&#125;&quot;&gt; &lt;a href=&quot;client/ClientBookServlet?action=page&amp;pageNo=1&quot;&gt;首页&lt;/a&gt; &lt;a href=&quot;client/ClientBookServlet?action=page&amp;pageNo=$&#123;requestScope.page.pageNo-1&#125;&quot;&gt;上一页&lt;/a&gt; &lt;/c:if&gt; &lt;%--页码输出的开始--%&gt; &lt;c:choose&gt; &lt;%--情况 1：如果总页码小于等于 5 的情况，页码的范围是：1-总页码--%&gt; &lt;c:when test=&quot;$&#123; requestScope.page.pageTotal &lt;= 5 &#125;&quot;&gt; &lt;c:set var=&quot;begin&quot; value=&quot;1&quot;/&gt; &lt;c:set var=&quot;end&quot; value=&quot;$&#123;requestScope.page.pageTotal&#125;&quot;/&gt; &lt;/c:when&gt; &lt;%--情况 2：总页码大于 5 的情况--%&gt; &lt;c:when test=&quot;$&#123;requestScope.page.pageTotal &gt; 5&#125;&quot;&gt; &lt;c:choose&gt; &lt;%--小情况 1：当前页码为前面 3 个：1，2，3 的情况，页码范围是：1-5.--%&gt; &lt;c:when test=&quot;$&#123;requestScope.page.pageNo &lt;= 3&#125;&quot;&gt; &lt;%--记录begin和end--%&gt; &lt;c:set var=&quot;begin&quot; value=&quot;1&quot;/&gt; &lt;c:set var=&quot;end&quot; value=&quot;5&quot;/&gt; &lt;/c:when&gt; &lt;%--小情况 2：当前页码为最后 3 个，8，9，10，页码范围是：总页码减 4 - 总页码--%&gt; &lt;c:when test=&quot;$&#123;requestScope.page.pageNo &gt; requestScope.page.pageTotal-3&#125;&quot;&gt; &lt;%--记录begin和end--%&gt; &lt;c:set var=&quot;begin&quot; value=&quot;$&#123;requestScope.page.pageTotal-4&#125;&quot;/&gt; &lt;c:set var=&quot;end&quot; value=&quot;$&#123;requestScope.page.pageTotal&#125;&quot;/&gt; &lt;/c:when&gt; &lt;%--小情况 3：4，5，6，7，页码范围是：当前页码减 2 - 当前页码加 2--%&gt; &lt;c:otherwise&gt; &lt;c:set var=&quot;begin&quot; value=&quot;$&#123;requestScope.page.pageNo-2&#125;&quot;/&gt; &lt;c:set var=&quot;end&quot; value=&quot;$&#123;requestScope.page.pageNo+2&#125;&quot;/&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/c:when&gt; &lt;/c:choose&gt; &lt;c:forEach begin=&quot;$&#123;begin&#125;&quot; end=&quot;$&#123;end&#125;&quot; var=&quot;i&quot;&gt; &lt;c:if test=&quot;$&#123;i == requestScope.page.pageNo&#125;&quot;&gt; 【$&#123;i&#125;】 &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;i != requestScope.page.pageNo&#125;&quot;&gt; &lt;a href=&quot;client/ClientBookServlet?action=page&amp;pageNo=$&#123;i&#125;&quot;&gt;$&#123;i&#125;&lt;/a&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;%--页码输出的结束--%&gt; &lt;%--如果已经是最后一页则不显示下一页和末页--%&gt; &lt;c:if test=&quot;$&#123;requestScope.page.pageNo&lt;requestScope.page.pageTotal&#125;&quot;&gt; &lt;a href=&quot;client/ClientBookServlet?action=page&amp;pageNo=$&#123;requestScope.page.pageNo+1&#125;&quot;&gt;下一页&lt;/a&gt; &lt;a href=&quot;client/ClientBookServlet?action=page&amp;pageNo=$&#123;requestScope.page.pageTotal&#125;&quot;&gt;末页&lt;/a&gt; &lt;/c:if&gt; 共$&#123;requestScope.page.pageTotal&#125;页，$&#123;requestScope.page.pageTotalCount&#125;条记录 到第&lt;input value=&quot;$&#123;requestScope.page.pageNo&#125;&quot; name=&quot;pn&quot; id=&quot;pn_input&quot;/&gt;页 &lt;input type=&quot;button&quot; value=&quot;确定&quot;&gt; 共$&#123;requestScope.page.pageTotal&#125;页，$&#123;requestScope.page.pageTotalCount&#125;条记录 到第&lt;input value=&quot;$&#123;requestScope.page.pageNo&#125;&quot; name=&quot;pn&quot; id=&quot;pn_input&quot;/&gt;页 &lt;input type=&quot;button&quot; id=&quot;searchPageBtn&quot; value=&quot;确定&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; $(&quot;#searchPageBtn&quot;).click(function()&#123; var pageNo=$(&quot;#pn_input&quot;).val(); //javascript语言中提供了一个location地址栏 //他有一个属性叫href，它可以获取浏览器地址栏中的地址 //href属性可读可写 location.href=&quot;$&#123;pageScope.basePath&#125;client/ClientBookServlet?action=page&amp;pageNo=&quot;+pageNo; &#125;); &#125;); &lt;/script&gt; &lt;/div&gt;&lt;/div&gt;&lt;!--静态包含页脚的代码--&gt;&lt;%@include file=&quot;/pages/common/footer.jsp&quot; %&gt;&lt;/body&gt;&lt;/html&gt; 在页面遍历内容 1234567891011121314151617181920212223242526272829303132&lt;c:forEach items=&quot;$&#123;requestScope.page.items&#125;&quot; var=&quot;book&quot;&gt; &lt;div class=&quot;b_list&quot;&gt; &lt;div class=&quot;img_div&quot;&gt; &lt;img class=&quot;book_img&quot; alt=&quot;&quot; src=&quot;$&#123;book.imgPath&#125;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;book_info&quot;&gt; &lt;div class=&quot;book_name&quot;&gt; &lt;span class=&quot;sp1&quot;&gt;书名:&lt;/span&gt; &lt;span class=&quot;sp2&quot;&gt;$&#123;book.name&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;book_author&quot;&gt; &lt;span class=&quot;sp1&quot;&gt;作者:&lt;/span&gt; &lt;span class=&quot;sp2&quot;&gt;$&#123;book.author&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;book_price&quot;&gt; &lt;span class=&quot;sp1&quot;&gt;价格:&lt;/span&gt; &lt;span class=&quot;sp2&quot;&gt;$&#123;book.price&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;book_sales&quot;&gt; &lt;span class=&quot;sp1&quot;&gt;销量:&lt;/span&gt; &lt;span class=&quot;sp2&quot;&gt;$&#123;book.sales&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;book_amount&quot;&gt; &lt;span class=&quot;sp1&quot;&gt;库存:&lt;/span&gt; &lt;span class=&quot;sp2&quot;&gt;$&#123;book.stock&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;book_add&quot;&gt; &lt;button&gt;加入购物车&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/c:forEach&gt; 同时把后台的那个分页条复制到这个文件中，然后还要改一下路径 1client/ClientBookServlet?action=page&amp;pageNo=$&#123;i&#125; 分页条抽取在Page中直接添加一个url属性，代表分页条的跳转 然后在client的index.jsp中做一个替换 1&lt;a href=&quot;$&#123;requestScope.page.url&#125;&amp;pageNo=$&#123;requestScope.page.pageNo+1&#125;&quot;&gt;下一页&lt;/a&gt; BookServlet的page方法中加这是后台的分页条跳转 1page.setUrl(&quot;manager/BookServlet?action=page&quot;); ClientBookServlet中page加 这是首页的分页条跳转 1page.setUrl(&quot;client/ClientBookServlet?action=page&quot;); 这种改变之后，首页和后台的分页条都差不多可以抽取到page_nv.jsp 然后静态引入 1&lt;%@include file=&quot;/pages/common/page_nav.jsp&quot;%&gt; 价格区间搜索这个操作和前面的设置分页类似s 先对client中的index.jsp的表单进行了修改 改了提交地址，和value设置为pageByPrice 123456&lt;form action=&quot;client/ClientBookServlet&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;pageByPrice&quot;/&gt; 价格：&lt;input id=&quot;min&quot; type=&quot;text&quot; name=&quot;min&quot; value=&quot;&quot;&gt; 元 - &lt;input id=&quot;max&quot; type=&quot;text&quot; name=&quot;max&quot; value=&quot;&quot;&gt; 元 &lt;input type=&quot;submit&quot; value=&quot;查询&quot; /&gt;&lt;/form&gt; 在ClientBookServlet中创建pageByPrice方法，用了bookService的pageByPrice方法 12345678910111213141516protected void pageByPrice(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1。获取请求的参数，pageNo和pageSize //用户没有点击第几页，就默认显示第一页，所以第二个参数是1 System.out.println(100); int pageNo= WebUtils.parseInt(req.getParameter(&quot;pageNo&quot;),1); int pageSize=WebUtils.parseInt(req.getParameter(&quot;pageSize&quot;), Page.PAGE_SIZE); //获取最小价格min和最大价格max两个参数 int min=WebUtils.parseInt(req.getParameter(&quot;min&quot;),1); int max=WebUtils.parseInt(req.getParameter(&quot;max&quot;),100); Page&lt;Book&gt; page=bookService.pageByPrice(pageNo,pageSize,min,max); req.setAttribute(&quot;page&quot;,page); page.setUrl(&quot;client/ClientBookServlet?action=pageByPrice&quot;); req.getRequestDispatcher(&quot;/pages/client/index.jsp&quot;).forward(req,resp);&#125; BookService 123456789101112131415161718192021222324252627@Overridepublic Page&lt;Book&gt; pageByPrice(int pageNo, int pageSize, int min, int max) &#123; Page&lt;Book&gt; page=new Page&lt;&gt;(); //设置每页显示的数量 page.setPageSize(pageSize); //求总记录数 Integer pageTotalCount=bookDao.queryForPageTotalCountByPrice(min,max); //设置总记录数 page.setPageTotalCount(pageTotalCount); //求总页码 Integer pageTotal=pageTotalCount/pageSize; if(pageTotalCount%pageSize&gt;0)&#123; pageTotal+=1; &#125; //设置总页码 page.setPageTotal(pageTotal); //设置page对象的当前页 page.setPageNo(pageNo); //求当前页面开始的索引 int begin=(page.getPageNo()-1)*pageSize; //求当前页数据 List&lt;Book&gt; items=bookDao.queryForPageItemsByPrice(begin,pageSize,min,max); //设置当前页数据 page.setItems(items); return page;&#125; 用了BookDao中的queryForPageItemsByPrice和queryForPageTotalCountByPrice 123456789101112@Overridepublic Integer queryForPageTotalCountByPrice(int min, int max) &#123; String sql=&quot;select count(*) from t_book where price between ? and ?&quot;; Number count=(Number)queryForSingleValue(sql,min,max); return count.intValue();&#125;@Overridepublic List&lt;Book&gt; queryForPageItemsByPrice(int begin, int pageSize, int min, int max) &#123; String sql=&quot;select id,name,author,price,sales,stock,img_path imgPath from t_book where price between ? and ? limit ?,? &quot;; return queryForList(Book.class,sql,min,max,begin,pageSize);&#125; 搜索完成后显示区间范围12价格：&lt;input id=&quot;min&quot; type=&quot;text&quot; name=&quot;min&quot; value=&quot;$&#123;param.min&#125;&quot;&gt; 元 -&lt;input id=&quot;max&quot; type=&quot;text&quot; name=&quot;max&quot; value=&quot;$&#123;param.max&#125;&quot;&gt; 元 点了提交之后一直是一次请求，因为中间用的是请求转发，所以提交的min和max参数可以通过param获取 实现每个页面都能显示搜索区间 12345678StringBuilder sb=new StringBuilder(&quot;client/ClientBookServlet?action=pageByPrice&quot;);if(req.getParameter(&quot;min&quot;)!=null)&#123; sb.append(&quot;&amp;min=&quot;).append(req.getParameter(&quot;min&quot;));&#125;if(req.getParameter(&quot;max&quot;)!=null)&#123; sb.append(&quot;&amp;max=&quot;).append(req.getParameter(&quot;max&quot;));&#125;page.setUrl(sb.toString()); Cookie&amp;Session什么是Cookie 1、Cookie 翻译过来是饼干的意思。 2、Cookie 是服务器通知客户端保存键值对的一种技术。 3、客户端有了 Cookie 后，每次请求都发送给服务器。 4、每个 Cookie 大小不能超过4kb cookie的创建创建是服务器创建cookie发送给客户端 给cookie.html加上base标签 1&lt;base href=&quot;http://localhost:8079/cookie/&quot;&gt; 1&lt;li&gt;&lt;a href=&quot;CookieServlet?action=createCookie&quot; target=&quot;target&quot;&gt;Cookie的创建&lt;/a&gt;&lt;/li&gt; 给cookie创建的连接修改 CookieServlet程序 可以一次性创建多个cookie 12345678910111213141516171819202122232425package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class CookieServlet extends BaseServlet&#123; protected void createCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.创建cookie对象 Cookie cookie=new Cookie(&quot;key1&quot;,&quot;value1&quot;); //2.通知客户端保存cookie resp.addCookie(cookie); //1.创建cookie对象 Cookie cookie1=new Cookie(&quot;key2&quot;,&quot;value2&quot;); //2.通知客户端保存cookie resp.addCookie(cookie1); resp.getWriter().write(&quot;Cookie创建成功&quot;); &#125;&#125; BaseServlet 在BaseServlet的最开头加上这句代码能避免响应的中文乱码 12345//解决post请求中文乱码问题//一定要在获取请求参数之前调用才有效//req.setCharacterEncoding(&quot;UTF-8&quot;);//解决响应的中文乱码问题resp.setContentType(&quot;text/html;charset=UTF-8&quot;); 可以在下面图片中的位置看到cookie 服务器获取Cookie服务器获取客户端的 Cookie 只需要一行代码：req.getCookies():Cookie[] cookie.html 1&lt;li&gt;&lt;a href=&quot;CookieServlet?action=getCookie&quot; target=&quot;target&quot;&gt;Cookie的获取&lt;/a&gt;&lt;/li&gt; 查看请求头中的cookie 获取全部cookie的方法 12345678910111213141516171819202122232425262728 protected void getCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; Cookie[] cookies = req.getCookies(); for (Cookie cookie : cookies) &#123; //getName方法返回cookie的名称 resp.getWriter().write(&quot;Cookie[&quot;+cookie.getName()+&quot;=&quot;+cookie.getValue()+&quot;]&lt;br/&gt;&quot;); &#125;Cookie iWantCookie= CookieUtils.findCookie(&quot;key1&quot;,cookies); if(iWantCookie!=null)&#123; resp.getWriter().write(&quot;找到了需要的cookie&quot;); &#125; // for (Cookie cookie : cookies) &#123; //getName方法返回cookie的名称 // resp.getWriter().write(&quot;Cookie[&quot;+cookie.getName()+&quot;=&quot;+cookie.getValue()+&quot;]&lt;br/&gt;&quot;); // if(&quot;key1&quot;.equals(cookie.getName()))&#123; // iWantCookie=cookie; // break; // &#125; //&#125; //如果不等于null,说明附过值，也就是找到了需要的cookie // if(iWantCookie!=null)&#123; // resp.getWriter().write(&quot;找到了需要的cookie&quot;); //&#125; &#125; 封装的获取指定cookie的方法 传入要找到的cookie的名字，和全部的cookie就可以 1234567891011121314151617181920package com.atguigu.util;import javax.servlet.http.Cookie;/*查找指定名称的cookie对象 */public class CookieUtils &#123; public static Cookie findCookie(String name,Cookie[] cookies)&#123; if(name==null||cookies==null||cookies.length==0)&#123; return null; &#125; for (Cookie cookie : cookies) &#123; if(name.equals(cookie.getName()))&#123; return cookie; &#125; &#125; return null; &#125;&#125; Cookie值的修改方案一：1、先创建一个要修改的同名（指的就是 key）的 Cookie 对象 ​ 2、在构造器，同时赋于新的 Cookie 值。 ​ 3、调用 response.addCookie( Cookie ); 123456789protected void updateCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 1、先创建一个要修改的同名（指的就是 key）的 Cookie 对象 //2、在构造器，同时赋于新的 Cookie 值。 Cookie cookie=new Cookie(&quot;key1&quot;,&quot;newvalue1&quot;); // 3、调用 response.addCookie( Cookie ); resp.addCookie(cookie); resp.getWriter().write(&quot;key1的值已经修改好了&quot;);&#125; 方案二： 1、先查找到需要修改的 Cookie 对象 ​ 2、调用 setValue()方法赋于新的 Cookie 值。 ​ 3、调用 response.addCookie()通知客户端保存修改 12345678protected void updateCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1、先查找到需要修改的 Cookie 对象 Cookie cookie=CookieUtils.findCookie(&quot;key1&quot;,req.getCookies()); //2、调用 setValue()方法赋于新的 Cookie 值。 cookie.setValue(&quot;new1Value&quot;); //3、调用 response.addCookie()通知客户端保存修改 resp.addCookie(cookie);&#125; 这个value的值是不支持中文的 各种浏览器查看cookie Cookie生命周期Cookie 的生命控制指的是如何管理 Cookie 什么时候被销毁（删除） setMaxAge() 正数，表示在指定的秒数后过期 负数，表示浏览器一关，Cookie 就会被删除（默认值是-1） 零，表示马上删除 Cooki 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 默认级别的cookie会话，设置为-1是浏览器关闭才消失 * @param req * @param resp * @throws ServletException * @throws IOException */protected void defaultLife(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; Cookie cookie=new Cookie(&quot;defaultLife&quot;,&quot;defaultLife&quot;); cookie.setMaxAge(-1);//设置存活时间 resp.addCookie(cookie);&#125;/*立即删除 */protected void deleteNow(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;//先找到你要删除的cookie对象 Cookie cookie=CookieUtils.findCookie(&quot;key1&quot;,req.getCookies());//调用setMaxAge(0); if(cookie!=null)&#123; //马上删除 cookie.setMaxAge(0); &#125; //response.addCookie(cookie); resp.addCookie(cookie); resp.getWriter().write(&quot;key1的cookie已经被删除&quot;);&#125;/*指定cookie再存货一段时间 */protected void life3600(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; Cookie cookie=new Cookie(&quot;life3600&quot;,&quot;life3600&quot;); cookie.setMaxAge(60*60); resp.addCookie(cookie); resp.getWriter().write(&quot;已经创建了一个存货一小时的cookie&quot;);&#125; Cookie的Path设置Cookie 的 path 属性可以有效的过滤哪些 Cookie 可以发送给服务器。哪些不发。 path 属性是通过请求的地址来进行有效的过滤 只要能匹配cookie路径的请求地址都是可以发送的，就是cookie路径是请求地址的子串 · 1234567891011/*带路径的cookie的测试 */protected void testPath(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; Cookie cookie=new Cookie(&quot;path&quot;,&quot;path&quot;); //getContextPath()==&gt;&gt;得到工程路径 cookie.setPath(req.getContextPath()+&quot;/abc&quot;); System.out.println(req.getContextPath()+&quot;/abc&quot;); resp.addCookie(cookie); resp.getWriter().write(&quot;创建了一个带有Path路径的cookie&quot;);&#125; 访问它是不会给你pathcookie的 1http://localhost:8079/cookie/cookie.html 访问它可以给你cookie 1http://localhost:8079/cookie/abc/cookie.html 免输入用户名登录 login.jsp 1234567891011121314151617181920&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/8 Time: 16:08 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://localhost:8079/cookie/LoginServlet&quot; method=&quot;get&quot;&gt; 用户名: &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;$&#123;cookie.username.value&#125;&quot;&gt;&lt;br&gt; 密码: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234&lt;body&gt;获取cookie的名称:$&#123;cookie.JSESSIONID.name&#125;&lt;br/&gt;获取Cookie的值：$&#123;cookie.JSESSIONID.value&#125;&lt;/body&gt; JESSIONID是一个cookie的名字 LoginServlet 12345678910111213141516171819202122232425262728package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class LoginServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String username=req.getParameter(&quot;username&quot;); String password=req.getParameter(&quot;password&quot;); if(&quot;zzh&quot;.equals(username)&amp;&amp;&quot;123456&quot;.equals(password))&#123; //登陆成功 Cookie cookie=new Cookie(&quot;username&quot;,username); cookie.setMaxAge(60*60*24*7); resp.addCookie(cookie); System.out.println(&quot;登录成功&quot;); &#125; else &#123; //登陆失败 System.out.println(&quot;登陆失败&quot;); &#125; &#125;&#125; 第一次登陆成功之后 服务器发送了一个响应头中有cookie的值，cookie中保存了username 但是此时浏览器的cookie中还没有zzh&#x3D;username 第二次发起请求的时候 用户名上就有用户名 第二次请求的时候 请求头中就有cookie为username&#x3D;zzh，所以这时就是浏览器有cookie请求服务器时就会带着cookie一起 Session的创建什么是 Session 会话? 1、Session 就一个接口（HttpSession）。 2、Session 就是会话。它是用来维护一个客户端和服务器之间关联的一种技术。 3、每个客户端都有自己的一个 Session 会话。 4、Session 会话中，我们经常用来保存用户登录之后的信息。 Session是保存在服务器上 123456789101112public class SessionServlet extends BaseServlet&#123; protected void createorGetSession(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //创建和获取Session会话对象 HttpSession session=req.getSession(); //判断当前session会话，是否是新创建出来的 boolean isNew=session.isNew(); //获取Session会话的唯一标识 String id=session.getId(); resp.getWriter().write(&quot;得到的Session的id是&quot;+id+&quot;&lt;br/&gt;&quot;); resp.getWriter().write(&quot;这个Session是否是新创建的&quot;+isNew+&quot;&lt;br/&gt;&quot;); &#125; 1&lt;li&gt;&lt;a href=&quot;http://localhost:8079/cookie/SessionServlet?action=createorGetSession&quot; target=&quot;target&quot;&gt;Session的创建和获取（id号、是否为新创建）&lt;/a&gt;&lt;/li&gt; Session域中数据的存储在SessionServlet中增加的方法 12345678910111213141516/*往session域中存储数据 */protected void setAttribute(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.getSession().setAttribute(&quot;key1&quot;,&quot;value1&quot;); resp.getWriter().write(&quot;已经往session中保存了数据&quot;);&#125;/*从session域中获取数据 */protected void getAttribute(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; Object attribute=req.getSession().getAttribute(&quot;key1&quot;); resp.getWriter().write(&quot;从session域中获取的key1的值是&quot;+attribute);&#125; Session的生命周期的控制public void setMaxInactiveInterval(int interval) 设置 Session 的超时时间（以秒为单位），超过指定的时长，Session 就会被销毁。 session是基于cookie的，关闭浏览器cookie没了，session自然也就消失了 停服务器之后session也会没 值为正数的时候，设定 Session 的超时时长。 负数表示永不超时（极少使用） public int getMaxInactiveInterval()获取 Session 的超时时间 public void invalidate() 让当前 Session 会话马上超时无效。 Session 默认的超时时长是多少！ Session 默认的超时时间长为 30 分钟。 因为在 Tomcat 服务器的配置文件 web.xml中默认有以下的配置，它就表示配置了当前 Tomcat 服务器下所有的 Session 超时配置默认时长为：30 分钟 123 &lt;session-config&gt;&lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; 如果你想只修改个别 Session 的超时时长。就可以使用上面的 API。setMaxInactiveInterval(int interval)来进行单独的设 置。 session.setMaxInactiveInterval(int interval)单独设置超时时长。 当你间隔一秒二秒访问的时候这个timeout又会被重置为3 在SessionServlet中 12345678910111213141516171819202122232425262728293031 /* 获取Session的默认存在时长 */ protected void defaultLife(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取了Session的默认的超时时长 int maxInactiveInterval = req.getSession().getMaxInactiveInterval(); // resp.getWriter().write(&quot;Session的默认超时时长为&quot;+maxInactiveInterval+&quot;秒&quot;); &#125; /* 规定Session3秒之后超时 */ protected void life3(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //先获取session HttpSession session=req.getSession(); //设置当前session3秒之后消失 session.setMaxInactiveInterval(3); resp.getWriter().write(&quot;当前Session已经被设置3秒之后超时&quot;); &#125;/*让当前Session立即超时 */ protected void deleteNow(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //先获取session HttpSession session=req.getSession(); //设置当前session3秒之后消失 session.invalidate(); resp.getWriter().write(&quot;当前Session已经被设置为无效&quot;); &#125; 在Session.html中 123&lt;li&gt;&lt;a href=&quot;http://localhost:8079/cookie/SessionServlet?action=defaultLife&quot; target=&quot;target&quot;&gt;Session的默认超时及配置&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://localhost:8079/cookie/SessionServlet?action=life3&quot; target=&quot;target&quot;&gt;Session3秒超时销毁&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://localhost:8079/cookie/SessionServlet?action=deleteNow&quot; target=&quot;target&quot;&gt;Session马上销毁&lt;/a&gt;&lt;/li&gt; 浏览器合Session之间关联的内幕Session 技术，底层其实是基于 Cookie 技术来实现的。 书城项目第六阶段显示登陆的用户名UserServlet 中在sesseion中保存了用户信息 123456789//如果用户名和密码正确else&#123; //保存用户的登录信息 //因为每一个登陆成功页面都会显示名字，所以不能用request，request只有在一次请求中有效，再请求别的页面就无效了 //所以用Session req.getSession().setAttribute(&quot;user&quot;,loginUser); req.getRequestDispatcher(&quot;/pages/user/login_success.jsp&quot;).forward(req,resp);&#125; 在login_success_menu页面显示，出我登陆之后的用户名 123456&lt;div&gt; &lt;span&gt;欢迎&lt;span class=&quot;um_span&quot;&gt;$&#123;sessionScope.user.username&#125;&lt;/span&gt;光临尚硅谷书城&lt;/span&gt; &lt;a href=&quot;pages/order/order.jsp&quot;&gt;我的订单&lt;/a&gt; &lt;a href=&quot;index.jsp&quot;&gt;注销&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;index.jsp&quot;&gt;返回&lt;/a&gt;&lt;/div&gt; client下的index.jsp，分为登录和没登陆两种显示 12345678910111213141516171819202122232425 &lt;div&gt; &lt;%--如果用户没有注册--%&gt; &lt;c:if test=&quot;$&#123;empty sessionScope.user&#125;&quot;&gt; &lt;a href=&quot;pages/user/login.jsp&quot;&gt;登录&lt;/a&gt; | &lt;a href=&quot;pages/user/regist.jsp&quot;&gt;注册&lt;/a&gt; &lt;/c:if&gt;&amp;nbsp;&amp;nbsp; &lt;c:if test=&quot;$&#123;not empty sessionScope.user&#125;&quot;&gt; &lt;span&gt;欢迎&lt;span class=&quot;um_span&quot;&gt;$&#123;sessionScope.user.username&#125;&lt;/span&gt;光临尚硅谷书城&lt;/span&gt; &lt;a href=&quot;pages/order/order.jsp&quot;&gt;我的订单&lt;/a&gt; &lt;a href=&quot;index.jsp&quot;&gt;注销&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;/c:if&gt; &lt;a href=&quot;pages/cart/cart.jsp&quot;&gt;购物车&lt;/a&gt; &lt;a href=&quot;pages/manager/manager.jsp&quot;&gt;后台管理&lt;/a&gt; &lt;/div&gt; 注销登录1、销毁 Session 中用户登录的信息（或者销毁 Session） 2、重定向到首页（或登录页面）。 在UserServlet中添加方法 123456protected void logout(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //销毁session中的用户登录信息（或者销毁session） req.getSession().invalidate(); //重定向到首页 resp.sendRedirect(req.getContextPath());&#125; 将client的index.jsp和login_success_menu.jsp的注销都换成 1&lt;a href=&quot;UserServlet?action=logout&quot;&gt;注销&lt;/a&gt;&amp;nbsp; 表单重复提交之验证码表单重复提交有三种常见的情况： ‘ 一：提交完表单。服务器使用请求转来进行页面跳转。这个时候，用户按下功能键 F5，就会发起最后一次的请求。 造成表单重复提交问题。 解决方法：使用重定向来进行跳转 二：用户正常提交服务器，但是由于网络延迟等原因，迟迟未收到服务器的响应，这个时候，用户以为提交失败， 就会着急，然后多点了几次提交操作，也会造成表单重复提交。 三：用户正常提交服务器。服务器也没有延迟，但是提交完成后，用户回退浏览器。重新提交。也会造成表单重复 提交 RegistServlet中1.是获取Session中验证码，并删除Session的验证码 就是第一次访问regist.jsp的时候，服务器给一个验证码，保存到session域中，然后用户提交表单之后，保存Session中验证码之后，将Session域中验证码删除，然后将它和用户提交的验证码进行比较，第一次如果相同则运许，重复提交则会阻止 谷歌验证码的使用谷歌验证码 kaptcha 使用步骤如下： 1、导入谷歌验证码的 jar 包 ​ kaptcha-2.3.2.jar 2、在 web.xml 中去配置用于生成验证码的 Servlet 程序 12345678&lt;servlet&gt; &lt;servlet-name&gt;KaptchaServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.google.code.kaptcha.servlet.KaptchaServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;KaptchaServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/kaptcha.jpg&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 3、在表单中使用 img 标签去显示验证码图片并使用 123456&lt;form action=&quot;http://localhost:8080/tmp/registServlet&quot; method=&quot;get&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; &gt; &lt;br&gt; 验证码：&lt;input type=&quot;text&quot; style=&quot;width: 60px;&quot; name=&quot;code&quot;&gt; &lt;img src=&quot;http://localhost:8080/tmp/kaptcha.jpg&quot; alt=&quot;&quot; style=&quot;width: 100px; height: 28px;&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/form&gt; 4、在服务器获取谷歌生成的验证码和客户端发送过来的验证码比较使用 123456789101112131415161718192021222324252627282930313233package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import static com.google.code.kaptcha.Constants.KAPTCHA_SESSION_KEY;public class RegistServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 获取Session中的验证码 String token = (String) req.getSession().getAttribute(KAPTCHA_SESSION_KEY); // 删除 Session中的验证码 req.getSession().removeAttribute(KAPTCHA_SESSION_KEY); String code = req.getParameter(&quot;code&quot;); // 获取用户名 String username = req.getParameter(&quot;username&quot;); if (token != null &amp;&amp; token.equalsIgnoreCase(code)) &#123; System.out.println(&quot;保存到数据库：&quot; + username); resp.sendRedirect(req.getContextPath() + &quot;/ok.jsp&quot;); &#125; else &#123; System.out.println(&quot;请不要重复提交表单&quot;); &#125; &#125;&#125; 在书城中用验证码1、导入谷歌验证码的 jar 包 ​ kaptcha-2.3.2.jar 2、在 web.xml 中去配置用于生成验证码的 Servlet 程序 12345678&lt;servlet&gt; &lt;servlet-name&gt;KaptchaServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.google.code.kaptcha.servlet.KaptchaServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;KaptchaServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/kaptcha.jpg&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 3、在表单中使用 img 标签去显示验证码图片并使用 123&lt;label&gt;验证码：&lt;/label&gt;&lt;input class=&quot;itxt&quot; type=&quot;text&quot; name=&quot;code&quot; style=&quot;width: 100px;&quot; id=&quot;code&quot;/&gt;&lt;img alt=&quot;&quot; src=&quot;kaptcha.jpg&quot; style=&quot;float: right; margin-right: 40px;width:100px;height:28px &quot;&gt; 4.在服务器获取谷歌生成的验证码和客户端发送过来的验证码比较使用 修改的UserServlet中的regist方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950protected void regist(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 获取Session中的验证码 String token = (String) req.getSession().getAttribute(KAPTCHA_SESSION_KEY); // 删除 Session中的验证码 req.getSession().removeAttribute(KAPTCHA_SESSION_KEY); //1.获取请求的参数 //这个getParameter方法是通过那个属性的name得到的 String username=req.getParameter(&quot;username&quot;); String password=req.getParameter(&quot;password&quot;); String email=req.getParameter(&quot;email&quot;); String code=req.getParameter(&quot;code&quot;); //2.检查 验证码是否正确,先把验证码写死，要求为abcde if(token.equalsIgnoreCase(code)&amp;&amp;token!=null)&#123; //验证码正确 //检查用户名是否可用 if(userService.existsUsername(username))&#123; System.out.println(&quot;用户名&quot;+username+&quot;已存在&quot;); req.setAttribute(&quot;msg&quot;,&quot;用户名已存在&quot;); req.setAttribute(&quot;username&quot;,username); req.setAttribute(&quot;email&quot;,email); //跳回到注册页面 req.getRequestDispatcher(&quot;/pages/user/regist.jsp&quot;).forward(req,resp); &#125; else &#123; //可用 //调用Sercice保存到数据库 Map map=req.getParameterMap(); User user= WebUtils.copyParamToBean(map,new User()); userService.registerUser(user); //注册成功后，跳转到注册成功页面 req.getRequestDispatcher(&quot;/pages/user/regist_success.jsp&quot;).forward(req,resp); &#125; &#125;else&#123; //把回显信息保存到request域中 req.setAttribute(&quot;msg&quot;,&quot;用户验证码错误&quot;); req.setAttribute(&quot;username&quot;,username); req.setAttribute(&quot;email&quot;,email); System.out.println(&quot;验证码&quot;+code+&quot;错误&quot;); //验证码不正确 //跳回注册页面，因为还是申请服务器中文件所以/还是工程目录下的 req.getRequestDispatcher(&quot;/pages/user/regist.jsp&quot;).forward(req,resp); &#125;&#125; 验证码的切换切换指的是点击验证码，会切换一个图片 给图片添加一个单击事件，这种方法在ie和火狐浏览器只能重新生成一个 1234567891011$(function()&#123; /* 给验证码的图片绑定单击事件 */ $(&quot;#codeimg&quot;).click(function()&#123; //在事件响应的function函数中有一个this对象，是当前正在响应事件的dom对象 //src属性表示验证码img标签的 图片路径，它可读，它可写 //下面给它赋值之后，就会自动再生成一个图片 this.src=&quot;$&#123;basePath&#125;&quot;+&quot;/kaptcha.jpg&quot;; &#125;); 在重新生成验证码的路径后面加一个get传参，然后这个参数每次都不一样，所以拿时间戳作为参数是最好的选择 1234567891011$(function()&#123; /* 给验证码的图片绑定单击事件 */ $(&quot;#codeimg&quot;).click(function()&#123; //在事件响应的function函数中有一个this对象，是当前正在响应事件的dom对象 //src属性表示验证码img标签的 图片路径，它可读，它可写 //下面给它赋值之后，就会自动再生成一个图片 this.src=&quot;$&#123;basePath&#125;kaptcha.jpg?d=&quot;+new Date(); &#125;); 购物车模块 点击添加至购物车时（带着图书的id），就是先调用CartServlet中的方法（将图书转换为商品项），然后CartServlt中的方法调用Cart对象中的功能方法，然后再把Cart购物车展示 购物车商品项 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.atguigu.pojo;import java.math.BigDecimal;/*购物车的商品项 */public class CartItem &#123; private Integer id; private String name; private Integer count; public Integer getId() &#123; return id; &#125; @Override public String toString() &#123; return &quot;CartItem&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, count=&quot; + count + &quot;, price=&quot; + price + &quot;, totalPrice=&quot; + totalPrice + &#x27;&#125;&#x27;; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getCount() &#123; return count; &#125; public void setCount(Integer count) &#123; this.count = count; &#125; public BigDecimal getPrice() &#123; return price; &#125; public void setPrice(BigDecimal price) &#123; this.price = price; &#125; public BigDecimal getTotalPrice() &#123; return totalPrice; &#125; public void setTotalPrice(BigDecimal totalPrice) &#123; this.totalPrice = totalPrice; &#125; public CartItem(Integer id, String name, Integer count, BigDecimal price, BigDecimal totalPrice) &#123; this.id = id; this.name = name; this.count = count; this.price = price; this.totalPrice = totalPrice; &#125; private BigDecimal price; private BigDecimal totalPrice; public CartItem() &#123; &#125;&#125; 购物车对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.atguigu.pojo;import java.math.BigDecimal;import java.util.ArrayList;import java.util.List;public class Cart &#123; public Integer getTotalCount() &#123; return totalCount; &#125; @Override public String toString() &#123; return &quot;Cart&#123;&quot; + &quot;totalCount=&quot; + totalCount + &quot;, totalPrice=&quot; + totalPrice + &quot;, items=&quot; + items + &#x27;&#125;&#x27;; &#125; public void setTotalCount(Integer totalCount) &#123; this.totalCount = totalCount; &#125; public BigDecimal getTotalPrice() &#123; return totalPrice; &#125; public void setTotalPrice(BigDecimal totalPrice) &#123; this.totalPrice = totalPrice; &#125; public List&lt;CartItem&gt; getItems() &#123; return items; &#125; public void setItems(List&lt;CartItem&gt; items) &#123; this.items = items; &#125; private Integer totalCount; private BigDecimal totalPrice; private List&lt;CartItem&gt; items=new ArrayList&lt;CartItem&gt;(); &#125; 购物车的功能方法Cart 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package com.atguigu.pojo;import com.sun.javafx.collections.MappingChange;import java.math.BigDecimal;import java.util.ArrayList;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;public class Cart &#123; private Integer totalCount; private BigDecimal totalPrice; public Integer getTotalCount() &#123; totalCount=0; for(Map.Entry&lt;Integer,CartItem&gt; entry : items.entrySet())&#123; totalCount+=entry.getValue().getCount(); &#125; return totalCount; &#125; @Override public String toString() &#123; return &quot;Cart&#123;&quot; + &quot;totalCount=&quot; + getTotalCount() + &quot;, totalPrice=&quot; + getTotalPrice() + &quot;, items=&quot; + items + &#x27;&#125;&#x27;; &#125; public BigDecimal getTotalPrice() &#123; totalPrice=new BigDecimal(0); for(Map.Entry&lt;Integer,CartItem&gt; entry : items.entrySet())&#123; totalPrice=totalPrice.add(entry.getValue().getTotalPrice()); &#125; return totalPrice; &#125; public Map&lt;Integer, CartItem&gt; getItems() &#123; return items; &#125; public void setItems(Map&lt;Integer, CartItem&gt; items) &#123; this.items = items; &#125; /* Map类型，key是商品编号，value是商品信息 */ private Map&lt;Integer,CartItem&gt; items=new LinkedHashMap&lt;Integer,CartItem&gt;(); /* 添加商品项 */ public void addItem(CartItem carItem)&#123; //先看商品中是否已经添加过此商品，如果已经添加，则数量累加，总金额更新，如果没有添加过，直接放到集合中即可 CartItem item = items.get(carItem.getId()); if(item==null)&#123; //如果之前没有添加过,则直接添加 items.put(carItem.getId(),carItem); &#125; else &#123; //之前添加过 //数量累加 item.setCount(item.getCount()+1); //两个BigDecimal之间才能相乘，所以把count改为BigDecimal类型的 item.setTotalPrice(item.getPrice().multiply(new BigDecimal(item.getCount()))); &#125; &#125; /* 删除商品项 */ public void deleteItem(Integer id)&#123; items.remove(id); &#125; /* 清空购物车 */ public void clear()&#123;items.clear(); &#125; /* 修改商品数量 */ public void updateCount(Integer id,Integer count)&#123; //先查看购物车中是否有此商品，如果有，就修改商品数量，更新总金额 CartItem item=items.get(id); if(item!=null)&#123; item.setCount(count); item.setTotalPrice(item.getPrice().multiply(new BigDecimal(item.getCount()))); &#125; &#125;&#125; 添加商品到购物车使用请求转发是在request域中存储东西的时候用的 CartServlet中加一个方法 1234567891011121314151617181920212223242526272829303132private BookService bookService=new BookServiceImpl();/*加入购物车 */protected void addItem(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求的参数，商品编号 int id= WebUtils.parseInt(req.getParameter(&quot;id&quot;),0); //调用bookService.queryBookById(id):得到Book的信息 Book book = bookService.queryBookById(id); //把图书信息转化成为CartItem商品项 CartItem cartItem=new CartItem(book.getId(),book.getName(),1,book.getPrice(),book.getPrice()); /* 用session存储cart信息 */ Cart cart = (Cart) req.getSession().getAttribute(&quot;cart&quot;); if(cart==null)&#123; cart=new Cart(); req.getSession().setAttribute(&quot;cart&quot;,cart); &#125; //调用Cart.addItem(CartItem)添加商品项 cart.addItem(cartItem); System.out.println(cart); //重定向回商品列表页面 /* req.getHeader(&quot;Referer&quot;)获取请求服务器的地址，然后下面再跳回到这个地址 */ resp.sendRedirect(req.getHeader(&quot;Referer&quot;));&#125; client中的index.jsp 1&lt;button bookId=$&#123;book.id&#125; class=&quot;addToCart&quot;&gt;加入购物车&lt;/button&gt; 给加入购物车加一个bookId属性，用来保存要加入购物车的书的id 那加入购物车的点击的事件 12345678910111213141516171819&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; $(&quot;button.addToCart&quot;).click(function()&#123; /** * 在事件响应的function函数中有一个this对象，就是是当前正在响应事件的dom对象，就是那个标签的dom对象， * @type &#123;*|jQuery&#125; */ /* 先把this改为jQery对象然后获取属性值 */ var bookId=$(this).attr(&quot;bookId&quot;); //跳转到 location.href=&quot;http://localhost:8087/book2/CartServlet?action=addItem&amp;id=&quot;+bookId; &#125;); &#125;);&lt;/script&gt; 这个图意思就是点击加入购物车的时候，返回的地址是不一样的 但是可以通过Referer获取请求发起时，浏览器地址栏中的地址发给服务器，然后获取这个地址之后，再跳转回去 1req.getHeader(&quot;Referer&quot;) 购物车展示cart.jsp是购物车界面 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;购物车&lt;/title&gt; &lt;!--使用静态包含引入css样式jQuery和base标签--&gt; &lt;%@ include file=&quot;/pages/common/head.jsp&quot;%&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;header&quot;&gt; &lt;img class=&quot;logo_img&quot; alt=&quot;&quot; src=&quot;static/img/logo.gif&quot; &gt; &lt;span class=&quot;wel_word&quot;&gt;购物车&lt;/span&gt; &lt;!--静态包含jsp文件--&gt; &lt;%@ include file=&quot;/pages/common/login_success_menu.jsp&quot;%&gt; &lt;/div&gt; &lt;div id=&quot;main&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td&gt;数量&lt;/td&gt; &lt;td&gt;单价&lt;/td&gt; &lt;td&gt;金额&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;%--空的时候输出--%&gt; &lt;c:if test=&quot;$&#123;empty sessionScope.cart.items&#125;&quot;&gt; &lt;tr&gt; &lt;td colspan=&quot;5&quot;&gt;&lt;a href=&quot;index.jsp&quot;&gt;亲，当前购物车为空快去浏览商品吧&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:if&gt; &lt;%--非空的时候输出--%&gt; &lt;c:if test=&quot;$&#123;not empty sessionScope.cart.items&#125;&quot;&gt; &lt;c:forEach items=&quot;$&#123;sessionScope.cart.items&#125;&quot; var=&quot;entry&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;entry.value.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;entry.value.count&#125;&lt;/td&gt; &lt;td&gt;$&#123;entry.value.price&#125;&lt;/td&gt; &lt;td&gt;$&#123;entry.value.totalPrice&#125;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;#&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/c:if&gt; &lt;/table&gt; &lt;%--如果购物车是非空才输出下面的内容--%&gt; &lt;c:if test=&quot;$&#123;not empty sessionScope.cart.items&#125;&quot;&gt; &lt;div class=&quot;cart_info&quot;&gt; &lt;span class=&quot;cart_span&quot;&gt;购物车中共有&lt;span class=&quot;b_count&quot;&gt;$&#123;sessionScope.cart.totalCount&#125;&lt;/span&gt;件商品&lt;/span&gt; &lt;span class=&quot;cart_span&quot;&gt;总金额&lt;span class=&quot;b_price&quot;&gt;$&#123;sessionScope.cart.totalPrice&#125;&lt;/span&gt;元&lt;/span&gt; &lt;span class=&quot;cart_span&quot;&gt;&lt;a href=&quot;#&quot;&gt;清空购物车&lt;/a&gt;&lt;/span&gt; &lt;span class=&quot;cart_span&quot;&gt;&lt;a href=&quot;pages/cart/checkout.jsp&quot;&gt;去结账&lt;/a&gt;&lt;/span&gt; &lt;/div&gt; &lt;/c:if&gt; &lt;/div&gt; &lt;!--静态包含页脚的代码--&gt; &lt;%@include file=&quot;/pages/common/footer.jsp&quot; %&gt;&lt;/body&gt;&lt;/html&gt; 1$&#123;entry.value.name&#125; 这个entry应该是Map.Entry对象，所以可以用entry.value取得value的值 删除购物车中的商品改删除的这个链接 1&lt;td&gt;&lt;a href=&quot;CartServlet?action=deleteItem&amp;id=$&#123;entry.value.id&#125;&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; 给链接加一个单击事件 1234567891011&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; //给删除绑定一个单击事件 $(&quot;a.deleteItem&quot;).click(function()&#123; //返回true是单击事件发生，返回false是单击事件不发生 return confirm(&quot;你确定要删除&quot;+$(this).parent().parent().find(&quot;td:first&quot;).text()+&quot;】吗&quot;); &#125;); &#125;);&lt;/script&gt; 给a标签绑定单击事件，如果返回false就不会跳转了 confirm是崩出一个确认的弹框，有true和false两个选项，点true就返回true，点false就返回false 在js中return false的作用一般是用来取消默认动作的。比如你单击一个链接除了触发你（指定的）的onclick事件以外还要触发一个默认事件就是执行页面的跳转。所以如果你想取消对象的默认动作就可以return false。 比如表单的提交，如果有一个单击事件返回false，那么会阻止表单提交 CartServlet中添加一个方法 123456789101112protected void deleteItem(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求的参数，商品编号 int id= WebUtils.parseInt(req.getParameter(&quot;id&quot;),0); Cart cart = (Cart) req.getSession().getAttribute(&quot;cart&quot;); if(cart!=null)&#123; //删除 了购物车商品项 cart.deleteItem(id); &#125; //重定向到请求的那个地址 resp.sendRedirect(req.getHeader(&quot;Referer&quot;));&#125; 清空购物车的实现CartServlet中加一个clear()方法 123456789protected void clear(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.获取购物车对象 Cart cart = (Cart)req.getSession().getAttribute(&quot;cart&quot;); if(cart!=null)&#123; cart.clear(); //重定向会原来购物车展示的页面 resp.sendRedirect(req.getHeader(&quot;Referer&quot;)); &#125;&#125; 清空购物车选项改一下链接 1&lt;span class=&quot;cart_span&quot;&gt;&lt;a class=&quot;deleteAll&quot; href=&quot;CartServlet?action=clear&quot;&gt;清空购物车&lt;/a&gt;&lt;/span&gt; 给清空购物车定义一个单击事件，用来确认是否全部删除 1234567891011121314151617&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; //给删除绑定一个单击事件 $(&quot;a.deleteItem&quot;).click(function()&#123; //返回true是单击事件发生，返回false是单击事件不发生 return confirm(&quot;你确定要删除&quot;+$(this).parent().parent().find(&quot;td:first&quot;).text()+&quot;】吗&quot;); &#125;); //给清空购物车邦单击事件 $(&quot;a.deleteAll&quot;).click(function()&#123; return confirm(&quot;你确定要删除全部的图书么&quot;); &#125;); &#125;);&lt;/script&gt; 修改购物车商品数量CartServlet中添加一个方法 1234567891011121314protected void updateCount(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求的参数，商品编号，商品数量 int id=WebUtils.parseInt(req.getParameter(&quot;id&quot;),0); int count=WebUtils.parseInt(req.getParameter(&quot;count&quot;),1); //获取购物车对象 Cart cart=(Cart)req.getSession().getAttribute(&quot;cart&quot;); //修改商品数量 if(cart!=null) &#123; cart.updateCount(id, count); //重定向会原来购物车展示的页面 resp.sendRedirect(req.getHeader(&quot;Referer&quot;)); &#125;&#125; cart.jsp中给输入框加一个内容改变事件 获得count是图书数量要改变成得值，num是书的名字，id是那本书的id，然后带着count和id访问CartServlet 1234567891011121314$(&quot;.updateCount&quot;).change(function()&#123; var num=$(this).parent().parent().find(&quot;td:first&quot;).text(); var count=this.value; var id=$(this).attr(&#x27;bookId&#x27;); if( confirm(&quot;你确定要将这本【&quot;+num+&quot;】的数量改编为【&quot;+count+&quot;】&quot;))&#123; //发起请求给服务器保存修改 location.href=&quot;http://localhost:8087/book2/CartServlet? action=updateCount&amp;count=&quot;+count+&quot;&amp;id=&quot;+id; &#125; else &#123; //this.defaultValue它是表单项dom对象的属性，它表示默认的value属性值 this.value=this.defaultValue; &#125;&#125;); 把书的数量那里变一个输入框 bookId记录要改得书的id，value是书的数量要改成的值 12345678910111213&lt;c:forEach items=&quot;$&#123;sessionScope.cart.items&#125;&quot; var=&quot;entry&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;entry.value.name&#125;&lt;/td&gt; &lt;td&gt; &lt;input class=&quot;updateCount&quot; style=&quot;width: 80px;&quot; bookId=&quot;$&#123;entry.value.id&#125;&quot; type=&quot;text&quot; value=&quot;$&#123;entry.value.count&#125;&quot;&gt; &lt;/td&gt; &lt;td&gt;$&#123;entry.value.price&#125;&lt;/td&gt; &lt;td&gt;$&#123;entry.value.totalPrice&#125;&lt;/td&gt; &lt;td&gt;&lt;a class=&quot;deleteItem&quot; href=&quot;CartServlet?action=deleteItem&amp;id=$&#123;entry.value.id&#125;&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; 首页购物车数据展示再CartServlet中的addItem方法添加这一行，来存储最新的加入购物车书的名称 1req.getSession().setAttribute(&quot;lastName&quot;,cartItem.getName()); 分为购物车为空和购物车不为空 123456789101112131415161718&lt;c:if test=&quot;$&#123;empty sessionScope.cart.items&#125;&quot;&gt; &lt;%--购物车为空的输出--%&gt; &lt;span&gt;&lt;/span&gt; &lt;div&gt; &lt;span style=&quot;color: red&quot;&gt;当前购物车为空&lt;/span&gt; &lt;/div&gt;&lt;/c:if&gt;&lt;c:if test=&quot;$&#123;not empty sessionScope.cart.items&#125;&quot;&gt; &lt;%--购物车不为空的输出--%&gt; &lt;span&gt;您的购物车中有$&#123;sessionScope.cart.totalCount&#125;件商品&lt;/span&gt; &lt;div&gt; &lt;%--这是用来获取session中存储的最后添加的书的名字--%&gt; 您刚刚将&lt;span style=&quot;color: red&quot;&gt;$&#123;sessionScope.lastName&#125;&lt;/span&gt;加入到了购物车中 &lt;/div&gt;&lt;/c:if&gt; 书城项目第七阶段订单模块的分析 订单项是订单的物品的详细信息，一个购物车属于是一个订单 创建数据库表123456789101112131415161718 use book; create table t_order(`order_id` varchar(50) primary key,`create_time` datetime, `price` decimal(11,2),`status` int, `user_id` int, foreign key(`user_id`) references t_user(`id`) ); create table t_order_item(`id` int primary key auto_increment,`name` varchar(100),`count` int, `price` decimal(11,2),`total_price` decimal(11,2),`order_id` varchar(50), foreign key(`order_id`) references t_order(`order_id`) ); foreign key(order_id) references t_order(order_id)建立外键 编写订单两个模块的数据模型Order 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.atguigu.pojo;import java.math.BigDecimal;import java.util.Date;public class Order &#123; private String orderId; private Date createTime; public String getOrderId() &#123; return orderId; &#125; public void setOrderId(String orderId) &#123; this.orderId = orderId; &#125; @Override public String toString() &#123; return &quot;Order&#123;&quot; + &quot;orderId=&#x27;&quot; + orderId + &#x27;\\&#x27;&#x27; + &quot;, createTime=&quot; + createTime + &quot;, price=&quot; + price + &quot;, status=&quot; + status + &quot;, userId=&quot; + userId + &#x27;&#125;&#x27;; &#125; public Order() &#123; &#125; public Date getCreateTime() &#123; return createTime; &#125; public void setCreateTime(Date createTime) &#123; this.createTime = createTime; &#125; public BigDecimal getPrice() &#123; return price; &#125; public void setPrice(BigDecimal price) &#123; this.price = price; &#125; public Integer getStatus() &#123; return status; &#125; public void setStatus(Integer status) &#123; this.status = status; &#125; public Integer getUserId() &#123; return userId; &#125; public void setUserId(Integer userId) &#123; this.userId = userId; &#125; private BigDecimal price; //0未发货，1已发货，2表示以签收 private Integer status=0; private Integer userId;&#125; OrderItem 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.atguigu.pojo;import java.math.BigDecimal;public class OrderItem &#123;private Integer id;private String name; public OrderItem() &#123; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getCount() &#123; return count; &#125; public void setCount(Integer count) &#123; this.count = count; &#125; public BigDecimal getPrice() &#123; return price; &#125; public void setPrice(BigDecimal price) &#123; this.price = price; &#125; public String getOrderId() &#123; return orderId; &#125; public void setOrderId(String orderId) &#123; this.orderId = orderId; &#125; @Override public String toString() &#123; return &quot;OrderItem&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, count=&quot; + count + &quot;, price=&quot; + price + &quot;, orderId=&#x27;&quot; + orderId + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public OrderItem(Integer id, String name, Integer count, BigDecimal price, String orderId) &#123; this.id = id; this.name = name; this.count = count; this.price = price; this.orderId = orderId; &#125; private Integer count;private BigDecimal price;private String orderId;&#125; 编写DaoOrderDao 12345678910111213141516package com.atguigu.dao;import com.atguigu.pojo.Order;import java.util.List;public interface OrderDao &#123; //保存订单 public int saveOrder(Order order); //查询全部订单 public List&lt;Order&gt; queryOrders(); //改变订单状态 public int changeStatus(int orderId, int status); //根据用户id查找订单 public List&lt;Order&gt; queryOrdersByUserId(int userId);&#125; OrderDaoImpl 12345678910111213141516171819202122232425262728293031323334353637package com.atguigu.dao.impl;import com.atguigu.dao.OrderDao;import com.atguigu.pojo.Order;import java.util.List;public class OrderDaoImpl extends BaseDao implements OrderDao &#123; @Override public int saveOrder(Order order) &#123; String sql=&quot;insert into t_order(order_id,create_time,price,status,user_id) values(?,?,?,?,?)&quot;; return update(sql,order.getOrderId(),order.getCreateTime(),order.getPrice(),order.getStatus(),order.getUserId()); &#125; @Override public List&lt;Order&gt; queryOrders() &#123; String sql=&quot;select order_id orderId,create_time createTime,price,status,user_Id userId from t_order&quot;; return queryForList(Order.class,sql); &#125; @Override public int changeStatus(int orderId, int status) &#123; String sql=&quot;update t_order set status=? where order_id=?&quot;; return update(sql,status,orderId); &#125; @Override public List&lt;Order&gt; queryOrdersByUserId(int userId) &#123; String sql=&quot;select order_id orderId,create_time createTime,price,status,user_id userId from t_order where user_id=?&quot;; return queryForList(Order.class,sql,userId); &#125;&#125; 在使用queryForList和queryForOne来获得javaBean对象的时候，这个javaBean类中属性的名字必须和select后面的列名相同，或者是起名让他相同 sql的update语句完全可以只改变一两个属性 OrderItemDao 1234567891011121314package com.atguigu.dao;import com.atguigu.pojo.OrderItem;public interface OrderItemDao &#123; /* 保存订单项 */ public int saveOrderItem(OrderItem orderItem); /* 根据订单号查询订单明细 */ public OrderItem queryOrderItemsByOrderId(int orderId);&#125; OrderItemDaoImpl 12345678910111213141516171819202122package com.atguigu.dao.impl;import com.atguigu.dao.OrderItemDao;import com.atguigu.pojo.OrderItem;public class OrderItemDaoImpl extends BaseDao implements OrderItemDao &#123; @Override public int saveOrderItem(OrderItem orderItem) &#123; String sql=&quot;insert into t_order_item(name,count,price,total_price,order_id) values(?,?,?,?,?)&quot;; return update(sql,orderItem.getName(),orderItem.getCount(),orderItem.getPrice(),orderItem.getTotalPrice(),orderItem.getOrderId()); &#125; @Override public OrderItem queryOrderItemsByOrderId(int orderId) &#123; String sql=&quot;select id,name,count,price,total_price totalPrice,order_id orderId from t_order_item where order_id=?&quot;; return queryForOne(OrderItem.class,sql,orderId); &#125;&#125; Service的编写OrderService 123456789101112package com.atguigu.service;import com.atguigu.pojo.Cart;public interface OrderService &#123; public String createOrder(Cart cart, int userId); public void showAllOrders(); public void sendOrder(int orderId); public void showOrderDetail(int orderId); public void showMyOrders(int userId); public void receiveOrder(int orderId);&#125; OrderServiceImpl 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.atguigu.service.impl;import com.atguigu.dao.impl.OrderDaoImpl;import com.atguigu.dao.impl.OrderItemDaoImpl;import com.atguigu.pojo.Cart;import com.atguigu.pojo.CartItem;import com.atguigu.pojo.Order;import com.atguigu.pojo.OrderItem;import com.atguigu.service.OrderService;import java.util.List;import java.util.Map;import java.util.Date;public class OrderServiceImpl implements OrderService &#123; private OrderDaoImpl orderDao=new OrderDaoImpl(); private OrderItemDaoImpl orderItemDao=new OrderItemDaoImpl(); @Override public String createOrder(Cart cart, int userId) &#123; //订单号，唯一性 用时间戳加userId保证唯一性 String orderId=System.currentTimeMillis()+&quot;&quot;+userId; //创建一个订单对象 Order order=new Order(orderId,new Date(),cart.getTotalPrice(),0,userId); //保存订单 orderDao.saveOrder(order); //遍历购物车中每一个商品转换成为订单项保存到数据库 for(Map.Entry&lt;Integer, CartItem&gt;entry:cart.getItems().entrySet())&#123; //获取每一个购物车中的商品项 CartItem cartItem=entry.getValue(); //然后转化为每一个订单项 OrderItem orderItem=new OrderItem(null,cartItem.getName(),cartItem.getTotalPrice(),cart.getTotalCount(),cartItem.getPrice(),orderId); //保存到数据库 orderItemDao.saveOrderItem(orderItem); &#125; //清空购物车 cart.clear(); return orderId; &#125; @Override public void showAllOrders() &#123; List&lt;Order&gt; orders = orderDao.queryOrders(); for (Order order : orders) &#123; System.out.println(order); &#125; &#125; @Override public void sendOrder(int orderId) &#123;orderDao.changeStatus(orderId,1); &#125; @Override public void showOrderDetail(int orderId) &#123; OrderItem orderItem = orderItemDao.queryOrderItemsByOrderId(orderId); System.out.println(orderItem); &#125; @Override public void showMyOrders(int userId) &#123; List&lt;Order&gt; orders = orderDao.queryOrdersByUserId(userId); for (Order order : orders) &#123; System.out.println(order); &#125; &#125; @Override public void receiveOrder(int orderId) &#123;orderDao.changeStatus(orderId,2); &#125;&#125; 结账功能实现改一下Service中的createOrder方法 实现结账后同时更新库存和销量 123456789101112131415161718192021222324252627@Overridepublic String createOrder(Cart cart, int userId) &#123; //订单号，唯一性 用时间戳加userId保证唯一性 String orderId=System.currentTimeMillis()+&quot;&quot;+userId; //创建一个订单对象 Order order=new Order(orderId,new Date(),cart.getTotalPrice(),0,userId); //保存订单 orderDao.saveOrder(order); //遍历购物车中每一个商品转换成为订单项保存到数据库 for(Map.Entry&lt;Integer, CartItem&gt;entry:cart.getItems().entrySet())&#123; //获取每一个购物车中的商品项 CartItem cartItem=entry.getValue(); //然后转化为每一个订单项 OrderItem orderItem=new OrderItem(null,cartItem.getName(),cartItem.getTotalPrice(),cart.getTotalCount(),cartItem.getPrice(),orderId); //保存到数据库 orderItemDao.saveOrderItem(orderItem); //更新库存和销量 Book book=bookDao.queryBookById(cartItem.getId()); book.setSales(book.getSales()+cartItem.getCount()); book.setStock(book.getStock()-cartItem.getCount()); &#125; //清空购物车 cart.clear(); return orderId;&#125; OrderServlet 123456789101112131415161718192021222324252627282930313233343536373839package com.atguigu.web;import com.atguigu.pojo.Cart;import com.atguigu.pojo.User;import com.atguigu.service.OrderService;import com.atguigu.service.impl.OrderServiceImpl;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class OrderServlet extends BaseServlet&#123; private OrderService orderService=new OrderServiceImpl(); /* 生成订单 */ protected void createOrder(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //先获取Cart购物车对象 Cart cart=(Cart)req.getSession().getAttribute(&quot;cart&quot;); //获取Userid User loginUser=(User)req.getSession().getAttribute(&quot;user&quot;); //如果没有注册就去注册一下 if(loginUser==null)&#123; req.getRequestDispatcher(&quot;/pages/user/login.jsp&quot;).forward(req,resp); &#125; Integer userId=loginUser.getId(); //调用orderService.createOrder(Cart,Userid) //得到获得的订单号 String orderId=orderService.createOrder(cart,userId); //将订单号保存在session域中 req.getSession().setAttribute(&quot;orderId&quot;,orderId); //请求转发 resp.sendRedirect(req.getContextPath()+&quot;/pages/cart/checkout.jsp&quot;); return; &#125;&#125; checkout.jsp 显示订单的号 1&lt;h1&gt;你的订单已结算，订单号为$&#123;sessionScope.orderId&#125;&lt;/h1&gt; cart.jsp 改去结账的链接 1&lt;span class=&quot;cart_span&quot;&gt;&lt;a href=&quot;OrderServlet?action=createOrder&quot;&gt;去结账&lt;/a&gt;&lt;/span&gt; 一开始一直不行，经过我的不断测试发现其实userId是空的，然后看到UserServlet中的保存user的时候，保存的是没有id的 于是对这个保存id的操作修改，用userDao从数据库中找到了有id的user，保存到session域中 12//用Dao找到那个有id的User而不是用loginUser这个没id的User User user=userDao.queryByUsername(username); UserServlet 1234567891011121314151617181920212223242526 private UserService userService=new UserServiceImpl(); private UserDao userDao=new UserDaoImpl(); protected void login(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;//获取用户名和密码参数 String username=req.getParameter(&quot;username&quot;); String password=req.getParameter(&quot;password&quot;); User loginUser=new User(null,username,password,null); //如果用户名或密码错误 if(userService.login(loginUser)==null)&#123; //把错误信息，和回显的表单项信息，保存到request域中 req.setAttribute(&quot;msg&quot;,&quot;用户名或者密码错误&quot;); req.setAttribute(&quot;username&quot;,username); req.getRequestDispatcher(&quot;/pages/user/login.jsp&quot;).forward(req,resp); &#125; //如果用户名和密码正确 else &#123; //用Dao找到那个有id的User而不是用loginUser这个没id的User User user=userDao.queryByUsername(username); //保存用户的登录信息 //因为每一个登陆成功页面都会显示名字，所以不能用request，request只有在一次请求中有效，再请求别的页面就无效了 //所以用Session req.getSession().setAttribute(&quot;user&quot;,user); req.getRequestDispatcher(&quot;/pages/user/login_success.jsp&quot;).forward(req,resp); &#125; &#125; Filter过滤器1、Filter 过滤器它是 JavaWeb 的三大组件之一。三大组件分别是：Servlet 程序、Listener 监听器、Filter 过滤器 2、Filter 过滤器它是 JavaEE 的规范。也就是接口 3、Filter 过滤器它的作用是：拦截请求，过滤响应。 拦截请求常见的应用场景有： 1、权限检查 2、日记操作 3、事务管理 ……等等 Filter初体验要求：在你的 web 工程下，有一个 admin 目录。这个 admin 目录下的所有资源（html 页面、jpg 图片、jsp 文件、等等）都必 须是用户登录之后才允许访问。 思考：根据之前我们学过内容。我们知道，用户登录之后都会把用户登录的信息保存到 Session 域中。所以要检查用户是否 登录，可以判断 Session 中否包含有用户登录的信息即可！！！ 实现一 如果用户没有用户名，也就是没登录，跳转到登录页面 局限：只有jsp文件才有 12345678&lt;% Object user=session.getAttribute(&quot;user&quot;); //如果等于null，说明还没有登陆 if(user==null)&#123; request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request,response); return; &#125;%&gt; 用Filter实现这个功能 AdminFilter实现Filter 1234567891011121314151617181920212223242526272829303132333435363738394041package com.atguigu.filter;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;import java.io.IOException;public class AdminFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; /* doFilter方法，专门用于拦截请求，可以做权限检查 */ @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;foFilter&quot;); //获取Session HttpServletRequest httpServletRequest=(HttpServletRequest) servletRequest; HttpSession session=httpServletRequest.getSession(); Object user=session.getAttribute(&quot;user&quot;); //如果等于null，说明还没有登陆 if(user==null)&#123; servletRequest.getRequestDispatcher(&quot;/login.jsp&quot;).forward(servletRequest,servletResponse); return; &#125; else &#123; //让程序继续往下访问用户的目标资源 filterChain.doFilter(servletRequest,servletResponse); &#125; &#125; @Override public void destroy() &#123; &#125;&#125; web.xml 123456789101112131415161718192021222324 &lt;!--filter标签用于配置一个Filter过滤器--&gt; &lt;filter&gt; &lt;!--给filter起一个别名--&gt; &lt;filter-name&gt; AdminFilter &lt;/filter-name&gt; &lt;!--配置filter全类名--&gt; &lt;filter-class&gt; com.atguigu.filter.AdminFilter &lt;/filter-class&gt; &lt;/filter&gt; &lt;!--filter-mapping配置Filter过滤器的拦截路径--&gt; &lt;filter-mapping&gt; &lt;!--filter-name表示当前的拦截路径给哪个filter使用--&gt; &lt;filter-name&gt;AdminFilter &lt;/filter-name&gt; &lt;!--url-pattern配置拦截路径 /admin/* 表示请求地址为web目录下admin下的全部 --&gt; &lt;url-pattern&gt; /admin/* &lt;/url-pattern&gt; &lt;/filter-mapping&gt; a.sjp 123456789101112131415161718192021222324&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/10 Time: 19:58 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% System.out.println(&quot;a.jsp页面执行了&quot;); Object user=session.getAttribute(&quot;user&quot;); //如果等于null，说明还没有登陆 if(user==null)&#123; request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request,response); return; &#125;%&gt;&lt;/body&gt;&lt;/html&gt; 12[Title](http://localhost:8080/Filter/admin/a.jsp)访问这个的时候会访问不到，被Filter拦截，跳到login.jsp 完整的用户登录和权限检查Filter 过滤器的使用步骤： 1、编写一个类去实现 Filter 接口 2、实现过滤方法 doFilter() 3、到 web.xml 中去配置 Filter 的拦截路径 login.jsp 123456789101112131415161718192021&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/10 Time: 20:08 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://localhost:8080/Filter/loginServlet&quot; method=&quot;get&quot;&gt; 用户名 &lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br&gt; 密码 &lt;input tyep=&quot;password&quot; name=&quot;password&quot;/&gt;&lt;br&gt; &lt;input type=&quot;submit&quot;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; LoginServlet 123456789101112131415161718192021222324252627package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class LoginServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //解决相应乱码问题 resp.setContentType(&quot;text/html;charset=UTF-8&quot;); String username=req.getParameter(&quot;username&quot;); String password=req.getParameter(&quot;password&quot;); if(&quot;wzg168&quot;.equals(username)&amp;&amp;&quot;123456&quot;.equals(password))&#123; req.getSession().setAttribute(&quot;user&quot;,username); resp.getWriter().write(&quot;登陆成功&quot;); &#125; else &#123; req.getRequestDispatcher(&quot;/login.jsp&quot;).forward(req,resp); &#125; &#125;&#125; 登录之后就可以访问admin下面的内容了 Filter的生命周期 FilterConfig类FilterConfig 类见名知义，它是 Filter 过滤器的配置文件类。 Tomcat 每次创建 Filter 的时候，也会同时创建一个 FilterConfig 类，这里包含了 Filter 配置文件的配置信息 FilterConfig 类的作用是获取 filter 过滤器的配置内容 1、获取 Filter 的名称 filter-name 的内容 2、获取在 Filter 中配置的 init-param 初始化参数 3、获取 ServletContext 对象 测试FilterConfig类 1234567891011 @Override public void init(FilterConfig filterConfig) throws ServletException &#123; // 1、获取 Filter 的名称 filter-name 的内容System.out.println(&quot;2.Filter的init(FilterConfig filterConfig)初始化&quot;);System.out.println(&quot;filter-name的值&quot;+filterConfig.getFilterName()); //2、获取在 web,xml Filter 中配置的 init-param 初始化参数System.out.println(&quot;初始化参数username的值&quot;+filterConfig.getInitParameter(&quot;username&quot;));System.out.println(&quot;初始化参数url的值&quot;+filterConfig.getInitParameter(&quot;url&quot;)); //3、获取 ServletContext 对象 System.out.println(filterConfig.getServletContext()); &#125; web.xml文件中加上init-param参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445 &lt;!--filter标签用于配置一个Filter过滤器--&gt; &lt;filter&gt; &lt;!--给filter起一个别名--&gt; &lt;filter-name&gt; AdminFilter &lt;/filter-name&gt; &lt;!--配置filter全类名--&gt; &lt;filter-class&gt; com.atguigu.filter.AdminFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;root&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;url&lt;/param-name&gt; &lt;param-value&gt;jdbc:mysql:localhost3306/test&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!--filter-mapping配置Filter过滤器的拦截路径--&gt; &lt;filter-mapping&gt; &lt;!--filter-name表示当前的拦截路径给哪个filter使用--&gt; &lt;filter-name&gt;AdminFilter &lt;/filter-name&gt; &lt;!--url-pattern配置拦截路径 /admin/* 表示请求地址为web目录下admin下的全部 --&gt; &lt;url-pattern&gt; /admin/* &lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt; LoginServlet &lt;/servlet-name&gt; &lt;servlet-class&gt; com.atguigu.servlet.LoginServlet &lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/loginServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; FilterChain过滤链是doFilter方法的第三个参数FilterChain filterChain 前两个参数是request和response Filter 过滤器 Chain 链，链 条 FilterChain 就是过滤器链（多个过滤器如何一起工作） 如果通过了两个doFilter方法的guolv 代码执行就是 Filter1前置代码 Filter2前置代码 目标资源被访问啦 Filter2后置代码 Filter1后置代码 如果Filter2过滤不通过 代码执行是 FilTer1前置代码 Filter2 前置代码 Filter1后置代码 如果Filter2过滤不通过 Filter1前置代码 Thread.getCurrentThread().getName()得到当前线程的名字 Filter过滤器的三种拦截路径路径后面加参数都是可以匹配的 —精确匹配 1/target.jsp 以上配置的路径，表示请求地址必须为：http://ip:port/工程路径/target.jsp 后面可以加参数都是无所谓的 –目录匹配 1/admin/* 以上配置的路径，表示请求地址必须为：http://ip:port/工程路径/admin/* –后缀名匹配 书城项目第八阶段1.使用 Filter 过滤器拦截&#x2F;pages&#x2F;manager&#x2F;所有内容，实 现权限检查 加一个过滤器 12345678910111213141516171819202122232425262728293031323334package com.atguigu.filter;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;import java.io.IOException;public class ManagerFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; //获得session HttpServletRequest servletRequest1 = (HttpServletRequest) servletRequest; HttpSession session = servletRequest1.getSession(); Object user = session.getAttribute(&quot;user&quot;); if(user==null)&#123; servletRequest1.getRequestDispatcher(&quot;/pages/user/login.jsp&quot;).forward(servletRequest,servletResponse); &#125;else &#123; filterChain.doFilter(servletRequest,servletResponse); &#125; &#125; @Override public void destroy() &#123; &#125;&#125; 在web.xml中加上一个filter的过滤器 两个路径，因为通过&#x2F;manager&#x2F;BookServlet?action&#x3D;page也可以访问后台，所以两个都要过滤掉 123456789&lt;filter&gt; &lt;filter-name&gt;ManagetFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.atguigu.filter.ManagerFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;ManagetFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/pages/manager/*&lt;/url-pattern&gt; &lt;url-pattern&gt;/manager/BookServlet&lt;/url-pattern&gt;&lt;/filter-mapping&gt; ThreadLocal使用介绍ThreadLocal 的作用，它可以解决多线程的数据安全问题。 ThreadLocal 它可以给当前线程关联一个数据（可以是普通变量，可以是对象，也可以是数组，集合） ThreadLocal 的特点： 1、ThreadLocal 可以为当前线程关联一个数据。（它可以像 Map 一样存取数据，key 为当前线程） 2、每一个 ThreadLocal 对象，只能为当前线程关联一个数据，如果要为当前线程关联多个数据，就需要使用多个 ThreadLocal 对象实例。 3、每个 ThreadLocal 对象实例定义的时候，一般都是 static 类型 4、ThreadLocal 中保存数据，在线程销毁后。会由 JVM 虚拟自动释放 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.atguigu.test;import java.util.Random;class OrderService &#123; public void createOrder()&#123; String name = Thread.currentThread().getName(); System.out.println(&quot;OrderService 当前线程[&quot; + name + &quot;]中保存的数据是：&quot; + ThreadLocalTest.threadLocal.get()); new OrderDao().saveOrder(); &#125;&#125; class OrderDao &#123; public void saveOrder()&#123; String name = Thread.currentThread().getName(); System.out.println(&quot;OrderDao 当前线程[&quot; + name + &quot;]中保存的数据是：&quot; + ThreadLocalTest.threadLocal.get()); &#125;&#125;public class ThreadLocalTest &#123; // public static Map&lt;String,Object&gt; data = new Hashtable&lt;String,Object&gt;(); public static ThreadLocal&lt;Object&gt; threadLocal = new ThreadLocal&lt;Object&gt;(); private static Random random = new Random(); public static class Task implements Runnable &#123; @Override public void run() &#123;// 在 Run 方法中，随机生成一个变量（线程要关联的数据），然后以当前线程名为 key 保存到 map 中 Integer i = random.nextInt(1000);// 获取当前线程名 String name = Thread.currentThread().getName(); System.out.println(&quot;线程[&quot;+name+&quot;]生成的随机数是：&quot; + i);// data.put(name,i); threadLocal.set(i); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //这个也是为验证取出的同一线程相关联的数都是相同的 new OrderService().createOrder();// 在 Run 方法结束之前，以当前线程名获取出数据并打印。查看是否可以取出操作// Object o = data.get(name); Object o = threadLocal.get(); System.out.println(&quot;在线程[&quot;+name+&quot;]快结束时取出关联的数据是：&quot; + o); &#125; &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 3; i++)&#123; new Thread(new Task()).start(); &#125; &#125;&#125; 使用 Filter 和 ThreadLocal 组合管理事务查询时不需要提交事务的 保存订单和保存订单项还有更新销量要么都成功，要么都失败 可以用到事务 JDBCUtils 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package com.atguigu.utils;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.pool.DruidDataSourceFactory;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.SQLException;import java.util.Properties;public class JdbcUtils &#123; private static DruidDataSource dataSource; //用ThreadLocal保存conn链接 private static ThreadLocal&lt;Connection&gt; conns=new ThreadLocal&lt;Connection&gt;();static &#123; try&#123; Properties properties=new Properties(); InputStream inputStream=JdbcUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); properties.load(inputStream); dataSource= (DruidDataSource) DruidDataSourceFactory.createDataSource(properties); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125;&#125;//获取数据库连接池中的连接，如果返回null就是获取失败，有值就是获取成功public static Connection getConnection()&#123;Connection conn=conns.get();if(conn==null)&#123; try &#123; conn=dataSource.getConnection();//从数据库连接池中获取链接 conns.set(conn);//保存到ThreadLocal对象中，供后面的jdbc操作使用 conn.setAutoCommit(false);//设置为手动管理事务 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125;return conn;&#125;/*提交事务，并释放连接 */public static void commitAndColose() &#123; Connection connection = conns.get(); if(connection!=null)&#123; //如果不等于null，说明之前使用过链接操作过数据库 try &#123; connection.commit();//提交事务 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally&#123; //关闭链接 try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //一定要执行remove操作，否则就会出错，因为Tomcat服务器底层用了线程池技术 conns.remove();&#125;/*回滚事务，关闭连接 */public static void rollbackAndColose() &#123; Connection connection = conns.get(); if(connection!=null)&#123; //如果不等于null，说明之前使用过链接操作过数据库 try &#123; connection.rollback();//提交事务 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally&#123; //关闭链接 try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //一定要执行remove操作，否则就会出错，因为Tomcat服务器底层用了线程池技术 conns.remove();&#125;//关闭连接 /*public static void close(Connection conn)&#123; if(conn!=null)&#123; try&#123; conn.close(); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;*/ public static void main(String[] args) &#123; &#125;&#125; BaseDao 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.atguigu.dao.impl;import com.atguigu.utils.JdbcUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.apache.commons.dbutils.handlers.ScalarHandler;import java.sql.Connection;import java.sql.SQLException;import java.util.List;public class BaseDao &#123; //使用DbUtils操作数据库private QueryRunner queryRunner=new QueryRunner();/*update()方法用来执行：insert update delete语句如果返回-1说明执行失败， 否则返回其他表示影响的行数 */ public int update(String sql,Object...args)&#123; Connection conn= JdbcUtils.getConnection(); try &#123; return queryRunner.update(conn, sql, args); &#125; catch(Exception e)&#123; e.printStackTrace(); //将异常都抛出去 throw new RuntimeException(e); &#125; &#125; /* 查询返回一个javaBean的sql语句 type为返回对象类型，args是sql对应的参数值，sql是执行的sql语句 &lt;T&gt;返回的类型和泛型 */ public &lt;T&gt; T queryForOne(Class&lt;T&gt; type,String sql,Object...args) &#123; Connection con=JdbcUtils.getConnection(); try &#123; return queryRunner.query(con,sql,new BeanHandler&lt;T&gt;(type),args); &#125;catch(SQLException e)&#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125; /* 查询返回多个javaBean的sql语句 */ public &lt;T&gt; List&lt;T&gt; queryForList(Class&lt;T&gt; type,String sql,Object...args)&#123; Connection con=JdbcUtils.getConnection(); try &#123; return queryRunner.query(con,sql,new BeanListHandler&lt;T&gt;(type),args); &#125;catch(SQLException e)&#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125; /* 执行返回一个单元格的sql */ public Object queryForSingleValue(String sql,Object...args)&#123; Connection conn=JdbcUtils.getConnection(); try &#123; return queryRunner.query(conn, sql,new ScalarHandler(), args); &#125; catch(SQLException e)&#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125;&#125; OrderServlet 12345678try &#123; orderId = orderService.createOrder(cart, userId); JdbcUtils.commitAndColose();//提交事务&#125;catch(Exception e)&#123; JdbcUtils.rollbackAndColose();//回滚事务 e.printStackTrace();&#125; 一开始一直不成功，将表的引擎改为Innodb就可以了，以及把mysql默认引擎改为innodb mylsam引擎是不支持事务操作的 右键表的设计表选项 使用Filter统一给所有的Service方法都加上try-catch 就是doFilter有除了filterChain.doFilter()方法之外还有前置代码和后置代码，只要给这个工程的所有访问路径加上这个过滤器，然后再在 filterChain.foFilter后面加上提交事务，和catch 回滚事务，这样访问资源回来之后，可以执行后置代码，这个后置代码就是提交事务，或者捕捉错误之后回滚事务 TranscationFilter类的代码 123456789101112131415161718192021222324252627282930313233package com.atguigu.filter;import com.atguigu.utils.JdbcUtils;import javax.servlet.*;import java.io.IOException;public class TranscationServlet implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; try &#123; filterChain.doFilter(servletRequest, servletResponse); //提交事务 JdbcUtils.commitAndColose(); &#125; catch(Exception e) &#123;//回滚事务 JdbcUtils.rollbackAndColose(); e.printStackTrace(); &#125; &#125; @Override public void destroy() &#123; &#125;&#125; web.xml 123456789&lt;filter&gt; &lt;filter-name&gt;TranscationServlet&lt;/filter-name&gt; &lt;filter-class&gt;com.atguigu.filter.TranscationServlet&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;TranscationServlet&lt;/filter-name&gt; &lt;!--表示当前工程下的所有请求--&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; BaseServlet 把BaseServlet中的异常抛出 就是过程中的异常都应该抛出，如果异常没被Filter捕获就不能回滚事务了 1234567891011121314151617181920212223242526272829303132333435package com.atguigu.web;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.Method;public abstract class BaseServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req,resp); &#125; protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(&quot;text/html;charset=UTF-8&quot;); String parameter=req.getParameter(&quot;action&quot;); try &#123; //通过反射获取对应的方法，因为设定获取的action的参数值和调用方法的名字相同 //this是指调用该post方法的对象 Method parameter1 = this.getClass().getDeclaredMethod(parameter,HttpServletRequest.class,HttpServletResponse.class); //执行目标业务方法 parameter1.invoke(this,req,resp); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException();//把异常抛给Filter过滤器 &#125; &#125;&#125; 使用Tomcat统一管理，展示友好的错误页面在 web.xml 中我们可以通过错误页面配置来进行管理 1234567891011121314&lt;!--error-page 标签配置，服务器出错之后，自动跳转的页面--&gt;&lt;error-page&gt; &lt;!--error-code 是错误类型--&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;!--location 标签表示。要跳转去的页面路径--&gt; &lt;location&gt;/pages/error/error500.jsp&lt;/location&gt;&lt;/error-page&gt;&lt;!--error-page 标签配置，服务器出错之后，自动跳转的页面--&gt;&lt;error-page&gt; &lt;!--error-code 是错误类型--&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;!--location 标签表示。要跳转去的页面路径--&gt; &lt;location&gt;/pages/error/error404.jsp&lt;/location&gt;&lt;/error-page&gt; error500.jsp 1234567891011121314151617&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/13 Time: 15:18 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;这是错误页面&lt;a href=&quot;index.jsp&quot;&gt;返回首页&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; TranscationServlet 12345678 catch(Exception e) &#123;//回滚事务 JdbcUtils.rollbackAndColose(); e.printStackTrace(); throw new RuntimeException();//继续抛异常，让tomcat服务器收到异常 &#125;&#125; 回滚事务之后还是抛出异常，让tomcat服务器接收异常 Json和AjaxJsonJSON (JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON 采用完全独立于语言的文本格式，而且很多语言都提供了对 json 的支持（包括 C, C++, C#, Java, JavaScript, Perl, Python 等）。 这样就使得 JSON 成为理想的数据交换格式 json 是一种轻量级的数据交换格式。 轻量级指的是跟 xml 做比较 数据交换指的是客户端和服务器之间业务数据的传递格式 Json在javascript的使用json定义 json 是由键值对组成，并且由花括号（大括号）包围。每个键由引号引起来，键和值之间使用冒号进行分隔， 多组键值对之间进行逗号进行分隔。 1234567891011121314// json的定义//vlaue可以使字符串，数组，布尔，数字，json对象，有json对象的数组var jsonobj=&#123; &quot;key1&quot;:12, &quot;key2&quot;:&quot;abc&quot;, &quot;key3&quot;:true, &quot;key4&quot;:[11,&quot;arr&quot;,false], &quot;key5&quot;:&#123; &quot;key5_1&quot;:12, &quot;key5_2&quot;:&quot;value&quot; &#125;, &quot;key6&quot;:[&#123;&quot;key1&quot;:&quot;12&quot;&#125;,&#123;&quot;key1&quot;:123&#125;] &#125;; json的访问 json 本身是一个对象。 json 中的 key 我们可以理解为是对象中的一个属性。 json 中的 key 访问就跟访问对象的属性一样： json 1234567891011121314151617181920212223242526272829// json的定义//vlaue可以使字符串，数组，布尔，数字，json对象，有json对象的数组var jsonobj=&#123; &quot;key1&quot;:12, &quot;key2&quot;:&quot;abc&quot;, &quot;key3&quot;:true, &quot;key4&quot;:[11,&quot;arr&quot;,false], &quot;key5&quot;:&#123; &quot;key5_1&quot;:12, &quot;key5_2&quot;:&quot;value&quot; &#125;, &quot;key6&quot;:[&#123;&quot;key1&quot;:&quot;12&quot;&#125;,&#123;&quot;key1&quot;:123&#125;]&#125;;//json就是一个对象alert(typeof(jsonobj))// json的访问 alert(jsonobj.key1);alert(jsonobj.key2);alert(jsonobj.key3);//数组遍历for(var i=0;i&lt;jsonobj.key4.length;i++)&#123; alert(jsonobj.key4[i]);&#125;alert(jsonobj.key5.key5_1);alert(jsonobj.key5.key5_2);alert(jsonobj.key6);//key6存储的就是json对象的数组，所以变量json被赋了个json对象var json=jsonobj.key6[0]; json两个常用方法 json 的存在有两种形式。 一种是：对象的形式存在，我们叫它 json 对象。 一种是：字符串的形式存在，我们叫它 json 字符串。 一般我们要操作 json 中的数据的时候，需要 json 对象的格式。 一般我们要在客户端和服务器之间进行数据交换的时候，使用 json 字符串。 123456// json对象转字符串var jsonstring=JSON.stringify(jsonobj);//特别象java中对象的toString方法alert(jsonstring)// json字符串转json对象var json2=JSON.parse(jsonstring);alert(typeof(json2)); json在java中使用json和javaBean的互转 12345678910111213141516 //javaBean和json互相转化 @Test public void test1()&#123;Person person=new Person(1,&quot;好帅&quot;);//创建Gson对象实例Gson gson=new Gson();///toJson方法可以把java对象转换成为json字符串 String personJsonString = gson.toJson(person); System.out.println(personJsonString); //fromJson把json字符串转换为java对象 //第一个参数是json字符串，第二个参数是转换回去的java对象类型 //看好是哪个方法选择第一个参数是字符串的fromJson方法 Person person1 = gson.fromJson(personJsonString, Person.class); System.out.println(person1); &#125; List 和 json互转 1234567891011121314151617//list集合和json转换@Testpublic void test2()&#123; ArrayList&lt;Person&gt; personList = new ArrayList&lt;&gt;(); personList.add(new Person(1,&quot;哥&quot;)); personList.add(new Person(2,&quot;第&quot;)); Gson gson=new Gson(); //把List转换为Json字符串 String personListJsonString = gson.toJson(personList); System.out.println(personListJsonString);//[&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;哥&quot;&#125;,&#123;&quot;id&quot;:2,&quot;name&quot;:&quot;第&quot;&#125;] //第二个参数不能是personList.getClass(),这样得到的集合里面存储的是map对象不能转换为Person对象，所以用这个方法 ArrayList&lt;Person&gt; arrayList = gson.fromJson(personListJsonString, new PersonListType().getType()); Person person = arrayList.get(0); System.out.println(person);&#125; 12345678910package com.atguigu.json;import com.atguigu.pojo.Person;import com.google.gson.reflect.TypeToken;import java.util.ArrayList;public class PersonListType extends TypeToken&lt;ArrayList&lt;Person&gt;&gt; &#123;&#125; json和Map集合相互转换 123456789101112131415161718//map和json的互转@Testpublic void test3()&#123; Map&lt;Integer,Person&gt; personMap=new HashMap&lt;&gt;(); personMap.put(1,new Person(1,&quot;国歌&quot;)); personMap.put(2,new Person(2,&quot;康师傅&quot;)); Gson gson=new Gson(); String personMapJsonString = gson.toJson(personMap); System.out.println(personMapJsonString);//&#123;&quot;1&quot;:&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;国歌&quot;&#125;,&quot;2&quot;:&#123;&quot;id&quot;:2,&quot;name&quot;:&quot;康师傅&quot;&#125;&#125; Map&lt;Integer,Person&gt; personMap1 = gson.fromJson(personMapJsonString, new PersonMapType().getType()); //使用匿名内部类的方式，这样就不用多创建java的class TypeToken泛型中是你要返回的类型 // Map&lt;Integer,Person&gt; personMap1 = gson.fromJson(personMapJsonString, new TypeToken&lt;HashMap&lt;Integer,Person&gt;&gt;()&#123;&#125;.getType()); System.out.println(personMap1); Person p=personMap1.get(1); System.out.println(p);&#125; 如果Map的value存储的是一个实体类对象，那么json对象.key取出的也就是一个json对象 ​ 如果是一个正常的12，字符串或者布尔，可以直接取出， Map的key就是json对象的key Ajaxajax是单线程异步的 AJAX 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发 技术。 ajax 是一种浏览器通过 js 异步发起请求，局部更新页面的技术（地址栏不发生变化，页面局部更新，其他地方不变） 同步是指你调了一个什么方法，这个线程就一直在这等着，这个方法调用完往下走，异步是指接着往下走先调用下面的代码，等那个方法服务器返回再执行 异步就是等服务器回应的时候，接着执行下面的代码 Ajax 请求的局部更新，浏览器地址栏不会发生变化 局部更新不会舍弃原来页面的内容 原生Ajax请求实例BaseServlet 1234567891011121314151617181920212223242526272829303132333435package com.atguigu.web;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.Method;public abstract class BaseServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req,resp); &#125; protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //解决返回中文时的乱码问题 resp.setContentType(&quot;text/html;charset=UTF-8&quot;); String parameter=req.getParameter(&quot;action&quot;); try &#123; //通过反射获取对应的方法，因为设定获取的action的参数值和调用方法的名字相同 //this是指调用该post方法的对象 Method parameter1 = this.getClass().getDeclaredMethod(parameter,HttpServletRequest.class,HttpServletResponse.class); //执行目标业务方法 parameter1.invoke(this,req,resp); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; AjaxServlet 123456789101112131415161718192021package com.atguigu.servlet;import com.atguigu.pojo.Person;import com.google.gson.Gson;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class AjaxServlet extends BaseServlet&#123; protected void javascriptAjax(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;Ajax请求过来啦&quot;); Person person=new Person(1,&quot;国歌&quot;); //json格式的字符串 Gson gson=new Gson(); //服务器响应一个person对象，用json字符串传送 String personJsonString = gson.toJson(person); resp.getWriter().write(personJsonString); &#125;&#125; ajax.html 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot; /&gt; &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot; /&gt; &lt;meta http-equiv=&quot;Expires&quot; content=&quot;0&quot; /&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; //在这里使用javascript语言发起Ajax请求，访问服务器AjaxServlet中javascriptAjax function ajaxRequest() &#123;// 1、我们首先要创建XMLHttpRequest var xmlhttpreqest =new XMLHttpRequest();// 2、调用open方法设置请求参数 //第一个参数是请求的方法，第二个参数是请求的地址，第三个参数是请求是否是异步 xmlhttpreqest.open(&quot;GET&quot;,&quot;http://localhost:8080/jsonajax/AjaxServlet?action=javascriptAjax&quot;,true);// 3、调用send方法发送请求 xmlhttpreqest.send();// 4、在send方法前绑定onreadystatechange事件，处理请求完成后的操作。 //这个事件是响应值做好被处理准备之后调用 xmlhttpreqest.onreadystatechange=function()&#123; //满足这两个条件，才能用responseText if(xmlhttpreqest.readyState==4&amp;&amp;xmlhttpreqest.status==200)&#123; //转成json对象 var jsonobj = JSON.parse(xmlhttpreqest.responseText); document.getElementById(&quot;div01&quot;).innerHTML=&quot;编号&quot;+jsonobj.id+&quot;，姓名&quot;+jsonobj.name; &#125; &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;ajaxRequest()&quot;&gt;ajax request&lt;/button&gt; &lt;div id=&quot;div01&quot;&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; Ajax请求的特点说明jQuery中的ajax方法 回调函数的参数获取服务器返回的数据 这是$.ajax演示 1234567891011121314151617// ajax请求$(&quot;#ajaxBtn&quot;).click(function()&#123; $.ajax(&#123; url:&quot;http://localhost:8080/jsonajax/AjaxServlet&quot;, data:&#123;action:&quot;jQueryAjax&quot;&#125;, //data:&quot;action=jQueryAjax&quot;, type:&quot;Get&quot;, success:function(msg)&#123;//参数获取服务器返回的数据 //先转成json对象 var jsonobj=JSON.parse(msg); $(&quot;#msg&quot;).html(&quot;编号&quot;+jsonobj.id+&quot;，姓名&quot;+jsonobj.name); &#125;, dataType:&quot;text&quot; &#125;);&#125;); 在AjaxServlet中加方法 1234567891011protected void jQueryAjax(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;jQueryAjax===方法调用了&quot;); Person person=new Person(1,&quot;国歌&quot;); //json格式的字符串 Gson gson=new Gson(); //服务器响应一个person对象，用json字符串传送 String personJsonString = gson.toJson(person); //往客户端返回Json字符串 resp.getWriter().write(personJsonString);&#125; jQuery中的get和post方法 1234567891011121314151617// ajax--get请求$(&quot;#getBtn&quot;).click(function()&#123; $.get(&quot;http://localhost:8080/jsonajax/AjaxServlet&quot;,&quot;action=jQueryGet&quot;,function(data)&#123;//参数获取服务器返回的数据 //这里不用把data转为json对象，是因为服务器返回数据本来就设置为json对象 $(&quot;#msg&quot;).html(&quot;get编号&quot;+data.id+&quot;,姓名&quot;+data.name); &#125;,&quot;json&quot;); &#125;);// ajax--post请求$(&quot;#postBtn&quot;).click(function()&#123; $.post(&quot;http://localhost:8080/jsonajax/AjaxServlet&quot;,&quot;action=jQueryPost&quot;,function(data)&#123; $(&quot;#msg&quot;).html(&quot;post编号&quot;+data.id+&quot;,姓名&quot;+data.name); &#125;,&quot;json&quot;); &#125;); Servlet中加的方法 12345678910111213141516171819protected void jQueryGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;jQueryget===方法调用了&quot;); Person person = new Person(1, &quot;国歌&quot;); //json格式的字符串 Gson gson = new Gson(); //服务器响应一个person对象，用json字符串传送 String personJsonString = gson.toJson(person); resp.getWriter().write(personJsonString);&#125;protected void jQueryPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;jQuerypost===方法调用了&quot;); Person person = new Person(1, &quot;国歌&quot;); //json格式的字符串 Gson gson = new Gson(); //服务器响应一个person对象，用json字符串传送 String personJsonString = gson.toJson(person); resp.getWriter().write(personJsonString);&#125; jQuery的getJson方法$.getJSON 方法 getJSON的返回值都是json对象 url 请求的 url 地址 data 发送给服务器的数据 callback 成功的回调函数 1234567// ajax--getJson请求$(&quot;#getJSONBtn&quot;).click(function()&#123;$.getJSON(&quot;http://localhost:8080/jsonajax/AjaxServlet&quot;,&quot;action=jQueryGetJson&quot;,function(data)&#123; $(&quot;#msg&quot;).html(&quot;getJson编号&quot;+data.id+&quot;,姓名&quot;+data.name);&#125;);&#125;); Servlet中增加的方法 123456789protected void jQueryGetJson(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;jQuerygetJson===方法调用了&quot;); Person person = new Person(1, &quot;国歌&quot;); //json格式的字符串 Gson gson = new Gson(); //服务器响应一个person对象，用json字符串传送 String personJsonString = gson.toJson(person); resp.getWriter().write(personJsonString);&#125; jQuery中的serialize()方法serialize()可以把表单中所有表单项的内容都获取到，并以 name&#x3D;value&amp;name&#x3D;value “action&#x3D;jQuerySerialize&amp;”+$(“#form01”).serialize() 获取表单的所有项再和自己传的参数拼接 123456// ajax请求$(&quot;#submit&quot;).click(function()&#123; $.getJSON(&quot;http://localhost:8080/jsonajax/AjaxServlet&quot;,&quot;action=jQuerySerialize&amp;&quot;+$(&quot;#form01&quot;).serialize(),function(data)&#123; $(&quot;#msg&quot;).html(&quot;getJson编号&quot;+data.id+&quot;,姓名&quot;+data.name); &#125;);&#125;); Servlet中加方法 12345678910111213protected void jQuerySerialize(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;jQuerySeialize===方法调用了&quot;); //获取serialize从表单中得到的用户名 System.out.println(&quot;用户名&quot;+req.getParameter(&quot;username&quot;)); //获取serialize从表单中或得到的密码 System.out.println(&quot;密码&quot;+req.getParameter(&quot;password&quot;)); Person person = new Person(1, &quot;国歌&quot;); //json格式的字符串 Gson gson = new Gson(); //服务器响应一个person对象，用json字符串传送 String personJsonString = gson.toJson(person); resp.getWriter().write(personJsonString);&#125; 书城项目第九阶段使用 AJAX请求验证用户名是否可用 123456789101112131415161718$(function()&#123; //给用户名绑定失去焦点事件 $(&quot;#username&quot;).blur(function()&#123; //1.获取用户名 var username=this.value; //获得JSON，并得到json对象 $.getJSON(&quot;http://localhost:8087/book2/UserServlet&quot;,&quot;action=ajaxExistUsername&amp;username=&quot;+username,function(data)&#123; if(data.existsUsername)&#123; $(&quot;span.errorMsg&quot;).text(&quot;用户名已存在&quot;); &#125; else &#123; $(&quot;span.errorMsg&quot;).text(&quot;用户名可用&quot;); &#125; &#125;); &#125;); 上面这个是regisr.jsp 这个是UserServlet加了一个方法 1234567891011121314protected void ajaxExistUsername(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求的参数 String username=req.getParameter(&quot;username&quot;); //调用userService.exsitsUsername() boolean b = userService.existsUsername(username); //把返回的结果封装成为Map对象 Map&lt;String,Object&gt; resultMap=new HashMap&lt;String,Object&gt;(); resultMap.put(&quot;existsUsername&quot;,b); //将Map转成json字符串 Gson gson=new Gson(); String s = gson.toJson(resultMap); //回传给客户端resp.getWriter().write(s);&#125; 使用Ajax修改把商品添加到购物车 index.jsp 把原本的添加到购物车的按钮的点击事件给改了 12345678910111213141516171819202122232425&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; $(&quot;button.addToCart&quot;).click(function()&#123; /** * 在事件响应的function函数中有一个this对象，就是是当前正在响应事件的dom对象，就是那个标签的dom对象， * @type &#123;*|jQuery&#125; */ /* 先把this改为jQery对象然后获取属性值 */ var bookId=$(this).attr(&quot;bookId&quot;); //跳转到 /* location.href=&quot;http://localhost:8087/book2/CartServlet?action=addItem&amp;id=&quot;+bookId;*/ $.getJSON(&quot;http://localhost:8087/book2/CartServlet&quot;,&quot;action=ajaxAddItem&amp;id=&quot;+bookId,function(data)&#123; //法Ajax请求，添加商品到购物车 $(&quot;#cartTotalCount&quot;).text(&quot;您的购物车中有&quot;+data.totalCount+&quot;件商品&quot;); $(&quot;#cartLastName&quot;).text(data.lastName); &#125;); &#125;); &#125;);&lt;/script&gt; CartServlet 12345678910111213141516171819202122232425262728293031323334353637protected void ajaxAddItem(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求的参数，商品编号 int id= WebUtils.parseInt(req.getParameter(&quot;id&quot;),0); //调用bookService.queryBookById(id):得到Book的信息 Book book = bookService.queryBookById(id); //把图书信息转化成为CartItem商品项 CartItem cartItem=new CartItem(book.getId(),book.getName(),1,book.getPrice(),book.getPrice()); /* 用session存储cart信息 */ Cart cart = (Cart) req.getSession().getAttribute(&quot;cart&quot;); if(cart==null)&#123; cart=new Cart(); req.getSession().setAttribute(&quot;cart&quot;,cart); &#125; //调用Cart.addItem(CartItem)添加商品项 cart.addItem(cartItem); System.out.println(cart); //重定向回商品列表页面 /* req.getHeader(&quot;Referer&quot;)获取请求服务器的地址，然后下面再跳回到这个地址 */ req.getSession().setAttribute(&quot;lastName&quot;,cartItem.getName()); //返回购物车总的商品数量和最后一个添加的商品 HashMap&lt;String, Object&gt; resultMap = new HashMap&lt;&gt;(); resultMap.put(&quot;totalCount&quot;,cart.getTotalCount()); resultMap.put(&quot;lastName&quot;,cartItem.getName()); Gson gson=new Gson(); String resultMapJsonString = gson.toJson(resultMap); resp.getWriter().write(resultMapJsonString);&#125; index.jsp中的html代码 1234567891011121314151617&lt;c:if test=&quot;$&#123;empty sessionScope.cart.items&#125;&quot;&gt; &lt;%--购物车为空的输出--%&gt; &lt;span id=&quot;cartTotalCount&quot;&gt;&lt;/span&gt; &lt;div&gt; &lt;span id=&quot;cartLastName&quot; style=&quot;color: red&quot;&gt;当前购物车为空&lt;/span&gt; &lt;/div&gt;&lt;/c:if&gt;&lt;c:if test=&quot;$&#123;not empty sessionScope.cart.items&#125;&quot;&gt; &lt;%--购物车为空的输出--%&gt; &lt;span id=&quot;cartTotalCount&quot;&gt;您的购物车中有$&#123;sessionScope.cart.totalCount&#125;件商品&lt;/span&gt; &lt;div&gt; 您刚刚将&lt;span id=&quot;cartLastName&quot; style=&quot;color: red&quot;&gt;$&#123;sessionScope.lastName&#125;&lt;/span&gt;加入到了购物车中 &lt;/div&gt;&lt;/c:if&gt; 给标签加上了id cartTotalCount cartLastName","categories":[],"tags":[]},{"title":"java","slug":"java","date":"2022-09-29T09:56:50.000Z","updated":"2022-10-01T03:44:57.280Z","comments":true,"path":"2022/09/29/java/","link":"","permalink":"http://example.com/2022/09/29/java/","excerpt":"","text":"变量在Java中，静态变量和实例变量可以统称为成员变量。首先，明白什么是静态变量，什么是实例变量，他们定义的形式。静态变量也叫做类变量，独立于方法之外的变量，有static修饰。实例变量同样独立也是独立于方法之外 的变量，但没有static修饰。 运算符&lt;&lt;：是逻辑左移，右边补0，符号位和其他位一样要移动。 数学意义：在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以2的1次方，左移n位就相当于乘以2的n次方。 计算：3 &lt;&lt; 2 3 &lt;&lt; 2，则是将数字3左移2位 1、首先把3转换为二进制数字0000 0000 0000 0000 0000 0000 0000 0011 2、然后把该数字高位（左侧）的两个零移出，其他的数字都朝左平移2位，最后在低位（右侧）的两个空位补零。 3、则得到的最终结果是0000 0000 0000 0000 0000 0000 0000 1100，则转换为十进制是12。 （右移运算符） 位运算符 凡位运算符都是把值先转换成二进制再进行后续的处理，5的二进制位是0000 0101，右移两位就是把101左移后为0000 0001，正数左边第一位补0，负数补1，等于除于2的n次方，结果为1 ，只保留了结果的整数部分 &amp;（按位与） 位运算符 &amp;按位与的运算规则是将两边的数转换为二进制位，然后运算最终值，运算规则即(两个为真才为真)1&amp;1&#x3D;1 , 1&amp;0&#x3D;0 , 0&amp;1&#x3D;0 , 0&amp;0&#x3D;0 3的二进制位是0000 0011 ， 5的二进制位是0000 0101 ， 那么就是011 &amp; 101，由按位与运算规则得知，001 &amp; 101等于0000 0001，最终值为1 7的二进制位是0000 0111，那就是111 &amp; 101等于101，也就是0000 0101，故值为5 |（按位或） 位运算符 |按位或和&amp;按位与计算方式都是转换二进制再计算，不同的是运算规则(一个为真即为真)1|0 &#x3D; 1 , 1|1 &#x3D; 1 , 0|0 &#x3D; 0 , 0|1 &#x3D; 1 6的二进制位0000 0110 , 2的二进制位0000 0010 , 110|010为110，最终值0000 0110，故6|2等于6 ^（异或运算符） 位运算符 ^异或运算符顾名思义，异就是不同，其运算规则为1^0 &#x3D; 1 , 1^1 &#x3D; 0 , 0^1 &#x3D; 1 , 0^0 &#x3D; 0 5的二进制位是0000 0101 ， 9的二进制位是0000 1001，也就是0101 ^ 1001,结果为1100 , 00001100的十进制位是12 ~（取反运算符） 位运算符 取反就是1为0,0为1,5的二进制位是0000 0101，取反后为1111 1010，值为-6 （无符号右移运算符） 正数无符号右移 无符号右移运算符和右移运算符的主要区别在于负数的计算，因为无符号右移是高位补0，移多少位补多少个0。 15的二进制位是0000 1111 ， 右移2位0000 0011，结果为3 负数无符号右移 -6的二进制是6的二进制取反再加1,6的二进制也就是0000 0000 0000 0000 0000 0000 0000 0110，取反后加1为1111 1111 1111 1111 1111 1111 1111 1010，右移三位0001 1111 1111 1111 1111 1111 1111 1111 二进制正值转负值 a.最高位改成1 b.除了最高位，其他位取反 c.结果+1 d.得到的结果就是对应的负值 java.lang包java.lang包是java语言的核心，它提供了java中的基础类。包括基本Object类、Class类、String类、基本类型的包装类、基本的数学类等等最基本的类。我们介绍一下Java 8中的java.lang包。主要类如下图： 类 由 域(变量) 方法 组成 常量叫做直接量 数据类型基本数据类型:整形:短整型，整形，长整型，字节型空数组引用数据类型:类，接口，数组 字符’ ‘字符串” “ 一个字节八比特，一个byte八位 byte 1字节 short2字节 int 4字节 long 8字节 float 4字节 double 8字节 char 2字节 boolean 1位 类方法与实例方法的区别定义：类方法：static修饰的方法实例方法：由类创建实例调用 对象变量:指类中不加static的成员变量 区别： 类方法中不能引用对象变量；实例方法可以引用对象变量，也可以引用类变量。 类方法不能直接调用实例方法；实例方法可以直接调用类方法 类方法中不能使用super、this关键字；实例方法可以使用。 类方法不能被覆盖。 5.实例方法不能通过类名调用，当类的字节码文件被加载到内存时，类的实例方法不会被分配入口地址，当该类创建对象后，类中的实例方法才分配入口地址，从而实例方法可以被类创建的任何对象调用执行。 6.类方法可以通过类名调用，类方法在该类被加载到内存时，就分配了相应的入口地址。从而类方法不仅可以被类创建的任何对象调用执行，也可以直接通过类名调用。类方法的入口地址直到程序退出时才被取消。 类名.方法名() 子类中出现和父类相同的方法，就是覆盖，子类的对象就无法访问父类的那个被覆盖的方法，覆盖方法和被覆盖的方法要么都是类方法，要么都是实例方法，不能一个是类方法，一个是实例方法 private方法不支持重写 如果父类方法是private，即使子类中定义一个与父类private方法相同的方法名，相同的参数列表依然不是重写，只是在子类里重新定义了一个新的方法 标识符标识符命名规则：1，只能由字母数字，_或$2.必须以字母，_或$开头3.大小写敏感，无长度限制4，不能是java的关键字和保留字 标识符规则标识符常量用大写字母，变量用小写字母开始，类以大写字母开始标识符不能与关键字同名标识符最好见名知义 super关键字在子类方法中调用父类中被覆盖的方法，则可以使用super（被覆盖的是实例方法），或者父类类名来调用父类中被覆盖的函数（被覆盖的是类方法） 继承和多态12345678910111213141516171819202122232425262728293031323334353637383940414243package Hello;public class Hello &#123; public String s; public int a; public Hello() &#123; &#125; public Hello(String s,int a) &#123; this.s=s; this.a=a; &#125; public void print() &#123; System.out.println(&quot;123&quot;); &#125; public void print2() &#123; System.out.println(&quot;1234&quot;); &#125; public static void main(String[] args) &#123; Hello a=new Hello(); Hello b=new Hello(&quot;as&quot;,1); System.out.print(b.s); System.out.print(a.s); Hello c=new Hello(); Hello d=new Hell(); c.print(); d.print(); d.print2(); ((Hell)d).print3(); &#125;&#125;class Hell extends Hello&#123; public void print() &#123; System.out.print(&quot;234&quot;); &#125; public void print3() &#123; System.out.println(&quot;12345&quot;); &#125; &#125; 静态初始化块，和初始化块 12345678910111213141516171819202122232425262728293031323334package Hello;public class Hello &#123; static int a; int b; static&#123; System.out.println(&quot;静态初始化块&quot;); a=6; // b=2;这个地方会报错 &#125; &#123; int b=6; if (b&gt;4) &#123; System.out.println(&quot;lss&quot;); &#125; System.out.println(a); &#125; &#123; System.out.println(&quot;第二个构造器&quot;); &#125; public Hello() &#123; System.out.println(&quot;构造器&quot;); &#125; public static void main(String[] args) &#123; Hello a=new Hello(); &#125;&#125; 数字转字符串 String b&#x3D;5+””; equals和&#x3D;&#x3D;的使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package Hello;class Person&#123; private String name; public Person(String name) &#123; this.name=name; &#125;&#125;public class Hello &#123;public static void main(String[] args) &#123; Person p=new Person (&quot;123&quot;); System.out.println(p.toString()); System.out.println(p); System.out.println(p+&quot;123&quot;); int it =65; float fl=65.0f; char ch=&#x27;A&#x27;; if(it==fl) &#123; System.out.print(&quot;相等&quot;); &#125; if(ch==it) &#123; System.out.println(&quot;相等&quot;); &#125; Hello a=new Hello(); Hello b=new Hello(); if(a==b) &#123; System.out.println(&quot;相等&quot;); &#125; else &#123; System.out.println(&quot;不相等&quot;); &#125; if(a.equals(b)) &#123; System.out.println(&quot;相等&quot;); &#125; else &#123; System.out.println(&quot;不相等&quot;); &#125; String H=&quot;123&quot;; String G=&quot;345&quot;; String I=&quot;123345&quot;; String T=H+G; String R=new String(&quot;123&quot;); if(H==R) &#123; System.out.println(&quot;相等1&quot;); &#125; if(T==I) &#123; System.out.println(&quot;相等2&quot;); &#125; if(H.equals(R)) &#123; System.out.println(&quot;相等1&quot;); &#125; if(T.equals(I)) &#123; System.out.println(&quot;相等2&quot;); &#125; &#125;&#125; 1O:12:&quot;Road_is_Long&quot;:2:&#123;s:6:&quot;string&quot;;O:13:&quot;Make_a_Change&quot;:1:&#123;s:6:&quot;effort&quot;;O:13:&quot;Try_Work_Hard&quot;:1:&#123;s:3:&quot;var&quot;;s:52:&quot;php://filter/convert.base64-encode/resource=flag.php&quot;;&#125;&#125;s:4:&quot;page&quot;;O:12:&quot;Road_is_Long&quot;:2:&#123;s:6:&quot;string&quot;;N;s:4:&quot;page&quot;;N;&#125;&#125; 1O:12:&quot;Road_is_Long&quot;:2:&#123;s:6:&quot;string&quot;;N;s:4:&quot;page&quot;;O:12:&quot;Road_is_Long&quot;:2:&#123;s:6:&quot;string&quot;;O:13:&quot;Make_a_Change&quot;:1:&#123;s:6:&quot;effort&quot;;O:13:&quot;Try_Work_Hard&quot;:1:&#123;s:3:&quot;var&quot;;s:52:&quot;php://filter/convert.base64-encode/resource=flag.php&quot;;&#125;&#125;s:4:&quot;page&quot;;s:3:&quot;aaa&quot;;&#125;&#125; final的使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package Hello;class Person&#123; private String name; public static int a=1; public int c=1; final static int d; static&#123; a=2; //b=2; d=1; &#125; public Person(String name) &#123; this.name=name; &#125; public void print() &#123; final int h=1; //public int y=1; int x=1; &#125; public static void print1(final int i) &#123; final int a=1; //i=1; &#125;&#125;public class Hello &#123; public final void test()&#123; &#125; public final void test(String name) &#123; &#125;public static void main(String[] args) &#123; Person b=new Person(&quot;1&quot;); System.out.println(b.a); System.out.println(Person.a); final int[] iArr= &#123;5,6,12,9&#125;; iArr[2]=10; //iArr=null; final Person p=new Person(&quot;1&quot;); p.a=123; String str2=&quot;java&quot;; String str3=&quot;com&quot;; final String str=&quot;java&quot;; final String str1=&quot;com&quot;; String s1=&quot;javacom&quot;; System.out.println(str+str1==s1); System.out.println(str2+str3==s1); &#125;&#125; 有关强制类型转换基本类型之间的转换只能在数值类型之间间进行，这里所说的数值类型包括整数型，字符型和浮点型，但数值类型和字符串类型和布尔类型是不能进行类型转换的 总结：父类引用可以指向子类对象，子类引用不能指向父类对象。把子类对象直接赋给父类引用叫做向上转型，向上转型不用强制转型，如Father f1&#x3D;new Son()，把指向子类对象的父类引用赋给子类引用叫做向下转型，要强制转型，如Son s1 &#x3D; (Son)f1。向上转型会丢失子类特有的方法，但是子类overriding父类的方法，子类方法有效。 将一种类型的数据赋给另外一种类型变量时，满足下列两种要求将执行自动类型转换：1.两种类型是兼容的；2.目的类型的范围比来源类型大。 数据值类型按照范围从小到大为：byte，short，char，int，long，float，double 例如int类型比所有byte合法类型大，因此不要求显式强制类型转换。对于数字类型，整型和浮点型都是彼此兼容的，但是数字类型和字符类型和布尔类型是不兼容的，字符类型和布尔类型也不是互相兼容的。 自动类型转换不能满足所有的转换需求，比如int型变量赋值给byte型变量，这种转换不会自动进行，因为byte型比int型范围小。为了完成两种不兼容类型转换，需要用到强制类型转换。 目标类型指定了要转换成为的类型。例如果将int型转为byte型，int型取值范围大于byte型，它的值将堆byte型范围进行取模。而把浮点型赋值给整数型，就会出现截断，截取掉小数部分。从其他数值类型转换为char类型时，必须进行强制转换。将char类型转换为其他数值类型时，除了byte、short必须强制转换之外，int、long、float、double都不用强制转换。 类型转换都是小范围向大范围转换的，大范围往小范围转化需要用到强制转换，转换后的值会有所损失。 String 与其他数据类型的转换String to int int i&#x3D;Integer.parseInt(str); int to String String s&#x3D;String.valueOf(i); String to Array char []a&#x3D;str.toCharArray(); char []a&#x3D;str.getChars(0,str.length,anArray,0); Array toString String str&#x3D;new String(anArray); char to String 123 char b=&#x27;2&#x27;;String a=String.valueOf(b); System.out.println(a); String to char charAt()和toCharArray() java的Big数字类java的BigDecimal类方法声明public BigDecimal add (BigDecinal value) 加法运算 public BigDecimal subtract (BigDecimal value)减法运算 public BigDecimal multiply(BigDecimal value)乘法运算 public BigDecimal divide (BigDecimal value)除法运算 精确的计算小数之间的加减乘除 1234567891011121314151617import java.math.BigDecimal;import java.util.Scanner;public class Main&#123; public static void main(String []args)&#123; Scanner in=new Scanner(System.in); while(in.hasNext())&#123; String a=in.next(); String b=in.next(); BigDecimal a1=new BigDecimal(a); BigDecimal a2=new BigDecimal(b); System.out.println(a2.add(a1));//求两个相加 System.out.println(a2.multiply(a1));//求两个的乘积 &#125; &#125;&#125; java的BigInteger类12345678910111213141516171819202122import java.math.BigInteger;import java.util.Arrays;import java.util.Scanner;public class Main&#123; public static void main(String []args)&#123; BigInteger a=new BigInteger(&quot;0&quot;); Scanner in=new Scanner(System.in); while(in.hasNext()) &#123; String key=in.nextLine(); if(key.equalsIgnoreCase(&quot;e&quot;)) &#123; break; &#125; a=a.add(new BigInteger(key));//求相加&#125; System.out.println(a);&#125;&#125; 一.BigInteger简介 BigInteger类所在的包 java中可以使用BigInteger操作大整数，也可以转换进制。如果在操作的时候一个整型数据已经超过了整数的最大类型长度long的话，则此数据就无法装入，所以，此时要使用BigInteger类进行操作。这些大数都会以字符串的形式传入。 二.BigInteger类常用方法 1.BigInteger(String value)：构造方法，将value字符串变成BigInteger类型数据。 2.BigInteger add(BigInteger value)：加法，求两个BigInteger类型数据的和。 3.BigInteger subtract(BigInteger value)：减法，求两个BigInteger类型数据的差。 4.BigInteger multiply(BigInteger value)：乘法，求两个BigInteger类型数据的积。 5.BigInteger divide(BigInteger divisor)：除法，求两个BigInteger类型数据的商。 6.BigInteger modInverse(BigInteger m)：求模，求BigInteger类型数据对m求模。 7.BigInteger remainder(BigInteger divisor)：求余数，求BigInteger类型数据除以divisor的余数。 8.BigInteger max(BigInteger value)：最大数，求两个BigInteger类型数据的最大值。 9.BigInteger min(BigInteger value)：最小数，求两个BigInteger类型数据的最小值。 10.BigInteger gcd(BigInteger value)：最大公约数，求两个BigInteger类型数据的最大公约数。 11.BigInteger abs()：绝对值，求BigInteger类型数据的绝对值。 12.BigInteger negate()：相反数，求BigInteger类型数据的相反数。 123456789101112131415161718192021222324252627282930 BigInteger a = new BigInteger(&quot;15&quot;);BigInteger b = new BigInteger(&quot;10&quot;);BigInteger c = new BigInteger(&quot;-10&quot;);BigInteger d = new BigInteger(&quot;2&quot;);BigInteger add_result = a.add(b);BigInteger subtract_result = a.subtract(b);BigInteger multiply_result = a.multiply(b);BigInteger divide_result = a.divide(b);BigInteger modinverse_result = a.modInverse(d);BigInteger remainder_result = a.remainder(b);BigInteger max_result = a.max(b);BigInteger min_result = a.min(b);BigInteger gcd_result = a.gcd(b);BigInteger abs_result = c.abs();BigInteger negate_result = a.negate();Log.d(&quot;TAG&quot;, &quot;15+10=&quot; + add_result);Log.d(&quot;TAG&quot;, &quot;15-10=&quot; + subtract_result);Log.d(&quot;TAG&quot;, &quot;15*10=&quot; + multiply_result);Log.d(&quot;TAG&quot;, &quot;15/10=&quot; + divide_result);Log.d(&quot;TAG&quot;, &quot;15对2求模=&quot; + modinverse_result);Log.d(&quot;TAG&quot;, &quot;15/10余数=&quot; + remainder_result);Log.d(&quot;TAG&quot;, &quot;15和10最大数=&quot; + max_result);Log.d(&quot;TAG&quot;, &quot;15和10最小数=&quot; + min_result);Log.d(&quot;TAG&quot;, &quot;15和10最大公约数=：&quot; + gcd_result);Log.d(&quot;TAG&quot;, &quot;-10的绝对值=&quot; + abs_result);Log.d(&quot;TAG&quot;, &quot;15的相反数=&quot; + negate_result); Java String类总序java中的字符串分为两类，字符串常量和字符串变量 字符串常量：包括直接字符串常量和String类的对象；字符串常量的值一旦创建不会再改动 字符串变量：指的是StringBuffer类的对象，创建之后允许对其进行修改 字符串文本 1234567String str1=&quot;java&quot;; 相当于 char cstr[]= &#123;&#x27;J&#x27;,&#x27;a&#x27;,&#x27;v&#x27;,&#x27;a&#x27;&#125;; String str=new String(cstr); System.out.println(str);把字符数组转变为字符串的一个方法 2.String str1&#x3D;new String(“hello”); 3.使用数组方式 char str[]&#x3D;{‘h’,’e’,’l’,’l’,’0’}; String str[]&#x3D;{“hello”,”word”,”!”} String类的构造方法 例子 n在String类提供的构造方法中，可以由字符数组、字节数组以及字符串缓冲区来构成字符串，如下面的代码所示。 char cDeomo[]&#x3D; {‘2’,’3’,’4’,’5’}; char cDeomo1[]&#x3D; {‘1’,’2’,’3’,’4’,’5’}; String strDemo1&#x3D;new String(cDeomo); String strDemo2&#x3D;new String(cDeomo1,1,4);&#x2F;&#x2F;从cDeomo1的下标1元素到下标为4的元素 System.out.println(strDemo1); System.out.println(strDemo2); 利用上面的两个构造方法生成的字符串实例的内容均为“2345”。 n下面例子说明如何利用字节数组生成字符串： byte cDemo[]&#x3D; {66,67,68};byte cDemo1[]&#x3D; {65,66,67,68};String strDemo1&#x3D;new String(cDemo);String strDemo2&#x3D;new String(cDemo1,1,3);&#x2F;&#x2F;从下标1到下标3 都包括刚开始第一个下标的那个字符System.out.println(strDemo1);System.out.println(strDemo2);&#x2F;&#x2F;会把数字转换为unicode编码的字符 利用上面的两个构造方法生成的字符串实例的内容均为”BCD” length方法1234String str=&quot;java&quot;;System.out.println(str.length());获取字符串长度 getChars方法public void getChars(int start,int end,char c[],int offset) ​ 该方法的作用是将当前字符串从start到end-1位置上的字符复制到字符数组c中，并从c的offset处开始存放 就是将字符串从下标为start到下标为end-1的字符从c字符数组的offset下标处开始存放 String str&#x3D;”java”;char dstch[]&#x3D;new char[20];int n&#x3D;str.length();str.getChars(0, n, dstch, 0);System.out.println(dstch); 都包括第一个下标开始的那个字符 compareTo方法String类是默认实现的comparable接口的compareTo方法 用于字符串比较 int compareTo(String str) 例如:字符串A和字符串B进行比较,如果A大于B,返回大于0的值;如果A等于B,返回0; 如果A小于B,返回小于0的值。 ​ A.compareTo(B); 即参与比较的两个字符串如果首字符相同，则比较下一个字符，直到有不同的为止，返回该不同的字符的ASCII码差值； 是A字符串字符的ascii编码减去B字符串字符的ascii编码 如果两个字符串不一样长，可以参与比较的字符又完全一样，则返回两个字符串的长度差值 String str&#x3D;”abcde”;System.out.println(str.compareTo(“boy”));System.out.println(str.compareTo(“aba”));System.out.println(str.compareTo(“abcdefghi”)); 运行结果 -12-4 使用例子 12345678public int compareTo(Student o1) &#123; if(o1.getScore()==this.getScore()) &#123; return this.id.compareTo(o1.id); &#125; else &#123; return o1.getScore()-this.getScore(); &#125;&#125; 先按成绩降序排序，当成绩相同的时候按照id来自然排序 concat方法n将调用该方法的字符串与指定字符串连接，返回新的字符串。 String str1&#x3D;”java”;String str2&#x3D;”world”;String str3;str3&#x3D;str1.concat(str2);System.out.println(str3);&#x2F;&#x2F;javaworld substring方法n用于提取调用方法的字符串中的子串。 String substring (int begin, int end)； 提取从begin到end-1处的字符。就是第二个参数是下标减一 String str1&#x3D;”java”,str2&#x3D;”world”,str3;str3&#x3D;str1.concat(str2);System.out.println(str3.substring(0,3)+” “+str3.substring(4,9)); 运行结果：jav world 当substring方法只有一个参数的时候 它是此字符串的一个子字符串。该子字符串从指定索引处的字符开始，直到此字符串末尾。 String str1&#x3D;”java”,str2&#x3D;”world”,str3;str3&#x3D;str1.concat(str2);System.out.println(str3.substring(2)); 运行结果：vaworld 包括这个第一个下标开始的那个字符 replace方法返回一个新字符串 n用于替换调用方法在字符串中的某个字符，返回替换后的新字符串。 String replace(char oldChar, char newChar)； String str1&#x3D;”java world”,str3;str3&#x3D;str1.replace(‘a’,’b’);System.out.println(str3); 运行结果： jbvb world trim方法返回一个新字符串 npublic String trim() 一个字符串s 通过调用方法trim()得到一个字符串对象,该字符串对象是s去掉前后空格后的字符串。 如下面的代码所示： String s&#x3D;”I mist theep “;String temp&#x3D;s.replace(‘t’, ‘s’);String a&#x3D;” i am a student “;String tema&#x3D;s.trim();System.out.println(temp);System.out.println(tema); indexOf方法indexOf, lastIndexOf: 这两个方法用于对字符串建立索引，返回字符串的位置； int indexOf(String str)；&#x2F;&#x2F;这个是返回第一个遇到的索引，两个都是返回匹配的字符串的第一个字符的索引值 int lastIndexOf(String str);&#x2F;&#x2F;这个是返回从最后开始遇到的索引 String str1&#x3D;”java world or”;String str2&#x3D;”or”;int v1&#x3D;str1.indexOf(str2);int v2&#x3D;str1.lastIndexOf(str2);System.out.println(v1+” “+v2); 运行结果：6 11 equals方法在String类中equals()定义如下： public boolean equals(String s) 该方法用来比较当前字符串对象的实体是否与参数指定的字符串s的实体是否相同。例如 String tom&#x3D;new String( “we are students”); String boy&#x3D;new String( “We are students”); String jerry&#x3D; new String(“we are students”); tom.equals(boy)的值是false，tom.equals(jerry)的值是true 而且字符串之间进行比较不能够用&#x3D;&#x3D;，因为&#x3D;&#x3D;是比较两个字符串的地址是否相同，而equals是比较两个字符串的内容是否是相等的 &#x3D;&#x3D;比较引用，equals 比较值 1、java中字符串的比较：&#x3D;&#x3D; 我们经常习惯性的写上if(str1&#x3D;&#x3D;str2)，这种写法在java中可能会带来问题 example1: 1String a=&quot;abc&quot;;String b=&quot;abc&quot; 那么a&#x3D;&#x3D;b将返回true。因为在java中字符串的值是不可改变的，相同的字符串在内存中只会存 一份，所以a和b指向的是同一个对象； example2： 1String a=new String(&quot;abc&quot;); String b=new String(&quot;abc&quot;); 那么a&#x3D;&#x3D;b将返回false，此时a和b指向不同的对象。 2、用equals方法比较的是字符串的内容是否相同， example： 123String a=new String(&quot;abc&quot;); String b=new String(&quot;abc&quot;); a.equals(b); 将返回true。 equalsIgnoreCase()方法n在String类中equalsIgnoreCase ()定义如下： public boolean equalsIgnoreCase(String s) 字符串对象调用比较当前字符串对象是否与参数指定的字符串s 相同,比较时忽略大小写。例如： String tom&#x3D;new String(“ABC”);String Jerry&#x3D;new String(“abc”);System.out.println(tom.equals(Jerry)); tom.equalsIgnoreCase(Jerry)的值是true。 split方法1public String[] split(String regex, int limit) 根据第一个参数的字符串将字符串分割为第二个参数的份数变成字符串数组 第一个参数一定是一个字符串用双引号 String [] c&#x3D;b[i].split(“：”);用冒号将字符串分割为字符串数组afd Integer.parseInt将字符串转换为数字 startsWith方法 prefix – 前缀。 toffset – 字符串中开始查找的位置。 12345public boolean startsWith(String prefix, int toffset)或public boolean startsWith(String prefix) toUpperCase()String cc &#x3D; “aBc123”.toUpperCase(); 结果就是：ABC123 Java中StringBuffer类构造方法StringBuffer中提供了三种构造方法 public StringBuffer() 构造一个不包含字符的字符串缓冲区，其初始的容量设为 16 个字符。 public StringBuffer(int) 构造一个不包含字符的字符串缓冲区，其初始容量由参数设定。 public StringBuffer(String) 构造一个字符串缓冲区，来表示和字符串参数相同的字符序列。 字符串缓冲区的初始容量为16加上字符串参数的长度。 capacity方法n用来计算StringBuffer的容量，返回容量大小的整型值。 StringBuffer sb&#x3D;new StringBuffer(100);int x&#x3D;sb.capacity();System.out.println(x); 运算结果：100 容量是一开始那个有的那个，而不是有内容的，可以是空的默认值 append方法n将指定的字符串的内容连接到StringBuffer对象中内容的后边，并返回连接后的的StringBuffer对象。 StringBuffer append(String str); StringBuffer sb1&#x3D;new StringBuffer(“Hello”);StringBuffer sb2&#x3D;new StringBuffer(“all”);String str&#x3D;”_good”;sb2&#x3D;sb1.append(str);System.out.println(sb2); 运行结果：Hello_good insert方法n将指定的字符ch插入到StringBuffer对象的offset处，并返回修改后的StringBuffer对象。 StringBuffer insert（int offset, char ch） StringBuffer sb1=new StringBuffer(&quot;Hello&quot;); char c=&#39;2&#39;; StringBuffer sb2=new StringBuffer(100); sb2=sb1.insert(1,c); System.out.println(sb2); insert的第一个参数是要插入的字符的下标 delete方法n将StringBuffer对象中的一部分内容删掉，并将删除后的StringBuffer对象返回。 StringBuffer delete(int start, int end); 从start 删除到 end-1； StringBuffer sb1&#x3D;new StringBuffer(“Hello”);StringBuffer sb2&#x3D;new StringBuffer(100);sb2&#x3D;sb1.delete(1, 3);System.out.println(sb2); 运行结果：Hlo reverse方法n将StringBuffer中的内容颠倒过来； StringBuffer reverse(); StringBuffer sb1&#x3D;new StringBuffer(“Hello”);sb1&#x3D;sb1.reverse();System.out.println(sb1); 结果为：olleH java中数组数组的声明需要提供数组元素的类型和数组的维数。 例如： int[] k; &#x2F;&#x2F;int型一维数组 ​ String s[]; 数组声明注意test 123456789101112131415161718package Main;import java.util.Scanner;class Main&#123; public static void main(String []args)&#123; int arr[]= &#123;1,3,2,4,5,6,7&#125;; int arr2[]= &#123;1,2,3,4&#125;; arr=arr2;//arr 也变成1,2,3,4 for(int i=0;i&lt;arr.length;i++) &#123; System.out.println(arr[i]); &#125; arr[0]=100; System.out.println(arr2[0]);//说明arr=arr2之后两个数组指向同一个内存地址 &#125;&#125; 创建数组对象使用关键字new； 例如：new int [5]; ​ new String [6][5]; &#x2F;&#x2F;创建String 型二维数组 创建后，需要将相应类型的数组引用指向该对象，才能对数组对象进行操作。 例如：int[] k; &#x2F;&#x2F;int型一维数组 ​ String[][] s; ​ k&#x3D;new int [5]; ​ s&#x3D;new String[6][5]; 枚举初始化例子：TestArray.java 循环初始化：TestArray.java 枚举初始化： 例如： int[] i&#x3D;{1,3,5,7,9}; ​ int[] i&#x3D;new int[]{1,3,5,7,9}; 数组排序整个数组排序 public static void sort (int[] a)； 对指定的数组区间进行排序 public static void sort (int[] a, int fromIndex, int toIndex)；这个第二个参数是最后一个下标减一 int a[]&#x3D; {1,2,3,5,4};Arrays.sort(a);for(int i:a){ System.out.println(i);} } 查找指定元素nJava中也提供binarySearch方法来帮助开发人员进行查找操作，该方法格式如下所示。 public static int binarySearch(int[ ] a,int key)； 方法的object[]参数是要查找的数组，key参数为要查找的key值。 方法的返回值有几种： 1.找到的情况下：如果key在数组中，则返回搜索值的索引。 2.找不到的情况下： [1] 搜索值不是数组元素，且在数组范围内，从1开始计数，得“ - 插入点索引值”； [2] 搜索值是数组元素，从0开始计数，得搜索值的索引值； [3] 搜索值不是数组元素，且大于数组内元素，索引值为 – (length + 1); [4] 搜索值不是数组元素，且小于数组内元素，索引值为 – 1。 这个binarySearch方法必须是按照从小到大的顺序排的元素才能够算是key在数组中，如果有小的数跟在最后面就是找不到的情况下的第一种情况 123456 int a[] = new int[] &#123;1, 3, 4, 6, 8, 9&#125;; int x1 = Arrays.binarySearch(a, 5); int x2 = Arrays.binarySearch(a, 4); int x3 = Arrays.binarySearch(a, 0); int x4 = Arrays.binarySearch(a, 10);x1=-4 x2=2 x3=-1 x4=-7结果 数组利用比较器排序注意点：这个数组必须是Integer这种对象类型的而不是int基本类型 同时自己设计的比较器需要实现Comparator接口，当下面例子这种形式的时候是从小到大排序 将第一个if返回值变为-1 第二个elseif返回值变为1就可以实现从大到小排序 1234567891011121314151617181920212223242526272829303132package Main;import java.util.Arrays;import java.util.Comparator;import java.util.Scanner;class compare implements Comparator&lt;Integer&gt;&#123; @Override public int compare(Integer o1, Integer o2) &#123; if(o1&gt;o2) &#123; return 1; &#125; else if(o1&lt;o2) &#123; return -1; &#125; else &#123; return 0; &#125; &#125;&#125;class Main&#123; public static void main(String []args) &#123; Integer []a= &#123;1,3,4,2,5&#125;;//这里必须使用Integer Comparator c=new compare(); Arrays.sort(a,c);for(int i:a) &#123; System.out.println(i);&#125; &#125;&#125; Java Character类中的方法Character类在java.lang包下所以不需要自己去导入 isLower(Upper)Case和to(Upper)Case方法作用：是转大小写或者判断是否是大写或者小写 char cstr[]&#x3D; {‘j’,’a’,’v’,’a’};System.out.println(Character.isUpperCase(cstr[0]));System.out.println(Character.isLowerCase(cstr[0]));cstr[1]&#x3D;Character.toUpperCase(cstr[1]);System.out.println(cstr[1]);cstr[1]&#x3D;Character.toLowerCase(cstr[1]);System.out.println(cstr[1]); java.lang包下的类是默认自动导入的，character类就是在java.lang包下，以及java.lang包下的自包还是不可以被默认导入，如果用到里面的类需要自己手动导入 转大小写的时候不会把原来的字符变为大写或小写，但可以重新赋值 isDigit方法确定指定字符是否为数字 Character a=&#39;2&#39;; System.out.println(Character.isDigit(a)); 输出的结果是true isLetter方法 确定指定字符是否为字母。 1234Character a=&#x27;a&#x27;; System.out.println(Character.isLetter(a)); 输出结果为true equals方法 Character a=&#39;a&#39;; Character b=&#39;b&#39;; System.out.println(a.equals(b)); 输出结果为faulse 两个基本类型字符（用char定义的，或者char数组中的）之间可以直接进行&#x3D;&#x3D;，!&#x3D;之间的比较，两个Character对象字符之间不能够用&#x3D;&#x3D; !&#x3D;得用equals 123456Character a=new Character(&#x27;a&#x27;);Character b=new Character(&#x27;a&#x27;);System.out.println(a==b);System.out.println(a.equals(b));结果：false true 123456789101112Character a=&#x27;a&#x27;;Character b=&#x27;a&#x27;;char c=&#x27;a&#x27;;char d=&#x27;a&#x27;;System.out.println(a==b);System.out.println(a.equals(b));System.out.println(c==d);//System.out.println(c.equals(d));结果：基本类型不能调用很多方法，可以用Character引用变量去指向基本类型truetruetrue 字符数组String str&#x3D;”java”;char dstch[]&#x3D;new char[20];int n&#x3D;str.length();str.getChars(0, n, dstch, 0);System.out.println(dstch); 结果：java java random类的使用random类不在java.lang包下，所以需要自己去导入 import java.util.Random; Random类的构造方法Random类包含两个构造方法，下面依次进行介绍：（1）public Random()该构造方法使用一个和当前系统时间对应的相对时间有关的数字作为种子数，然后使用这个种子数构造Random对象。（2）public Random(long seed)该构造方法可以通过制定一个种子数进行创建。示例代码：Random r &#x3D; new Random();Random r1 &#x3D; new Random(10);再次强调：种子数只是随机算法的起源数字，和生成的随机数字的区间无关。 Random有两种构造方法：1.Random()，用于创建一个伪随机数生成器，无参构造，每次生成的随机数是不同的。程序示例： 12345678Random r=new Random();//随机生成10个[0,100)之间的数for(int i=0;i&lt;10;i++)&#123;System.out.println(r.nextInt(100));&#125; 每次运行生成的随机数都是不同的 2.Random(long seed)，使用一个long型的seed种子创建伪随机数生成器 ，有参构造，每次生成的随机数相同。 12345678Random r=new Random(13); //创建对象时传入种子//随机生成10个[0,100)之间的数for(int i=0;i&lt;10;i++)&#123;System.out.println(r.nextInt(100));&#125; 每次运行生成的随机数都是相同的 nextBoolan方法该方法的作用是生成一个随机的boolean值，生成true和false的值几率相等，也就是都是50%的几率。 Random a=new Random(); System.out.println(a.nextBoolean()); nextDouble方法该方法的作用是生成一个随机的double值，数值介于[0,1.0)之间。 Random a=new Random(); System.out.println(a.nextDouble()); 也可以自己指定范围生成 1234567（2）生成[0,5.0)区间的小数double d2 = r.nextDouble() * 5;因为nextDouble方法生成的数字区间是[0,1.0)，将该区间扩大5倍即是要求的区间。同理，生成[0,d)区间的随机小数，d为任意正的小数，则只需要将nextDouble方法的返回值乘以d即可。（3）生成[1,2.5)区间的小数double d3 = r.nextDouble() * 1.5 + 1;生成[1,2.5)区间的随机小数，则只需要首先生成[0,1.5)区间的随机数字，然后将生成的随机数区间加1即可。同理，生成任意非从0开始的小数区间[d1,d2)范围的随机数字(其中d1不等于0)，则只需要首先生成[0,d2-d1)区间的随机数字，然后将生成的随机数字区间加上d1即可。 就是在原本的基础上乘以多少就可以变成原本的多少倍 nextInt方法该方法的作用是生成一个随机的int值，该值介于int的区间，也就是-231到231-1之间。 Random a=new Random(); System.out.println(a.nextInt()); 同时可以自己指定生成整数的范围 生成[0,10)区间的整数 Random a&#x3D;new Random(); System.out.println(a.nextInt(10)); 生成[0,10]区间的整数 Random a&#x3D;new Random(); System.out.println(a.nextInt(11)); 生成[-3,15)区间的整数 Random a&#x3D;new Random(); System.out.println(a.nextInt(18)-3); java中Math类不用导入包 静态常量Math 类中包含 E 和 PI 两个静态常量，正如它们名字所暗示的，它们的值分别等于 e（自然对数）和 π（圆周率）。 调用 Math 类的 E 和 PI 两个常量，并将结果输出。代码如下： 1System.out.println(&quot;E 常量的值：&quot; + Math.E);System.out.println(&quot;PI 常量的值：&quot; + Math.PI); 执行上述代码，输出结果如下： 12E 常量的值：2.718281828459045PI 常量的值：3.141592653589793 System.out.println(Math.E);System.out.println(Math.PI); 求最大值、最小值和绝对值在程序中常见的就是求最大值、最小值和绝对值问题，如果使用 Math 类提供的方法可以很容易实现。这些方法的说明如表 1 所示。 就是比较的时候两个数字的数字类型一定要相同，这些函数只能是在两个数之间进行比较 求 10 和 20 的较大值、15.6 和 15 的较小值、-12 的绝对值，代码如下： 12纯文本复制public class Test02 &#123; public static void main(String[] args) &#123; System.out.println(&quot;10 和 20 的较大值：&quot; + Math.max(10, 20)); System.out.println(&quot;15.6 和 15 的较小值：&quot; + Math.min(15.6, 15)); System.out.println(&quot;-12 的绝对值：&quot; + Math.abs(-12)); &#125;&#125; 该程序的运行结果如下： 12310和20的较大值：2015.6和15的较小值：15.0-12的绝对值：12 求整运算Math 类的求整方法有很多，详细说明如表 2 所示。 &#96;&#96;&#96;import java.util.Scanner;public class Test03 {public static void main(String[] args) { Scanner input &#x3D; new Scanner(System.in); System.outprintln(“请输入一个数字：”); double num &#x3D; input.nextDouble(); System.out.println(“大于或等于 “+ num +” 的最小整数：” + Math.ceil(num)); System.out.println(“小于或等于 “+ num +” 的最大整数：” + Math.floor(num)); System.out.println(“将 “+ num +” 加上 0.5 之后最接近的整数：” + Math.round(num)); System.out.println(“最接近 “+num+” 的整数：” + Math.rint(num)); }12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 Double a=1.0; System.out.println(Math.ceil(a)); System.out.println(Math.floor(a)); System.out.println(Math.rint(a)); System.out.println(Math.round(a));//当距离两个整数一样的时候取那个小的# Java Scanner 类2022-01-25 14:23 更新java.util.Scanner是Java5的新特征，我们可以通过 Scanner 类来获取用户的输入。下面是创建 Scanner 对象的基本语法： Scanner s &#x3D; new Scanner(System.in); 1234567接下来我们演示一个最简单的的数据输入，并通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据：### 使用 next 方法： import java.util.Scanner; public class ScannerDemo { public static void main(String[] args) { Scanner scan &#x3D; new Scanner(System.in); &#x2F;&#x2F; 从键盘接收数据 //next方式接收字符串 System.out.println(&quot;next方式接收：&quot;); // 判断是否还有输入 if(scan.hasNext())&#123; String str1 = scan.next(); System.out.println(&quot;输入的数据为：&quot;+str1); &#125; &#125; } 123执行以上程序输出结果为： $ javac ScannerDemo.java$ java ScannerDemonext方式接收：youj com输入的数据为：youj 12345可以看到 com 字符串并未输出，接下来我们看 nextLine。### 使用 nextLine 方法： import java.util.Scanner; public class ScannerDemo &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); // 从键盘接收数据 //nextLine方式接收字符串 System.out.println(&quot;nextLine方式接收：&quot;); // 判断是否还有输入 if(scan.hasNextLine())&#123; String str2 = scan.nextLine(); System.out.println(&quot;输入的数据为：&quot;+str2); &#125; &#125; &#125; 1 执行以上程序输出结果为：$ javac ScannerDemo.java $ java ScannerDemo nextLine方式接收： youj com 输入的数据为：youj com 可以看到 com 字符串输出。 12345678910111213141516171819### next()与nextLine()区别**next():**- 1、一定要读取到有效字符后才可以结束输入。- 2、对输入有效字符之前遇到的空白，next()方法会自动将其去掉。- 3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。- next()不能得到带有空格的字符串。**nextLine()：**- 1、以Enter为结束符,也就是说nextLine()方法返回的是输入回车之前的所有字符。- 2、可以获得空白。如果要输入int或float类型的数据，在Scanner类中也有支持，但是在输入之前最好先使用 hasNextXxx() 方法进行验证，再使用 nextXxx() 来读取： import java.util.Scanner; public class ScannerDemo { public static void main(String[] args) { Scanner scan &#x3D; new Scanner(System.in); &#x2F;&#x2F; 从键盘接收数据 int i &#x3D; 0 ; float f &#x3D; 0.0f ; System.out.print(“输入整数：”); if(scan.hasNextInt()){ &#x2F;&#x2F; 判断输入的是否是整数 i &#x3D; scan.nextInt() ; &#x2F;&#x2F; 接收整数 System.out.println(“整数数据：” + i) ; }else{ &#x2F;&#x2F; 输入错误的信息 System.out.println(“输入的不是整数！”) ; } System.out.print(“输入小数：”); if(scan.hasNextFloat()){ &#x2F;&#x2F; 判断输入的是否是小数 f &#x3D; scan.nextFloat() ; &#x2F;&#x2F; 接收小数 System.out.println(“小数数据：” + f) ; }else{ &#x2F;&#x2F; 输入错误的信息 System.out.println(“输入的不是小数！”) ; } }} 123执行以上程序输出结果为： $ javac ScannerDemo.java$ java ScannerDemo输入整数：12整数数据：12输入小数：1.2小数数据：1.2 12345678910111213一个字节八比特，一个byte八位## java SimpleDateFormat类**1、为什么要使用SimpleDateFormat？**在Java中，如果我们想获取当前时间，一般会使用Date类的无参构造函数，如下所示，我们获取到当前时间并输出： import java.util.Date; public class SimpleDateFormatDemo { public static void main(String[] args) { Date currentTime &#x3D; new` `Date(); System.out.println(currentTime); &#x2F;&#x2F; 输出：Mon Feb 18 10:24:30 CST 2019 }&#96;&#96;} 123456789101112131415161718192021此时我们会发现， 输出的格式并不是我们预期的格式，一般情况下，我们希望的格式都是类似于2019-02-18，2019-02-18 10:24:30，2019/02/18这样的，此时我们就需要用到java.text.SimpleDateFormat来自定义格式。**2.使用format()方法将日期转换为字符串**使用format()方法，我们可以将日期类型转换为自己自定义的字符串格式，如2019-02-18，2019/02/18，2019-02-18 10:24:30等，自定义格式如下表所示：| 格式 | 释义 | 举例 || ---- | -------------- | ------------ || yyyy | 年 | 2019 || MM | 月 | 02 || dd | 日 | 18 || HH | 小时(24小时制) | 13，下午一点 || mm | 分钟 | 53 || ss | 秒 | 42 || SSS | 毫秒 | 629 | package com.zwwhnly.springbootdemo; import java.text.SimpleDateFormat;import java.util.Date;` `public class SimpleDateFormatDemo &#123; public static void main(String[] args) &#123; Date currentTime = new Date(); System.out.println(currentTime); // Mon Feb 18 13:53:50 CST 2019` ` SimpleDateFormat simpleDateFormat1 &#x3D; new` `SimpleDateFormat(“yyyy-MM-dd HH:mm:ss.SSS”); SimpleDateFormat simpleDateFormat2 = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); SimpleDateFormat simpleDateFormat3 &#x3D; new` `SimpleDateFormat(“yyyy&#x2F;MM&#x2F;dd”);` ` System.out.println(simpleDateFormat1.format(currentTime)); // 输出2019-02-18 13:53:50.629 System.out.println(simpleDateFormat2.format(currentTime)); &#x2F;&#x2F; 输出2019-02-18 System.out.println(simpleDateFormat3.format(currentTime)); // 输出2019/02/18 &#125;} 1234567**3.使用parse()方法将字符串转换为日期**在实际开发过程中，我们经常需要将字符串转换为日期类型，以进行后续操作，此时可以使用parse()方法，但需要**注意：如果字符串与指定的格式不匹配，会报java.text.ParseException异常**。 package com.zwwhnly.springbootdemo; import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date; public class SimpleDateFormatDemo { public static void main(String[] args) { try` `&#123; SimpleDateFormat simpleDateFormat1 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;); String strDate1 = “2019-02-18 13:58”; String strDate2 = “2019-02-18”;` ` Date date1 &#x3D; simpleDateFormat1.parse(strDate1); System.out.println(date1); Date date2 &#x3D; simpleDateFormat1.parse(strDate2); System.out.println(date2); } catch` `(ParseException e) &#123; e.printStackTrace(); &#125; &#125;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455运行结果如下图所示：![img](https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291918082.png)由此我们可以看到，strDate1格式匹配能正常转换为Date类型，而strDate2由于格式不匹配，抛出java.text.ParseException，正是因为如此，以上的代码才必须包括在try,catch语句中，否则IDEA会提示错误，代码也编译不通过，如下图所示：![img](https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291918064.png)## 抽象类和接口package Shape;public abstract class Shape &#123; &#123; System.out.println(&quot;执行Shapes初始化块..&quot;); &#125; private String color; public abstract double calPerimeter(); public abstract String getType(); public Shape() &#123;&#125; public Shape(String color) &#123; System.out.println(&quot;执行Shape的构造器&quot;); this.color=color; &#125;​ public interface Output&#123; int MAX_CACHE_LINE=50; void out(); void getData(String msg); default void print(String...msgs) &#123; for (String msg :msgs) &#123; System.out.println(&quot;默认的test()方法&quot;); &#125; &#125; default void test() &#123; System.out.println(&quot;test方法&quot;); &#125; static String staticTest() &#123; return &quot;接口里的类方法&quot;; &#125; &#125;&#125;多入参方式 public static void main(String[] args) { System.out.println(“test1:”); test(“a”,”b”,”c”); System.out.println(“test2:”); test(new String[] {“a”, “b”, “c”}); } /** * 测试方法 * @param params 参数 * */ public static void test(String... params)&#123; //遍历参数内容 for(String temp : params)&#123; System.out.println(temp); &#125; System.out.println(); 123定义这种类型的入参必须放到最后一个才可以，也就是说int入参需要放到可变入参的前面，同时再test1处增加一个String进行测试，看一下代码。 public static void main(String[] args) { System.out.println(“test1:”); test(1,”a”,”b”,”c”,”d”); System.out.println(“test2:”); test(2,new String[] {“a”, “b”, “c”}); } 12345678910111213141516171819202122​ /** * 测试方法 * @param params 参数 * */​ public static void test(int intParam,String... params)&#123;​ System.out.println(&quot;int:&quot;+intParam);​ //遍历参数内容​ for(String temp : params)&#123;​ System.out.println(temp);​ &#125;​ System.out.println();​ &#125;# java的内部类## 非静态内部类 package Shape; public class Shape{ private String prop&#x3D;”外部类的实例变量”; private class InClass{ private String prop&#x3D;”内部类的实例变量”; public void info() { String prop&#x3D;”局部变量”; System.out.println(Shape.this.prop); System.out.println(this.prop); System.out.println(prop); } } public void test() { InClass a&#x3D;new InClass(); a.info(); } public static void main(String[] args) { new Shape().test(); } } 123## 静态内部类 package Shape; public class Shape{ private int a&#x3D;1; private static int b&#x3D;2; static class show{ 123456789101112131415161718 private static int age=1; public int c=3; public void accessOuterProp() &#123; //System.out.println(a); System.out.println(b); &#125; &#125; public static void main(String[] args) &#123; System.out.println(show.age); System.out.println(new show().c); &#125; &#125;## 在外部类以外使用非静态内部类 package Shape; class Out{ class In{ public In(String msg){ System.out.println(msg); } }}public class Shape{ public static void main(String[] args) { Out.In in&#x3D;new Out().new In(“测试信息”); &#125; } 123## 在外部类以外使用静态内部类 package Shape; class StaticOut{ static class StaticIn{ public StaticIn() { System.out.println(“静态类内部的构造器”); } }}public class Shape{ public static void main(String[] args) { StaticOut.StaticIn in&#x3D;new StaticOut.StaticIn(); &#125; } 1234567891011121314151617181920212223242526272829## 使用静态内部类注意事项```javapackage Shape;class StaticOut&#123; private int a=1; private static int h=2; static class StaticIn&#123; public StaticIn() &#123; System.out.println(&quot;静态类内部的构造器&quot;); //System.out.println(a); StaticOut b= new StaticOut(); System.out.println(b.a); System.out.println(h); &#125; &#125;&#125;public class Shape&#123; public static void main(String[] args) &#123; StaticOut.StaticIn in=new StaticOut.StaticIn(); &#125;&#125; 匿名内部类1234567891011121314151617181920212223242526272829303132package Shape;interface Product&#123; public double getPrice(); public String getName();&#125;public class Shape&#123; private static int age=1; public void test(Product P) &#123; System.out.println(&quot;购买了一个&quot;+P.getName()+&quot;,花掉了&quot;+P.getPrice()); &#125; public static void main(String[] args) &#123; Shape a=new Shape(); a.test(new Product() &#123; public double getPrice() &#123; System.out.println(age); return 567.8; &#125; public String getName() &#123; return &quot;Agp显卡&quot;; &#125; &#125;); &#125;&#125; 12345678910111213141516171819 可以替代上面的匿名内部类 class product1 implements Product&#123;public double getPrice()&#123;return 56.7;&#125;public String getName()&#123;return &quot;agp显卡&quot;;&#125;&#125;a.test(new product1()); lambda表达式1234567891011121314151617181920212223242526272829303132333435363738394041package Shape;interface Eatable&#123;void taste(); &#125;interface Flyable&#123; void fly(String weather);&#125;interface Addable&#123; int add(int a,int b);&#125;public class Shape&#123; public void eat(Eatable e) &#123; System.out.println(e); e.taste(); &#125; public void drive(Flyable f) &#123; System.out.println(&quot;我正在驾驶&quot;+f); &#125; public void test(Addable add) &#123; System.out.println(&quot;5域3的和位&quot;+add.add(5,3)); &#125; public static void main(String[] args) &#123; Shape lq=new Shape(); lq.eat(()-&gt;System.out.println(&quot;okok&quot;)); lq.drive(weather-&gt;&#123;System.out.println(&quot;今天的天气是&quot;+weather);&#125;); lq.test((a,b)-&gt;a+b); &#125;&#125; 123456789101112package hello;interface like&#123; void print();&#125;public class Hello&#123; public static void main(String []args) &#123; like l=()-&gt;&#123; System.out.println(&quot;1&quot;); &#125;; &#125;&#125; 引用类方法1234567891011121314package Shape;@FunctionalInterfaceinterface Converter&#123; Integer convert(String from);&#125;public class Shape&#123;public static void main(String[] args) &#123;Converter converter1=from-&gt;Integer.valueOf(from);Converter converter2=Integer::valueOf;&#125;&#125; 引用特定对象的实例方法1234567891011121314package Shape;@FunctionalInterfaceinterface Converter&#123; Integer convert(String from);&#125;public class Shape&#123; Converter converter2=from-&gt;&quot;fkit.org&quot;.indexOf(from); Converter converter1=&quot;fkit.org&quot;::indexOf; int value=converter1.convert(&quot;1&quot;); void print() &#123; System.out.println(value); &#125; } 引用某类对象的实例方法12345678910111213141516171819202122package Shape;@FunctionalInterfaceinterface Mytest&#123; String test(String a,int b ,int c);&#125;public class Shape&#123;Mytest mt =(a,b,c)-&gt;a.substring(b,c);Mytest mt1=String::substring;void print() &#123; String str=mt.test(&quot;java i love you&quot;,3,9); System.out.println(str);&#125;public static void main(String[] args)&#123; Shape a=new Shape(); a.print(); &#125;&#125; 引用构造器12345678910111213141516171819202122package Shape;@FunctionalInterfaceinterface YourTest&#123; JFrame win(String title);&#125;public class Shape&#123;YourTest yt=(String a)-&gt;new JFrame(a);YourTest yt1=JFrame::new;void print() &#123; JFrame jf=yt.win(&quot;我的窗口&quot;); System.out.println(jf);&#125;public static void main(String[] args)&#123; Shape a=new Shape(); a.print(); &#125;&#125; 12345678package Shape;public class JFrame &#123;public JFrame(String a)&#123; System.out.println(&quot;a&quot;); &#125;&#125; 枚举类1234567891011121314151617181920212223242526272829303132333435363738394041package Shape;enum SeasonEnum&#123; SPRING,SUMMER,FALL,WINTER;&#125;public class Shape&#123;public void judge(SeasonEnum s)&#123; switch (s) &#123; case SPRING: System.out.println(&quot;春天&quot;); break; case SUMMER: System.out.println(&quot;夏天&quot;); break; case FALL: System.out.println(&quot;秋天&quot;); break; case WINTER: System.out.println(&quot;冬天&quot;); break; &#125;&#125;public static void main(String[] args)&#123; for (SeasonEnum s:SeasonEnum.values()) &#123; System.out.println(s); &#125; new Shape().judge(SeasonEnum.SPRING); &#125;&#125; 更合理的枚举类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package Shape;enum Gender&#123; MALE,FEMALE; private String name; public void setName(String name) &#123; switch (this) &#123; case MALE: if(name.equals(&quot;男&quot;)) &#123; this.name=name; &#125; else &#123; System.out.println(&quot;参数错误&quot;); &#125; break; case FEMALE: if(name.equals(&quot;女&quot;)) &#123; this.name=name; &#125; else &#123; System.out.println(&quot;参数错误&quot;); &#125; break; &#125; &#125; public String getName() &#123; return this.name; &#125;&#125;public class Shape&#123;public static void main(String[] args)&#123; Gender g=Gender.valueOf(&quot;FEMALE&quot;); g.setName(&quot;女&quot;); System.out.println(g+&quot;代表&quot;+g.getName()); //g.setName(&quot;男&quot;); &#125;&#125; 用构造器做的枚举类，更合理12345678910111213141516171819202122232425package Shape;enum Gender&#123; MALE(&quot;男&quot;),FEMALE(&quot;女&quot;); private final String name; private Gender(String name) &#123; this.name=name; &#125; public String getName() &#123; return this.name; &#125;&#125;public class Shape&#123;public static void main(String[] args)&#123; Gender g=Gender.valueOf(&quot;FEMALE&quot;); System.out.println(g.getName()); &#125; &#125; 实现接口的枚举类，不同的枚举值重写的函数还不一样1234567891011121314151617181920212223242526272829303132333435package Shape;interface GenderDesc&#123; void info(); &#125;enum Gender implements GenderDesc&#123;MALE(&quot;男&quot;)&#123;public void info()&#123;System.out.println(&quot;这个枚举值代表男性&quot;); &#125;&#125;,FEMALE(&quot;女&quot;)&#123; public void info() &#123; System.out.println(&quot;这个枚举值代表女性&quot;); &#125;&#125;; private final String name;private Gender(String name) &#123; this.name=name;&#125;&#125;public class Shape&#123;public static void main(String[] args)&#123; Gender g=Gender.valueOf(&quot;FEMALE&quot;); g.info(); &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051这个是包含抽象方法的枚举类在对枚举值实例化的时候也是进行了一个方法的重写，类似于匿名内部类，创建了一个Gender子类的实例package Shape;enum Gender&#123;PLUS&#123;public double eval(double x, double y)&#123; return x+y;&#125;&#125;,MINUS&#123;public double eval(double x,double y) &#123;return x-y; &#125;&#125;,TIMES&#123;public double eval(double x,double y)&#123;return x*y; &#125;&#125;,DEVIDE&#123; public double eval(double x,double y) &#123; return x/y; &#125;&#125;;public abstract double eval(double x,double y);public static void main(String []args) &#123; System.out.println(Gender.PLUS.eval(5,4)); System.out.println(Gender.PLUS.eval(5,4)); System.out.println(Gender.PLUS.eval(5,4)); System.out.println(Gender.PLUS.eval(5,4));&#125; } java中的集合Collection这是一个接口，只能new 实现类 Collection常用方法 12345678910111213141516171819202122int size();boolean isEmpty();boolean contains(Object o);//调用o的equals方法和集合中元素比较来判断是否存在Iterator&lt;E&gt; iterator();Object[] toArray ();boolean add(E o);boolean remove(Object o);boolean containsAll (Collection&lt;?&gt; c);//检查集合c是否在集合里面出现boolean addAll (Collection&lt;? extends E&gt; c);boolean removeAll (Collection&lt;?&gt; c);//boolean retainAll (Collection&lt;?&gt; c);//保留两个集合交集void clear();boolean equals(Object o); 常用方法的使用 12345678910111213141516171819202122232425package Shape;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;public class Shape&#123;public static void main(String []args) &#123; Collection c =new ArrayList(); c.add(&quot;寻悟空&quot;); c.add(6); c.remove(6); System.out.println(c.contains(&quot;寻悟空&quot;)); c.add(&quot;java&quot;); Collection books=new HashSet(); books.add(&quot;轻量级javaee企业实战&quot;); books.add(&quot;疯狂java将以&quot;); books.add(&quot;寻悟空&quot;); c.removeAll(books);//移除c中和books相同的元素 c.clear();//清除所有元素 books.retainAll(c);//移除books中和c不相同的元素 System.out.println(books);&#125;&#125; 使用lambda表达式遍历集合 12345678910111213141516package Shape;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;public class Shape&#123;public static void main(String []args) &#123; Collection books=new HashSet(); books.add(&quot;轻量级javaee企业实战&quot;); books.add(&quot;疯狂java讲义&quot;); books.add(&quot;疯狂安定&quot;); books.forEach(obj-&gt;System.out.println(&quot;迭代元素集合&quot;+obj));&#125;&#125; Iterator 遍历集合元素 例一 12345678910111213141516171819202122232425262728293031323334package Shape;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;import java.util.Iterator;public class Shape&#123;public static void main(String []args) &#123; Collection books=new HashSet(); books.add(&quot;轻量级javaee企业实战&quot;); books.add(&quot;疯狂java讲义&quot;); books.add(&quot;疯狂安定&quot;); Iterator it =books.iterator(); while(it.hasNext()) &#123; String book=(String)it.next(); System.out.println(book); if(books.equals(&quot;疯狂java讲义&quot;)) &#123; it.remove();//从集合中删除上一次next()方法返回的元素 //books.remove();迭代过程中不能使用这个，只有Iterator来remove才行 &#125; book=&quot;测试字符串&quot;;//对book变量赋值，不会改变集合元素本身的 System.out.println(books); it.forEachRemaining(obj-&gt;System.out.println(&quot;可迭代的元素&quot;+obj)); &#125;&#125;&#125; 例二 12345678910111213141516public static void main(String []args) &#123;Collection c=new HashSet();c.add(new Student(1,&quot;Tom&quot;,60));c.add(new Student(2,&quot;Peter&quot;,70));c.add(new Student(3,&quot;Bob&quot;,80));Iterator i=c.iterator();while(i.hasNext()) &#123; Student s=(Student)i.next();//将得到的元素强制转换为（Student）类然后就可以正常使用了 //如果这里上面的Iterator规定泛型是&lt;Student&gt;就不需要转换了 //其实其他集合也是一样，因为java无法知道集合中是什么类 System.out.println(s.getName());&#125; &#125; jdk1.5用foreach循环遍历集合 1234567891011121314151617181920212223242526package Shape;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;public class Shape&#123;public static void main(String []args) &#123; Collection books=new HashSet(); books.add(&quot;轻量级javaee企业实战&quot;); books.add(&quot;疯狂java讲义&quot;); books.add(&quot;疯狂安定&quot;); for(Object obj:books) &#123; String book=(String)obj; System.out.println(&quot;book&quot;); if(book.equals(&quot;疯狂java讲义&quot;)) &#123; books.remove(book); &#125; &#125; System.out.println(books); &#125;&#125; Predicate操作集合 1234567891011121314151617181920package Shape;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;public class Shape&#123;public static void main(String []args) &#123; Collection books=new HashSet(); books.add(&quot;轻量级javaee企业实战&quot;); books.add(&quot;疯狂java讲义&quot;); books.add(&quot;疯狂安定&quot;); books.add(&quot;疯狂ios讲义&quot;); books.add(&quot;疯狂ajax讲义&quot;); books.add(&quot;疯狂andriod将以&quot;); books.removeIf(ele-&gt;((String)ele).length()&lt;10); System.out.println(books);&#125;&#125; 123456789101112131415161718192021222324252627282930package Shape;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;import java.util.function.Predicate;public class Shape&#123;public static void main(String []args) &#123; Collection books=new HashSet(); books.add(&quot;疯狂java&quot;); books.add(&quot;疯狂javajavajavajvaa&quot;); System.out.println(calAll(books,ele-&gt;((String)ele).contains(&quot;疯狂&quot;)));&#125;public static int calAll(Collection books,Predicate p)&#123; int total=0; for(Object obj:books) &#123; if(p.test(obj)) &#123; total++; &#125; &#125; return total;&#125;&#125; List集合是一个集合，需要new实现类 特点：实现该接口的类中的元素**有顺序，可以重复 List容器中的元素都有一个对应的整数型的序号，用以记录元素在容器中的位置，可以根据序号取元素。** 主要实现类：ArrayList，LinkedList 列表：按照一定次序（对象进入的顺序）排列的·对象集，对象之间有次序关系，对象可以重复 Object get(int index); Object set(int index, Object element); void add(int index,Object element); Object remove(int index); int indexOf (Object o); int lastIndexOf(Object o); 常用方法的使用 123456789101112131415161718192021222324package Hello;import java.util.ArrayList;import java.util.List;import java.util.Scanner;public class Hello&#123; public static void main(String[] args) &#123;List books=new ArrayList();books.add(new String(&quot;轻量级javaee企业应用实战&quot;));books.add(new String (&quot;疯狂java讲义&quot;));books.add(new String(&quot;疯狂狂andriod讲义&quot;));System.out.println(books);books.add(1,new String(&quot;java讲义&quot;));//将新字符串对象插入在第二个位置for(int i=0;i&lt;books.size();i++)&#123;System.out.println(books.get(i)); &#125;books.remove(2);//删除第三个元素System.out.println(books);System.out.println(books.indexOf(new String(&quot;java讲义&quot;)));//判断指定元素在List集合中的位置，输出1，表明位于第二位books.set(1,new String(&quot;疯狂java讲义&quot;));//将第二个元素替换成新的字符串对象System.out.println(books);System.out.println(books.subList(1,2));//将集合的第二个元素截取成子集合,就是第二个参数减一是结束下标 &#125; } addAll方法 1234567891011121314151617 public static void main(String []args) &#123;ArrayList&lt;String&gt; a=new ArrayList&lt;String&gt;();ArrayList&lt;String&gt; b=new ArrayList&lt;String&gt;();a.add(&quot;a&quot;);a.add(&quot;b&quot;);a.add(&quot;c&quot;);b.add(&quot;a&quot;);b.add(&quot;b&quot;);b.add(&quot;c&quot;);a.addAll(b);System.out.println(a); &#125;结果：[a, b, c, a, b, c] LIST集合是通过equals方法判断两个对象是否一样的 A类重写了equals方法 123456789101112131415161718192021222324package Hello;import java.util.ArrayList;import java.util.List;import java.util.Scanner;class A&#123; public boolean equals(Object obj) &#123; return true; &#125;&#125;public class Hello&#123; public static void main(String[] args) &#123;List books=new ArrayList();books.add(new String(&quot;轻量级javaee企业应用实战&quot;));books.add(new String (&quot;疯狂java讲义&quot;));books.add(new String(&quot;疯狂狂andriod讲义&quot;));books.remove(new A());//会删除第一个元素，因为它和任意元素都可以相等books.remove(new A());//再次删除第一个元素System.out.println(books); &#125;&#125; List两个新增方法sort和replacell()方法 sort需要一个Comparator对象来控制元素排序，程序可使用Lambda表达式作为参数 sort方法必须传入构造器 replaceAll()方法需要一个UnaryOperator来替换所有的集合元素，UnaryOperator是一个函数式接口，也可以使用Lambda作为参数 12345678910111213141516171819202122232425262728package Hello;import java.util.ArrayList;import java.util.List;import java.util.Scanner;class A&#123; public boolean equals(Object obj) &#123; return true; &#125;&#125;public class Hello&#123; public static void main(String[] args) &#123;List books=new ArrayList();books.add(new String(&quot;轻量级javaee企业应用实战&quot;));books.add(new String (&quot;疯狂java讲义&quot;));books.add(new String(&quot;疯狂狂andriod讲义&quot;)); //使用目标类型为Comparator的Lambda表达式对List集合排序books.sort((o1,o2)-&gt;((String)o1).length()-((String)o2).length());System.out.println(books); //使用目标类型为UnaryOperator的Lambda表达式来替换集合中的所有元素 //该Lambda表达式控制使用每个字符串的长度作为新的集合元素books.replaceAll(ele-&gt;((String)ele).length());System.out.println(books); &#125;&#125; 123456789101112131415161718192021222324252627class Compare implements Comparator&lt;Integer&gt;&#123; @Override public int compare(Integer o1, Integer o2) &#123; return o2-o1; &#125;&#125;public class Main&#123; public static void main(String []args) &#123;ArrayList&lt;Integer&gt; a=new ArrayList&lt;Integer&gt;();a.add(1);a.add(4);a.add(3);Compare b=new Compare();a.sort(b);System.out.println(a); &#125;&#125;结果：[4, 3, 1] Arrays.List方法 123456789101112131415161718192021222324package Hello;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.Scanner;class A&#123; public boolean equals(Object obj) &#123; return true; &#125;&#125;public class Hello&#123; public static void main(String[] args) &#123;List books=Arrays.asList(&quot;轻量级javaee企业应用实战&quot;,&quot;疯狂java讲义&quot;,&quot;疯狂狂andriod讲义&quot;);System.out.println(books.getClass());books.forEach(System.out::println);//books.add(&quot;疯狂java讲义&quot;);//books.add(&quot;疯狂java&quot;); &#125;&#125; 将集合转变为数组的方法 ** 123456789101112131415161718192021222324public** **static** **void** main(String[] args)&#123;​ *// 创建一个动态数组*​ ArrayList&lt;String&gt; sites = **new** ArrayList&lt;&gt;();​ ​ sites.add(&quot;Runoob&quot;);​ sites.add(&quot;Google&quot;);​ sites.add(&quot;Wiki&quot;);​ sites.add(&quot;Taobao&quot;);​ System.out.println(&quot;网站列表: &quot; + sites);​ *// 创建一个新的 String 类型的数组*​ *// 数组长度和 ArrayList 长度一样*​ String[] arr = **new** String[sites.size()];​ *// 将ArrayList对象转换成数组*​ sites.toArray(arr);​ *// 输出所有数组的元素*​ System.out.print(&quot;Array: &quot;);​ **for**(String item:arr) &#123;​ System.out.print(item+&quot;, &quot;);​ &#125; &#125; 子类ArrayListArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。 ArrayList 继承了 AbstractList ，并实现了 List 接口。 12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.Collections;class Main&#123;public static void main(String []args)&#123; ArrayList&lt;String&gt; sites=new ArrayList&lt;String&gt;(); sites.add(&quot;google&quot;);//向集合中添加 sites.add(&quot;runoob&quot;); sites.add(&quot;taobao&quot;); System.out.println(sites.get(1));//得到指定下标的元素 sites.set(2, &quot;Wiki&quot;);//在指定下标处插入 sites.remove(3);//移除下标为3的元素 System.out.println(sites.size()); for(int i=0;i&lt;sites.size();i++) &#123; System.out.println(sites.get(i)); &#125; for(String i:sites) &#123; System.out.println(i); &#125; ArrayList&lt;Integer&gt; myNumbers=new ArrayList&lt;Integer&gt;(); myNumbers.add(10); myNumbers.add(15); myNumbers.add(20); myNumbers.add(25); System.out.println(myNumbers.size());//得到数组中元素的数量 Collections.sort(sites);//排序 for(String i:sites) &#123; System.out.println(i); &#125;&#125;&#125; 一个ArrayList自己的排序方法 sort方法中的参数是一个比较器，下面这个例子是按照字母顺序进行排序 12345678910111213class Main&#123; public static void main(String []args) &#123; ArrayList&lt;String&gt; name=new ArrayList&lt;String&gt;(); name.add(&quot;a&quot;); name.add(&quot;c&quot;); name.add(&quot;b&quot;); name.sort(Comparator.naturalOrder()); System.out.println(name); &#125;&#125; ArrayList转数组 1234567891011121314151617181920public class Main &#123;public static void main(String []args) &#123; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.add(&quot;c&quot;); list.add(&quot;d&quot;); list.add(&quot;e&quot;); list.add(&quot;f&quot;); list.add(&quot;g&quot;); String[] array =new String[list.size()]; list.toArray(array); for(String x:list) &#123; System.out.println(x); &#125;&#125;&#125; VectorList接口的实现类。 特点：跟ArrayList一样，都是可变长的对象数组。 与ArrayList区别 ①Vector是线程安全的，是可以同步的，运行效率低； ②ArrayList不同步，适合于单线程环境中。 public Object elementAt(int index) public void addElement(Object obj) public void removeElementAt(int index) public void insertElementAt(E obj, int index) public boolean removeElement(Object obj) public void removeAllElements() Stack(栈)extends Vector 后进先出，就是一个底下有底的箱子，只能从上面拿所以是后进先出 常用方法 – public Object push(E item) – public Object pop() – public Object peek() – public boolean empty() – public int search(Object o) 1234567891011121314public static void main(String []args) &#123; Stack s=new Stack(); s.push(&quot;hello&quot;); s.push(new Date());//往箱子里面放东西 s.push(100); s.push(3.14); System.out.println(&quot;弹栈前size=&quot;+s.size()); System.out.println(s.pop());//弹出箱子中最顶上的元素 System.out.println(&quot;弹栈后size=&quot;+s.size()); System.out.println(s.peek());//获得箱子中最顶上的元素，但是不弹出 System.out.println(&quot;peek操作后&quot;+s.size()); while(!s.isEmpty()) &#123;//判断箱子中是否是空 System.out.println(s.pop()); &#125; 把Stack当作普通List用 失去了Stack所特有的性质 12345678910111213141516171819202122public static void main(String[] args) &#123;Stack&lt;String&gt; s = new Stack&lt;String&gt;();s.add(&quot;one&quot;);s.add(&quot;two&quot;);s.add(&quot;three&quot;);s.add(2, &quot;four&quot;);s.add(0,&quot;five&quot;);System.*out*.println(s);s.remove(&quot;two&quot;);System.*out*.println(s);&#125; Queue集合队列：一种先进先出（FIFO）的容器，从容器的一端放入对象，从另一端取出对象，并且放入和取出的顺序相同 常用方法 –offer()：（入队）如果可能，将指定的元素插入此队列。 –peek()，element()：在不移除的情况下返回队头。peek方法在队列为空时返回null，element方法在队列为空时抛出异常。 –poll()，remove()：移除并返回队头（出队）。poll方法在队列为空时返回null，remove方法在队头为空时抛出异常。 12345678910Queue queue=new LinkedList();queue.offer(&quot;hello&quot;);queue.offer(&quot;world&quot;);queue.offer(&quot;你好&quot;);System.out.println(queue.size());String str;System.out.println(queue.peek());//返回当前队头的元素while((str=(String)queue.poll())!=null) &#123;//移除并返回当前队头的元素 System.out.println(str);&#125; PriorityQueue实现类123456789101112131415161718192021222324package Hello;import java.util.PriorityQueue;class A&#123; public boolean equals(Object obj) &#123; return true; &#125;&#125;public class Hello&#123; public static void main(String[] args) &#123;PriorityQueue pq=new PriorityQueue();pq.offer(6);pq.offer(-3);pq.offer(20);pq.offer(18);System.out.println(pq);System.out.println(pq.poll()); &#125;&#125; Deque接口与ArrayDeque实现类1234567891011121314151617181920212223package Hello;import java.util.ArrayDeque;import java.util.PriorityQueue;class A&#123; public boolean equals(Object obj) &#123; return true; &#125;&#125;public class Hello&#123; public static void main(String[] args) &#123;ArrayDeque stack=new ArrayDeque();stack.push(&quot;疯狂java讲义&quot;);stack.push(&quot;轻量级java ee企业应用实战&quot;);System.out.println(stack.peek());System.out.println(stack.pop());System.out.println(stack); &#125;&#125; LinkedList实现类123456789101112131415161718192021222324252627282930313233package Hello;import java.util.ArrayDeque;import java.util.LinkedList;import java.util.PriorityQueue;class A&#123; public boolean equals(Object obj) &#123; return true; &#125;&#125;public class Hello&#123; public static void main(String[] args) &#123;LinkedList books=new LinkedList();books.offer(&quot;疯狂java讲义&quot;);books.push(&quot;轻量级java ee企业级应用实战&quot;);books.offerFirst(&quot;疯狂andriod讲义&quot;);for(int i=0;i&lt;books.size();i++)&#123;System.out.println(&quot;遍历中&quot;+books.get(i)); &#125;System.out.println(books.peekFirst());System.out.println(books.peekLast());System.out.println(books.pop());System.out.println(books);System.out.println(books.pollLast());System.out.println(books); &#125;&#125; Set对象唯一，不会重复，元素没有顺序 HashSet元素值可以使null HashSet判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode方法返回值也相等（重写两个方法的时候最好两者统一） 先判断hashCode是否相等，如果hashCode相等再去判断equals方法是否为true 只有用到Hashtable HashMap HashSet LinkedHashMap等时才要注意hashcode方法。 equals方法重写的方法1234567891011121314151617181920212223242526272829public boolean equals(Object obj) &#123;if (this == obj) return true;if (obj == null)//先看看参数是不是空 return false;if (getClass() != obj.getClass())//再看看参数是否是同一个类，getClass()是指获取这个类创建实例的类型，也就是获取当前类这个类型 return false;//getClass方法获得的不是引用变量的类型，而是真正的类型final Student other = (Student) obj;if (no != other.no) return false;return true;&#125;public String toString() &#123; return &quot;no is : &quot; + no;&#125; 重写equals方法 12345678910public boolean equals(Object obj) &#123; if(obj==null) &#123;//先判断是否为空 return false; &#125; if(obj instanceof Company) &#123;//判断能否向下转型 Company c=(Company)obj; return c.name.equals(name); &#125; return false; &#125; TreeSet实现了对Set的排序 自然排序 123456789public static void main(String []args) &#123;TreeSet ts=new TreeSet();ts.add(&quot;YaoMing&quot;);ts.add(&quot;Kobe&quot;);ts.add(&quot;McGrand&quot;);ts.add(&quot;Jordan&quot;);System.out.println(ts); &#125; 结果：[Jordan, Kobe, McGrand, YaoMing] 按照字典排序 定制排序 TreeSet(Comparator&lt;? super E&gt; comparator) 可以自己写一个构造器当作参数 LinkedSet就是按照插入的顺序排列元素 Mapjava中的Hash表Hash表介绍 哈希表：能够通过元素快速查获找到元素的存储位置，又称为散列表。 哈希表基本原理：通过哈希函数或散列函数将元素的关键字和元素的存储位置关联起来。由哈希函数计算出来的值称为哈希码(Hash Code)或散列索引。 哈希表的存储空间称为哈希表的容量(Capacity)。 hash表分为三类 java语言提供了java.util.Hashtable, java.util.HashMap, java.util.WeakHashMap三个类来提供哈希存储支持。这三者的元素都是主要由关键字和值两部分组成。 Hashtable元素的关键字和值都不允许null。HashMap和WeakHashMap的关键字和值都允许null。 Hashtable支持线程同步， HashMap和WeakHashMap不支持线程同步。 WeakHashMap会自动按一定规则检查各个元素是否常用，不常用的元素会被去除，从而被系统回收。（WeakHashMap是HashMap的子类） k-y相等判断方式判断两个value相等，两个对象通过equals方法比较返回true即可，判断两个key相等，那equals放回true hashcode值也相等 Map元素遍历Set keySet( )获取所有Key的集合 Collection values( ) 获取所有Value的集合 Set entrySet( ) 获取所有key-value对的集合 再用相应的Iterator或者for循环遍历 例一 12345678910HashMap&lt;String ,Integer&gt; a=new HashMap&lt;String,Integer&gt;();a.put(&quot;a&quot;,1);a.put(&quot;b&quot;,2);Set b=a.keySet();Iterator&lt;String&gt; i=b.iterator();while(i.hasNext()) &#123; String key=i.next(); Integer value=a.get(key); System.out.println(key+&quot;-&quot;+value+&quot; &quot;);&#125; 1234567891011 public static void main(String []args) &#123;HashMap &lt;String,Integer&gt;a=new HashMap&lt;String,Integer&gt;();a.put(&quot;a&quot;,1);a.put(&quot;b&quot;,2);a.put(&quot;c&quot;,3);Collection b=a.values();System.out.println(b);结果：[1, 2, 3]&#125; 例二 entrySet方法介绍 Map的entrySet()方法返回一个实现Map.Entry接口的对象集合。集合中每个对象都是底层Map中一个特定的键&#x2F;值对。通过这个集合的迭代器，获得每一个条目(唯一获取方式)的键或值并对值进行更改。Map.Entry中的常用方法如下所示： 123(1) Object getKey(): 返回条目的关键字 (2) Object getValue(): 返回条目的值 (3) Object setValue(Object value): 将相关映像中的值改为value，并且返回旧值 12345678910public static void main(String[]args) &#123; HashMap&lt;String ,Integer&gt; a=new HashMap&lt;String,Integer&gt;(); a.put(&quot;a&quot;,1); a.put(&quot;b&quot;,2); Set b=a.entrySet(); for(Object o:b) &#123; Map.Entry e=(Map.Entry)o; System.out.println(e.getKey()+&quot;-&quot;+e.getValue()+&quot; &quot;); &#125;&#125; 按照key或者value对map排序的方法Map会根据key的大小来自动排序 因为LinekedHashMap是按照顺序添加的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.*;class compare1 implements Comparator&lt;Map.Entry&gt;&#123; @Override public int compare(Map.Entry o1,Map.Entry o2) &#123; return (int)(o2.getValue())-(int)(o1.getValue());//注意这个地方的()缺一不可 &#125;&#125;class Main&#123; public static void main(String []args)&#123; Scanner in=new Scanner(System.in); String a=in.nextLine(); String b[]=a.split(&quot; &quot;); Hashtable&lt;String,Integer&gt; c=new Hashtable&lt;String,Integer&gt;(); int count =0; for(int i=0;i&lt;b.length;i++) &#123; if(c.containsKey(b[i])) &#123; c.put(b[i],c.get(b[i])+1); &#125; else &#123; c.put(b[i],1); &#125; &#125; List list=new LinkedList(c.entrySet()); compare1 q=new compare1(); Collections.sort(list,q); Map sortedMap=new LinkedHashMap();//这个地方必须使用LinkedHashMap for(Iterator it=list.iterator();it.hasNext();) &#123; Map.Entry entry=(Map.Entry)it.next();//这里的迭代器如果加泛型&lt;Iterator&gt;,就不用强制转换了 sortedMap.put(entry.getKey(), entry.getValue());&#125; Set h=sortedMap.keySet(); Iterator&lt;String&gt; r=h.iterator(); while(r.hasNext()) &#123; String i=r.next(); System.out.println(i+&quot;:&quot;+ sortedMap.get(i)); &#125; &#125;&#125; 用函数法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.*;import java.util.Map.Entry;class Compare implements Comparator&lt;Map.Entry&gt;&#123; @Override public int compare(Map.Entry o1,Map.Entry o2) &#123; return (int)(o2.getValue())-(int)(o1.getValue()); &#125;&#125;class Main&#123; public static Map getMap(Map unsortedMap) &#123; List a=new ArrayList(unsortedMap.entrySet()); Compare b=new Compare(); Collections.sort(a,b); Map sortedMap=new LinkedHashMap();//这里必须是LinkedHashMap for(Iterator it=a.iterator();it.hasNext();) &#123; Map.Entry entry=(Map.Entry)it.next(); sortedMap.put(entry.getKey(), entry.getValue()); &#125; return sortedMap; &#125; public static void main(String []args) &#123; Scanner in=new Scanner(System.in); String a=in.nextLine(); String b[]=a.split(&quot; &quot;); Hashtable&lt;String,Integer&gt; c=new Hashtable&lt;String,Integer&gt;(); int count =0; for(int i=0;i&lt;b.length;i++) &#123; if(c.containsKey(b[i])) &#123; c.put(b[i],c.get(b[i])+1); &#125; else &#123; c.put(b[i],1); &#125; &#125; Map n=getMap(c); Set i=n.keySet(); Iterator&lt;String&gt; e=i.iterator(); while(e.hasNext()) &#123; String t=e.next(); System.out.println(t+&quot;:&quot;+n.get(t)); &#125; &#125;&#125;就是java是向下兼容的，如果函数返回类型是Map其实是返回的只要是Map的子类的实例化对象都可以 如果函数的参数类型是Map类型，其实这个参数只要是Map子类的实例化对象都可以 ​ Hashtable集合不能保证顺序 Hashtable的构造方法 名称 描述 public Hashtable( ) 创建哈希表实例对象，容量为11，装填因子为0.75。 public Hashtable( int initialCapacity) 创建哈希表实例对象，容量为initialCapacity，装填因子为0.75。 public Hashtable( int initialCapacity, float loadFactor) 创建哈希表实例对象，容量为initialCapacity，装填因子为loadFactor。 Hashtable ht1&#x3D;new Hashtable&lt;String, Integer&gt; ( ); Hashtable ht2&#x3D;new Hashtable( );&#x2F;&#x2F;未指定关键字和键值类型，编译会警告 java.util.Hashtable的成员方法 名称 描述 public V put(K key, V value ) 添加关键字为****key, 值为value的元素 public V get(Object key) 获得由参数key指定的关键字所对应的元素值 public void Clear( ) 清空整个Hash表 public boolean containsKey(Object key) 判断表中是否存在关键字****key public boolean containsValue(Object value) 判断表中是否存在元素值****value public boolean contains(Object value) 判断表中是否存在元素值****value public boolean isEmpty( ) 判断Hash表是否为空 public V remove(Object key) 删除指定关键字key所对应的元素 public int size( ) 返回Hash表元素的个数 1234567891011121314151617例子 String []sa= &#123;&quot;Mary&quot;,&quot;Tom&quot;,&quot;John&quot;,&quot;James&quot;,&quot;Louis&quot;,&quot;Jim&quot;,&quot;Rose&quot;,&quot;Ann&quot;,&quot;Liza&quot;,&quot;Betty&quot;,&quot;Henry&quot;&#125;; Hashtable &lt;String ,Integer&gt; ht=new Hashtable&lt;String ,Integer&gt;(); for(int i=0;i&lt;sa.length;i++) &#123; ht.put(sa[i],new Integer(i) );//将这个key和value放入hash表中 &#125; String s=sa[5]; System.out.println(ht.get(s));//获得key为参数所对应的value值 System.out.println(ht.containsKey(sa[5])); System.out.println(ht.containsValue(1)); System.out.println(ht.contains(1)); System.out.println(ht.isEmpty()); System.out.println(ht.size()); ht.remove(sa[5]); System.out.println(ht.size()); 还有一个方法就是keySet() ，可以得到集合的key的一个集合** Set s &#x3D; ht.keySet();** Properties集合Properties是用来读取配置文件的（结尾为.properties的文件） Properties类表示一组持久的属性。 Properties可以保存到流中或从流中加载。 extends Hashtable&lt;k,v&gt; implements Map&lt;k,v&gt; Properties集合是一个唯一和IO相结合的集合 第一条的解释 可以使用Properties集合中的方法store，把集合中的临时数据，持久化写入到硬盘中存储 可以使用Properties集合中的load，把硬盘保存的文件（键值对），读取到集合中使用 属性列表中的每个键及其对应的值都是一个字符串。 解释： ​ Properties集合是一个双列集合，key和value默认都是字符串 Properties集合存储数据，遍历取出Properties集合中的数据 Properties结合是一个双列集合，key和value默认都是字符串 Properties集合有一些操作字符串的特有方法 ​ Object setProperty(String key,String value)其实就是调用Hashtable的方法put ​ String getProperty(String key) 通过key找到value值，相当于Map集合中的get方法 ​ Set stringPropertyNames() 返回此属性列表中的一组键，其中键及其对应的值为字符串，包括默认属性列表中的不同键，如果尚未从主属性列表中找到相同名称的键。相当于Map集合中的keySet方法 几个方法的基本使用 //创建Properties集合对象 Properties prop=new Properties(); prop.setProperty(&quot;a&quot;, &quot;1&quot;); prop.setProperty(&quot;b&quot;,&quot;2&quot;); prop.setProperty(&quot;c&quot;,&quot;3&quot;); //使用stringPropertyNames把Properties集合中的键取出，存储到一个Set集合中 Set&lt;String&gt; set=prop.stringPropertyNames(); for(String key:set) &#123; String value=prop.getProperty(key); System.out.println(key+&quot;-&quot;+value); Properties集合中的store方法 void store(OutputStream out,String comments) void store(Writer writer,String comments) 参数： ​ OutputStream out：字节输出流，不能写入中文 ​ Writer writer ：字符输出流，可以写中文 ​ String comments：注释，解释说明保存的文件是做什么用的 ​ 不能使用中文，会产生乱码，默认是Unicode编码，而系统默认编码是GBK 使用步骤： ​ 1.创建Properties集合对象，添加数据 ​ 2.创建字节输出流&#x2F;字符输出流对象，构造方法中绑定要输出的目的地 ​ 3.使用Properties集合中的方法store，把集合中的临时数据，持久化写入到硬盘中存储 ​ 4.释放资源 123456789101112131415161718192021222324public static void main(String []args) throws IOException &#123;show01();&#125;private static void show01() throws IOException &#123; //1.创建Properties集合对象，添加数据 Properties prop=new Properties(); prop.setProperty(&quot;a&quot;, &quot;1&quot;); prop.setProperty(&quot;b&quot;,&quot;2&quot;); prop.setProperty(&quot;c&quot;,&quot;3&quot;); //.创建字节输出流/字符输出流对象，构造方法中绑定要输出的目的地FileWriter fw=new FileWriter(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);// 3.使用Properties集合中的方法store，把集合中的临时数据，持久化写入到硬盘中存储prop.store(fw,&quot;sava data&quot;);//关闭资源fw.close();&#125;文件写入结果： #sava data#Fri Jul 01 10:34:48 CST 2022a=1b=2c=3上面的时间是自己加的 Properties集合的load方法 可以使用Properties集合中的方法load，把硬盘中保存的文件（键值对），读取到集合中使用 void load(InputStream inStream) void load(Reader reader) 参数： ​ InputStream inStream：不能读取含有中文的键值对 ​ Reader reader：字符输入流，能读取含有中文的键值对 使用步骤： ​ 1.创建Properties集合对象 ​ 2.使用Properites集合对象中的方法load读取到保存键值对的文件 ​ 3.遍历Properties集合 注意：1.存储键值对的文件中，键与值默认的连接符号可以使用-，空格（其他符号） ​ 2.存储键值对的文件中，可以使用井号进行注释，被注释的键值对不会再被读取 ​ 3.存键值对的文件中，键与值都默认是字符串，都不用再加引号 12345678public void test2() throws Exception &#123; Properties pros=new Properties(); FileInputStream fis=new FileInputStream(&quot;./jdbc.properties&quot;); pros.load(fis); String user=pros.getProperty(&quot;user&quot;); String password=pros.getProperty(&quot;password&quot;); System.out.println(&quot;user=&quot;+user+&quot;password=&quot;+password);&#125; HashMap集合不能保证顺序 12345678910111213141516171819202122232425262728293031323334package Hello;import java.util.HashMap;import java.util.Map;class A&#123; public boolean equals(Object obj) &#123; return true; &#125;&#125;public class Hello&#123; public static void main(String[] args) &#123;Map map=new HashMap();map.put(&quot;疯狂Java&quot;,109);map.put(&quot;疯狂python&quot;,10);map.put(&quot;疯狂ios&quot;,79);map.put(&quot;疯狂php&quot;,99);System.out.println(map.put(&quot;疯狂python&quot;,99));System.out.println(map);System.out.println(map.containsKey(&quot;疯狂python&quot;));System.out.println(map.containsValue(99));for(Object key:map.keySet())&#123;System.out.println(key+&quot;--&gt;&quot;+map.get(key));&#125;map.remove(&quot;疯狂python&quot;);System.out.println(map); &#125;&#125; LinkedHashMap实现类是一种按照map的添加顺序存储的实现类 12345678910111213141516171819202122package Hello;import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;class A&#123; public boolean equals(Object obj) &#123; return true; &#125;&#125;public class Hello&#123; public static void main(String[] args) &#123;LinkedHashMap scores=new LinkedHashMap();scores.put(&quot;语文&quot;,80);scores.put(&quot;英语&quot;,82);scores.put(&quot;数学&quot;,76);scores.forEach((key,value)-&gt;System.out.println(key+&quot;--&gt;&quot;+value)); &#125;&#125; 实用类Collections类提供了List容器操作的静态方法 void sort(List list);&#x2F;&#x2F;对List容器内元素排序，默认升序 void reverse(List list);&#x2F;&#x2F;对List容器内的对象进行逆序排列 void copy(List dest,List src); &#x2F;&#x2F;把src中List容器内容拷贝到dest List容器 int binarySearch(List list, Object key); &#x2F;&#x2F;对顺序的List容器，用折半查找方法查找指定对象，返回对应key元素的下标 void shuffle(List);&#x2F;&#x2F;对List容器内的对象进行随机排序 12345678910111213public static void main(String[]args) &#123; List list1=new LinkedList(); for(int i=0;i&lt;=9;i++) &#123; list1.add(&quot;a&quot;+i); &#125; System.out.println(list1); Collections.reverse(list1); System.out.println(list1); Collections.shuffle(list1); System.out.println(list1); Collections.sort(list1); System.out.println(Collections.binarySearch(list1,&quot;a2&quot;)); &#125; Collections.sort()方法public static void sort(List list, Comparator&lt;? super T&gt; c) List(接口)就是指List类型,那么也就是说只能对集合的具体类的Arraylist和LinkedList这两种类型进行排序,由于接口也能向上转型,光论排序的内容的话其它各种自建类型都行。 第一种方法 在日常开发中，很多时候都需要对一些数据进行排序的操作。然而那些数据一般都是放在一个集合中如：Map ，Set ，List 等集合中。他们都提共了一个排序方法 sort()，要对数据排序直接使用这个方法就行，但是要保证集合中的对象是 可比较的。 怎么让一个对象是 可比较的，那就需要该对象实现 Comparable 接口啦。然后重写里面的compareTo()方法 &#96;&#96;&#96;public interface Comparable123456789101112131415161718192021222324252627282930313233当实现Comparable类的时候也是不规定泛型就是Object，且下面的compareTo方法中的参数类型要和他一样```javapublic class Student implements Comparable&lt;Student&gt; &#123; private int id; private int age; private String name; public Student(int id, int age, String name) &#123; this.id = id; this.age = age; this.name = name; &#125; @Override public int compareTo(Student o) &#123; //降序 //return o.age - this.age; //升序 return this.age - o.age; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&quot; + id + &quot;, age=&quot; + age + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 调用compareTo方法后负数时，当前对象在前面，正数时当前对象在后面，0时位置不变 12345678public int compareTo(Student o1) &#123; if(o1.getScore()==this.getScore()) &#123; return this.id.compareTo(o1.id); &#125; else &#123; return o1.getScore()-this.getScore(); &#125;&#125; 先按照成绩降序排序，成绩相同按照学号升序排序 第二种方法 &#96;&#96;&#96;public interface Comparator1234567891011121314实现Comparator接口的时候，如果没有规定泛型默认是Object，同时T必须和下面compare方法中的参数类型一样自己搞一个构造器，重写compare方法当作Collections.sort(第二个参数)```javaclass compare implements Comparator&lt;Integer&gt;&#123; @Override public int compare(Integer o1, Integer o2) &#123; return o1-o2; &#125;&#125; 第三种直接倒叙的方法 Collection.sort的第二个参数 如果要降序呢?可以传入Collections.reverseOrder(), 返回一个倒叙的Comparator对象, Arrays类定义了多种数组操作的方法 12345678910Integer[]a= &#123;3,25,12,79,48&#125;; System.out.println(Arrays.toString(a));//输出数组 Arrays.sort(a);//对数组中元素进行排序 System.out.println(Arrays.toString(a));//输出数组以[3,25,12,79,48] int idx=Arrays.binarySearch(a,25);//返回25元素所对应的下标 System.out.println(idx); List list=Arrays.asList(3,4,5);//将其转换为List集合返回值是一个List//public static &lt;T&gt; List&lt;T&gt; asList(T... a) System.out.println(list); 其实Arrays.toString的本质是调用数组中所有对象的toString方法然后用逗号隔开然后用[ ]框起来 java异常机制的处理异常：指程序中出现的不期而至的各种状况，如文件找不到，网络连接失败，非法参数等等； java把异常当作对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类 在javaAPI中已经定一个许多异常类，这些异常分为两类，错误Error和异常Exception 这个图中只是举了例子 错误：一般指程序运行时遇到的硬件或操作系统的错误，如内存溢出、不能读取硬盘分区、 硬 件驱动错误等。这是致命的，将导致程序无法运行，同时也是程序本身不能处理 的。错误大都是jvm的问题 2.异常： 异常大都是语法问题； 运行异常和编译异常。 运行异常：顾名思义，是程序运行时才会出现的异常。运行异常是java.lang.RuntimeException类及其子类的统称。如NullPointerException（空指针异常）、IndexOutOfBoundsException（数组下标越界异常）等。运行异常一般是由程序逻辑错误导致的，可以通过捕获处理或向上抛出。运行异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现运行异常，也会被编译通过。编译异常：顾名思义，是程序编译时就会出现的异常。编译异常是java.lang.RuntimeException以外的异常。编译异常必须进行处理，如果不处理，程序就不能编译通过。 异常可以分为两类：1.运行时异常 RuntimeException 2.其他的异常都属于非运行时异常 异常处理机制例1 1234int a=1; int b=0; try &#123;//try监控区域 System.out.println(a/b); &#125; catch(ArithmeticException e)//这个地方的错误必须是和try中出现的错误类型相同，否则没什么用 &#123;//catch 捕获异常 System.out.println(&quot;程序出现异常，变量b不能为0&quot;); &#125; finally &#123;//处理善后工作，无论是否报错这个finally都是会执行的，无论怎样都会执行，报其他错也会执行 System.out.println(&quot;finally&quot;); //finally可以不要finally，假设IO时读取文件关闭资源关闭时可以用 &#125; 例2 123456public static void main(String args[])&#123; int a=1; int b=0; try &#123;//try监控区域 new Main().a();//这是一个栈溢出的异常 &#125; catch(Error e)//这个地方如果时Error和Throwable都可以，就是根据上面那个表格，cathch括号里错误类型的子类也可以被捕获 &#123;//catch 捕获异常 System.out.println(&quot;程序出现异常，变量b不能为0&quot;); &#125; finally &#123;//处理善后工作，无论是否报错这个finally都是会执行的，无论怎样都会执行，报其他错也会执行 System.out.println(&quot;finally&quot;); //finally可以不要finally，假设IO时读取文件关闭资源关闭时可以用 &#125; &#125; public void a() &#123; b(); &#125; public void b() &#123; a(); &#125; 例3 有多个catch的异常处理机制，只能执行一个catch，所以越往下catch括号里的错误类型越高层，从小到大去捕获 123try &#123;//try监控区域 new Main().a();//这是一个栈溢出的异常 &#125; catch(Error e)//这个地方的错误必须是和try中出现的错误类型相同，否则没什么用 &#123;//catch 捕获异常 System.out.println(&quot;程序出现异常，变量b不能为0&quot;); &#125; catch(Exception e) &#123; System.out.println(&quot;exception&quot;); &#125; catch(Throwable e) &#123; System.out.println(&quot;throwable&quot;); &#125; finally &#123;//处理善后工作，无论是否报错这个finally都是会执行的，无论怎样都会执行，报其他错也会执行 System.out.println(&quot;finally&quot;); //finally可以不要finally，假设IO时读取文件关闭资源关闭时可以用 &#125; 例四 throw和throws的用法，是用来主动抛出异常 public void test(int a,int b) throws ArithmeticException&#123;//有throws就是在调用这个方法的时候要对这个异常进行捕获，也就是下面使用这个trycatch /*if(b==0) &#123; throw new ArithmeticException();//主动的抛出异常，一般在方法中使用 &#125;*/ &#125; public static void main(String[] args) &#123; try &#123; new Hello().test(1,0); &#125; catch(ArithmeticException e)&#123; e.printStackTrace(); &#125; &#125; 不用throws的话就是要在throw那个地方去进行一个异常捕获 自定义异常exception类能被继承的常用方法： public void printStackTrace() public String toString() public String getMessage() 除内置的异常类可以描述大部分异常情况，除此之外，用户还可以自定义异常，用户自定义异常类，只需继承Exception类即可； 1.创建自定义异常类 2.在方法中通过throw关键字抛出异常对象 3.如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理；否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作 4.再出现异常方法的调用者捕获并处理异常 例子 自定义的异常类 12345678910111213141516package Main;class MyException extends Exception&#123;//传递数字大于10 private int detail; public MyException(int a) &#123; this.detail=a; &#125; @Override public String toString() &#123; return &quot;MyException&#123;&quot;+detail+&#x27;&#125;&#x27;; &#125;&#125; 测试 123456789101112131415161718192021class Test&#123;static void test(int a) throws MyException&#123; System.out.println(&quot;传递的参数为: &quot;+a); if(a&gt;10) &#123; throw new MyException(a)//抛出 &#125; System.out.println(&quot;ok&quot;);&#125;public static void main(String[] args)&#123;try &#123; test(11);&#125;catch(MyException e)&#123; System.out.println(&quot;MyException=&gt;&quot;+e);//这是调用e类中的toString方法&#125;&#125;&#125; 1234567891011121314### 自定义异常的常用格式public class MyException extends Exception&#123;public MyException()&#123;&#125;public MyException(String msg)&#123;super(msg);&#125;&#125; ATM 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package Main;import java.util.Scanner;class NoMoney extends Exception &#123; public NoMoney() &#123; &#125; public NoMoney(String msg) &#123; super(msg);//构造方法传报错信息 &#125; /* public String toString () &#123; return &quot;您的余额不足，您当前余额为&quot;+Main.money; &#125;*/&#125;class Main&#123; public static double money=0; public void deposit(double a) &#123; this.money+=a; System.out.println(&quot;您的当前余额为&quot;+this.money); &#125; public void query() &#123; System.out.println(&quot;您的当前余额为&quot;+this.money); &#125; public void withdraw(double a) throws NoMoney &#123; if(this.money&lt;a) &#123; throw new NoMoney(&quot;余额不足&quot;); &#125; &#125;public static void main(String []args) &#123; int index=0; while(true) &#123; if(index==0) &#123; System.out.println(&quot;您可以输入 查询余额,取款,存款,退出&quot;);&#125; index++; Scanner in=new Scanner(System.in); String str=in.nextLine(); String str1=&quot;查询余额&quot;; String str2=&quot;取款&quot;; String str3=&quot;存款&quot;; String str4=&quot;退出&quot;; Main discount =new Main(); if(str.equals(str1))&#123; discount.query(); &#125; else if(str.equals(str2))&#123; System.out.println(&quot;您要取出的金额是&quot;); double count =in.nextDouble(); try &#123; discount.withdraw(count); Main.money=Main.money-count; System.out.println(&quot;您当前的余额是&quot;+Main.money); &#125; catch(NoMoney e)&#123; //System.out.println(&quot;您当前的余额不足,您当前的余额是&quot;+Main.money); /*System.out.println(e.toString()); continue;*/ e.printStackTrace();//打印报错信息和堆栈信息 System.out.println(e.getMessage());//打印获得的报错信息 &#125; &#125; else if(str.equals(str3)) &#123; System.out.println(&quot;您要存入的金额是&quot;); double count=in.nextDouble(); discount.deposit(count); &#125; else if(str.equals(str4))&#123; break; &#125; else &#123; System.out.println(&quot;输入内容有问题&quot;); continue; &#125; &#125; &#125; &#125;# 异常语句的执行顺序分析12345678910111213141516public class Demo&#123; public int add(int a,int b)&#123; try&#123; return a+b; &#125;catch(Exception e)&#123; System.out.println(“catch 语句块”); &#125;finally&#123; System.out.println(“finally 语句块”); &#125; return 0; &#125; public static void main(String[] args)&#123; Demo demo = new Demo(); System.out.println(“和是：”+demo.add(9,34)); &#125;&#125; 执行结果： finally 语句块和是：43 调用add方法之后一直等到finally调用完才返回到主函数 java中的泛型泛型初体验 123456789101112131415161718192021//编译期间检查类型//减少了数据类型的转换ArrayList&lt;String&gt; strList=new ArrayList&lt;&gt;();strList.add(&quot;a&quot;);strList.add(&quot;b&quot;);strList.add(&quot;c&quot;);for(int i=0;i&lt;strList.size();i++)&#123; String s=strList.get(i); System.out.println(s);&#125;ArrayList&lt;Integer&gt; intList=new ArrayList&lt;&gt;();intList.add(100);intList.add(200);intList.add(300);for(int i=0;i&lt;intList.size();i++)&#123; int num=intList.get(i); System.out.println(num);&#125; 泛型类的创建12345678910111213141516171819202122232425/*泛型类的定义 * &lt;T&gt;泛型标识--类型形参 * T 创建对象的时候里指定具体的数据类型 */ public class Generic &lt;T&gt;&#123; //T，是由外部使用类的时候来指定 private T key; public Generic(T key) &#123; this.key=key; &#125; public T getKey() &#123; return key; &#125; public void setKey(T key) &#123; this.key=key; &#125; @Override public String toString() &#123; return &quot;Generic&#123;&quot;+&quot;key=&quot;+key+&#x27;&#125;&#x27;; &#125;&#125; 泛型类使用语法： 类名&lt;具体的数据类型&gt; 对象名&#x3D;new 类名&lt;具体的数据类型&gt;(); 或者 类名&lt;具体的数据类型&gt; 对象名&#x3D;new 类名&lt;&gt;(); 测试123456public static void main(String []args) &#123; //泛型类在创建对象的时候，来指定操作的具体的数据类型 Generic&lt;String&gt; strGeneric=new Generic&lt;&gt;(&quot;赵梓皓&quot;); String key1=strGeneric.getKey(); System.out.println(&quot;key1:&quot;+key1); Generic&lt;Integer&gt; intGeneric =new Generic&lt;&gt;(123); int key=intGeneric.getKey(); System.out.println(&quot;key:&quot;+key); //泛型类在创建对象的时候，没有指定类型，将按照Object类型来操作 Generic generic =new Generic(&quot;ABC&quot;); Object key3=generic.getKey(); System.out.println(&quot;key3:&quot;+key3); //泛型类不支持基本数据类型 // Generic &lt;int&gt; generic2=new Generic &lt;int&gt;(100); //同一泛型类，根据不同的数据类型创建的对象，本质上是同一类型，是Generic类型 System.out.println(intGeneric.getClass()); System.out.println(strGeneric.getClass()); System.out.println(intGeneric.getClass()==strGeneric.getClass()); &#125; 注意事项：泛型类，如果没有指定具体的数据类型，此时，操作类型是Object 2.泛型的类型参数只能是类类型，不能是基本数据类型 3.泛型类型在逻辑上可以看成是多个不同的类型，但实际上都是相同类型 泛型类的使用抽奖器泛型类 1234567891011121314151617import java.util.ArrayList;import java.util.Random;public class ProductGetter &lt;T&gt; &#123; Random random=new Random(); //奖品private T product;//奖品池ArrayList &lt;T&gt; list=new ArrayList&lt;T&gt;();public void addProduct(T t) &#123; list.add(t);&#125; //抽奖public T getProduct() &#123; return list.get(random.nextInt(list.size()));&#125;&#125; 抽奖器使用 1234567891011121314151617181920class Main&#123; public String b=&quot;100&quot;; public static void main(String []args) &#123; //创建抽奖器对象，指定数据类型 ProductGetter&lt;String&gt; stringProductGetter=new ProductGetter&lt;&gt;(); String[] strProducts= &#123;&quot;苹果手机&quot;,&quot;华为手机&quot;,&quot;扫地机器人&quot;,&quot;咖啡机&quot;&#125;; //给抽奖器中，填充奖品 for(int i=0;i&lt;strProducts.length;i++) &#123; stringProductGetter.addProduct(strProducts[i]); &#125; //抽奖 String product1=stringProductGetter.getProduct(); System.out.println(&quot;恭喜您，你抽中了&quot;+product1); &#125;&#125; 泛型类派生子类1.子类也是泛型类，子类和父类的泛型类型一致 class ChildGeneric extends Generic 2.子类不是泛型类，父类要明确泛型的数据类型 class ChildGeneric extends Generic 例一： 1234567891011父类public class Parent &lt;E&gt; &#123;private E value;public E getValue() &#123; return value;&#125;public void setValue(E value) &#123; this.value=value;&#125;&#125; 123456789子类 //子类中可以泛型扩展，但必须要有一个泛型和父类中的一样 //泛型类派生子类，子类也是泛型类的情况时，子类的泛型标识要和父类一致public class ChildFirst&lt;T&gt; extends Parent&lt;T&gt; &#123; @Override public T getValue() &#123; return super.getValue(); &#125;&#125; 1234567891011测试class Main&#123; public static void main(String []args) &#123; ChildFirst&lt;String&gt; childFirst=new ChildFirst&lt;String&gt;(); childFirst.setValue(&quot;abc&quot;); String value=childFirst.getValue(); System.out.println(value); &#125;&#125; 例二 &#96;&#96;&#96;java&#x2F;* 子类 当泛型类派生自类的时候，如果子类不是泛型类那么父类要明确数据类型*&#x2F;public class ChildFirst extends Parent { @Override public String getValue() { return super.getValue(); }}1 1234567891011 * 测试class Main&#123; public static void main(String []args) &#123; ChildFirst childfirst=new ChildFirst(); childfirst.setValue(&quot;abc&quot;); String value1=childfirst.getValue(); System.out.println(value1); &#125;&#125; 泛型接口 1.泛型接口的实现类不是泛型类，接口要明确数据类型 泛型接口 1234567* /* * 泛型接口 */ public interface Generator&lt;T&gt; &#123; T getKey(); &#125; 子类 1234567891011public class Apple implements Generator&lt;String&gt;&#123; /* * 实现泛型接口的类，不是泛型类，需要明确实现泛型接口的数据类型 */ @Override public String getKey() &#123; return &quot;hello generic&quot;; &#125;&#125; 测试 12345678class Main&#123; public static void main(String []args) &#123; Apple apple=new Apple(); String key=apple.getKey(); System.out.println(key); &#125;&#125; 2.实现类也是泛型类，实现类和接口的泛型类型要一致 /*子类 123456789101112131415161718192021* 泛型接口的实现类是一个泛型类，那么要保证实现接口的泛型类泛型标识包含泛型接口的泛型标识 */ //实现类的泛型标识必须和接口的一样 public class Apple&lt;T,E&gt; implements Generator&lt;T&gt;&#123; private T key; private E value; public Apple(T key,E value)&#123; this.key=key; this.value=value; &#125; @Override public T getKey() &#123; return key; &#125; public E getValue() &#123; return value; &#125; &#125; 123* ``` /*泛型类 泛型接口*&#x2F;public interface Generator {T getKey();} 12345678910111213141516 实现类```javaclass Main&#123; public static void main(String []args) &#123; Apple&lt;String,Integer&gt; apple=new Apple&lt;&gt;(&quot;abc&quot;,100); String a=apple.getKey(); int b=apple.getValue(); System.out.println(a+b); &#125;&#125; 泛型方法12345修饰符 &lt;T,E,...&gt; 返回值类型 方法名(形参列表) &#123;方法体&#125; 泛型类 &#96;&#96;&#96;javaimport java.util.ArrayList; import java.util.Random; 123456789101112131415161718192021222324public class ProductGetter &lt;T&gt; &#123; Random random=new Random(); //奖品private T product;//奖品池ArrayList &lt;T&gt; list=new ArrayList&lt;T&gt;();public void addProduct(T t) &#123; list.add(t);&#125; //抽奖public T getProduct() &#123;//这都不是泛型方法，是用泛型的成员方法 return list.get(random.nextInt(list.size()));&#125;/* * 定义泛型方法 * 这里定义的就是一个泛型方法，有了&lt;E&gt;泛型标识，方法里就可以用这个泛型标识，具体类型由调用方法的时候来指定 */ public &lt;E&gt; E getProduct(ArrayList&lt;E&gt; list) &#123;//这个泛型方法的类型是独立于泛型类的 return list.get(random.nextInt(list.size())); &#125; &#125; 测试 123456789101112class Main&#123; public static void main(String []args) &#123; ProductGetter&lt;Integer&gt; productGetter=new ProductGetter&lt;&gt;(); ArrayList&lt;String&gt; strList=new ArrayList&lt;&gt;(); strList.add(&quot;笔记本&quot;); strList.add(&quot;手机&quot;); //这是对泛型方法的调用，类型是通过调用方法的时候来制定的，这个地方就是指定E类型为String String product1=productGetter.getProduct(strList); System.out.println(product1); &#125;&#125; 注意问题： 1.如果一个普通的成员方法用了类的这个泛型类型，是不能用static来修饰的 2.如果是泛型方法可以支持静态 静态类型的泛型方法 12345678910/* * 静态类型的泛型方法，采用多个泛型类型 */ public static &lt;E,T,K&gt; void printtype(E e,T t,K k) &#123; System.out.println(t.getClass()); System.out.println(e.getClass()); System.out.println(k.getClass()); &#125; 测试 123public static void main(String []args) &#123; ProductGetter.printtype(100,&quot;java&quot;,true);&#125; 泛型方法与可变参数 例子 1234567//因为参数的数目是可以变化的，所以可以形成数组//泛型方法对可变参数的支持public static &lt;E&gt; void print(E...e) &#123; for(int i=0;i&lt;e.length;i++) &#123; System.out.println(e[i]); &#125;&#125; 测试 123public static void main(String []args) &#123; ProductGetter.print(1,2,3,4,5,6);&#125; 总结：泛型方法能使方法独立于类而产生变化 如果static方法要使用泛型能力，就必须使其成为泛型方法 类型通配符方法参数使用类的泛型标识符时不能重载，因为标识符从根本上都是Object类 注意：1.类型通配符一般是使用“?”代替具体的类型实参 2.所以，类型通配符是类型实参，而不是类型形参 通配符初体验 1234567891011121314151617181920class Main&#123; public static void main(String []args) &#123; Box&lt;Number&gt; box1=new Box&lt;&gt;(); box1.setFirst(100); showBox(box1); Box&lt;Integer&gt; box2=new Box&lt;&gt;(); box2.setFirst(200); showBox(box2); &#125; public static void showBox(Box&lt;?&gt;box)//这个地方是问号就可以是任意类型的，都可以用这个showBox方法，但如果是Number类型的，即使是它的子类Integer也不能用因为标识符类型本质上都是一样的Object类所以不能进行方法重载 &#123; Object first=box.getFirst(); System.out.println(first); &#125;&#125; 通配符设置上限语法 类&#x2F;接口&lt;? extends 实参类型&gt; 要求该泛型的类型，只能是实参类型，或者是实参类型的子类类型 1234567891011121314151617181920class Main&#123; public static void main(String []args) &#123; Box&lt;Number&gt; box1=new Box&lt;&gt;(); box1.setFirst(100); showBox(box1); Box&lt;Integer&gt; box2=new Box&lt;&gt;(); box2.setFirst(200); showBox(box2); &#125; public static void showBox(Box&lt;? extends Number&gt;box)//这里意思就是最大接收的类型就是Number，如果单独是一个?的话就是最大是Object &#123; Number first=box.getFirst(); System.out.println(first); &#125;&#125; 例子： Cat是miniCat的父类，Animal是Cat的父类 1234567891011121314151617181920212223242526public class miniCat extends Cat&#123; public static void main(String[] args) &#123; ArrayList&lt;Animal&gt; animals=new ArrayList&lt;&gt;(); ArrayList&lt;Cat&gt; cats=new ArrayList&lt;&gt;(); ArrayList&lt;miniCat&gt; miniCats=new ArrayList&lt;&gt;(); //showAnimal(animals);这个会报错因为下面的通配符上限是Cat，传递的集合类型只能是Cat或Cat的子类 showAnimal(cats); showAnimal(miniCats); &#125; public static void showAnimal(ArrayList&lt;? extends Cat&gt; list) &#123; //这种用通配符来表述存储对象类型的集合是不能向其中添加元素的 /*list.add(new Cat()); list.add(new miniCat()); list.add(new Animal());*/ for(int i=0;i&lt;list.size();i++) &#123; //ArrayList通配符上限为Cat所以下面用Cat引用变量接受没有任何问题 Cat cat = list.get(i);//这个地方得到集合的类型，引用变量必须是最大的那一种 System.out.println(cat); &#125; &#125;&#125; 类型通配符的下限类&#x2F;接口&lt;? super 实参类型&gt; 要求该泛型的类型，只能是实参类型，或实参类型的父类类型 通配符下限初体验 12345678910111213141516171819202122232425import java.util.ArrayList;public class miniCat extends Cat&#123; public static void main(String[] args) &#123; ArrayList&lt;Animal&gt; animals=new ArrayList&lt;&gt;(); ArrayList&lt;Cat&gt; cats=new ArrayList&lt;&gt;(); ArrayList&lt;miniCat&gt; miniCats=new ArrayList&lt;&gt;(); showAnimal(animals); showAnimal(cats); // showAnimal(miniCats);要求只能是Cat或者Cat的父类类型，所以这个地方报错 &#125; /* * 类型通配符的下限，要求集合只能是Cat或Cat的父类类型 */ public static void showAnimal(ArrayList&lt;? super Cat&gt; list) &#123; for(Object o:list) &#123;//当接受用下限通配符标识的集合元素的时候，用object，因为Object是所有类的父类 System.out.println(o); &#125; &#125;&#125; TreeSet是通过自己定义的比较器来排序的 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Main&#123; public static void main(String []args) &#123; TreeSet&lt;Cat&gt; treeSet=new TreeSet&lt;&gt;(new Comprator2());//因为是comprator2所以是按照年龄大小来排序的 //TreeSet&lt;Cat&gt; treeSet=new TreeSet&lt;&gt;(new Comprator1());不会报错 //TreeSet&lt;Cat&gt; treeSet=new TreeSet&lt;&gt;(new Comprator3());会报错 //因为TreeSet的这个地方泛型是Cat它的构造方法也用到了泛型，只有是继承Cat或Cat子类标识Comparator接口的比较器才能够好用 treeSet.add(new Cat(&quot;jerry&quot;,20)); treeSet.add(new Cat(&quot;amy&quot;,22)); treeSet.add(new Cat(&quot;frank&quot;,23)); treeSet.add(new Cat(&quot;jim&quot;,25)); for(Cat cat:treeSet) &#123; System.out.println(cat); &#125; &#125;&#125;class Comprator1 implements Comparator&lt;Animal&gt;&#123; @Override public int compare(Animal o1, Animal o2) &#123; // TODO Auto-generated method stub return o1.name.compareTo(o2.name); &#125;&#125;class Comprator2 implements Comparator&lt;Cat&gt;&#123; @Override public int compare(Cat o1, Cat o2) &#123; // TODO Auto-generated method stub return o1.age-o2.age; &#125;&#125;class Comprator3 implements Comparator&lt;miniCat&gt;&#123; @Override public int compare(miniCat o1, miniCat o2) &#123; // TODO Auto-generated method stub return o1.level-o2.level; &#125;&#125; 12345public Treeset(Comparator &lt;? super E&gt; comparator)&#123;&#125; 类型擦除123456public static void main(String []args) &#123; //泛型类在创建对象的时候，来指定操作的具体的数据类型 Generic&lt;String&gt; strGeneric=new Generic&lt;&gt;(&quot;赵梓皓&quot;); String key1=strGeneric.getKey(); System.out.println(&quot;key1:&quot;+key1); Generic&lt;Integer&gt; intGeneric =new Generic&lt;&gt;(123); int key=intGeneric.getKey(); System.out.println(&quot;key:&quot;+key); //泛型类在创建对象的时候，没有指定类型，将按照Object类型来操作 Generic generic =new Generic(&quot;ABC&quot;); Object key3=generic.getKey(); System.out.println(&quot;key3:&quot;+key3); //泛型类不支持基本数据类型 // Generic &lt;int&gt; generic2=new Generic &lt;int&gt;(100); //同一泛型类，根据不同的数据类型创建的对象，本质上是同一类型，是Generic类型 System.out.println(intGeneric.getClass()); System.out.println(strGeneric.getClass()); System.out.println(intGeneric.getClass()==strGeneric.getClass()); } 判断两个类型是否相同 最后是相同的 因为泛型只有在编译阶段存在，编译结束之后类型就擦除了，都是Object类 泛型数组的创建可以声明带泛型的数组引用，但是不能直接创建带泛型的的数组对象 1234567891011class Main&#123; public static void main(String []args) &#123; ArrayList&lt;String&gt;[] listArr=new ArrayList[5];//定义泛型数组的方式，操作的时候就是拿引用去操作 ArrayList&lt;String&gt; strList=new ArrayList&lt;&gt;(); strList.add(&quot;abc&quot;); listArr[0]=strList; String s=listArr[0].get(0); System.out.println(s); &#125;&#125; 可以通过java.lang.reflect.Array的newInstance(Class,int) 创建T[]数组 Fruit 1234567891011121314151617181920212223package Main;import java.lang.reflect.Array;public class Fruit&lt;T&gt; &#123; private T[] array; public T[] getArray() &#123; return array; &#125; public void setArray(T[] array) &#123; this.array = array; &#125; public Fruit(Class&lt;T&gt; clz,int length)&#123;array=(T[])Array.newInstance(clz, length); &#125; public void put(int index, T string) &#123; array[index]=string; &#125; &#125; 测试 12345678910111213class Main&#123; public static void main(String []args) &#123; Fruit&lt;String&gt; fruit=new Fruit&lt;&gt;(String.class ,3); fruit.put(0,&quot;苹果&quot;); fruit.put(1,&quot;西瓜&quot;); fruit.put(2,&quot;香蕉&quot;); System.out.println(Arrays.toString(fruit.getArray())); &#125;&#125; 一个利用比较器以及string的compareTo的一个题 java的File类java.io.File类 文件和目录路径的抽象表示形式 java把电脑中的文件和文件夹封装为了一个File类，我们可以使用File类对文件和文件夹进行操作 我们可以使用File类的方法 创建一个文件&#x2F;文件夹等等 File类是一个和系统无关的类，任何的操作系统都可以使用这个类中的方法 重点记住三个单词：file：文件 directory：文件夹&#x2F;目录 path：路径 File类的静态属性 123456String pathSeparator=File.pathSeparator;//路径分隔符，分割多个路径的，windows系统是分号，linux系统是冒号System.out.println(pathSeparator);String separator=File.separator;System.out.println(separator);//文件名称分隔符，windows系统是反斜杠\\ linux系统是正斜杠///操作路径&quot;C:&quot;+File.separator+&quot;develop&quot;+File.separator+&quot;a&quot;+File.separator+&quot;a.txt&quot;//将反斜杠或者正斜杠用File.separator代替，不写死 绝对路径与相对路径 构造方法 &#96;&#96;&#96;java&#x2F;*一 File(String pathname) 通过将给定路径名字字符串转换为抽象路径来创建一个新的File实例 参数： String pathname 字符串的路径名称 路径可以是文件结尾也可以是文件夹结尾 路径可以是相对路径，也可以是绝对路径 路径可以存在也可以不存在，创建File对象，只是把字符串封装为File对象，不考虑路径的真假情况 *&#x2F;File f1&#x3D;new File(“D:\\放乱七八糟\\File.txt”);System.out.println(f1);&#x2F;&#x2F;重写了object类里的toString方法输出路径 D:\\放乱七八糟\\File.txt 1234567891011121314/* * ``` * File(String parent,Stringchild) * 参数分为两部分，String parent父路径 * String child 子路径 * 好处： * 父路径和子路径可以单独书写，使用起来非常灵活，父路径和子路径都可以变化 */ File f1=new File(&quot;c:\\\\&quot;,&quot;a.txt&quot;); System.out.println(f1); File f2=new File(&quot;d:\\\\&quot;,&quot;a.txt&quot;); System.out.println(f2); ​ &#x2F;* * ``` * File(File parent,String child)根据parent抽象路径名和child路径字符串创建一个新File实例 * 参数：把路径分为了两部分 * File parent：父路径 * String child：子路径 * 好处： * 父路径和子路径可以单独书写，使用起来非常灵活，父路径和子路径都可以变化 * */ File parent=new File(&quot;c:\\\\&quot;); File file=new File(parent,&quot;hello.java&quot;); System.out.println(file); 123456789 ## 常用方法### 获取方法public String getAbsolutePath() :返回此File的绝对路径字符串，获取构造方法中的传递的路径，不管你写的是相对的还是绝对的都返回绝对路径字符串 File f1&#x3D;new File(“C:\\a.txt”);System.out.println(f1.getAbsolutePath());File f2&#x3D;new File(“a.txt”);System.out.println(f2.getAbsolutePath());结果:C:\\a.txtD:\\Java\\12345\\a.txt 1234567891011public String getPath()将此File转换为路径名字符串```javaFile f1=new File(&quot;C:\\\\a.txt&quot;);System.out.println(f1.getPath());File f2=new File(&quot;a.txt&quot;);System.out.println(f2.getPath());结果：C:\\a.txta.txt public String getName()返回由此File表示的文件或目录的名称 1234567File f1=new File(&quot;C:\\\\a.txt&quot;);System.out.println(f1.getName());File f2=new File(&quot;a.txt&quot;);System.out.println(f2.getName());结果：a.txta.txt public long length() 获取的式构造方法指定的文件的大小，以字节为单位 注意： 文件夹是没有大小概念的，不能获取文件夹的大小，如果构造方法中给出的路径不存在，那么length方法返回零 文件夹没有大小概念，返回值也是零 1234567File f1=new File(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);System.out.println(f1.length());File f2=new File(&quot;a.txt&quot;);System.out.println(f2.length());结果：100 判断功能的方法public boolean exists() ：此File表示的文件或目录是否实际存在 用于判断构造方法中的路径是否存在 存在：true 不存在：false 123File f1=new File(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);System.out.println(f1.exists());结果：true 123File f1=new File(&quot;D:\\\\放乱七八糟\\\\Fil.txt&quot;);System.out.println(f1.exists());结果：false 注意下面两个判断方法的路径必须是存在的如果不存在则都返回false public boolean isDirectory() 表示此File是否为目录 用于判断构造方法中给定的路径是否是以文件夹结尾 123File f1=new File(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);System.out.println(f1.isDirectory());结果:false publicboolean isFile() 用于判断构造方法中给定的路径是否是以文件结尾 123File f1=new File(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);System.out.println(f1.isFile());结果：true 123File f1=new File(&quot;D:\\\\放乱七八糟\\\\Fil.txt&quot;);System.out.println(f1.isFile());结果：false 因为路径不存在 创建删除功能的方法public boolean createNewFile() :当且仅当具有该名称的文件尚不存在时，创建一个新的空文件 创建文件的路径和名称在构造方法中给出（构造方法的参数） 返回值：布尔值 true：文件不存在，创建文件，返回true false：文件存在不会创建，返回false 注意;1.此方法之恩那个创建文件，不能创建文件夹所以创建文件的路径必须存在，否则会抛出异常 123456File f1=new File(&quot;D:\\\\放乱七八糟\\\\Fil.txt&quot;);try &#123; System.out.println(f1.createNewFile());&#125; catch (IOException e) &#123; e.printStackTrace();//createNewFile声明抛出了IOException，我们调用这个方法，就必须的处理这个异常，要么throws，要么trycatch如果调用方法的时候也throws就会交给jvm处理&#125; 如果路径不存在则会抛出IO异常 public boolean mkdir() :创键单级空文件夹 public boolean mkdirs() :创建单级空文件夹，也可以创建多级文件夹 创建文件夹的路径和名称在构造方法中给出（构造方法的参数） 返回值：布尔值 true：文件夹不存在，创建文件夹，返回true false：文件夹存在不会创建，返回false，构造方法中给出的路径不存在返回false 注意;1.此方法只能创建文件夹，不能创建文件 123456789File f1=new File(&quot;D:\\\\放乱七八糟\\\\aaa\\\\bb&quot;);System.out.println(f1.mkdir());//不能创建多级目录File f2=new File(&quot;D:\\\\放乱七八糟\\\\aaa\\\\bb&quot;);System.out.println(f1.mkdirs());File f3=new File(&quot;D:\\\\放乱七八糟\\\\ccc&quot;);System.out.println(f3.mkdir());结果：falsetruetrue public boolean delete() 删除构造方法路径中给出的文件和文件夹 返回值也是一个布尔值 true：文件&#x2F;文件夹删除成功，返回true false：文件夹中有内容，不会删除返回false，构造方法中的路径不存在返回false，文件不管里面有没有内容都会删除 注意： delete方法是直接在硬盘删除文件&#x2F;文件夹，不走回收站，删除要谨慎 1234567File f2=new File(&quot;D:\\\\放乱七八糟\\\\aaa\\\\bb&quot;);System.out.println(f2.delete());File f3=new File(&quot;D:\\\\放乱七八糟\\\\ccc&quot;);System.out.println(f3.delete());结果：truetrue删除路径的最后一个文件或者文件夹 1234File f2=new File(&quot;D:\\\\放乱七八糟\\\\aaa&quot;);System.out.println(f2.delete());结果false因为文件夹aaa中有内容 1234File f2=new File(&quot;D:\\\\放乱七八糟\\\\aaa\\\\新建文本文档.txt&quot;);System.out.println(f2.delete());结果：true就算txt文件中有内容也会被删除 目录的遍历功能public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录（隐藏的也能获取到） 遍历构造方法中给出的目录，会获取目录中所有文件&#x2F;文件夹的名称，把获取到的多个名称存储到一个字符串String类型的数组中 public File[] listFiles(): 返回一个File数组，表示该File目录中所有的子文件或目录 遍历一个构造方法中给出的目录，会获取目录中所有个文件&#x2F;文件夹，把文件或文件夹封装为File对象，多个File对象存储到File数组里 注意： list方法和listFiles方法遍历的是构造方法中给出的目录 如果构造方法中给出的目录的路径不存在，会抛出空指针异常 如果构造方法中给出的路径不是一个目录，也会抛出空指针异常 1234567891011File f2=new File(&quot;D:\\\\放乱七八糟&quot;);String str[]=f2.list();for(String filename:str) &#123; System.out.println(filename);&#125;结果：eclipse.zipEverything-1.4.1.1017.x64-Setup.exeFil.txtFile.txtjava8中文说明文档321456第五章.ppt 1234567891011File file=new File(&quot;D:\\\\放乱七八糟&quot;);File []files=file.listFiles();for(File f:files) &#123; System.out.println(f);&#125;结果：D:\\放乱七八糟\\eclipse.zipD:\\放乱七八糟\\Everything-1.4.1.1017.x64-Setup.exeD:\\放乱七八糟\\Fil.txtD:\\放乱七八糟\\File.txtD:\\放乱七八糟\\java8中文说明文档321456D:\\放乱七八糟\\第五章.ppt 递归递归的分类：1.直接递归和间接递归 直接递归：main(){ a() } a(){ a();自己调用自己 } 间接递归：b(){ c();} c(){ b();} 注意事项：1.递归一定要有条件限定，保证递归能够停下来，否则会发生栈内存溢出 2.在递归中虽然有限定条件，但是递归次数不能太多，否则也会发生栈内存溢出 3.构造方法，禁止递归，编译错误，构造方法是创建对象时侯用的，一直递归会导致内存中有无数多个对象，直接编译报错 递归地使用前提：当调用方法的时候，方法的主体不变，每次调用方法的参数不同，可以使用递归 为什么递归无限制会导致栈内存溢出 a方法会在栈内存中一直调用a方法，就会导致栈内存中由无数多个a方法 方法太多了，超出栈内存的大小，就会导致内存溢出的错误 注意： 当一个方法调用其他方法时，被调用的方法没有执行完毕，当前方法就会一直等待低矮哦用的方法执行完毕才会继续执行 1使用递归计算0到n之间的和 1234567891011121314class Main&#123; public static void main(String []args) &#123; int s=Sum(3); System.out.println(s);&#125; public static int Sum(int n) &#123; if(n==1) return 1; return n+Sum(n-1); &#125;&#125; 递归计算阶乘 12345 public static void main(String []args) &#123; int s=Sum(7); System.out.println(s);&#125; public static int Sum(int n) &#123; if(n==1) return 1; return n*Sum(n-1); &#125; 递归打印多级目录 1遍历c:\\\\abc文件夹，及abc文件夹的子文件夹以及子文件夹中所有文件 12345678910111213141516171819class Main&#123;public static void main(String []args)&#123; File file=new File(&quot;d:\\\\放乱七八糟&quot;); getAllFile(file);&#125;public static void getAllFile(File dir) &#123; System.out.println(dir);//打印被遍历的目录 File[]files=dir.listFiles(); for(File f:files) &#123; if(f.isDirectory()) &#123; getAllFile(f); &#125; else &#123; System.out.println(f); &#125; &#125;&#125;&#125; 综合案例找出目录下文件中只有以.java为结尾的 12345678910111213141516171819202122232425262728293031323334353637class Main&#123;public static void main(String []args)&#123; File file=new File(&quot;D:\\\\同步空间\\\\新建文件夹&quot;); getAllFile(file);&#125;public static void getAllFile(File dir) &#123; // System.out.println(dir); File[]files=dir.listFiles(); for(File f:files) &#123; if(f.isDirectory()) &#123; getAllFile(f); &#125; else &#123; /* * 只要.java结尾的文件 * 把File对象f转换为字符串对象 * String name=f.getName(); * String path=f.getPath(); * String s=f.toString(); * System.out.println(f); */ /* * 2.调用String类中的方法endswith判断字符串是否是以.java结尾 * */ String s=f.toString(); //把字符串转换为小写 //s=s.toLowerCase(); boolean b=s.endsWith(&quot;.java&quot;); if(b) &#123; System.out.println(f); &#125; &#125; &#125;&#125;&#125; 第二种方法 1234567if(f.getName().toLowerCase().endsWith(&quot;.java&quot;))&#123;System.out.println(f);&#125; 文件过滤器优化 1234567891011121314151617181920212223需求：遍历某个文件夹，及其子文件夹，只要.java结尾的文件我们可以使用过滤器来实现，在File类中有两个和ListFiles重载的方法，方法的参数传递就是过滤器File[] listFiles(FileFilter filter)java.io.FileFilter接口：用于抽象路径名（File对象）的过滤器作用：用来过滤文件（File对象）抽象方法：用来过滤文件的方法boolean accept(File pathname) 测定指定抽象路径名是否应该包含在某一个路径名列表中参数： File pathname 使用listFiles方法遍历目录，得到的每一个文件对象 File[] listFiles(FilenameFileter filter) java.io.FilenameFilter接口：实现此接口的类实例可以用于过滤文件名 作用：用于过滤文件名称 抽象方法：用来过滤文件 boolean accept(File dir,String name) 参数： File dir:构造方法中传递的被遍历的目录，也就是除了最后一个之外的 String name:使用ListFiles方法遍历目录，获取的每一个文件/文件夹的名称(也就是最后一个)注意：两个过滤器接口是没有实现类的，需要我们自己写实现类，重写过滤的方法accept，在方法中自己定义过滤的规则 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.Scanner;//创建过滤器FileFilter的实现类，重写过滤方法accept，定义过滤规则//如果accept返回false就不会把这个文件对象放到文件对象数组中//如果accept返回true就可以把这个文件对象放到文件对象数组中class FileFilterimpl implements FileFilter&#123; @Override public boolean accept(File pathname) &#123; //如果是文件夹就返回true，再下面检测出是文件夹会继续调用getAllFile方法 if(pathname.isDirectory()) &#123; return true; &#125;return pathname.getName().toLowerCase().endsWith(&quot;.md&quot;);//要到.md结尾的文件对象 &#125;&#125;class Main&#123;public static void main(String []args)&#123; File file=new File(&quot;D:\\\\同步空间\\\\新建文件夹&quot;); getAllFile(file);&#125;public static void getAllFile(File dir) &#123; // System.out.println(dir); File[]files=dir.listFiles(new FileFilterimpl());//传递过滤器对象 /* * listFiles()方法做了三件事 * 1.listFiles方法会对构造方法中传递的目录进行遍历，获取目录中的每一个文件/文件夹--&gt;封装为File对象 * 2.listFiles会调用参数传递过程中的过滤器的方法accept * 3.listFiles方法会把遍历得到的每一个File对象传递给accept方法的参数叫pathname */ for(File f:files) &#123; if(f.isDirectory()) &#123; getAllFile(f); &#125; else &#123; System.out.println(f); &#125; &#125; &#125; &#125; FileNameFilter过滤器的使用和Lambda优化程序 当接口只有一个抽象方法的时候叫函数式接口此时可以用Lambda表达式来代替这个接口的实例化对像，要实现那一个抽象方法 匿名内部类是当这个接口的实例化对象只用一次时可以用来代替，要实现接口的所有抽象方法 1234567class Main&#123;public static void main(String []args)&#123; File file=new File(&quot;D:\\\\同步空间\\\\新建文件夹&quot;); getAllFile(file);&#125;public static void getAllFile(File dir) &#123;; File[]files=dir.listFiles(new FilenameFilter() &#123; @Override public boolean accept(File dir, String name) &#123; return new File(dir,name).isDirectory()||name.toLowerCase().endsWith(&quot;.md&quot;); &#125; &#125;);//传递过滤器对象 for(File f:files) &#123; if(f.isDirectory()) &#123; getAllFile(f); &#125; else &#123; System.out.println(f); &#125; &#125; &#125; &#125; java的IOio概述 字符和Ascii码的转换问题字符强转为(int)是获得它的Ascii码值 char a=&#39;a&#39;; int b=(int)a; System.out.println(b); 结果：97 ascii码值强转为char就是获得字符 int a =97; char b=(char)a; System.out.println(b); 结果：a 将字符1转换为数字1 123char a=&#x27;1&#x27;;System.out.println(a-&#x27;0&#x27;);结果：1 字节流一切文件数据在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据 在Ascii码中一个英文字符占用一个字节，一个汉字字符占用两个字节的空间 在unicode编码中，一个英文字符占用两个字节一个汉字字符也占用两个字节 UTF-8中，一个英文字符占用一个字节，一个汉字字符占用三个字节空间 字节输出流（OutputStream和FileOutputStream介绍） &#96;&#96;&#96;java java.io.OutputStream 字节输出流 这个抽象类是表示字节输出流的所有类的超类 定义了一些子类共性的成员方法 public void close() :关于此输出流并释放与此流相关联的任何系统资源 public void flush():刷新此输出流并强制任何缓冲的输出字节被写出 public void write(byte[] b):将 b.length字节从指定的字节数组写入此输出流。 public void write(byte[] b, int off, int len):从指定的字节数组写入 len个字节，从偏移 off开始输出到此输出流。 pubic void write(int b):将指定的字节写入此输出流。 java.io.FileOutputStream extends OutputStream FileOutputStream:文件字节输出流 作用：把内存中的数据给写入到硬盘的文件中 构造方法： FileOutputStream(File file)创建文件输出流以写入由指定的 File对象表示的文件。 FileOutputStream(String name) 创建文件输出流以指定的名称写入文件。构造方法作用1.创建一个FileOutputStream对象2.会根据构造方法中传递的文件&#x2F;文件路径，创建一个空的文件3.会把FileOutputStream对象指向创建好的文件 *&#x2F; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223​ **pubic void write(int b)**​ 写入数据的原理（内存到硬盘）：​ java程序--&gt;jvm(虚拟机)--&gt;os（操作系统）--&gt;os调用写数据的方法--&gt;把数据写入文件夹中字节输出流的使用步骤（重点） 1.创建一个FileOutputStream对象，构造方法中传递写入数据的目的地 2.调用FileOutputStream对象中的方法write，把数据写入到文件中 3.释放资源（流使用会占用一定的内存，使用完毕后把内存清空，提供程序效率） public static void main(String[]args) throws IOException &#123; //创建一个FileOutputStream对象，构造方法中传递写入数据的目的地 FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;); //调用FileOutputStream对象中的方法write，把数据写入到文件中 fos.write(97);//这个只能写入一个字节的大小的内容，97是这个字节对应的ASCII码值 //释放资源（流使用会占用一定的内存，使用完毕后把内存清空，提供程序效率） fos.close(); &#125;![image-20220630102639535](https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291918085.png)原理就是：97回先转换为二进制数储存在硬盘（文件）中，当用任何文本编辑器（记事本，notepad）再打开文件的时候，都会查询编码表，把字节转换为字符表示，0-127查询ASCII表 其他值：查询系统默认码表（中文windows系统GBK）我的电脑记事本查询的是UTF-8 **一次写多个字节的方法****public void write(byte[] b):将 b.length字节从指定的字节数组写入此输出流。**一次写多个字节： ​ 如果写的第一个字节是正数（0-127），那么显示的时候会查询ASCII表​ 如果写入的第一个字节是负数，那第一个字节会和第二个字节，两个字节组成一个中文显示，查询系统默认码表（中文系统GBK） 第一个例子 public static void main(String[]args) throws IOException &#123; //创建一个FileOutputStream对象，构造方法中传递写入数据的目的地 FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;); //调用FileOutputStream对象中的方法write，把数据写入到文件中 //在文件中显示100，写入3个字节 byte []bytes= &#123;49,48,48&#125;; fos.write(bytes); //释放资源 fos.close(); &#125;第二个例子 public static void main(String[]args) throws IOException &#123; //创建一个FileOutputStream对象，构造方法中传递写入数据的目的地 FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;); //调用FileOutputStream对象中的方法write，把数据写入到文件中 //在文件中显示100，写入3个字节 byte []bytes= &#123;-65,-66,-67,68,69&#125;; fos.write(bytes); //释放资源 fos.close(); &#125; 文件写入结果： 烤紻E就是前两个加起来组成一个系统默认码，后两个是一个组成一个系统默认码，最后一个时Ascii码**public void write(byte[] b, int off, int len):从指定的字节数组写入 len个字节，从偏移 off开始输出到此输出流。**把字节数组的一部分写入到文件中 public static void main(String[]args) throws IOException &#123; //创建一个FileOutputStream对象，构造方法中传递写入数据的目的地 FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;); //调用FileOutputStream对象中的方法write，把数据写入到文件中 byte []bytes= &#123;-65,-66,-67,68,69&#125;; fos.write(bytes,1,3);//从字节数组的下标1开始写入三个字节 //释放资源 fos.close(); &#125;写入字符的方法，可以使用String类方法把字符串，转换为字节数组，byte []getBytes() 把字符串转换为字节数组 public static void main(String[]args) throws IOException &#123; //创建一个FileOutputStream对象，构造方法中传递写入数据的目的地 FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;); byte []bytes=&quot;你好&quot;.getBytes(); System.out.println(Arrays.toString(bytes));//结果[-60, -29, -70, -61] //中文在eclipse中默认编码是GBK编码所以是一个中文两个字节 // 如果写入的第一个字节是负数，那第一个字节会和第二个字节，两个字节组成一个中文显示，查询系统默认码表（中文系统GBK） fos.write(bytes); fos.close(); &#125; 文件写入结果： 你好**数据的追加写和换行写**上面的方法都是将文件中原有的东西覆盖掉下面是追加写,续写FileOutputStream(String name, boolean append)创建文件输出流以指定的名称写入文件。FileOutputStream(File file, boolean append)创建文件输出流以写入由指定的 File对象表示的文件。​ 参数：​ String name File file：写入数据的目的地​ boolean append ：追加写开关 true ：创建对象不会覆盖源文件，继续在文件的末尾追加写数据​ false：创建一个新文件，覆盖原文件，在新文件中重新写数据 //创建一个FileOutputStream对象，构造方法中传递写入数据的目的地 FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;,true);//追加写 fos.write(&quot;你好&quot;.getBytes()); fos.close(); 源文件内容：你好 程序执行之后：你好你好**换行**写换行符号：windows \\r\\n​ linux:/n​ mac:/r //创建一个FileOutputStream对象，构造方法中传递写入数据的目的地 FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;,true);//追加写 for(int i=1;i&lt;=10;i++) &#123; fos.write(&quot;你好&quot;.getBytes()); fos.write(&quot;\\r\\n&quot;.getBytes()); &#125; fos.close(); 文件添加结果： 你好 你好 你好 你好 你好 你好 你好 你好 你好​ ### 字节输入流（InputStream）FileInputStream和InputStream的介绍java.io.InputStream抽象类时表示字节输入流的所有类的超类，可以读取字节信息到内存中，它定义了字节输入流的基本共性功能方法定义了所有子类的共性的方法：​ int `read()` 从输入流读取数据的下一个字节。返回读取的那一个字节的内容​ int `read(byte[] b)` 从输入流读取一些字节数，并将它们存储到缓冲区 `b` 。返回读取的字节数，读取的内容储存在参数数组​ void `close()` 关闭此输入流并释放与流相关联的任何系统资源。java.io.FileInputStream extends InputStreamFileInputStream :文件字节输入流作用：把硬盘文件中的数据，读取到内存中使用构造方法：`FileInputStream(String name)` - - `FileInputStream(File file)` - 参数：读取文件的数据源 - ​ String name是文件的路径 - ​ File file就是一个文件对象 - 构造方法的作用： - ​ 1.会创建一个FileInputStream对象 - ​ 2.会把FileInputStream对象指定构造方法中要读取的文件 读取数据的原理（硬盘--&gt;内存）：​ java程序--&gt;jvm--&gt;os--&gt;os读取数据的方法--&gt;读取文件字节输入流的使用步骤：​ 1.创建FileInputStream对象，构造方法中绑定要读取的数据源​ 2.使用FileInputStream对象中的方法read，读取文件​ 3.释放资源```java//1.创建FileInputStream对象，构造方法中绑定要读取的数据源 FileInputStream fos=new FileInputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;); //2.使用FileInputStream对象中的方法read，读取文件 int len=fos.read();//读取文件中的一个字节并返回，读取到文件末尾返回-1 //读取读入的那一个字节 System.out.println(len); len=fos.read();//每次read文件中的文件指针会向后移动一位 System.out.println(len); len=fos.read(); System.out.println(len); len=fos.read(); System.out.println(len); len=fos.read(); System.out.println(len); len=fos.read(); System.out.println(len); fos.close(); &#x2F;* 发现以上读取文件是一个重复的过程，所以可以使用循环优化，不知道文件中有多少字节，使用while循环，while循环结束条件，读取到-1时结束*&#x2F; 1234567FileInputStream fos=new FileInputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;); int len=0; while((len=fos.read())!=-1) &#123; System.out.println((char)(len)); &#125; fos.close(); 字节输入流一次读取一个字节的原理 java程序–&gt;jvm–&gt;os–&gt;os读取数据的方法–&gt;读取文件 每次读取结束，文件下标就会向后移一个 字节输入流一次读取多个字节 方法的参数byte[]作用 ​ 起到缓冲的作用，存储每次读取到的多个字节 ​ 数组的长度一般定义为1024（1kb）或者是1024的整数倍 int的返回值是什么 ​ 每次读取到的有效字节个数 123456789101112131415161718192021222324252627282930313233 int `read(byte[] b)` 从输入流读取一些字节数，并将它们存储到缓冲区 `b` 。 返回值是读入了多少个字节 public static void main(String[]args) throws IOException &#123; FileInputStream fis=new FileInputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;); //读取文件，指定读取多少字节 byte []bytes=new byte[2]; int len=fis.read(bytes); System.out.println(len);//2 System.out.println(Arrays.toString(bytes));//65,66 /* * String类的构造方法 * String(byte[] bytes) 通过使用平台的默认字符集解码指定的字节数组来构造新的 String 。String(byte[] bytes, int offset, int length) 通过使用平台的默认字符集解码指定的字节子阵列来构造新的 String offset是开始的下标，length是长度。 */ System.out.println(new String(bytes));//AB len=fis.read(bytes); System.out.println(len);//2,返回的是读到的字节的个数，没读到返回-1 System.out.println(new String(bytes));//CD len=fis.read(bytes); System.out.println(len);//1 System.out.println(new String(bytes));//ED len=fis.read(bytes); System.out.println(len);//-1 System.out.println(new String(bytes));//ED fis.close(); &#125; 第三次读取时只读取到一个E，故len返回1，而且byte数组的第二个位置没有被重新覆盖掉所以剩下的东西还是D，所以第三次输出数组还是ED，第四次没有东西读，所以返回-1结束标记，数组里还是上次的东西DE 循环优化 1234567891011121314public static void main(String[]args) throws IOException &#123;FileInputStream fis=new FileInputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;);//读取文件，指定读取多少字节byte []bytes=new byte[1024];int len=0;while((len=fis.read(bytes))!=-1) &#123; //String(byte[] bytes, int offset, int length) //通过使用平台的默认字符集解码指定的字节子阵列来构造新的 String offset是开始的下标，length是长度。 System.out.println(new String(bytes,0,5));&#125;fis.close();&#125; 字节流练习复制文件 12345678910111213public static void main(String []args) throws IOException &#123; FileInputStream fis=new FileInputStream(&quot;C:\\\\Users\\\\#赵梓皓&amp;\\\\Pictures\\\\Default.jpg&quot;); FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.jpg&quot;); int len=0; 读取之后再写入 while((len=fis.read())!=-1) &#123; fos.write(len); &#125; fos.close();//先关写的 fis.close();//后关闭读的，如果写完了，肯定读取完毕了 &#125; 更高效率 123456789101112 FileInputStream fis=new FileInputStream(&quot;C:\\\\Users\\\\#赵梓皓&amp;\\\\Pictures\\\\Default.jpg&quot;); FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.jpg&quot;); int len=0; byte []bytes=new byte[1024]; while((len=fis.read(bytes))!=-1) &#123; fos.write(bytes,0,len); &#125; fos.close();//先关写的 fis.close();//后关闭读的，如果写完了，肯定读取完毕了&#125; public static void main(String []args) throws IOException &#123; long s=System.currentTimeMillis(); FileInputStream fis=new FileInputStream(&quot;C:\\\\Users\\\\#赵梓皓&amp;\\\\Pictures\\\\Default.jpg&quot;); FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.jpg&quot;); int len=0; byte []bytes=new byte[1024]; while((len=fis.read(bytes))!=-1) &#123; fos.write(bytes,0,len); &#125; fos.close();//先关写的 fis.close();//后关闭读的，如果写完了，肯定读取完毕了 long e=System.currentTimeMillis(); System.out.println(&quot;复制文件共耗时&quot;+(e-s)+&quot;毫秒&quot;); &#125; 字符流一个中文 ​ GBK:占用两个字节 ​ UTF-8：占用3个字节 所以在从硬盘文件中读入中文时没有很好的办法读入中文 使用字节流读取中文文件会产生乱码 字符输入流Reader和FileReader类Reader定义 的一些子类公用的方法,它是字符输入流最顶级的父类 int read() 读一个字符并返回 int read(char[] cbuf) 将字符读入数组 用来一次读取多个字符，返回读取的字符个数。 void close() 关闭流并释放与之相关联的任何系统资源。 java.io.FileReader extends InputStreamReader extends Reader ​ FileReader:文件字符输入流 ​ 作用：把硬盘文件中的数据以字符的方式读取到内存中 构造方法： ​ 1.FileReader(String fileName) 创建一个新的 FileReader ，给定要读取的文件的名称。 ​ 2.FileReader(File file) 创建一个新的 FileReader ，给出 File读取。 作用：创建一个FileReader对象 ​ 会把FileReader对象指向要读取的文件 ​ 参数：String fileName和File file是数据来源 #### 读取字符数据（以及编码问题） 一次读取一个字节 int read() 读一个字符并返回 每次只读取一个字符无论是中文还是英文还是数字 public static void main(String []args) throws IOException &#123; FileReader fis=new FileReader(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;); int len=0; while((len=fis.read())!=-1) &#123; System.out.println((char)len); &#125; fis.close(); &#125; 这里出现了一点小插曲，因为我的电脑记事本默认是UTF-8编码，但eclipse默认编码是GBK所以会出现错误 我把电脑记事本编码转换为ASNI也就是默认是windows中文默认的GBK编码然后就可以实现了 int read(char[] cbuf) 将字符读入数组 用来一次读取多个字符，返回读取的字符个数。 12345678910111213public static void main(String []args) throws IOException &#123; FileReader fis=new FileReader(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;); char[] cs=new char[1024];//存储读取到的多个字符 int len=0; while((len=fis.read(cs))!=-1) &#123; System.out.println(new String(cs)); System.out.println(new String(cs,0,len));//0是开始的索引，len是转换的个数 &#125; fis.close();&#125;读取文件的结果 123你好 123你好 字符输出流Writer类和FileWriter类的介绍 Writer是字符输出流最顶层的父类 定义了一些共性的方法 void write(String str) 写一个字符串 void write(String str, int off, int len) 写一个字符串的一部分。 void write(int c) 写一个字符 void flush() 刷新流 子类：FileWriter java.io.FileWriter extends OutputStreamWriter extends Writer FileWriter:文件字符输出流 作用：把内存中的字符数据写入到文件中 构造方法： ​ FileWriter(File file) 给一个File对象构造一个FileWriter对象。 ​ FileWriter(String fileName) 构造一个给定文件名的FileWriter对象。 ​ 参数：写入数据的目的地 ​ String fileName：文件的路径 ​ File file：是一个文件 ​ 构造方法的作用： ​ 1.会创建一个FileWriter的对象 ​ 2.会根据构造方法中传递的文件&#x2F;文件的路径，创建文件 ​ 3.会把FileWriter对象指向创建好的文件 写出单个字符到文件 字符输出流的使用步骤： ​ 1.创建FileWriter对象，构造方法中绑定要写入数据的目的地 ​ 2.使用FileWriter中的方法write，把数据写到内存缓冲区中（字符转换字节的过程） ​ 3.使用FileWriter中的方法flush，把内存缓冲区中的数据，刷新到文件中 ​ 4.释放资源（会先把内存缓冲区的数据刷新到文件中）所以其实不用flush 如果没有调用flush或者close方法那么文件中将不会写入内容，因为write方法是把数据写到内存缓冲区 123456789public static void main(String []args) throws IOException &#123; //1.创建FileWriter对象，构造方法中绑定要写入数据的目的地 FileWriter fw=new FileWriter(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;); // 2.使用FileWriter中的方法write，把数据写到内存缓冲区中（字符转换字节的过程） fw.write(97); //3 3.使用FileWriter中的方法flush，把内存缓冲区中的数据，刷新到文件中 fw.flush(); fw.close();&#125; flush方法和close方法的区别 flush：刷新缓冲区，流对象可以继续使用 close：先刷新缓冲区，然后通知系统释放资源，流对象不可以再被使用了 字符输出流写数据的其他方法 void write(char []cbuf)写入字符数组 123456 public static void main(String []args) throws IOException &#123;FileWriter fw=new FileWriter(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);char []cs= &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;&#125;;fw.write(cs);fw.close(); &#125; void write(char []cbuf,int off,int len) 123456 public static void main(String []args) throws IOException &#123;FileWriter fw=new FileWriter(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);char []cs= &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;&#125;;fw.write(cs,0,2);//从下标为零开始，读取两个字符fw.close(); &#125; void write(String str)写入字符串 123456 public static void main(String []args) throws IOException &#123;FileWriter fw=new FileWriter(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);String a=&quot;你好&quot;;fw.write(a);fw.close(); &#125; void write(String str,int off,int len) 123456 public static void main(String []args) throws IOException &#123;FileWriter fw=new FileWriter(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);String a=&quot;你好我是java程序员&quot;;fw.write(a,0,4);//从下标为零然后读取四个字符fw.close(); &#125; 字符输出流写数据的续写和换行 续写： ​ 下面是追加写,续写 FileWriter(String name, boolean append)创建文件输出流以指定的名称写入文件。 FileWriter(File file, boolean append)创建文件输出流以写入由指定的 File对象表示的文件。 ​ 参数： ​ String name File file：写入数据的目的地 ​ boolean append ：追加写开关 true ：创建对象不会覆盖源文件，继续在文件的末尾追加写数据 ​ false：创建一个新文件，覆盖原文件，在新文件中重新写数据 换行：换行符号 ​ windows：\\r\\n ​ Linux:&#x2F;n ​ mac:&#x2F;r 123456789101112131415161718FileWriter fw=new FileWriter(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;,true);for(int i=0;i&lt;10;i++) &#123; fw.write(&quot;HelloWorld&quot;+i+&quot;\\r\\n&quot;);&#125;fw.close(); &#125;文件内容： 你好我是HelloWorld0HelloWorld1HelloWorld2HelloWorld3HelloWorld4HelloWorld5HelloWorld6HelloWorld7HelloWorld8HelloWorld9 IO异常的处理fw.close要放在finally中因为程序无论是否报错都得有这个流的关闭 同时fw.close也有异常，所以在fianally里要嵌套一个trycatch 12345678910111213141516171819202122232425262728public static void main(String []args) &#123; //提高变量fw的作用域，让finally可以使用 //变量在定义的时候可以没有值，但是使用的时候必须有值 //如果下面new执行失败了，则fw没有值，fw.close()会报错，所以 FileWriter fw=null; try &#123; //可能会产出异常的代码 fw=new FileWriter(&quot;w:\\\\放乱七八糟\\\\File.txt&quot;,true);for(int i=0;i&lt;10;i++) &#123; fw.write(&quot;HelloWorld&quot;+i+&quot;\\r\\n&quot;);&#125; &#125; catch(IOException e) &#123; System.out.println(e); &#125; finally &#123; //一定会指定的代码 //创建对象失败了，fw的默认值就是null，null是不能调用方法的，会抛出NullPointerException，需要增加一个判断，不是null再把资源释放 if(fw!=null)&#123;try &#123; //fw.close方法声明抛出了IOException异常对象，所以我们就处理这个异常对象，要么throws要么trycatch fw.close();&#125; catch (IOException e) &#123; e.printStackTrace();&#125;&#125; &#125;&#125; JDK7新特性 在try的后面可以增加一个()，在括号中可以定义流对象 那么这个流对象的作用域就在try中有效，就不用自己关闭流了 try中代码执行完毕，会自动把流对象释放，不再写finally try(定义流对象;定义流对象…){ &#x2F;&#x2F;可能会产生异常的代码 } catch(异常类变量 变量名){ 异常处理的逻辑 } 123456789//try括号中的这个流只在try中有效，就不用自己关闭流了 try (FileWriter fw=new FileWriter(&quot;d:\\\\放乱七八糟\\\\File.txt&quot;,true);)&#123;for(int i=0;i&lt;10;i++) &#123; fw.write(&quot;HelloWorld&quot;+i+&quot;\\r\\n&quot;);&#125; &#125; catch(IOException e) &#123; System.out.println(e); &#125; 缓冲流缓冲流都是在基本的流对象基础之上创建来的，就像穿上铠甲的武士一样，相当于是对基本流对象的一种增强 概述： 缓冲流也叫做高效流，是对四个基本的FileXxx流的增强，所以也是四个流，按照数据类型分类： 字节缓冲流：BufferedInputStream，BufferedOutputStream 字符缓冲流：BufferedReader，BufferedWriter 缓冲流的基本原理是在创建流对象的时候，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写效率 就是返回文件内容的时候，不是一个一个返回，是把所有的都整到一个缓冲区里然后全部一起以一个数组的形式返回 字节缓冲输出流java.io.BufferedOutputStream extends OutputStream 继承的父类的共性方法 OutputStream有的方法它都有 构造方法 BufferedOutputStream(OutputStream out) 创建一个新的缓冲输出流，以将数据写入指定的底层输出流 BufferedOutputStream(OutputStream out, int size) 创建一个新的缓冲输出流，以便以指定的缓冲区大小将数据写入指定的底层输出流。 参数：OutputStream 就是一个字节输出流 我们可以传递FileOutputStream，缓冲流会给FileOutputStream增加一个缓冲区，提高FileOutputStream的的写入效率 int size：指定缓冲流内部缓冲区的大小，不指定就是默认的大小 使用步骤： ​ 1.创建FileOutputStream对象，构造方法中绑定要输出的目的地 ​ 2.创建BufferedOutputStream对象，构造方法中传递FileOutputStream对象，提高FileOutputStream对象效率 ​ 3.使用BufferedOutputStream对象中的方法write，把数据写入到内部缓冲区中 ​ 4.使用BufferedOutputStream对象中方法flush，吧内部缓冲区的数据刷新到文件中 ​ 5.释放资源（会先调用flush方法刷新数据，所以第四步可以省略） 12345678910111213141516class Main&#123;public static void main(String []args) throws IOException &#123; // 1.创建FileOutputStream对象，构造方法中绑定要输出的目的地 FileOutputStream fos= new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;); //2.创建BufferedOutputStream对象，构造方法中传递FileOutputStream对象，提高FileOutputStream对象效率 BufferedOutputStream bos=new BufferedOutputStream(fos); //3.使用BufferedOutputStream对象中的方法write，把数据写入到内部缓冲区中 bos.write(&quot;我把数据写入到内部缓冲区中&quot;.getBytes()); //4.使用BufferedOutputStream对象中方法flush，吧内部缓冲区的数据刷新到文件中 bos.flush(); //5.释放资源（会先调用flush方法刷新数据，所以第四步可以省略） bos.close();&#125;&#125; 字节缓冲输入流java.io.BufferedInputStream extends InputStream BufferedInputStream:字节缓冲输入流 所有InputStream有的方法他都有 构造方法 BufferedInputStream(InputStream in) 创建一个 BufferedInputStream并保存其参数，输入流 in ，供以后使用。 BufferedInputStream(InputStream in, int size) 创建 BufferedInputStream具有指定缓冲区大小，并保存其参数，输入流 in ，供以后使用 参数; ​ InputStream in:字节输入流 ​ 我们可以传递FileInputStream，缓冲区会给FileInputStream增加一个缓冲区，提高FileInputStream的读取效率 使用步骤： ​ 1.创建一个FileInputStream对象，构造方法中绑定要读取的数据源 ​ 2.创建BufferedInputStream对象，构造方法中传递FileInputStream对象，提高FileInputStream对象的读取效率 ​ 3.使用BufferedInputStream对象中的方法read()，读取文件 ​ 4.释放资源 123456789101112public static void main(String []args) throws IOException &#123; //1.创建一个FileInputStream对象，构造方法中绑定要读取的数据源 FileInputStream fis=new FileInputStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;); //2.创建BufferedInputStream对象，构造方法中传递FileInputStream对象，提高FileInputStream对象的读取效率 BufferedInputStream bis=new BufferedInputStream(fis); // 3.使用BufferedInputStream对象中的方法read()，读取文件 int len=0;//记录每次读取到的字节 while((len=bis.read())!=-1) &#123; System.out.println(len); &#125; bis.close();&#125; 12345678910111213public static void main(String []args) throws IOException &#123; //1.创建一个FileInputStream对象，构造方法中绑定要读取的数据源 FileInputStream fis=new FileInputStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;); //2.创建BufferedInputStream对象，构造方法中传递FileInputStream对象，提高FileInputStream对象的读取效率 BufferedInputStream bis=new BufferedInputStream(fis); // 3.使用BufferedInputStream对象中的方法read()，读取文件 int len=0;//记录每次读取的有效字节个数 byte[] bytes=new byte[1024]; while((len=bis.read(bytes))!=-1) &#123;//最后这个-1是不会返回给len的 System.out.println(new String(bytes,0,len)); &#125; bis.close();&#125; 用缓冲流来复制文件速度变得更快，可见效率变得更高 123456789101112131415161718public static void main(String []args) throws IOException &#123; long end =System.currentTimeMillis(); FileInputStream fis=new FileInputStream(&quot;C:\\\\Users\\\\#赵梓皓&amp;\\\\Pictures\\\\Default.jpg&quot;); BufferedInputStream bis=new BufferedInputStream(fis); FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.jpg&quot;); BufferedOutputStream bos=new BufferedOutputStream(fos); int len=0; while((len=bis.read())!=-1) &#123; bos.write(len); &#125; bos.close(); bis.close(); long end1=System.currentTimeMillis(); System.out.println(&quot;耗时&quot;+(end1-end)+&quot;毫秒&quot;);&#125;耗时42毫秒 123456789101112131415161718public static void main(String []args) throws IOException &#123; long end =System.currentTimeMillis(); FileInputStream fis=new FileInputStream(&quot;C:\\\\Users\\\\#赵梓皓&amp;\\\\Pictures\\\\Default.jpg&quot;); BufferedInputStream bis=new BufferedInputStream(fis); FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.jpg&quot;); BufferedOutputStream bos=new BufferedOutputStream(fos); int len=0; byte []bytes=new byte[1024]; while((len=bis.read(bytes))!=-1) &#123; bos.write(bytes,0,len); &#125; bos.close(); bis.close(); long end1=System.currentTimeMillis(); System.out.println(&quot;耗时&quot;+(end1-end)+&quot;毫秒&quot;);&#125;耗时4毫秒 字符缓冲输出流 &#96;&#96;&#96;public class BufferedWriterextends Writer123456789101112131415161718192021222324252627282930313233343536有继承自父类的共性成员方法，所有Writer的方法他都有构造方法- - `BufferedWriter(Writer out)` 创建使用默认大小的输出缓冲区的缓冲字符输出流- - `BufferedWriter(Writer out, int sz)` 创建一个新的缓冲字符输出流，使用给定大小的输出缓冲区参数：​ 第一个参数是一个字符输出流​ 我们可以传递FileWriter，缓冲流会给FileWriter增加一个缓冲区，提高FileWriter的写入效率​ 第二个参数 int sz：指定缓冲区的大小，不写是默认大小特有的成员方法- - `void newLine()` 写一行行分隔符。方法和上面的都一样，便不再注释```javapublic static void main(String []args) throws IOException &#123; FileWriter fw=new FileWriter(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);BufferedWriter bw=new BufferedWriter(fw);for(int i=0;i&lt;10;i++) &#123; bw.write(&quot;你好&quot;); bw.newLine();//用来进行换行&#125;bw.flush();bw.close();&#125; BufferedReader字符缓冲输入流 Java.io.BufferedReader extends Reader 继承自父类的共性成员方法 构造方法 BufferedReader(Reader in) 创建使用默认大小的输入缓冲区的缓冲字符输入流。 BufferedReader(Reader in, int sz) 创建使用指定大小的输入缓冲区的缓冲字符输入流 参数： 字符输入流 ​ 我们可以传递FileReader，缓冲流会给FileReader增加一个缓冲区，提高FileReader的读取效率 特有的成员方法 String readLine() 读一行文字。 ​ 行的终止符浩：通过下列字符之一即可认为某行已经终止：换行(‘\\n’),回车(‘\\r’),或回车后直接跟着换行(\\r\\n) ​ 返回值： ​ 包含该行内容的字符串，不包含任何终止符，如果已经达到里流末尾，返回null 1234567891011public static void main(String []args) throws IOException &#123;FileReader fr=new FileReader(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);BufferedReader br=new BufferedReader(fr);String line;while((line=br.readLine())!=null) &#123; System.out.println(line);&#125;br.close();&#125;结果:可以输出所有行 练习：文本排序（以及转义）12345678910111213141516171819202122232425262728class Main&#123;public static void main(String []args) throws IOException &#123; HashMap&lt;String,String&gt; hm=new HashMap&lt;String,String&gt;();FileReader fr=new FileReader(&quot;D:\\\\放乱七八糟\\\\File1.txt&quot;);FileWriter fw=new FileWriter(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);BufferedWriter bw=new BufferedWriter(fw);BufferedReader br=new BufferedReader(fr);String line;while((line=br.readLine())!=null) &#123; String []str=line.split(&quot;\\\\.&quot;);//split用的是正则表达式.有特殊含义，所以用\\转义，而java中\\\\才是\\ // \\t,\\n等有特殊含义所以java中字符串如果出现\\会有歧义，所以用\\\\来吧\\替换为一个普通字符，这个普通字符进了正则表达式中又可以把.转义，所以在java中使用正则表达式匹配“\\”时就需要写成&quot;\\\\\\\\&quot; //把切割好的序号和文本内容储存到HashMap集合中(key序号是有序的，会自动排序1，2，3，4) hm.put(str[0], str[1]);&#125;for(String b:hm.keySet()) &#123; String value=hm.get(b); line=b+&quot;.&quot;+value; bw.write(line); bw.newLine();&#125;bw.close();br.close();&#125;&#125; 文件原内容 12341.我是2.我才不是4.我真的不是3.你不是 文件变更以后 12341.我是2.我才不是3.你不是4.我真的不是 插曲：我读取内容的文件是utf-8形式的，写入的文件是以gbk打开，所以出现乱码我把utf-8改为gbk就好了 转换流字符编码： 计算机中储存的信息都是用二进制表示的，而我们在屏幕上看到的数字英文标点符号汉字等字符是二进制转换之后的结果 按照某种规则，将字符储存到计算机中，成为编码，反之，将存储在计算机中的二进制数按照某种规则解析出来称为解码，比如说按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号，反之，按照A规则存储，按照B规则解析，就会出现乱码 编码：字符–》字节 解码：字节–》字符 字符编码：就是一套自然语言的字符与二进制数之间的对应规则。 编码表：生活中文字和计算机中二进制的对应规则 字符集： Ascii码字符集–》Ascii码编码 GBK字符集–》GBK编码 Unicode字符集–》UTF8编码，UTF16编码，UTF32编码 转换流原理输入转换原理 用InputStreamReader FileReader底层还是FileInputStream将字节转换为字符时只能用IDE默认编码 而InputStreamReader可以指定字节转换为字符的编码形式 输出转换原理 用OutputStreamWriter FileWriter的底层实现还是FileOutputStream，只能将字符转换为IDE默认的编码的字节 如果用OutputStreamWriter 可以指定字符转字节的时候的编码格式 编码引出的问题FileReader读取文件 就是FileReader能读取编译器默认编码的文件，比如eclipse时GBK，IDEA是UTF-8 下面演示在eclipse用FileReader读取UTF-8 OutputStreamWriter OutputStreamWriter是字符的桥梁流以字节流：向其写入的字符编码成使用指定的字节charset 。 它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集。 java.io.BufferedWriter extends Writer Writer中的方法都可以使用 构造方法： OutputStreamWriter(OutputStream out) 创建一个使用默认字符编码的OutputStreamWriter OutputStreamWriter(OutputStream out, String charsetName) 创建一个使用命名字符集的OutputStreamWriter。 参数：OutputStream out：字节输出流，可以用来写转换之后的字节到文件中 ​ String charsetName：指定的编码表的名称，不区分大小写，可以使utf-8&#x2F;UTF-8&#x2F;GBK&#x2F; public static void main(String []args) throws IOException &#123; //创建OutputStreamWriter对象，构造方法中传递字节输出流的指定的编码表名称 OutputStreamWriter osw=new OutputStreamWriter(new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;),&quot;UTF-8&quot;); //使用OutputStreamWriter对象中的方法write，把字符转换为字节存储缓冲区中（编码） osw.write(&quot;你好&quot;); //使用OutputStreamWriter对象中的flush，把内存缓冲区中的字节刷新到文件中（使用字节流写字节） osw.flush(); //释放内存 osw.close(); &#125; 将你好写入了UTF-8编码显示的文件 InputStreamReaderjava.io.InputStreamReader extends Reader InputStreamReader是从字节流到字符流的桥：它读取字节，并使用指定的charset将其解码为字符 。 它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集。 它由继承字父类的共性的成员方法 ​ Reader有的方法它都有 构造方法： ​ InputStreamReader(InputStream in) 创建一个使用默认字符集的InputStreamReader ​ InputStreamReader(InputStream in, String charsetName) 创建一个使用命名字符集的InputStreamReader ​ 参数： ​ InputStream in：字节输入流，用来读取文件中保存的字节 ​ String charsetName：字符表名称 public static void main(String []args) throws IOException &#123; //创建InputStreamWriter对象，构造方法中传递字节输入流和指定的编码表名称 InputStreamReader osw=new InputStreamReader(new FileInputStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;),&quot;UTF-8&quot;); //使用InputStreamWriter对象中的方法read()，把字符转换为字节存储缓冲区中（编码） int len=0; while((len=osw.read())!=-1) &#123; System.out.println((char)len); &#125; //释放内存 osw.close(); &#125; 即是文件内容是UTF-8，也可以给他读入到内存中 结果：你 好 转换文件编码的练习 1234567891011public static void main(String []args) throws IOException &#123; InputStreamReader isr=new InputStreamReader(new FileInputStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;),&quot;UTF-8&quot;); OutputStreamWriter osw=new OutputStreamWriter(new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\File1.txt&quot;),&quot;GBK&quot;); int len=0; while((len=isr.read())!=-1) &#123; osw.write(len); &#125; osw.close(); isr.close();&#125;将UTF-8的文件转换为GBK编码的文件 序列化ObjectOutputStream extends OutputStream ObjectOutputStream：对象的序列化流 作用：把对象以流的形式写入到文件中保存 构造方法： ​ ObjectOutputStream(OutputStream out) 创建一个写入指定的OutputStream的ObjectOutputStream。 ​ 参数： ​ 床第一个字节输出流 特有的成员方法： ​ writeObject(Object obj) 将指定的对象写入ObjectOutputStream。 使用步骤; ​ 1.创建ObjectOutputStream对象，构造方法中传递字节输出流 ​ 2.使用ObjectOutputStream对象中的writeObject，把对象写入到文件中 ​ 3.释放资源 类只有实现了Serializable接口才能被序列化或者反序列化 1234567891011121314151617181920212223242526272829class Test implements Serializable&#123;private String name;public String getName() &#123; return name;&#125;public void setName(String name) &#123; this.name = name;&#125;public int getAge() &#123; return age;&#125;public void setAge(int age) &#123; this.age = age;&#125;private int age;public Test() &#123; &#125;public Test(String name,int age) &#123; this.name=name; this.age=age;&#125;&#125;文件内容以二进制字节来存储所以无法直接打开看 1234567 public static void main(String []args) throws IOException, ClassNotFoundException &#123;ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;));oos.writeObject(new Test(&quot;小美女&quot;,18));oos.close(); &#125; ObjectInputStream extends InputStream ObjectInputStream :对象的反序列化流 作用：把文件中保存的对象以流的形式读取出来使用过 构造方法: ​ ObjectInputStream(InputStream in) 创建从指定的InputStream读取的ObjectInputStream ​ 参数：传入一个字节输入流 特有的成员方法： ​ readObject() 从ObjectInputStream读取一个对象。 使用步骤： 1.创建ObjectInputStream对象，构造方法中传递字节输入流 2.使用ObjectInputStream对象中的方法readObject读取保存对象的文件 3.释放资源 4.使用读取出来的对象（打印） readObject方法声明抛出了ClassNotFoundException（Class文件找不到异常）当不存在对象的class文件时抛出此异常 反序列化的前提： ​ 1.类必须实现Serializable接口 ​ 2.必须存在类对应的class文件 1234567891011public static void main(String []args) throws IOException, ClassNotFoundException &#123; //1.创建ObjectInputStream对象，构造方法中传递字节输入流 ObjectInputStream ois=new ObjectInputStream(new FileInputStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;)); //2.使用ObjectInputStream对象中的方法readObject读取保存对象的文件 Object o=ois.readObject();//这里必须使用Object类型来接受 ois.close(); //4.使用读取出来的对象（打印） System.out.println(o); Test t=(Test)o; System.out.println(t.getName()+t.getAge());&#125; transient关键字 static关键字:静态关键字 1.静态优先于非静态加载到内存中（静态优先于对象进入到内存中） 被static修饰的成员变量不能被序列化的，序列化的都是对象 private static int age oos.writeObject(new Person(“小美女”,18)); Object o&#x3D;ois.readObject(); Person{name&#x3D;”小美女”,age&#x3D;0} 所以静态的不能够被序列化 transient关键字：瞬态关键字 ​ 被transient修饰的成员变量，不能被序列化 它的功能就是不让某个属性序列化，但是又没有静态的含义 InvalidClassException异常当分别一次序列化和反序列化之后是正常的，但现在你去改了那个序列化的类属性，然后没有对他序列化而是直接反序列化 就会报InvalidClassException 就是当你改动了类之后你txt文件中的类的id和你class文件中的id不同就导致不能够反序列化成功 所以就在类中加一个private static final long serialVersionUID&#x3D;1L; 这样无论怎么改id都不会变了 练习：序列化集合练习：序列化集合 ​ 当我们想在文件中保存多个对象的时候 ​ 可以把多个对象储存到一个集合中 ​ 对集合进行序列化和反序列化 分析： ​ 1.定义一个存储Person对象的集合和ArrayList集合 ​ 2.往ArrayList集合中存储Person对象 ​ 3.创建一个序列化流ObjectOutputStream ​ 4.使用ObjectOutputStream对象中的方法writeObject，对集合进行序列化 ​ 5.创建一个反序列化ObjectInputStream对象 ​ 6.使用ObjectInput中的方法readObject读取文件中保存的集合 ​ 7.把Object类型的集合转换为ArrayList类型 ​ 8，遍历这个ArrayList集合 ​ 9.释放资源 public static void main(String []args) throws IOException, ClassNotFoundException &#123; // 1.定义一个存储Person对象的集合和ArrayList集合 ArrayList&lt;Test&gt; list=new ArrayList&lt;Test&gt;(); // 2.往ArrayList集合中存储Person对象 list.add(new Test(&quot;张三&quot;,18)); list.add(new Test(&quot;例四&quot;,18)); list.add(new Test(&quot;赵武&quot;,18)); //3.创建一个序列化流ObjectOutputStream ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;)); //4.使用ObjectOutputStream对象中的方法writeObject，对集合进行序列化 oos.writeObject(list); // 5.创建一个反序列化ObjectInputStream对象 ObjectInputStream ois=new ObjectInputStream(new FileInputStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;)); // 6.使用ObjectInput中的方法readObject读取文件中保存的集合 Object o=ois.readObject(); //7.把Object类型的集合转换为ArrayList类型 ArrayList&lt;Test&gt; list2=(ArrayList&lt;Test&gt;)o; //8，遍历这个ArrayList集合 for(Test p:list2) &#123; System.out.println(p); &#125; // 9.释放资源 ois.close(); oos.close(); &#125; 打印流重定向标准输入输出java.io.PrintStream ​ PrintStream为另一个输出流添加了功能，即能够方便地打印各种数据值的表示。 PrintStream特带你： ​ 1.只负责数据的输出，不负责数据的读取 ​ 2.与其他输出流不同，PrintStream永远不会抛出IOException ​ 3.有特有的方法，print，println方法 ​ void print(任意类型的值) ​ void println(任意类型的值并换行) 构造方法： ​ PrintStream(File file) 输出的目的地是一个文件 ​ PrintStream(OutputStream out) 输出的目的地是一个字节输出流 ​ PrintStream(String fileName) 输出的目的地是一个文件路径 printStream extends OutputStream 继承自父类的成员方法 注意： ​ 如果使用继承自父类的write方法那么查看数据的时候会查询编码表 ​ 如果是用自己特有的方法print&#x2F;println方法写数据，写的数据原样输出 123456789101112131415161718192021222324```java用父类的方法会查询编码表 public static void main(String []args) throws IOException, ClassNotFoundException &#123;PrintStream ps=new PrintStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);ps.write(97);ps.close(); &#125;文件：文件的内容是a```用自己的方法是原样输出 public static void main(String []args) throws IOException, ClassNotFoundException &#123;PrintStream ps=new PrintStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);ps.println(&quot;a&quot;);ps.println(97);ps.println(100);ps.println(&quot;我是&quot;);ps.close(); &#125; 文件内容是：a 97 100 我是 可以改变输出语句的目的地（打印流的流向） 输出语句：默认在控制台输出 使用System.setOut放法改变输出语句的目的为参数传递的打印流的目的地 ​ static void setOut(printStream out) ​ 重新分配”标准”输出流 下面这个是将System.out的输出重定向到文件输出而不是在屏幕上输出 12345678 public static void main(String []args) throws IOException, ClassNotFoundException &#123; System.out.println(&quot;我在控制台输出&quot;);PrintStream ps=new PrintStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);System.setOut(ps);//把输出语句的目的地改变为打印流的目的地System.out.println(&quot;我在打印流的目的地中输出&quot;);&#125; 改变这个输出语句在流里输出 使用System的setIn()方法将系统标准输入重定向到该文件输入流，不会等待用户输入而是直接输出了文件的内容 java的多线程详解概念多线程案例：一起开黑打王者荣耀，你给我发消息的时候我也能给你发消息 多线程： 可以实现一个并发操作，在一个程序中可以定义多个线程并同时运行它们，每个线程可以执行不同的任务。 进程（Process）：在操作系统中运行的程序就是进程，比如你的qq播放器游戏IDE 进程则是执行程序的一次执行过程，它是一个动态的概念，是系统资源分配的单位 线程(Thread)：一个进程可以有多个线程，如视频中同时听声音，看图像，看弹幕等等 进程可以包含多个线程，一个进程至少有一个Main线程，不然没有存在的意义 多线程和多任务的区别：多任务是针对操作系统而言的，代表操作系统可以同时执行的程序个数；多线程是针对一个程序而言的，代表一个程序可以同时执行的线程的个数，每个线程完成不同的任务。 在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器(cpu)是与操作系统紧密相关的，先后顺序是不能人为干预的 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制（10000个人抢100张票必定有人抢不到） 继承Thread类 创建一个新的执行线程有两种方法。 一个是将一个类声明为Thread的子类。 这个子类应该重写run类的方法Thread 。 创建线程对象，调用start()方法启动线程 12345678910111213141516171819202122public class Hello extends Thread&#123; @Overridepublic void run() &#123; //run方法线程体 for(int i=0;i&lt;20;i++) &#123; System.out.println(&quot;我在看书&quot;); &#125;&#125; public static void main(String []args) &#123; //main线程主线程 //创建一个线程对象 Hello testThread=new Hello(); //调用start()方法开启线程 testThread.start(); for(int i=0;i&lt;20;i++) &#123; System.out.println(&quot;我在学习&quot;); &#125; &#125; &#125;用start方法是开了一条新线程，两条线程同时执行（线程不一定立即执行,cpu调度安排），如果是调用run方法则就是先执行run方法再回到主线程执行 注意：县城开启不一定立即执行，由cpu调度执行 网图下载 建立多个TestThread2对象，开辟多个线程，同时执行 实现Runnable接口定义MyRunnable类实现Runnable接口 实现run()方法，编写线程执行体 创建线程对象，调用start()方法启动线程 1234567891011121314151617@Override public void run() &#123; //run方法线程体 for(int i=0;i&lt;20;i++) &#123; System.out.println(&quot;我在看书&quot;); &#125; &#125; public static void main(String []args) &#123; //创建一个runnable接口的实现类对象 Hello testThread3=new Hello(); //创建线程对象，通过线程对象来开启我们的线程，代理 Thread thread=new Thread(testThread3); thread.start(); for(int i=0;i&lt;20;i++) &#123; System.out.println(&quot;我在学习&quot;); &#125; &#125; 小结 初始并发问题 &#x2F;&#x2F;多个线程同时操作同一个对象 &#x2F;&#x2F;买火车票的例子 &#x2F;&#x2F;返现问题：多个线程操作同一个资源的情况下，线程不安全，数据紊乱，就是小明老师黄牛党都拿到了第十张票， 12345678910111213141516171819202122232425262728public class Hello implements Runnable&#123; private int ticketNums=10; public void run() &#123; while(true) &#123; if(ticketNums&lt;=0) &#123; break; &#125; try &#123; Thread.sleep(200);//模拟延时,是当前线程进入休息状态 &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;--&gt;拿到了第&quot;+ticketNums--+&quot;票&quot;); &#125; &#125;public static void main(String []args) &#123; Hello ticket=new Hello(); //Thread后面的第二个参数是这个线程的名字 new Thread(ticket,&quot;小明&quot;).start(); new Thread(ticket,&quot;老师&quot;).start(); new Thread(ticket,&quot;黄牛党&quot;).start(); &#125;&#125; 龟兔赛跑相当于乌龟和兔子是两条线程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package hello;public class Hello implements Runnable&#123; private String winner;public void run() &#123; for(int i=0;i&lt;=100;i++) &#123; //模拟兔子休息 if(Thread.currentThread().getName().equals(&quot;兔子&quot;)&amp;&amp;i%10==0) &#123; try &#123; Thread.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //判断比赛是否结束 boolean flag=gameOver(i); //如果比赛结束了，就停止程序 if(flag) &#123; break; &#125; System.out.println(Thread.currentThread().getName()+&quot;--&gt;跑了&quot;+i+&quot;步&quot;); &#125;&#125;private boolean gameOver(int step) &#123; //判断是否存在胜利者 if(winner!=null) &#123; return true; &#125; else &#123; if(step&gt;=100) &#123; winner=Thread.currentThread().getName(); System.out.println(&quot;winner is&quot;+winner); return true; &#125; &#125; return false; &#125;public static void main(String []args) &#123; Hello race=new Hello(); new Thread(race,&quot;兔子&quot;).start(); new Thread(race,&quot;乌龟&quot;).start();&#125;&#125; 实现Callable接口好处：1.可以定义返回值 2.可以抛出异常 t1就是实现Callable接口的类的实例化对象 要重写call方法，可以自己设定它的返回值和哪个Collable接口的泛型类型一致 静态代理模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package hello;//静态代理模式：//真实对象和代理对象都要实现同一个接口//代理对象要代理真实角色//好处： //代理对象可以做很多真实对象做不了的事情 //真实对象专注做自己的事情public class Hello&#123; public static void main(String []args) &#123; WeddingCompany weddingCompany=new WeddingCompany(new You());//我来、把自己给婚庆公司 weddingCompany.HappyMarry();//婚庆公司代理我结婚，没有通过我直接去调用结婚的方法 &#125;&#125;interface Marry&#123; void HappyMarry();&#125;class You implements Marry&#123; @Override public void HappyMarry() &#123; System.out.println(&quot;我要结婚了&quot;); &#125;&#125;//婚庆公司代理我去结婚，还是我去结婚class WeddingCompany implements Marry&#123; //这个地方是一个真实的结婚的角色 private Marry target; public WeddingCompany(Marry target) &#123; this.target=target; &#125; @Override public void HappyMarry() &#123; before(); this.target.HappyMarry();//这就是真实对象 after(); &#125; private void after() &#123; System.out.println(&quot;结婚之后，收尾款&quot;); &#125; private void before() &#123; System.out.println(&quot;结婚之前，布置现场&quot;); &#125;&#125; 类比到多线程：new Thread(()-&gt;System.out.println(“我爱你”)).start(); Thread类代理Runnable接口那个真实对象 线程状态 new是创建状态 dead是死亡状态 停止线程不推荐使用jdk提供的stop() destroy()方法 推荐线程自己停下来 建议使用一个标志位进行终止变量 当flag&#x3D;false，则终止线程运行 &#x2F;&#x2F;测试stop&#x2F;&#x2F;1.建议线程正常停止—》利用次数，不建议死循环&#x2F;&#x2F;2.建议使用标志位–&gt;设置一个标志位&#x2F;&#x2F;3.不要使用stop或者destroy等果实或者JDK不建议使用的方法 12345678910111213141516171819202122232425262728293031public class Hello implements Runnable&#123; //1设置一个标识位 private boolean flag=true; @Override public void run() &#123; int i=0; while(flag) &#123; System.out.println(&quot;run thread&quot;+i++); &#125; &#125; //2.设置一个公开的方法停止线程 public void stop() &#123; this.flag=false; &#125; public static void main(String []args) &#123; Hello teststop=new Hello(); new Thread(teststop).start(); for(int i=0;i&lt;1000;i++) &#123; System.out.println(&quot;main&quot;+i); if(i==900) &#123; //调用stop方法切换标志位，让线程停止 teststop.stop(); System.out.println(&quot;线程该停止了&quot;); &#125; &#125; &#125;&#125; 线程休眠（sleep）sleep指定当前线程阻塞的毫秒数 sleep存在异常InterruptedException sleep时间达到后线程进入就绪状态 sleep可以模拟网络延迟，倒计时等 每一个对象都有一个锁，sleep不会释放锁 &#x2F;&#x2F;模拟网络延时，放大问题的发生性 12345678910111213141516171819202122232425262728public class Hello implements Runnable&#123; private int ticketNums=10; public void run() &#123; while(true) &#123; if(ticketNums&lt;=0) &#123; break; &#125; try &#123; Thread.sleep(200);//模拟延时,是当前线程进入休息状态 &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;--&gt;拿到了第&quot;+ticketNums--+&quot;票&quot;); &#125; &#125;public static void main(String []args) &#123; Hello ticket=new Hello(); //Thread后面的第二个参数是这个线程的名字 new Thread(ticket,&quot;小明&quot;).start(); new Thread(ticket,&quot;老师&quot;).start(); new Thread(ticket,&quot;黄牛党&quot;).start(); &#125;&#125; 模拟倒计时 12345678910111213141516171819202122public class Hello&#123; public static void tenDown() throws InterruptedException&#123; int num=10; while(true) &#123; Thread.sleep(1000); System.out.println(num--); if(num&lt;=0) &#123; break; &#125; &#125; &#125; public static void main(String []args) &#123; try &#123; tenDown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 获取当前系统时间 1234567891011121314151617public class Hello&#123; public static void main(String []args) &#123; Date startTime=new Date(System.currentTimeMillis()); //获取当前的时间Mon Jul 04 16:40:30 CST 2022 while(true) &#123; try &#123; Thread.sleep(1000); System.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(startTime));//16:40:30 startTime=new Date(System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;&#125; 礼让线程礼让线程(yield)：让当前正在执行的线程暂停，但不阻塞 将线程从运行状态转为就绪状态 让cpu重新调度，礼让不一定成功，看CPU心情 123456789101112131415161718192021222324public class Hello&#123; public static void main(String []args) &#123; Myyield e=new Myyield(); new Thread(e,&quot;a&quot;).start(); new Thread(e,&quot;b&quot;).start();&#125;&#125;class Myyield implements Runnable&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+&quot;线程开始执行&quot;); Thread.yield();//礼让 System.out.println(Thread.currentThread().getName()+&quot;线程停止执行&quot;); &#125;&#125;结果：a线程开始执行 b线程开始执行 a线程停止执行 b线程停止执行 线程强制执行（join）join合并线程，待此线程执行完成之后再执行其他线程，其他线程阻塞 可以想象成插队 123456789101112131415161718192021222324class Hello implements Runnable&#123; @Override public void run() &#123; for(int i=0;i&lt;1000;i++) &#123; System.out.println(&quot;线程vip来了&quot;); &#125; &#125; public static void main(String []args) throws InterruptedException &#123; //启动我们的线程 Hello testjoin=new Hello(); Thread a=new Thread(testjoin); a.start(); //主线程 for(int i=0;i&lt;500;i++) &#123; if(i==200) &#123; a.join();//强制让run方法线程执行完毕再执行主线程 &#125; System.out.println(&quot;main&quot;+i); &#125; &#125;&#125; 观测线程状态 NEW尚未启动的线程处于此状态。 RUNNABLE在Java虚拟机中执行的线程处于此状态。 BLOCKED被阻塞等待监视器锁定的线程处于此状态。 WAITING正在等待另一个线程执行特定动作的线程处于此状态。 TIMED_WAITING正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。 TERMINATED已退出的线程处于此状态 12345678910111213141516171819202122232425262728293031class Hello &#123; public static void main(String []args) throws InterruptedException &#123; Thread thread=new Thread(()-&gt;&#123; for(int i=0;i&lt;5;i++) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; System.out.println(&quot;abc&quot;); &#125;); //观察状态 Thread.State state=thread.getState(); System.out.println(state);//NEW //观察启动后 thread.start(); state=thread.getState(); while(state!=Thread.State.TERMINATED) &#123; Thread.sleep(100); state=thread.getState(); System.out.println(state); &#125; &#125;&#125;死亡之后的线程不能够被重新启动，一个线程不能够启动两次 线程的优先级123456789101112131415161718192021222324252627282930313233343536class Hello &#123; public static void main(String []args) throws InterruptedException &#123; System.out.println(Thread.currentThread().getPriority());//主线程默认优先级 MyPriority myPriority=new MyPriority(); Thread t1=new Thread(myPriority,&quot;1&quot;); Thread t2=new Thread(myPriority,&quot;2&quot;); Thread t3=new Thread(myPriority,&quot;3&quot;); Thread t4=new Thread(myPriority,&quot;4&quot;); Thread t5=new Thread(myPriority,&quot;5&quot;); Thread t6=new Thread(myPriority,&quot;6&quot;); //先设置优先级，再启动 t1.start(); t2.setPriority(1); t2.start(); t3.setPriority(4); t3.start(); t4.setPriority(Thread.MAX_PRIORITY); t4.start(); //设置优先级大于10小于0会报错 /*t5.setPriority(-1); t5.start(); t6.setPriority(11); t6.start();*/ &#125;&#125;class MyPriority implements Runnable&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+&quot;--&gt;&quot;+Thread.currentThread().getPriority()); &#125;&#125; 优先级低只是意味着获得调度的概率低，并不是优先级低就不会被调用了，这都是看cpu的调度 优先级低的执行，优先级高的在等待，这个就会造成性能倒置 守护线程线程分为用户线程（main）和守护线程（gc） 虚拟机必须确保用户线程执行完毕 虚拟机不用等待守护线程执行完毕 如，后台记录操作日志，监控内存，垃圾回收等待 1234567891011121314151617181920212223242526272829class Hello &#123; public static void main(String []args) throws InterruptedException &#123; God god =new God(); You you=new You(); Thread thread =new Thread(god); thread.setDaemon(true);//默认是false表示是用户线程,正常的线程都是用户线程 thread.start();//上帝守护线程启动，这个线程不停止程序也会在用户线程执行完毕时停止,这时守护线程也就停止了 new Thread(you).start();//你 用户线程启动&#125;&#125;class God implements Runnable&#123; public void run() &#123; while(true) &#123; System.out.println(&quot;上帝健康快乐地活着&quot;); &#125; &#125;&#125;class You implements Runnable&#123; public void run() &#123; for(int i=0;i&lt;36000;i++) &#123; System.out.println(&quot;我健康快乐的活着&quot;); &#125; System.out.println(&quot;goodbyeworld&quot;); &#125;&#125; 线程同步多个线程操作同一个资源 并发：同一个对象被多个线程同时操作 保证线程安全要有队列而且要有锁，线程同步需要队列加锁 锁就相当于排队上厕所的时候，你进去把门关上防止后面的人进来，等你解决完了下一个人才能够进来 关键词：synchronized 当一个线程获得对象的排它锁，独占资源，其他线程必须等待 存在问题：1.一个线程持有锁会导致其他所有需要此锁的线程挂起 ​ 2.在多线竞争下，加锁释放锁会导致比较多的上下文切换和调度延时，引起性能问题 ​ 3.如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题 不安全的买票 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.text.SimpleDateFormat;import java.util.Date;//不安全的买票//可能三个人都抢到同一个第十张票//出现负数，就是他们都认为有一张票，当他们买完之后有人拿到的就是负的public class Hello&#123; public static void main(String []args) &#123; buyticket station=new buyticket(); new Thread(station,&quot;小明&quot;).start(); new Thread(station,&quot;小红&quot;).start(); new Thread(station,&quot;小蓝&quot;).start(); &#125;&#125;class buyticket implements Runnable&#123; //票 private int ticketNum=10; boolean flag=true;//外部停止方式 public void run() &#123; //买票 while(flag) &#123; try &#123; buy(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; private void buy() throws InterruptedException &#123; //判断是否有票 if(ticketNum&lt;=0) &#123; flag=false; return; &#125; //模拟延时 Thread.sleep(100); //买票 System.out.println(Thread.currentThread().getName()+&quot;拿到&quot;+ticketNum--); &#125;&#125; 银行取钱不安全 最后钱会变成负数，总共100，你想取50你对象想去100，你俩看到的都是余额100块，所以会造成余额为负数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Hello&#123; public static void main(String []args) &#123; //账户 Account account=new Account(100,&quot;结婚基金&quot;); Drawing you=new Drawing(account,50,&quot;你&quot;); Drawing girl=new Drawing(account,100,&quot;她&quot;);//第三个参数传入的是这个线程的名字 you.start(); girl.start(); &#125;&#125;class Account&#123; int money;//金额 String name;//卡名 Account account;//账户 public Account(int money, String name) &#123; super(); this.money = money; this.name = name; &#125;&#125;//银行：模拟取款class Drawing extends Thread&#123; //取了多少钱 int drawingMoney; //现在手里有多少钱 int nowMoney; Account account ; public Drawing(Account account, int drawingMoney, String name) &#123; super(name);//这个线程的名字 this.account = account; this.drawingMoney = drawingMoney; &#125; public void run() &#123; //判断有没有钱 if(account.money-drawingMoney&lt;0) &#123; System.out.println(Thread.currentThread().getName()+&quot;钱不够取不到&quot;); return; &#125; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //卡内金额=金额-你取的钱 account.money=account.money-drawingMoney; //你手里的钱 nowMoney=nowMoney+drawingMoney; System.out.println(account.name+&quot;余额为:&quot;+account.money); //Thread.currentThread().getName()=this.getName() System.out.println(this.getName()+&quot;手里的钱:&quot;+nowMoney); &#125;&#125; ArrayList集合线程不安全 123456789101112131415161718192021222324252627import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.List;public class Hello&#123; public static void main(String []args) &#123; List&lt;String&gt; lise=new ArrayList&lt;String&gt;(); for(int i=0;i&lt;10000;i++) &#123; new Thread(()-&gt;&#123; lise.add(Thread.currentThread().getName()); &#125;).start(); &#125; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(lise.size()); &#125;&#125;结果：9992 可能会有两个元素同时占同一个坑位 线程同步的修改 使用synchronized修饰那个会出现线程问题的方法 这个买票的例子就是一个对象所以在buy方法前面加一个synchronized就可以 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.text.SimpleDateFormat;import java.util.Date;//不安全的买票//可能三个人都抢到同一个第十张票//出现负数，就是他们都认为有一张票，当他们买完之后有人拿到的就是负的public class Main&#123; public static void main(String []args) &#123; buyticket station=new buyticket(); new Thread(station,&quot;小明&quot;).start(); new Thread(station,&quot;小红&quot;).start(); new Thread(station,&quot;小蓝&quot;).start(); &#125;&#125;class buyticket implements Runnable&#123; //票 private int ticketNum=10; boolean flag=true;//外部停止方式 public void run() &#123; //买票 while(flag) &#123; try &#123; buy(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; //synchronized同步方法，锁的是this，会一个一个进来 private synchronized void buy() throws InterruptedException &#123; //判断是否有票 if(ticketNum&lt;=0) &#123; flag=false; return; &#125; //模拟延时 Thread.sleep(100); //买票 System.out.println(Thread.currentThread().getName()+&quot;拿到&quot;+ticketNum--); &#125;&#125; 下面这个取钱的如果按照上面那个一样在run方法前面加synchronized还是会出现负的余额，因为它是两个对象 这个就要用同步块 synchronized (Obj){} obj称之为同步监视器 同步监视器的执行过程 1.第一个线程访问，锁定同步监视器，执行器中的代码 2.第二个·线程访问，发现同步监视器被锁定，无法继续访问 3.第一个线程访问完毕，解锁同步监视器 4.第二个线程访问，发现同步监视器没有锁，然后锁定并访问 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Main&#123; public static void main(String []args) &#123; //账户 Account account=new Account(100,&quot;结婚基金&quot;); Drawing you=new Drawing(account,50,&quot;你&quot;); Drawing girl=new Drawing(account,100,&quot;她&quot;);//第三个参数传入的是这个线程的名字 you.start(); girl.start(); &#125;&#125;class Account&#123; int money;//金额 String name;//卡名 Account account;//账户 public Account(int money, String name) &#123; super(); this.money = money; this.name = name; &#125;&#125;//银行：模拟取款class Drawing extends Thread&#123; //取了多少钱 int drawingMoney; //现在手里有多少钱 int nowMoney; Account account ; public Drawing(Account account, int drawingMoney, String name) &#123; super(name);//这个线程的名字 this.account = account; this.drawingMoney = drawingMoney; &#125; public void run() &#123; //判断有没有钱 synchronized(account) &#123;//这里面是就是需要排队使用的资源，也就是account对象 if(account.money-drawingMoney&lt;0) &#123; System.out.println(Thread.currentThread().getName()+&quot;钱不够取不到&quot;); return; &#125; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //卡内金额=金额-你取的钱 account.money=account.money-drawingMoney; //你手里的钱 nowMoney=nowMoney+drawingMoney; System.out.println(account.name+&quot;余额为:&quot;+account.money); //Thread.currentThread().getName()=this.getName() System.out.println(this.getName()+&quot;手里的钱:&quot;+nowMoney); &#125; &#125;&#125; 下面这个和上面那个一样，锁住的是lise集合 123456789101112131415161718192021222324252627import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.List;public class Main&#123; public static void main(String []args) &#123; List&lt;String&gt; lise=new ArrayList&lt;String&gt;(); for(int i=0;i&lt;10000;i++) &#123; new Thread(()-&gt;&#123; synchronized(lise) &#123; lise.add(Thread.currentThread().getName()); &#125; &#125;).start(); &#125; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(lise.size()); &#125;&#125; 放在synchronized块里面的是可能会出现问题的代码 一个线程安全的集合1234567891011121314151617181920import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.List;import java.util.concurrent.CopyOnWriteArrayList;public class Main&#123; public static void main(String []args) &#123; CopyOnWriteArrayList&lt;String&gt; list=new CopyOnWriteArrayList&lt;String&gt;(); for(int i=0;i&lt;1000;i++) &#123; new Thread(()-&gt;&#123; list.add(Thread.currentThread().getName()); &#125;).start(); &#125; System.out.println(list.size()); &#125;&#125; 死锁多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形，某一个同步块同时拥有两个以上的锁时，就可能会发生死锁的问题 &#x2F;&#x2F;死锁：多个线程互相抱着对方需要的资源，然后形成僵持 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class Main&#123; public static void main(String []args) &#123; MakeUp g1=new MakeUp(0,&quot;灰姑娘&quot;); MakeUp g2=new MakeUp(1,&quot;白雪公主&quot;); g1.start(); g2.start(); &#125;&#125;//口红class Lipstick&#123; &#125;//镜子class Mirror&#123; &#125;class MakeUp extends Thread&#123; //需要的资源只有一份，用static保证只有一份 static Lipstick lipstick=new Lipstick(); static Mirror mirror=new Mirror(); public MakeUp(int choice,String girlname) &#123; this.choice=choice; this.girlname=girlname; &#125; int choice;//选择 String girlname;//使用化妆品的人 public void run() &#123; try &#123; makeup(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; //化妆，互相持有对方的锁，就是需要拿到对方的资源 private void makeup() throws InterruptedException &#123; if(choice==0) &#123; synchronized(lipstick) &#123; System.out.println(this.girlname+&quot;获得口红的锁&quot;); Thread.sleep(1000); synchronized(mirror) &#123;//一秒钟之后获得镜子 System.out.println(this.girlname+&quot;获得镜子的锁&quot;); &#125; &#125; &#125; else &#123; synchronized(mirror) &#123; System.out.println(this.girlname+&quot;获得镜子的锁&quot;); Thread.sleep(1000); synchronized(lipstick) &#123;//一秒钟之后获得镜子 System.out.println(this.girlname+&quot;获得口红的锁&quot;); &#125; &#125; &#125;​ &#125;&#125;结果： 白雪公主获得镜子的锁灰姑娘获得口红的锁 这样之后他们还想要对方的东西，所以程序就卡死了 解决方法 变成两个锁，不是一个锁在另一个锁里面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.List;import java.util.concurrent.CopyOnWriteArrayList;//死锁：多个线程互相抱着对方需要的资源，然后形成僵持public class Main&#123; public static void main(String []args) &#123; MakeUp g1=new MakeUp(0,&quot;灰姑娘&quot;); MakeUp g2=new MakeUp(1,&quot;白雪公主&quot;); g1.start(); g2.start(); &#125;&#125;//口红class Lipstick&#123; &#125;//镜子class Mirror&#123; &#125;class MakeUp extends Thread&#123; //需要的资源只有一份，用static保证只有一份 static Lipstick lipstick=new Lipstick(); static Mirror mirror=new Mirror(); public MakeUp(int choice,String girlname) &#123; this.choice=choice; this.girlname=girlname; &#125; int choice;//选择 String girlname;//使用化妆品的人 public void run() &#123; try &#123; makeup(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; //化妆，互相持有对方的锁，就是需要拿到对方的资源 private void makeup() throws InterruptedException &#123; if(choice==0) &#123; synchronized(lipstick) &#123; System.out.println(this.girlname+&quot;获得口红的锁&quot;); Thread.sleep(1000); &#125; synchronized(mirror) &#123;//一秒钟之后获得镜子 System.out.println(this.girlname+&quot;获得镜子的锁&quot;); &#125; &#125; else &#123; synchronized(mirror) &#123; System.out.println(this.girlname+&quot;获得镜子的锁&quot;); Thread.sleep(1000); &#125; synchronized(lipstick) &#123;//一秒钟之后获得镜子 System.out.println(this.girlname+&quot;获得口红的锁&quot;); &#125; &#125; &#125;&#125; 产生死锁的条件：1.互斥条件：一个资源每次只能被一个进程使用 2，请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放 3.不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺 4.循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关闭 破坏上面的一个条件就可以避免死锁的发生 Lock锁控制多个线程对共享资源进行访问的工具 ReentrantLock类实现了Lock 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.concurrent.locks.ReentrantLock;public class Main&#123; public static void main(String args[]) &#123; testlock testlock1=new testlock(); new Thread(testlock1,&quot;小蓝&quot;).start(); new Thread(testlock1,&quot;小红&quot;).start(); new Thread(testlock1,&quot;小明&quot;).start(); &#125;&#125;class testlock implements Runnable&#123;private int ticketnums=10;//定义lock锁private final ReentrantLock lock=new ReentrantLock(); @Override public void run() &#123; while(true) &#123; try &#123; lock.lock();//加锁 if(ticketnums&gt;0) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;拿到了第&quot;+ticketnums--+&quot;票&quot;); &#125; else &#123; break; &#125; &#125; finally&#123; //解锁 lock.unlock(); &#125; &#125; &#125; &#125; 加锁和解锁最好是在try和finally里面，而且try中是可能会出现问题的代码 线程协作线程通信：这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件 对于生产者，没有生产产品之前，要通知消费者等待，有了产品之后，马上通知消费者消费 对于消费者，在消费之后，要通知生产者结束消费，需要生产新的产品以供消费 在生产者消费者问题中，仅有synchronized是不够的 ​ synchronized可阻止并发更新同一个共享资源，实现了同步 ​ synchronized不能用来实现不同线程之间的消息传递 通过一个标志来判断什么时候应该等待，什么时候应该唤醒 notifyAll方法是唤醒线程只能唤醒wait等待的线程 wait方法是让该线程等待 管程法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import java.util.concurrent.locks.ReentrantLock;//测试：生产者消费者模型，利用缓冲区来解决：管程法public class Main&#123; public static void main(String []args) &#123; SynContainer container=new SynContainer(); new Productor(container).start(); new Consumer(container).start(); &#125; &#125;//生产者class Productor extends Thread&#123; SynContainer container; public Productor(SynContainer container) &#123; this.container=container; &#125; //生产 public void run() &#123; for(int i=0;i&lt;100;i++) &#123; System.out.println(&quot;生产了&quot;+i+&quot;只鸡&quot;); container.push(new Chicken(i)); &#125; &#125; &#125;//消费者class Consumer extends Thread&#123; SynContainer container; public Consumer(SynContainer container) &#123; this.container=container; &#125; //消费 public void run() &#123; for(int i=0;i&lt;100;i++) &#123; System.out.println(&quot;消费了--&gt;&quot;+container.pop().id+&quot;只鸡&quot;); &#125; &#125;&#125;//产品class Chicken&#123; public int id; public Chicken(int id) &#123; this.id=id; &#125;&#125;//缓冲区class SynContainer&#123; //需要一个容器大小 Chicken[] chickens=new Chicken[10]; //容器计数器 int count=0; //生产者放入产品 public synchronized void push(Chicken chicken) &#123; //如果容器满了就要等待消费者消费 if(count==chickens.length) &#123; //通知生产者消费，生产等待 try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; //如果没有满，我们就需要放入产品 chickens[count]=chicken; count++; //可以通知消费者消费了 this.notifyAll(); &#125; //消费者消费产品 public synchronized Chicken pop() &#123; //判断是否能消费 if(count==0) &#123; //等待生产者生产，消费者等待 try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; //如果可以消费 count--; Chicken chicken=chickens[count]; //吃完了，通知生产者生产 this.notifyAll(); return chicken; &#125; &#125; 信号灯法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.util.concurrent.locks.ReentrantLock;//测试：生产者消费者模型，信号灯法，标志位解决public class Main&#123; public static void main(String []args) &#123; TV tv=new TV(); new Player(tv).start(); new Watcher(tv).start(); &#125;&#125;//生产者-&gt;演员class Player extends Thread&#123; TV tv; public Player(TV tv) &#123; this.tv=tv; &#125; public void run() &#123; for(int i=0;i&lt;20;i++) &#123; if(i%2==0) &#123; this.tv.play(&quot;快乐大本营播放中&quot;); &#125; else &#123; this.tv.play(&quot;抖音:记录美好生活&quot;); &#125; &#125; &#125;&#125;//消费者-&gt;观众class Watcher extends Thread&#123; TV tv; public Watcher(TV tv) &#123; this.tv=tv; &#125; public void run() &#123; for(int i=0;i&lt;20;i++) &#123; this.tv.watch(); &#125; &#125;&#125;//产品-&gt;节目class TV&#123; //演员表演，观众等待 t //观众观看，演员等待 f String voice;//表演的节目 boolean flag=true; //表演 public synchronized void play(String voice) &#123; if(!flag) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; System.out.println(&quot;演员表演了&quot;+voice); //通知观众观看 this.notifyAll();//通知唤醒 this.voice=voice; this.flag=!this.flag; &#125; //观看 public synchronized void watch() &#123; if(flag) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; System.out.println(&quot;观看了&quot;+voice); //通知演员要表演了 this.notifyAll(); this.flag=!this.flag; &#125;&#125; 线程池java反射1.Reflection是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性和方法 2.加载完类之后，在堆内存中的方法区就产生了一个Class类型的对象，这个对象就包含了完整的类的结构信息，我们可以通过这个对象看到类的结构，这个对象就像一个面镜子，透过这个镜子看到类的结构，所以我们形象的称之为，反射 动态语言和静态语言的区别就是动态语言在运行时代码可以根据某些条件改变自身结构 java之所以成为准动态语言是因为有反射机制 正常方式：引入需要的包类名称 —》通过new实例化对象–》取得实例化对象 反射方式：实例化对象–》getClass()方法–》得到完整的包类名称 反射的功能反射的功能 反射相关的API java.lang.Class:代表一个类 java.lang.reflect.Method:代表类的方法 java.lang.reflect.Field:代表类的成员变量 java.lang.reflect.Constructor:代表类的构造器 一个反射的演示Person类 123456789101112131415161718192021222324252627282930313233343536373839404142public class Person &#123; private String name; public int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125;private Person(String name)&#123; this.name=name;&#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; public void show()&#123; System.out.println(&quot;你好，我是一个人&quot;); &#125; private String showNation(String nation)&#123; System.out.println(&quot;我的国籍是&quot;+nation); return nation; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; ReflectionTest 12345678910111213141516171819202122232425262728293031323334353637383940414243import org.junit.Test;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class ReflectionTest &#123; //反射之前，对于Person操作 @Test public void test1()&#123; //创建Person类的对象 Person p1=new Person(&quot;Tom&quot;,12); //通过对象，调用其内部属性方法 p1.age=10; System.out.println(p1.toString()); p1.show(); &#125; //在Person类外部不能通过person对象调用内部私有结构 //比如name。showNation()以及私有的构造器 //反射之后，对于Person的操作，做的是和上面一样的事 @Test public void test2() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException &#123; //获取一个Class类的实例对象 Class clazz=Person.class; //1.通过反射，创建Person类的对象 //获取构造器 Constructor cons=clazz.getConstructor(String.class,int.class); //创建实例 Object obj=cons.newInstance(&quot;Tom&quot;,12); Person p=(Person)obj; System.out.println(p.toString()); //2.通过反射，调用对象的指定属性方法 Field age=clazz.getDeclaredField(&quot;age&quot;); age.set(p,10); System.out.println(p.toString()); //调用空参的show方法 Method show=clazz.getDeclaredMethod(&quot;show&quot;); show.invoke(p); &#125;&#125; 疑问：通过直接new的方式或反射的方式都可以调用公共的结构，开发中到底用哪个 建议：用直接new的方式 疑问：什么时候用反射的方式 反射的特性是动态性，比如在编译的时候你无法确定到底是要实例化哪个类就是要用这种反射的方式 关于Class类理解1.类的加载过程 程序经过javac.exe命令以后，会生成一个或多个字节码文件（.class结尾） 接着我们使用java.exe命令对某个字节码文件进行解释运行，相当于将某个字节码文件加载到内存中，此过程就称为类的加载，加载到内存中的类，我们就称为运行时类，此运行时类，就作为Class的一个实例 2.换句话说，Class的实例就对应的一个运行时类 3.加载到内存中的运行时类，会缓存一定的时间，在此时间之内，我们可以通过不同的方式来获取此运行时类 123456789101112131415161718192021222324//获取大的class实例的方式 @Test public void test3() throws ClassNotFoundException &#123; //方式一 //加上泛型之后就避免了你后面进行强转 Class&lt;Person&gt; clazz1=Person.class; System.out.println(clazz1); //方式二:通过运行时类的对象 Person p1=new Person(); Class clazz2=p1.getClass(); System.out.println(clazz2); //方式三：调用Class的静态方法，forName(String classPath) //这个路径就是看以src为基准，这种文件直接在src下就直接用文件名，如果底下还有包，就要加上包名 Class clazz3=Class.forName(&quot;Person&quot;); System.out.println(clazz3); System.out.println(clazz1==clazz2); System.out.println(clazz2==clazz3); //方式四 ClassLoader classLoader = ReflectionTest.class.getClassLoader(); Class clazz4=classLoader.loadClass(&quot;Person&quot;); System.out.println(clazz1==clazz4); &#125; 其他可以有Class实例的类型 哪些类型可以有Class对象？ （1）class： 外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类 （2）interface：接口 （3）[]：数组 （4）enum：枚举 （5）annotation：注解@interface （6）primitive type：基本数据类型 （7）void 理解类的加载过程 在类的加载过程中就已经执行了静态代码块，构建对象才调用实例代码块和构造方法，且实例代码块比构造方法早 子类加载时，先加载子类的父类，也就是父类的静态代码块先执行再是子类的静态代码块 子类实例化时，先是父类的实例代码块和构造器再是子类的实例代码块和构造器 ClassLoader类加载器作用： 将class文件字节码内容加载到内存中，并将这些静态数据转换成方 法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为 方法区中类数据的访问入口。 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器 中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。 读取文件的时候，把这个Transparent native-to-ascii conversion勾上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import org.junit.Test;import java.io.FileInputStream;import java.io.InputStream;import java.util.Properties;public class ClassLoaderTest &#123; @Test public void test1()&#123; // 1.获取一个系统类加载器 ClassLoader classLoader = ClassLoaderTest.class.getClassLoader(); System.out.println(classLoader); //调用系统类加载器的getParent()：获取扩展类加载器 ClassLoader classLoader1 = classLoader.getParent(); System.out.println(classLoader1); //调用扩展类加载器的getParent()：无法获取引导类加载器 //引导类加载器主要负责加载java的核心类库，无法加载自定义类的。 ClassLoader classLoader2 = classLoader1.getParent(); System.out.println(classLoader2); ClassLoader classLoader3 = String.class.getClassLoader(); System.out.println(classLoader3); &#125; /* Properties 用来读取配置文件 */ @Test public void test2() throws Exception &#123; Properties pros=new Properties(); //读取配置文件的方式一 //此时的文件默认在当前的module下 FileInputStream fis=new FileInputStream(&quot;./jdbc.properties&quot;); //FileInputStream fis=new FileInputStream(&quot;src\\\\jdbc1.properties&quot;); System.out.println(fis); //pros.load(fis); //读取配置文件的方式二，使用ClassLoader ClassLoader classLoader = ClassLoaderTest.class.getClassLoader(); //这个方法直接是映射到src下的文件 //在java中路径字符串中/和\\\\都是一样的 InputStream resource = classLoader.getResourceAsStream(&quot;jdbc1.properties&quot;); pros.load(resource); String user=pros.getProperty(&quot;user&quot;); String password=pros.getProperty(&quot;password&quot;); System.out.println(&quot;user=&quot;+user+&quot;password=&quot;+password); &#125;&#125; java项目中的路径问题123456File file=new File(&quot;/&quot;);System.out.println(file.getAbsolutePath());//D:\\File file1=new File(&quot;.&quot;);System.out.println(file1.getAbsolutePath());D:\\IDEAjava工程\\javaSE\\javareflect\\. &#x2F;代表的是盘符 .代表的是工程目录下的 使用FileInputStream fis&#x3D;new FileInputStream(“jdbc.properties”); 所以这个jdbc.properties也可以是.&#x2F;jdbc.properties 默认就是项目路径下，而不是src路径下，也可以用 全部的整个路径比如D:\\IDEAjava工程\\javaSE\\javareflect\\jdbc.properties InputStream resource &#x3D; classLoader.getResourceAsStream(“jdbc1.properties”);方法就是映射到scr目录下 一般就不用相对路径了，用不明白 1而且idea中路径字符串中\\\\和/是同样的效果 创建运行时类的对象和体会动态加载到内存中的类我们就把它叫做运行时类 test1时创建运行时类的对象 test2是体会反射的动态性，就是在编译时不能确定创建哪个类对象，运行时才确定创建对象的类型 并且方法有参数别用@test 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import org.junit.Test;import java.util.Random;/** * 通过反射创建对应的运行时类的对象 */public class NewInstanceTest &#123; @Test public void test1() throws IllegalAccessException, InstantiationException &#123; //用了泛型之后后面就不用强转了 Class&lt;Person&gt; clazz=Person.class; //newInstance();调用子方法创建对应的运行时类的对象 //其实内部还是调用了Person的空参构造器， //所以这个方法要求1.类必须有空参构造器 // 2.这个空参构造器的权限不是私有。通常为public //在javabean中要求提供一个public的空参构造其，原因： //1.便于通过反射，创建运行时类的对象 //2.便于子类继承此运行时类时，默认调用super(),保证父类有空参构造器 Person obj = clazz.newInstance(); System.out.println(obj); &#125; @Test public void test2() &#123;int num=new Random().nextInt(3);//0.1.2String path=&quot;&quot;;switch(num) &#123; case 0: path = &quot;java.util.Date&quot;; break; case 1: path = &quot;java.lang.Object&quot;; break; case 2: path = &quot;Person&quot;; break;&#125; try &#123; Object obj = getInstance(path); System.out.println(obj); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125;&#125; /** * 创建一个指定类的对象 * @param classPath 指定类的全类名 * @return * @throwsException */ public Object getInstance(String classPath) throws Exception&#123; Class clazz=Class.forName(classPath); return clazz.newInstance(); &#125;&#125; 提供结构丰富的Person类1234567891011121314151617181920212223242526272829303132333435363738package com.atguigu.java;public class Person extends Creature&lt;String&gt; implements Comparable&lt;String&gt;,MyInterface&#123; private String name; int age; public int id; protected int score; public Person()&#123; &#125; private Person(String name)&#123; this.name=name; &#125; public Person(String name,int age)&#123; this.name=name; this.age=age; &#125; private String show(String nation)&#123; System.out.println(&quot;我的国际时&quot;+nation); return nation; &#125; public String display(String interests)&#123; return interests; &#125; @Override public int compareTo(String o) &#123; return 0; &#125; @Override public void info() &#123; System.out.println(&quot;我是一个人&quot;); &#125;&#125; 获取运行时类的属性结构及其内部结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.atguigu.java1;import com.atguigu.java.Person;import com.sun.deploy.util.SystemUtils;import org.junit.Test;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import java.util.Locale;/*获取运行时类的属性结构 */public class FieldTest &#123;@Test public void test1()&#123; Class clazz= Person.class; //获取属性结构 //getFields():获取当前运行时类及其父类中声明为public访问权限的属性 Field[] fields = clazz.getFields(); for (Field f : fields) &#123; System.out.println(f); &#125;System.out.println(&quot;******************&quot;); //getDeclaredFields():获取当前运行时类当中的所有属性 Field[] declaredFields = clazz.getDeclaredFields(); for (Field f : declaredFields) &#123; System.out.println(f); &#125;&#125;//每一个属性的具体的部分也是可以拿到的//权限，修饰符，数据类型，变量名，变量值 @Test public void test2()&#123; Class clazz=Person.class; Field[] declaredFields = clazz.getDeclaredFields(); for (Field f : declaredFields) &#123; //1.权限修饰符 //这个地方获取的是一个表示访问类型的数字 int modifier =f.getModifiers(); //这个地方是将访问类型的数字转换成访问类型的文字,空白是默认类型 System.out.println(Modifier.toString(modifier)); //2.数据类型 Class type=f.getType();//type获得的是一个类型 System.out.println(type.getName());//这样是获得type的全名 //3.变量名 String name = f.getName(); System.out.println(name); &#125;&#125;&#125; 获取运行时类的方法结构和内部结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.atguigu.java1;import com.atguigu.java.Person;import org.junit.Test;import java.lang.reflect.Method;import java.lang.reflect.Modifier;/*获取运行时类的方法结构 */public class MethodTest &#123; @Test public void test1() &#123; Class clazz = Person.class; //getMethods:获取当前运行时类及其所有父类中声明为public权限的方法 Method[] methods = clazz.getMethods(); for (Method m : methods) &#123; System.out.println(m); &#125; System.out.println(&quot;****************************&quot;); //获取当前运行时类中声明的所有方法，不包含父类中声明的 Method[] declaredMethods = clazz.getDeclaredMethods(); for (Method m : declaredMethods) &#123; System.out.println(m); &#125; &#125; @Test /* @注解 权限修饰符，返回值类型，方法名（参数类型 形参名1，...）throws Exception()&#123; &#125; */ public void test2() &#123; Class clazz = Person.class; Method[] methods = clazz.getDeclaredMethods(); for (Method m : methods) &#123; //获取权限修饰符 System.out.println(Modifier.toString(m.getModifiers())); //获取方法的返回值类型 System.out.println(m.getReturnType().getName()); //获取方法名 System.out.println(m.getName()); System.out.println(&quot;(&quot;); //获取形参列表 Class[] parameterTypes = m.getParameterTypes(); if (!(parameterTypes != null &amp;&amp; parameterTypes.length == 0)) &#123; for (int i = 0; i &lt; parameterTypes.length; i++) &#123; if (i == parameterTypes.length - 1) &#123; System.out.println(parameterTypes[i].getName() + &quot; args_&quot; + i); break; &#125; System.out.println(parameterTypes[i].getName() + &quot; args_&quot; + i + &quot;,&quot;); &#125; System.out.println(&quot;)&quot;); &#125; //获取抛出的异常 Class[] exceptionTypes = m.getExceptionTypes(); if (exceptionTypes.length &gt; 0) &#123; System.out.print(&quot;throws&quot;); for (int i = 0; i &lt; exceptionTypes.length; i++) &#123; if (i == exceptionTypes.length - 1) &#123; System.out.println(exceptionTypes[i].getName()); break; &#125; System.out.println(exceptionTypes[i].getName() + &quot;,&quot;); &#125; &#125; &#125; &#125;&#125; 获取运行时类的构造器结构1234567891011121314151617181920212223242526package com.atguigu.java1;import com.atguigu.java.Person;import org.junit.Test;import java.lang.reflect.Constructor;import java.lang.reflect.Method;public class OtherTest &#123;@Test public void test1()&#123; Class clazz= Person.class; //getConstructors获取当前运行时类中声明为public的构造器 Constructor[] constructors = clazz.getConstructors(); for (Constructor constructor : constructors) &#123; System.out.println(constructor); &#125; System.out.println(&quot;***********************&quot;); //getDeclaredMethods获取当前运行时类中声明的所有的构造器 Constructor[] declaredMethods = clazz.getDeclaredConstructors(); for (Constructor declaredMethod : declaredMethods) &#123; System.out.println(declaredMethod); &#125;&#125;&#125; 获取运行时类的父类和泛型ParameterizedType是Type的子接口 Type是Class的父接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 /* 获取运行时类的父类 */ @Test public void test2()&#123; Class clazz = Person.class; Class superclass = clazz.getSuperclass(); System.out.println(superclass); &#125; /* 获取运行时类的带泛型的父类 */ @Test public void test3()&#123; Class clazz = Person.class; Type genericSuperclass = clazz.getGenericSuperclass(); System.out.println(genericSuperclass); &#125; /* 获取运行时类的带泛型的父类的泛型 代码：逻辑性代码 vs 功能性代码 */ @Test public void test4()&#123; Class clazz = Person.class; Type genericSuperclass = clazz.getGenericSuperclass(); //ParameterizedType是Type的子接口 //Type是Class的父接口，就像是List和ArrayList的关系 ParameterizedType paramType = (ParameterizedType) genericSuperclass; //获取泛型类型 Type[] actualTypeArguments = paramType.getActualTypeArguments();// System.out.println(actualTypeArguments[0].getTypeName()); //将Type类型强转为class，然后再用getName，只有Type才有getTypename方法 System.out.println(((Class)actualTypeArguments[0]).getName()); &#125; /* 获取运行时类实现的接口 */ @Test public void test5()&#123; Class clazz = Person.class; Class[] interfaces = clazz.getInterfaces(); for(Class c : interfaces)&#123; System.out.println(c); &#125; System.out.println(); //获取运行时类的父类实现的接口 Class[] interfaces1 = clazz.getSuperclass().getInterfaces(); for(Class c : interfaces1)&#123; System.out.println(c); &#125; &#125; 获取运行时类实现的接口，所在的包，注解123456789101112131415161718192021222324252627282930313233343536373839404142434445/*获取运行时类实现的接口 */@Testpublic void test5()&#123; Class clazz = Person.class; Class[] interfaces = clazz.getInterfaces(); for(Class c : interfaces)&#123; System.out.println(c); &#125; System.out.println(); //获取运行时类的父类实现的接口 Class[] interfaces1 = clazz.getSuperclass().getInterfaces(); for(Class c : interfaces1)&#123; System.out.println(c); &#125;&#125;/* 获取运行时类所在的包 */@Testpublic void test6()&#123; Class clazz = Person.class; Package pack = clazz.getPackage(); System.out.println(pack);&#125;/* 获取运行时类声明的注解 */@Testpublic void test7()&#123; Class clazz = Person.class; Annotation[] annotations = clazz.getAnnotations(); for(Annotation annos : annotations)&#123; System.out.println(annos); &#125;&#125; 调用运行时类的指定结构指定结构主要指的是属性和方法构造器","categories":[],"tags":[]}],"categories":[],"tags":[]}