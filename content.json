{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"标题","date":"2022-09-29T15:18:19.000Z","updated":"2022-09-30T03:20:40.179Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"​ ​ 以一灌之的努力，不可懈怠的人生 ​ ​ 努力是奇迹的别名"},{"title":"example","date":"2022-09-30T03:23:42.000Z","updated":"2022-09-30T03:27:44.080Z","comments":false,"path":"example/index.html","permalink":"http://example.com/example/index.html","excerpt":"","text":"12312312"}],"posts":[{"title":"mybatis","slug":"mybatis","date":"2022-11-04T15:31:35.000Z","updated":"2023-04-10T13:20:35.051Z","comments":true,"path":"2022/11/04/mybatis/","link":"","permalink":"http://example.com/2022/11/04/mybatis/","excerpt":"","text":"MybatisJDBC代码冗长，维护不易，所以有了mybatis去封装了JDBC的框架 特点：sql和java分开，功能边界清晰 搭建mybatisIDE：idea 2019.2 构建工具：maven 3.5.4 mysql版本：Mysql 8 MyBatis版本:Mybatis 3.5.7 MySQL 5版本使用jdbc5驱动，驱动类使用：com.mysql.jdbc.Driver MySQL 8版本使用jdbc8驱动，驱动类使用：com.mysql.cj.jdbc.Driver 2、连接地址url MySQL 5版本的url： jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ssm MySQL 8版本的url： jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ssm?serverTimezone&#x3D;UTC 创建Maven工程创建Maven工程的时候 第二个就是那个模块的名字 其他的可以在maven.pdf中看到 然后在pom.xml中加入 123456789101112131415161718192021&lt;dependencies&gt; &lt;!-- Mybatis核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; **创建一个t_user表 ** 创建一个这个表对应的对象 User 创建Mybatis的核心配置文件习惯上命名为mybatis-config.xml，这个是自己命名的，不一定非要是这个 这个核心配置文件是用来连接数据库的和Mybatis的全局信息 放在resoures文件夹中，resources文件夹就是存放配置文件的 文件内容 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--设置连接数据库的环境--&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--驱动--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;!--url--&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC&quot;/&gt; &lt;!--数据库的用户名和密码--&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--引入映射文件--&gt; &lt;mappers&gt; &lt;package name=&quot;mappers/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 创建Mapper接口和映射文件Mapper接口其实就是以前的dao，但dao有接口还有实现类，Mapper接口不需要我们提供实现类 当我们调用Mapper接口的一个方法，就会直接对应一个sql语句来执行 在mapper包里创建UserMapper 12345678package com.atguigu.mybatis.mapper;public interface UserMapper &#123; int insertUser();&#125; 1、映射文件的命名规则： 表所对应的实体类的类名+Mapper.xml 例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml 用处：Mybatis映射文件就是针对一个mapper接口中的方法的实现，也就是sql语句的编写，进行一个javabean类和数据库中一个表中数据的交互 把UserMapper.xml映射文件放在resources下的mappers下 mapper接口的全类名和映射文件的命名空间（namespace）保持一致 mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--这个namespace要和Mapper接口的全类名相同--&gt;&lt;mapper namespace=&quot;com.atguigu.mybatis.mapper.UserMapper&quot;&gt; &lt;!--insert标签说明是插入语句，id要和mapper接口中对应的方法名字相同--&gt; &lt;!--int insertUser();--&gt; &lt;insert id=&quot;insertUser&quot;&gt;insert into t_user values(null,&#x27;admin&#x27;,&#x27;123456&#x27;,23,&#x27;男&#x27;,&#x27;12345@qq.com&#x27;)&lt;/insert&gt;&lt;/mapper&gt; 在mybatis-config.xml中引入映射文件 12345&lt;!--引入映射文件--&gt;&lt;mappers&gt; &lt;!--相对路径，这个配置文件和mappers在同一文件夹下--&gt; &lt;package name=&quot;mappers/UserMapper.xml&quot;/&gt;&lt;/mappers&gt; 测试添加用户功能mybatis-config.xml中引入映射文件 12345&lt;!--引入映射文件--&gt;&lt;mappers&gt; &lt;!--相对路径，这个配置文件和mappers在同一文件夹下--&gt; &lt;mapper resource=&quot;mappers/UserMapper.xml&quot;/&gt;&lt;/mappers&gt; test 下的java包中的com.atguigu.mybatis.test包下的MyBatisTest文件，用来测试的 123456789101112131415161718192021222324252627282930313233343536373839package com.atguigu.mybatis.test;import com.atguigu.mybatis.mapper.UserMapper;import com.atguigu.mybatis.pojo.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.net.URL;public class MyBatisTest &#123;@Test public void testInsert() throws IOException &#123; //获取核心配置文件的输入流 InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); //获取SalSessionFactoryBuilder对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); //获取SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); //获取sql的会话对象SqlSession,是Mybatis提供的操作数据库的对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //获取UserMapper的代理实现类对象 UserMapper mapper = sqlSession.getMapper(UserMapper.class); //调用Mapper接口中的方法，实现添加用户信息的功能 int result = mapper.insertUser(); //提交事务 sqlSession.commit(); System.out.println(&quot;结果+&quot;+result); //关闭sqlSession对象 sqlSession.close();&#125;&#125; Resources.getResourceAsStream(“mybatis-config.xml”);这个方法的参数路径直接映射到resources目录下 其实也是加载之后java和reources都在classes路径下 所以Resources.getResourceAsStream(“mybatis-config.xml”);是定位到target&#x2F;classes文件下 优化功能1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.atguigu.mybatis.test;import com.atguigu.mybatis.mapper.UserMapper;import com.atguigu.mybatis.pojo.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.net.URL;public class MyBatisTest &#123;@Test public void testInsert() throws IOException &#123; //获取核心配置文件的输入流 InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); //获取SalSessionFactoryBuilder对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); //获取SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); //获取sql的会话对象SqlSession,是Mybatis提供的操作数据库的对象 //布尔类型参数如果为true就是自动提交，如果不写true就不会自动提交事务 SqlSession sqlSession = sqlSessionFactory.openSession(true); //获取UserMapper的代理实现类对象 UserMapper mapper = sqlSession.getMapper(UserMapper.class); //调用Mapper接口中的方法，实现添加用户信息的功能 int result = mapper.insertUser(); /*//提供sql的唯一标识找到sql并执行，唯一标识是namespace.(sql的id) //执行insert的sql语句 //根据UserMapper的全类名找到UserMapper根据insertUser方法名找到对应的sql语句 int result = sqlSession.insert(&quot;com.atguigu.mybatis.mapper.UserMapper.insertUser&quot;);*/ //提交事务 //sqlSession.commit(); System.out.println(&quot;结果+&quot;+result); //关闭sqlSession对象 sqlSession.close();&#125;&#125; 加入log4j日志功能 在pom.xml中加上依赖 123456&lt;!-- log4j日志 --&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 加入log4j.xml配置文件在resources文件夹下 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt;&lt;log4j:configuration xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt; &lt;param name=&quot;Encoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt; &lt;param name=&quot;ConversionPattern&quot; value=&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125;%m (%F:%L) \\n&quot; /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;logger name=&quot;java.sql&quot;&gt; &lt;level value=&quot;debug&quot; /&gt; &lt;/logger&gt; &lt;logger name=&quot;org.apache.ibatis&quot;&gt; &lt;level value=&quot;info&quot; /&gt; &lt;/logger&gt; &lt;root&gt; &lt;level value=&quot;debug&quot; /&gt; &lt;appender-ref ref=&quot;STDOUT&quot; /&gt; &lt;/root&gt;&lt;/log4j:configuration&gt; 效果就是 执行代码的时候，能看到影响的行数，传递的参数，执行的sql语句 123DEBUG 10-16 13:54:41,170 ==&gt; Preparing: insert into t_user values(null,&#x27;admin&#x27;,&#x27;123456&#x27;,23,&#x27;男&#x27;,&#x27;12345@qq.com&#x27;); (BaseJdbcLogger.java:137) DEBUG 10-16 13:54:41,193 ==&gt; Parameters: (BaseJdbcLogger.java:137) DEBUG 10-16 13:54:41,281 &lt;== Updates: 1 (BaseJdbcLogger.java:137) 日志的级别 FATAL(致命)&gt;ERROR(错误)&gt;WARN(警告)&gt;INFO(信息)&gt;DEBUG(调试) 从左到右打印的内容越来越详细 你选择了一个日志的级别，那么之后就可以打印出大于等于这个日志级别的日志 mybatis的增删改先封装了获取sqlSession会话的方法 utils包下的 123456789101112131415161718192021222324252627282930313233343536package com.atguigu.mybatis.utils;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class SqlSessionUtil &#123; public static SqlSession getSqlSession()&#123; SqlSession sqlSession=null; //获取核心配置文件的输入流 try &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); //获取SalSessionFactoryBuilder对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); //获取SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); //获取sql的会话对象SqlSession,是Mybatis提供的操作数据库的对象 //布尔类型参数如果为true就是自动提交，如果不写true就不会自动提交事务 sqlSession = sqlSessionFactory.openSession(true); return sqlSession; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return sqlSession; &#125;&#125; UserMapper接口 123456789101112131415161718192021package com.atguigu.mybatis.mapper;public interface UserMapper &#123; /** * 添加用户信息 * @return */ int insertUser(); /* 修改用户信息 */ int updateUser(); /* 删除用户信息 */ int deleteUser();&#125; UserMapper.xml 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--这个namespace要和Mapper接口的全类名相同--&gt;&lt;mapper namespace=&quot;com.atguigu.mybatis.mapper.UserMapper&quot;&gt; &lt;!--insert标签说明是插入语句，id要和mapper接口中对应的方法名字相同--&gt; &lt;!--int insertUser();--&gt; &lt;insert id=&quot;insertUser&quot;&gt;insert into t_user values(null,&#x27;admin&#x27;,&#x27;123456&#x27;,23,&#x27;男&#x27;,&#x27;12345@qq.com&#x27;);&lt;/insert&gt; &lt;update id=&quot;updateUser&quot;&gt; update t_user set username=&#x27;root&#x27; ,password=&#x27;123&#x27; where id=3 &lt;/update&gt; &lt;delete id=&quot;deleteUser&quot;&gt; delete from t_user where id=3 &lt;/delete&gt;&lt;/mapper&gt; MyBatisTest 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.atguigu.mybatis.test;import com.atguigu.mybatis.mapper.UserMapper;import com.atguigu.mybatis.pojo.User;import com.atguigu.mybatis.utils.SqlSessionUtil;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.net.URL;public class MyBatisTest &#123;@Test public void testInsert() throws IOException &#123; //获取核心配置文件的输入流 InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); //获取SalSessionFactoryBuilder对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); //获取SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); //获取sql的会话对象SqlSession,是Mybatis提供的操作数据库的对象 //布尔类型参数如果为true就是自动提交，如果不写true就不会自动提交事务 SqlSession sqlSession = sqlSessionFactory.openSession(true); //获取UserMapper的代理实现类对象 UserMapper mapper = sqlSession.getMapper(UserMapper.class); //调用Mapper接口中的方法，实现添加用户信息的功能 int result = mapper.insertUser(); /*//提供sql的唯一标识找到sql并执行，唯一标识是namespace.(sql的id) //执行insert的sql语句 //根据UserMapper的全类名找到UserMapper根据insertUser方法名找到对应的sql语句 int result = sqlSession.insert(&quot;com.atguigu.mybatis.mapper.UserMapper.insertUser&quot;);*/ //提交事务 //sqlSession.commit(); System.out.println(&quot;结果+&quot;+result); //关闭sqlSession对象 sqlSession.close();&#125;@Testpublic void testUpdate()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); mapper.updateUser(); sqlSession.close(); &#125; @Test public void testDelete()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); mapper.deleteUser(); sqlSession.close();&#125;&#125; 测试查询功能UserMapper.xml 12345678910&lt;!--resultType 设置结果类型，即查询的数据要转换为的java类型--&gt;&lt;!--resultMap是自定义映射，处理多对一或一对多的映射关系--&gt;&lt;select id=&quot;getUserById&quot; resultType=&quot;com.atguigu.mybatis.pojo.User&quot;&gt; select *from t_user where id=1;&lt;/select&gt;&lt;select id=&quot;getAllUser&quot; resultType=&quot;com.atguigu.mybatis.pojo.User&quot;&gt; select *from t_user&lt;/select&gt; UserMapper 接口 123456789/*根据id查询用户信息 */User getUserById();/*查询所有的用户信息 */List&lt;User&gt; getAllUser(); 注意： 1、查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射关系 resultType：自动映射，用于属性名和表中字段名一致的情况 resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况 测试 1234567891011121314151617@Test public void testGetUserById()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User userById = mapper.getUserById(); System.out.println(userById);&#125;@Testpublic void testGetAllUser()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; allUser = mapper.getAllUser(); System.out.println(allUser);&#125; mybatis的核心配置文件environments12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- environments :配置连接数据库的环境 default:设置默认使用的环境的id --&gt; &lt;!--设置连接数据库的环境--&gt; &lt;environments default=&quot;development&quot;&gt; &lt;!-- environment:设置一个具体的连接数据库的环境 id:设置环境的唯一标识，不能重复 --&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 设置事务管理器 属性：type：设置事务管理的方式 type=&quot;JDBC/MANAGED&quot; JDBC:标识使用JDBC原生的事务管理方式，手动提交事务回滚事务，也可以自动提交事务 MANAGED:被管理的，例如spring --&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!-- dataSource:设置数据源 属性： type：设置数据源的类型 type=&quot;POOLED/UNPOOLED/JNDI&quot; POOLED:表示使用数据库连接池 UNPOOLED:表示不使用数据库连接池 JNDI:表示使用上下文中的数据源 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--驱动--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;!--url--&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC&quot;/&gt; &lt;!--数据库的用户名和密码--&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--引入映射文件--&gt; &lt;mappers&gt; &lt;!--相对路径，这个配置文件和mappers在同一文件夹下--&gt; &lt;mapper resource=&quot;mappers/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; properties存储连接数据库的信息这是resources下的jdbc.properties 1234jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=UTCjdbc.username=rootjdbc.password=root mybatis-config.xml &lt;!--引入properties文件，此后就可以在当前文件中使用$&#123;key&#125;的方式来访问value--&gt; &lt;properties resource=&quot;jdbc.properties&quot;/&gt; 123456789&lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--驱动--&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;!--url--&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;!--数据库的用户名和密码--&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--引入properties文件，此后就可以在当前文件中使用$&#123;key&#125;的方式来访问value--&gt; &lt;properties resource=&quot;jdbc.properties&quot;/&gt; &lt;!-- environments :配置连接数据库的环境 default:设置默认使用的环境的id --&gt; &lt;!--设置连接数据库的环境--&gt; &lt;environments default=&quot;development&quot;&gt; &lt;!-- environment:设置一个具体的连接数据库的环境 id:设置环境的唯一标识，不能重复 --&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 设置事务管理器 属性：type：设置事务管理的方式 type=&quot;JDBC/MANAGED&quot; JDBC:标识使用JDBC原生的事务管理方式，手动提交事务回滚事务，也可以自动提交事务 MANAGED:被管理的，例如spring --&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!-- dataSource:设置数据源 属性： type：设置数据源的类型 type=&quot;POOLED/UNPOOLED/JNDI&quot; POOLED:表示使用数据库连接池 UNPOOLED:表示不使用数据库连接池 JNDI:表示使用上下文中的数据源 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--驱动--&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;!--url--&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;!--数据库的用户名和密码--&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--引入映射文件--&gt; &lt;mappers&gt; &lt;!--相对路径，这个配置文件和mappers在同一文件夹下--&gt; &lt;mapper resource=&quot;mappers/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 核心配置文件之typeAliases1234567891011121314151617&lt;!-- typeAliases :设置类型别名，即为某个具体的类型设置一个别名 在Mybatis的范围中，就可以使用别名表示一个具体的类型 --&gt; &lt;typeAliases&gt; &lt;!-- type:设置需要起别名的类型 alias:设置某个类型的别名 --&gt; &lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.pojo.User&quot; alias=&quot;abc&quot;&gt;&lt;/typeAlias&gt;--&gt; &lt;!--只设置一个type属性，就会有一个默认的别名，就是他的类名，也就是User--&gt; &lt;!-- &lt;typeAlias type=&quot;com.atguigu.mybatis.pojo.User&quot;&gt;&lt;/typeAlias&gt;--&gt; &lt;!--通过包来设置类型别名，指定包下的所有的类型全部用有默认的别名。--&gt; &lt;package name=&quot;com.atguigu.mybatis.pojo&quot;/&gt; &lt;/typeAliases&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- mybatis中的核心配置文件中的标签必须要按照指定的顺序配置 properties?,settings?,typeAliases?,typeHandlers?, objectFactory?,objectWrapperFactory?,reflectorFactory?, plugins?,environments?,databaseIdProvider?,mappers? --&gt; &lt;!--引入properties文件，此后就可以在当前文件中使用$&#123;key&#125;的方式来访问value--&gt; &lt;properties resource=&quot;jdbc.properties&quot;/&gt; &lt;!-- typeAliases :设置类型别名，即为某个具体的类型设置一个别名 在Mybatis的范围中，就可以使用别名表示一个具体的类型 --&gt; &lt;typeAliases&gt; &lt;!-- type:设置需要起别名的类型 alias:设置某个类型的别名 --&gt; &lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.pojo.User&quot; alias=&quot;abc&quot;&gt;&lt;/typeAlias&gt;--&gt; &lt;!--只设置一个type属性，就会有一个默认的别名，就是他的类名，也就是User--&gt; &lt;!-- &lt;typeAlias type=&quot;com.atguigu.mybatis.pojo.User&quot;&gt;&lt;/typeAlias&gt;--&gt; &lt;!--通过包来设置类型别名，指定包下的所有的类型全部用有默认的别名。--&gt; &lt;package name=&quot;com.atguigu.mybatis.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- environments :配置连接数据库的环境 default:设置默认使用的环境的id --&gt; &lt;!--设置连接数据库的环境--&gt; &lt;environments default=&quot;development&quot;&gt; &lt;!-- environment:设置一个具体的连接数据库的环境 id:设置环境的唯一标识，不能重复 --&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 设置事务管理器 属性：type：设置事务管理的方式 type=&quot;JDBC/MANAGED&quot; JDBC:标识使用JDBC原生的事务管理方式，手动提交事务回滚事务，也可以自动提交事务 MANAGED:被管理的，例如spring --&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!-- dataSource:设置数据源 属性： type：设置数据源的类型 type=&quot;POOLED/UNPOOLED/JNDI&quot; POOLED:表示使用数据库连接池 UNPOOLED:表示不使用数据库连接池 JNDI:表示使用上下文中的数据源 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--驱动--&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;!--url--&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;!--数据库的用户名和密码--&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--引入映射文件--&gt; &lt;mappers&gt; &lt;!--以包的方式引入映射文件，但是必须满足两个条件1.mapper接口和映射文件所在的包名字必须一致2.mapper接口的名字和映射文件的名字必须一致--&gt; &lt;!--相对路径，这个配置文件和mappers在同一文件夹下--&gt; &lt;package name=&quot;com.atguigu.mybatis.mapper&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 核心配置文件中的mappers1234567891011 &lt;!--引入映射文件--&gt; &lt;!--以包的方式引入映射文件，但是必须满足两个条件1.mapper接口和映射文件所在的包名字必须一致2.mapper接口的名字和映射文件的名字必须一致--&gt; &lt;!--相对路径，这个配置文件和mappers在同一文件夹下--&gt; &lt;mappers&gt; &lt;package name=&quot;com.atguigu.mybatis.mapper&quot;/&gt; &lt;/mappers&gt; 在目录中创建包，用new directory的时候，要实现目录层级的变化要用&#x2F;来分割 java下和resources下的com.atguigu.mybatis.mapper包最终都会加载到同一个包中 创建核心配置文件和映射文件的模板这个就是创建一个模板，然后右键之后可以生成这个模板文件 mybatis-config.xml文件的模板 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- mybatis中的核心配置文件中的标签必须要按照指定的顺序配置 properties?,settings?,typeAliases?,typeHandlers?, objectFactory?,objectWrapperFactory?,reflectorFactory?, plugins?,environments?,databaseIdProvider?,mappers? --&gt; &lt;properties resource=&quot;jdbc.properties&quot;/&gt; &lt;typeAliases&gt; &lt;package name=&quot;&quot;/&gt; &lt;/typeAliases&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--驱动--&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;!--url--&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;!--数据库的用户名和密码--&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;package name=&quot;com.atguigu.mybatis.mapper&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 映射文件模板的创建 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;&quot;&gt;&lt;/mapper&gt; 用模板搭建mybatis框架就是又创建了一个mybatis项目 Mybatis获取参数值的两种方式MyBatis获取参数值的两种方式：${}和#{} ${}的本质就是字符串拼接，#{}的本质就是占位符赋值 ${}使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号；但是#{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单引号 获取单个字面量类型的参数若mapper接口中的方法参数为单个的字面量类型 此时可以使用${}和#{}以任意的名称获取参数的值，注意${}需要手动加单引号 UserMapper接口 12345678910111213package com.atguigu.mybatis.mapper;import com.atguigu.mybatis.pojo.User;public interface UserMapper &#123; /* 根据用户名查询用户信息 */ User getUserByUsername(String username);&#125; UserMapper.xml #{}或者${}大括号里面其实都是任意的，但最后是和函数的参数名字相同 ${}要加单引号 ‘${}’ 123456 &lt;!-- User getUserByUsername(String username);--&gt; &lt;select id=&quot;getUserByUsername&quot; resultType=&quot;com.atguigu.mybatis.pojo.User&quot;&gt;&lt;!--获取getUserByUsername的参数--&gt; &lt;!--select *from t_user where username=#&#123;username&#125;--&gt; select * from t_user where username=&#x27;$&#123;username&#125;&#x27; &lt;/select&gt; 测试 12345678public class ParameterTest &#123;@Test public void testGetUserByUsername()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User admin = mapper.getUserByUsername(&quot;admin&quot;); System.out.println(admin);&#125; 获取多个字面量类型的参数若mapper接口中的方法参数为多个时 此时MyBatis会自动将这些参数放在一个map集合中，以arg0,arg1…为键，以参数为值； 以 param1,param2…为键，以参数为值； 因此只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号 UserMapper接口 1234/*验证登录 */User checklogin(String username,String password); UserMapper.xml arg0或者param1表示第一个参数，arg1和param2表示第二个参数，接下来以此类推就可以 12345&lt;!-- User checklogin(String username,String password);--&gt;&lt;select id=&quot;checklogin&quot; resultType=&quot;com.atguigu.mybatis.pojo.User&quot;&gt; &lt;!-- select * from t_user where username=#&#123;arg0&#125; and password=#&#123;arg1&#125;--&gt; select *from t_user where username=#&#123;param1&#125; and password=#&#123;param2&#125;&lt;/select&gt; 测试 12345678 @Testpublic void testCheckLogin()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User admin = mapper.checklogin(&quot;admin&quot;,&quot;123456&quot;); System.out.println(admin); &#125; 获取map集合类型的参数若mapper接口中的方法需要的参数为多个时，此时可以手动创建map集合，将这些数据放在 map中 只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号 UserMapper 1234/*以map集合作为参数的验证登录 */User checkloginByMap(Map&lt;String,Object&gt; map); UserMapper.xml #{username}和#{password}大括号中的内容都是map对象中的key 1234&lt;!--User checkloginByMap(Map&lt;String,Object&gt; map);--&gt;&lt;select id=&quot;checkloginByMap&quot; resultType=&quot;com.atguigu.mybatis.pojo.User&quot;&gt; select *from t_user where username=#&#123;username&#125; and password=#&#123;password&#125;&lt;/select&gt; test 1234567891011@Testpublic void testCheckLoginByMap()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); Map&lt;String,Object&gt; map=new HashMap&lt;&gt;(); map.put(&quot;username&quot;,&quot;admin&quot;); map.put(&quot;password&quot;,&quot;123456&quot;); User admin = mapper.checkloginByMap(map); System.out.println(admin);&#125; 获取实体类类型的参数若mapper接口中的方法参数为实体类对象时 此时可以使用${}和#{}，通过访问实体类对象中的属性名获取属性值，注意${}需要手动加单引号 Usermapper 1234/*添加用户信息的功能 */int insertUser(User user); Usermapper.xml 1234&lt;!-- void insertUser(User user);--&gt;&lt;insert id=&quot;insertUser&quot;&gt; insert into t_user values(null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;gender&#125;,#&#123;email&#125;)&lt;/insert&gt; 通过属性名获取属性值，是和成员变量没有关系的，是和get和set方法有关的，只有这个属性有get方法才能够这样来获取 测试： 123456789@Testpublic void testInsertUser()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user=new User(null,&quot;root&quot;,&quot;123456&quot;,22,&quot;女&quot;,&quot;342qq.com&quot;); int i = mapper.insertUser(user); System.out.println(i);&#125; 使用@Param标识参数可以通过@Param注解标识mapper接口中的方法参数 此时，会将这些参数放在map集合中，以@Param注解的value属性值为键，以参数为值； 或者也可以 param1,param2…为键，以参数为值；只需要通过${}和#{}访问map集合的键就可以获取相对应 的值， 注意${}需要手动加单引号 @Param(“username”)给注解类的value参数赋值 12345678/** * 验证登录（使用@param注解） * @param username * @param password * @return *///@Param中不是键值对，就是默认给注解类的value属性赋值User checkLoginByParam(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password); 小结将这些获取参数值就分为两种 当参数类型是实体类对象的时候通过属性值获取 当参数类型是其他的时候，通过@Param标记来获取 @Param也可以获取list类型集合，或者Map类型集合 获取Map类型时可以通过 参数名.key来获取value值 list类型集合，可以通过遍历foreach来访问其中的每一个元素 ，如果元素是一个对象就得用对象名.属性名访问属性值 12345678&lt;!-- void insertMoreEmp(List&lt;Emp&gt; emps);--&gt;&lt;insert id=&quot;insertMoreEmp&quot;&gt; insert into t_emp values &lt;!--separator是每一次循环之间的分隔符的设置--&gt; &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;,&quot;&gt; (null,#&#123;emp.empName&#125;,#&#123;emp.age&#125;,#&#123;emp.gender&#125;,null) &lt;/foreach&gt;&lt;/insert&gt; 而且在sql语句中使用参数需要加#{}或者${}，在标签中使用参数不需要，直接用就可以 Mybatis的查询功能创建SelectMapperl.xml和SelectMapper接口 和selectMapperTest 查询返回一个实体类对象或list集合当查询的数据为多条时，不能使用实体类作为返回值，否则会抛出异常TooManyResultsException 但是若查询的数据只有一条，可以使用实体类或集合作为返回值 SelectMapper 123456789 /* 根据id查询用户信息 */ User getUserbyId(@Param(&quot;id&quot;) Integer id);/*查询所有的用户信息 */List&lt;User&gt; getAllUser(); SelectMapper.xml 123456789&lt;!--User getUserbyId(@Param(&quot;id&quot;) Integer id);--&gt;&lt;select id=&quot;getUserbyId&quot; resultType=&quot;User&quot;&gt; select *from t_user where id=#&#123;id&#125;&lt;/select&gt;&lt;!--List&lt;User&gt; getAllUser();--&gt;&lt;select id=&quot;getAllUser&quot; resultType=&quot;User&quot;&gt; select *from t_user&lt;/select&gt; SelectMapperTest 123456789101112131415@Testpublic void testGetUserById()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); SelectMapper mapper = sqlSession.getMapper(SelectMapper.class); User user = mapper.getUserbyId(9); System.out.println(user);&#125;@Testpublic void testGetAllUser()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); SelectMapper mapper = sqlSession.getMapper(SelectMapper.class); List&lt;User&gt; list = mapper.getAllUser(); list.forEach(System.out::println);&#125; 查询单行单列的数据SelectMapper接口 1234/*查询用户的总数量 */Integer getCount(); SelectMapper.xml mybatis中为java中常用的类型设置了类型别名类名:别名Integer:Integer ,intint :_int,_integerMap:mapString:string 有一个规律就是原本类名是小写字母开头的，别名是前面加一个_ 原本类名是大写字母开头的，别名是第一个字母变为小写字母 12345678910111213 &lt;!--Integer getCount();--&gt; &lt;select id=&quot;getCount&quot; resultType=&quot;integer&quot;&gt;&lt;!--mybatis中为java中常用的类型设置了类型别名类名:别名Integer:Integer ,intint :_int,_integerMap:mapString:string--&gt; select count(*) from t_user &lt;/select&gt; test 1234567@Testpublic void testGetCount()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); SelectMapper mapper = sqlSession.getMapper(SelectMapper.class); Integer count=mapper.getCount(); System.out.println(count);&#125; 查询一条数据为map集合查询出来的数据用map保存时 以字段名为键以字段值为值，以及如果哪个字段的值为null,它是不会放在map集合中的 用类保存的时候，必须保证字段名和类中的属性名相一致，但用map保存不需要 SelectMapper接口 1234/*根据id查询用户信息然后为一个map集合 */Map&lt;String,Object&gt; getUserByIdToMap(@Param(&quot;id&quot;) Integer id); SelectMapper.xml 1234&lt;!--Map&lt;String,Object&gt; getUserByIdToMap(@Param(&quot;id&quot;) Integer id);--&gt;&lt;select id=&quot;getUserByIdToMap&quot; resultType=&quot;map&quot;&gt; select *from t_user where id=#&#123;id&#125;&lt;/select&gt; test 12345678@Testpublic void testGetUserByIdToMap()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); SelectMapper mapper = sqlSession.getMapper(SelectMapper.class); Map&lt;String, Object&gt; userByIdToMap = mapper.getUserByIdToMap(9); System.out.println(userByIdToMap); //&#123;password=123456, gender=男, id=9, age=23, email=123@qq.com, username=admin&#125;&#125; 查询多条数据为map集合方法一： 1将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此 时可以将这些map放在一个list集合中获取 SelectMapper 1List&lt;Map&lt;String,Object&gt;&gt; getAllUserToMap(); SelectMapper.xml 1234&lt;!--Map&lt;String,Object&gt; getAllUserToMap();--&gt;&lt;select id=&quot;getAllUserToMap&quot; resultType=&quot;map&quot;&gt; select *from t_user;&lt;/select&gt; test 1234567@Testpublic void testGetAllUserToMap()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); SelectMapper mapper = sqlSession.getMapper(SelectMapper.class); List&lt;Map&lt;String, Object&gt;&gt; userByIdToMap = mapper.getAllUserToMap(); System.out.println(userByIdToMap);&#125; 方法二 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并 且最终要以一个map的方式返回数据，此时需要通过@MapKey注解设置map集合的键，值是每条数据所对应的 map集合 SelectMapper 123456 /* 查询所有用户信息在一个map中 */ //最后的大map集合是以id为键，一个map为值@MapKey(&quot;id&quot;)Map&lt;String,Object&gt; getAllUserToMap(); SelectMapper.xml 1234&lt;!--Map&lt;String,Object&gt; getAllUserToMap();--&gt;&lt;select id=&quot;getAllUserToMap&quot; resultType=&quot;map&quot;&gt; select *from t_user;&lt;/select&gt; test 1234567@Testpublic void testGetAllUserToMap()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); SelectMapper mapper = sqlSession.getMapper(SelectMapper.class); Map&lt;String,Object&gt; userByIdToMap = mapper.getAllUserToMap(); System.out.println(userByIdToMap);&#125; 结果 这是以id为键的大集合 12345678&#123;9=&#123;password=123456, gender=男, id=9, age=23, email=123@qq.com, username=admin&#125;, 10=&#123;password=123456, gender=女, id=10, age=22, email=342qq.com, username=root&#125;, 11=&#123;password=123456, gender=女, id=11, age=22, email=342qq.com, username=root&#125;, 12=&#123;password=123456, gender=女, id=12, age=22, email=342qq.com, username=root&#125;, 13=&#123;password=123456, gender=女, id=13, age=22, email=342qq.com, username=root&#125;, 14=&#123;password=123456, gender=女, id=14, age=22, email=342qq.com, username=root&#125;&#125; Mybatis特殊sql模糊查询新建specailSQLMapper 和specialSQLMapper.xml specailSQLMapper 1234/*通过用户名模糊查询用户信息 */List&lt;User&gt; getUserByLike(@Param(&quot;mohu&quot;) String mohu); specialSQLMapper.xml ‘%#{mohu}%’不行，#{}的原理是占位符，这样的话占位符在字符串中就失去意义了 ‘%${mohu}%’可以，因为${mohu}是字符串拼接原理，所以就没问题 下面三种方法都可以 1234567&lt;!-- List&lt;User&gt; getUserByLike(@Param(&quot;mohu&quot;) String mohu);--&gt;&lt;select id=&quot;getUserByLike&quot; resultType=&quot;User&quot;&gt; &lt;!--select * from t_user where username like &#x27;%$&#123;mohu&#125;%&#x27;--&gt; &lt;!--这个可以大概率是因为先用#&#123;mohu&#125;得到值再拼接字符串--&gt; &lt;!--select * from t_user where username like concat(&#x27;%&#x27;,#&#123;mohu&#125;,&#x27;%&#x27;);--&gt; select *from t_user where username like &quot;%&quot;#&#123;mohu&#125;&quot;%&quot;&lt;/select&gt; 测试 123456789public class SpecialSQLMapperTest &#123; @Test public void testGetUserByLike()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); SpecialSQLMapper mapper = sqlSession.getMapper(SpecialSQLMapper.class); List&lt;User&gt; list = mapper.getUserByLike(&quot;a&quot;); list.forEach(System.out::println); &#125;&#125; 批量删除SpecialSQLMapper 1234/*批量删除 */void deleteMoreUser(String ids); SpecialSQLMapper.xml 这个地方不能用#{ids}因为这个自动给参数加上单引号 sql语句就是：delete from t_user where id in(‘9,10’); 所以是不对的 用${ids}就不会自动加上单引号 sql语句就是：delete from t_user where id in(9,10);这个是正确的 1234&lt;!-- void deleteMoreUser(String ids);--&gt;&lt;delete id=&quot;deleteMoreUser&quot;&gt; delete from t_user where id in($&#123;ids&#125;);&lt;/delete&gt; SpecialSQLMapperTest 123456@Testpublic void testDeleteMoreUser()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); SpecialSQLMapper mapper = sqlSession.getMapper(SpecialSQLMapper.class); mapper.deleteMoreUser(&quot;9,10&quot;);&#125; 动态设置表名SpecialSQLMapper接口 1234/*动态设置表名，查询当前用户信息 */List&lt;User&gt; getUserList(@Param(&quot;tableName&quot;) String tableName); SpecialSQLMapper.xml 这里不能使用#{}因为这个会给语句加上单引号 select *from ‘tableName’ 用${}就是 select *from tableName这就是正确的 1234&lt;!-- List&lt;User&gt; getUserList(@Param(&quot;tableName&quot;) String tableName);--&gt;&lt;select id=&quot;getUserList&quot; resultType=&quot;User&quot;&gt; select *from $&#123;tableName&#125;&lt;/select&gt; test 1234567@Testpublic void testGetUserList()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); SpecialSQLMapper mapper = sqlSession.getMapper(SpecialSQLMapper.class); List&lt;User&gt; t_user = mapper.getUserList(&quot;t_user&quot;); t_user.forEach(System.out::println);&#125; 添加功能获取自增的主键（报错）场景模拟： t_clazz(clazz_id,clazz_name) ​ t_student(student_id,student_name,clazz_id) ​ 1、添加班级信息 ​ 2、获取新添加的班级的id ​ 3、为班级分配学生，即将某学的班级id修改为新添加的班级的id SpecialSQLMatter 1234/*添加用户信息，并获取自增的主键 */void insertUser(User user); SpecialSQLMatter.xml 123456&lt;!-- void insertUser(User user);--&gt;&lt;!--userGeneratedKeys是指是否获取主键，keyProperty是指将主键获取后赋给传递参数那个对象的哪个属性--&gt;&lt;!--因为增删改查sql方法默认都是返回数字的，所以不能用方法返回值作为获取id的值--&gt;&lt;select id=&quot;insertUser&quot; userGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into t_user values(null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;gender&#125;,#&#123;email&#125;)&lt;/select&gt; test 一开始user对象没有id，insertUser之后，id就有值了 12345678@Testpublic void testInsertUser()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); SpecialSQLMapper mapper = sqlSession.getMapper(SpecialSQLMapper.class); User user=new User(null,&quot;xiaoming&quot;,&quot;123456&quot;,23,&quot;女&quot;,&quot;3241525036@qq.com&quot;); mapper.insertUser(user); System.out.println(user);&#125; 自定义映射resultMap搭建mybatis 建立t_emp是员工信息表，里面的dept_id是员工所属部门的id 建立t_dept是部门信息表，里面的t_dept是部门的信息，部门的名字和id 处理字段名和属性名不一致的情况字段名和属性名不一致的情况下，如何处理映射关系 若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_），实体类中的属性名符合Java的规则（使用驼峰） 此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系 1.可以通过为字段起别名的方式，保证和实体类中的属性名保持一致 2.可以在MyBatis的核心配置文件中设置一个全局配置信息mapUnderscoreToCamelCase，可以在查询表中数据时，自动将_类型的字段名转换为驼峰 在mybatis-config.xml中加 12345678&lt;settings&gt; &lt;!--将下划线映射为驼峰--&gt; &lt;!-- 前面是字段，后面是映射成的驼峰 emp_id:empId, emp_name:empName --&gt;&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; EmpMatter 123456/** * 根据id来查询员工信息 * @param empId * @return */Emp getEmpById(@Param(&quot;empId&quot;) Integer empId); EmpMatter.xml 1234&lt;!-- Emp getEmpById(@Param(&quot;id&quot;) Integer id);--&gt;&lt;select id=&quot;getEmpById&quot; resultType=&quot;Emp&quot;&gt; select *from t_emp where emp_id=#&#123;empId&#125;&lt;/select&gt; test 12345678@Test public void testGetEmptyEmpId()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); Emp empById = mapper.getEmpById(1); System.out.println(empById);&#125; resultMap处理字段名和属性名不一致的情况EmpMatter 123456/** * 根据id来查询员工信息 * @param empId * @return */ Emp getEmpById(@Param(&quot;empId&quot;) Integer empId); EmpMatter.xml 123456789101112131415161718192021222324252627&lt;!--resultMap:设置自定义的映射关系id:唯一标识，就是在select标签中使用resultMap属性的时候那个value的值type:处理映射关系的实体类的类型，就是把那个数据表对应的java类的名字写上--&gt;&lt;!--resultMap常用的子标签id:处理主键和实体类属性的映射关系,也就是数据表主键用这个result:处理普通字段的实体类中属性的映射关系column:设置映射关系中的字段名，必须是sql查询出的某个字段property:设置映射关系中的属性的属性名，必须是处理的实体类类型中的属性名--&gt;&lt;resultMap id=&quot;empResultMap&quot; type=&quot;Emp&quot;&gt; &lt;id column=&quot;emp_id&quot; property=&quot;empId&quot;&gt;&lt;/id&gt; &lt;result column=&quot;emp_name&quot; property=&quot;empName&quot;&gt;&lt;/result&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;&gt;&lt;/result&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;&gt;&lt;/result&gt;&lt;/resultMap&gt;&lt;select id=&quot;getEmpById&quot; resultMap=&quot;empResultMap&quot;&gt; select *from t_emp where emp_id=#&#123;empId&#125;&lt;/select&gt; test 12345678910@Test public void testGetEmptyEmpId()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); Emp empById = mapper.getEmpById(1); System.out.println(empById);&#125; 处理多对一映射关系功能分析EMP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.atguigu.mybatis.pojo;public class Emp &#123; private Integer empId; private Dept dept; public Emp() &#123; &#125; public Dept getDept() &#123; return dept; &#125; public void setDept(Dept dept) &#123; this.dept = dept; &#125; @Override public String toString() &#123; return &quot;Emp&#123;&quot; + &quot;empId=&quot; + empId + &quot;, dept=&quot; + dept + &quot;, empName=&#x27;&quot; + empName + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public Integer getEmpId() &#123; return empId; &#125; public void setEmpId(Integer empId) &#123; this.empId = empId; &#125; public String getEmpName() &#123; return empName; &#125; public void setEmpName(String empName) &#123; this.empName = empName; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public Emp(Integer empId, Dept dept, String empName, Integer age, String gender) &#123; this.empId = empId; this.dept = dept; this.empName = empName; this.age = age; this.gender = gender; &#125; public Emp(Integer empId, String empName, Integer age, String gender) &#123; this.empId = empId; this.empName = empName; this.age = age; this.gender = gender; &#125; private String empName; private Integer age; private String gender;&#125; Dept 12345678910111213141516171819202122232425262728293031323334353637package com.atguigu.mybatis.pojo;public class Dept &#123; public Dept(Integer deptId, String deptName) &#123; this.deptId = deptId; this.deptName = deptName; &#125; private Integer deptId; @Override public String toString() &#123; return &quot;Dept&#123;&quot; + &quot;deptId=&quot; + deptId + &quot;, deptName=&#x27;&quot; + deptName + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public Integer getDeptId() &#123; return deptId; &#125; public void setDeptId(Integer deptId) &#123; this.deptId = deptId; &#125; public String getDeptName() &#123; return deptName; &#125; public void setDeptName(String deptName) &#123; this.deptName = deptName; &#125; private String deptName;&#125; 一对多多对一表关系解释一对多，两张表，多的表加外键 表一对多的意思是 一张表(父表)中的一条记录可以对应另一张表(子表)中的多条记录 就像一张部门表可以对应多个员工，但一个员工信息表只能对应部门表中的一条记录 多对一就是反过来 一堆员工在一个部门 多对一功能就是查询员工部门顺带查到它所在的部门的信息 一对多功能就是查询部门顺带查询其中员工的所有信息 所以就是在Emp类中加一个属性是Dept对象，来存储这个员工所处的部门的信息 1private Dept dept; EmpMapper.xml 这个sql语句是多表查询，可以查询到t_emp表中的所有员工以及员工对应的部门信息，但resultType是Emp肯定不行，因为查到的是dept的名字和id，不可能赋给emp中的dept的对象 123456789&lt;!--Emp getEmpAndDeptByEmpId(@Param(&quot;empId&quot;) Integer empId);--&gt;&lt;select id=&quot;getEmpAndDeptByEmpId&quot; resultType=&quot;Emp&quot;&gt; select t_emp.*,t_dept.* from t_emp left join t_dept on t_emp.dept_id=t_dept.dept_id where t_emp.emp_id=#&#123;empId&#125;&lt;/select&gt; 接下来是处理这个问题 处理多对一的映射关系： 1.级联方式处理（出错） dept是Emp中的Dept对象属性，所以property中就填这个dept.deptId和dept.deptName column就是两个分别对应的列字段名 12&lt;result column=&quot;dept_id&quot; property=&quot;dept.deptId&quot;&gt;&lt;/result&gt;&lt;result column=&quot;dept_name&quot; property=&quot;dept.deptName&quot;&gt;&lt;/result&gt; 1234567891011121314151617181920&lt;resultMap id=&quot;empAndDeptResultMap&quot; type=&quot;Emp&quot;&gt; &lt;id column=&quot;emp_id&quot; property=&quot;empId&quot;&gt;&lt;/id&gt; &lt;result column=&quot;emp_name&quot; property=&quot;empName&quot;&gt;&lt;/result&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;&gt;&lt;/result&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;&gt;&lt;/result&gt; &lt;result column=&quot;dept_id&quot; property=&quot;dept.deptId&quot;&gt;&lt;/result&gt; &lt;result column=&quot;dept_name&quot; property=&quot;dept.deptName&quot;&gt;&lt;/result&gt;&lt;/resultMap&gt;&lt;!--Emp getEmpAndDeptByEmpId(@Param(&quot;empId&quot;) Integer empId);--&gt;&lt;select id=&quot;getEmpAndDeptByEmpId&quot; resultMap=&quot;empAndDeptResultMap&quot;&gt; select t_emp.*,t_dept.* from t_emp left join t_dept on t_emp.dept_id=t_dept.dept_id where t_emp.emp_id=#&#123;empId&#125;&lt;/select&gt; EmpMapper 1234/*获取员工以及所对应的部门的信息 */Emp getEmpAndDeptByEmpId(@Param(&quot;empId&quot;) Integer empId); test 1234567@Testpublic void testGetEmpAndDeptByEmpId()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); Emp empById = mapper.getEmpAndDeptByEmpId(1); System.out.println(empById);&#125; association处理多对一映射 association标签：处理多对一的映射关系（处理实体类类型的属性） property:Emp中dept这个实体类对象的名字 javatype:dept这个实体类对象的类名 id 和result和之前一样，id是处理主键的映射，result是处理其他属性的映射， column是列字段名，property是dept这个实体类对象的属性名 1234&lt;association property=&quot;dept&quot; javaType=&quot;Dept&quot;&gt; &lt;id column=&quot;dept_id&quot; property=&quot;deptId&quot;&gt;&lt;/id&gt; &lt;result column=&quot;dept_name&quot; property=&quot;deptName&quot;&gt;&lt;/result&gt;&lt;/association&gt; 123456789101112131415161718192021&lt;resultMap id=&quot;empAndDeptResultMap&quot; type=&quot;Emp&quot;&gt; &lt;id column=&quot;emp_id&quot; property=&quot;empId&quot;&gt;&lt;/id&gt; &lt;result column=&quot;emp_name&quot; property=&quot;empName&quot;&gt;&lt;/result&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;&gt;&lt;/result&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;&gt;&lt;/result&gt; &lt;association property=&quot;dept&quot; javaType=&quot;Dept&quot;&gt; &lt;id column=&quot;dept_id&quot; property=&quot;deptId&quot;&gt;&lt;/id&gt; &lt;result column=&quot;dept_name&quot; property=&quot;deptName&quot;&gt;&lt;/result&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;!--Emp getEmpAndDeptByEmpId(@Param(&quot;empId&quot;) Integer empId);--&gt;&lt;select id=&quot;getEmpAndDeptByEmpId&quot; resultMap=&quot;empAndDeptResultMap&quot;&gt; select t_emp.*,t_dept.* from t_emp left join t_dept on t_emp.dept_id=t_dept.dept_id where t_emp.emp_id=#&#123;empId&#125;&lt;/select&gt; 分步查询处理多对一的映射 新建一个 DeptMapper用来查询dept表，所以就是最好一个mapper接口对应着一个表的操作 DeptMapper 因为最后是要给emp中的dept对象赋值所以第二次查询是用第一次查询的id做参数，得到Dept对象 123456789101112package com.atguigu.mybatis.mapper;import com.atguigu.mybatis.pojo.Dept;import org.apache.ibatis.annotations.Param;public interface DeptMapper &#123; /* 根据员工部门id查询部门信息 通过分布查询获取员工以及对应的部门信息的第一步 */ Dept getEmpAndDeptByStepTwo(@Param(&quot;deptId&quot;) Integer deptId);&#125; DeptMapper.xml 12345&lt;!-- Dept getEmpAndDeptByStepTwo(@Param(&quot;deptId&quot;) Integer deptId);--&gt;&lt;select id=&quot;getEmpAndDeptByStepTwo&quot; resultType=&quot;Dept&quot;&gt; select *from t_dept where t_dept.dept_id=#&#123;deptId&#125;&lt;/select&gt; EmpMapper 1234/*通过分布查询获取员工以及对应的部门信息的第一步 */Emp getEmpAndDeptByStepOne(@Param(&quot;empId&quot;) Integer empId); EmpMapper.xml 这个select对应的方法的返回值要和dept也就是property中那个对象的类型相同 1234567891011121314151617181920&lt;resultMap id=&quot;empAndDeptByStepResultMap&quot; type=&quot;Emp&quot;&gt; &lt;id column=&quot;emp_id&quot; property=&quot;empId&quot;&gt;&lt;/id&gt; &lt;result column=&quot;emp_name&quot; property=&quot;empName&quot;&gt;&lt;/result&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;&gt;&lt;/result&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;&gt;&lt;/result&gt; &lt;!-- peoperty：就是Emp中的那个需要处理映射关系的实体类对象的名字 select：设置分布查询的sql的唯一标识，就是选中mapper中的那个方法然后右键点击copy reference就可以获得它的唯一标识 column:将查询出的某个字段作为分布查询的下一步也就是select那个方法的参数，因为select标签那个方法参数是部门id所以这里column就是dept_id --&gt; &lt;association property=&quot;dept&quot; select=&quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot; column=&quot;dept_id&quot;&gt;&lt;/association&gt;&lt;/resultMap&gt;&lt;!-- Emp getEmpAndDeptByStepOne(@Param(&quot;empId&quot;) Integer empId);--&gt;&lt;select id=&quot;getEmpAndDeptByStepOne&quot; resultMap=&quot;empAndDeptByStepResultMap&quot;&gt; select *from t_emp where t_emp.emp_id=#&#123;empId&#125;&lt;/select&gt; mybatis分布查询的优势：延迟加载 可以实现就是有的时候想只要员工信息，有的时候想要员工信息以及对应的部门信息 mybatis-config.xml 1234&lt;!--开启延迟加载--&gt;&lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;&lt;!--按需加载，这个其实默认就是false--&gt;&lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; 123456789101112&lt;settings&gt; &lt;!--将下划线映射为驼峰--&gt; &lt;!-- 前面是字段，后面是映射成的驼峰 emp_id:empId, emp_name:empName --&gt;&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;!--开启延迟加载--&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;!--按需加载，这个其实默认就是false--&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; &lt;/settings&gt; test 12//这个地方只获得了员工的名字，所以不需要执行第二步的sql语句，这里可以用这个延迟加载System.out.println(empById.getEmpName()); 123456789@Testpublic void testGetEmpAndDeptByStep()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); Emp empById = mapper.getEmpAndDeptByStepOne(1); // System.out.println(empById); //这个地方只获得了员工的名字，所以不需要执行第二步的sql语句，这里可以用这个延迟加载 System.out.println(empById.getEmpName());&#125; 上面是进行了全局配置，对所有的分布查询都有效，现在想让有一些想让他不实现延迟加载 解决： fetchType属性可以指定这个分步查询是立即加载（eager）还是延迟加载(lazy) ，括号里是这个属性的value值 立即加载就是即使只要员工姓名，也会执行查询部门信息的那个sql语句 123&lt;association property=&quot;dept&quot; fetchType=&quot;eager&quot; select=&quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot; column=&quot;dept_id&quot;&gt;&lt;/association&gt; 处理一对多的映射关系的功能分析一对多就是一个部门中有很多的员工，就是实现查询部门信息的时候顺便也能查询到这个部门中员工的所有信息 在Dept表中加上一个属性 private List emps; 这个属性当中存储的是这个部门中的所有员工的信息 处理一对多的映射关系：1.collection 2.分布查询 1.collection属性:处理一对多的映射关系（处理集合类型的属性） DeptMapper 123456/** * 查询部门以及部门中的员工信息 * @param deptId * @return * */Dept getDeptAndEmpByDeptId(@Param(&quot;deptId&quot;) Integer deptId); DeptMapper.xml collection标签是用来对集合类型的属性进行映射的 就是Dept对象中存储多个员工信息的集合emps property的值就是这个集合类型属性的名字，ofType是这个集合中存储的元素的类型 id和result和之前一样 column是字段名，property就是emps中存储的emp对象中的属性名，要被映射处理的属性名 123456&lt;collection property=&quot;emps&quot; ofType=&quot;Emp&quot;&gt; &lt;id column=&quot;emp_id&quot; property=&quot;empId&quot;&gt;&lt;/id&gt; &lt;result column=&quot;emp_name&quot; property=&quot;empName&quot;&gt;&lt;/result&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;&gt;&lt;/result&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;&gt;&lt;/result&gt;&lt;/collection&gt; 123456789101112131415161718192021&lt;resultMap id=&quot;deptAndEmpResultMap&quot; type=&quot;Dept&quot;&gt; &lt;id column=&quot;dept_id&quot; property=&quot;deptId&quot;&gt;&lt;/id&gt; &lt;result column=&quot;dept_name&quot; property=&quot;deptName&quot;&gt;&lt;/result&gt; &lt;collection property=&quot;emps&quot; ofType=&quot;Emp&quot;&gt; &lt;id column=&quot;emp_id&quot; property=&quot;empId&quot;&gt;&lt;/id&gt; &lt;result column=&quot;emp_name&quot; property=&quot;empName&quot;&gt;&lt;/result&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;&gt;&lt;/result&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;&gt;&lt;/result&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;!-- Dept getDeptAndEmpByDeptId(@Param(&quot;deptId&quot;) Integer deptId);--&gt;&lt;!--这个sql语句是多表连接查询--&gt;&lt;select id=&quot;getDeptAndEmpByDeptId&quot; resultMap=&quot;deptAndEmpResultMap&quot;&gt; select t_dept.*,t_emp.* from t_dept left join t_emp on t_dept.dept_id=t_emp.dept_id where t_dept.dept_id=#&#123;deptId&#125;&lt;/select&gt; test 1234567@Testpublic void testGetDeptAndEmpByDeptId()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); DeptMapper mapper = sqlSession.getMapper(DeptMapper.class); Dept deptAndEmpByDeptId = mapper.getDeptAndEmpByDeptId(1); System.out.println(deptAndEmpByDeptId);&#125; 使用分步查询处理一对多的映射关系 DeptMapper 1234/*通过分布查询查询部门以及部门中的员工信息的第一步 */Dept getDeptAndEmpByStepOne(@Param(&quot;deptId&quot;)Integer deptId); DeptMapper.xml property是要赋值的属性，select是第二个sql语句的全名，第二个sql语句的返回值类型要和property中的那个类型一致 column是第二个sql语句的参数 123456789101112131415&lt;resultMap id=&quot;deptAndEmpResultMapByStep&quot; type=&quot;Dept&quot;&gt; &lt;id column=&quot;dept_id&quot; property=&quot;deptId&quot;/&gt; &lt;result column=&quot;dept_name&quot; property=&quot;deptName&quot;&gt;&lt;/result&gt; &lt;collection property=&quot;emps&quot; select=&quot;com.atguigu.mybatis.mapper.EmpMapper.getDeptAndEmpByStepTwo&quot; column=&quot;dept_id&quot; &gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;!-- Dept getDeptAndEmpByStepOne(@Param(&quot;deptId&quot;)Integer deptId);--&gt;&lt;select id=&quot;getDeptAndEmpByStepOne&quot; resultMap=&quot;deptAndEmpResultMapByStep&quot;&gt; select * from t_dept where dept_id=#&#123;deptId&#125;&lt;/select&gt; EmpMapper 123456/*通过分步查询获取部门以及部门的员工信息的第二步分布查询第二步的返回值类型一定要和要映射的那个属性类型相同用部门id作为参数查部门中的员工 */List&lt;Emp&gt; getDeptAndEmpByStepTwo(Integer deptId); EmpMapper.xml 1234&lt;!-- List&lt;Emp&gt; getDeptAndEmpByStepTwo(Integer deptId);--&gt;&lt;select id=&quot;getDeptAndEmpByStepTwo&quot; resultType=&quot;Emp&quot;&gt; select *from t_emp where dept_id=#&#123;deptId&#125;&lt;/select&gt; test 1234567@Testpublic void testGetDeptAndEmpByStep()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); DeptMapper mapper = sqlSession.getMapper(DeptMapper.class); Dept deptAndEmpByDeptId = mapper.getDeptAndEmpByStepOne(1); System.out.println(deptAndEmpByDeptId);&#125; 设为立即加载还是collection标签中加上fetchType属性设置为eager Mybatis动态sql就是比如选课的时候，有课外名师，有课程不冲突，有美术类型的，有创新类型的，选哪个过滤哪个，有的不选就不过滤，所以这个sql语句它不是固定的，它的条件不止有一个，也不是单纯的改参数，而是整个sql语句的长度 1.如何判断是否提交某个条件的问题，看这个表单项上传到服务器之后是否是null或者空字符串，如果不是就要加上这个条件 2.把这个条件拼接到sql中 if标签DynamicSQLMapper 123456/** * 根据条件查询员工信息 * @param emp * @return */ List&lt;Emp&gt; getEmpByCondition(Emp emp); DynamicSQLMapper.xml 1.if，通过test属性中的表达式判断标签内的内容是否有效，也就是是否是null或者空字符串(是否会拼接到sql中)，也就是判断表单传递的参数 方法的参数是Emp对象，判断它的属性是否有效可以直接用属性名，底下获取参数也是可以直接用属性名 12345678910111213&lt;!-- List&lt;Emp&gt; getEmpByCondition(Emp emp); --&gt;&lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;Emp&quot;&gt; select * from t_emp where &lt;if test=&quot;empName!=null and empName!=&#x27;&#x27;&quot;&gt; emp_name=#&#123;empName&#125; &lt;/if&gt; &lt;if test=&quot;age!=null and age!=&#x27;&#x27;&quot;&gt; and age=#&#123;age&#125; &lt;/if&gt; &lt;if test=&quot;gender!=null and gender!=&#x27;&#x27;&quot;&gt; and gender=#&#123;gender&#125; &lt;/if&gt;&lt;/select&gt; 执行的sql的语句的演示 1select * from t_emp where emp_name=? and age=? and gender=? where标签上面的第一种优化 DyanmicSQLMapper.xml 避免第一个条件不符合，或者都不符合的情况下sql语句错误 12345678910111213&lt;!-- List&lt;Emp&gt; getEmpByCondition(Emp emp); --&gt;&lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;Emp&quot;&gt; select * from t_emp where 1=1 &lt;if test=&quot;empName!=null and empName!=&#x27;&#x27;&quot;&gt; and emp_name=#&#123;empName&#125; &lt;/if&gt; &lt;if test=&quot;age!=null and age!=&#x27;&#x27;&quot;&gt; and age=#&#123;age&#125; &lt;/if&gt; &lt;if test=&quot;gender!=null and gender!=&#x27;&#x27;&quot;&gt; and gender=#&#123;gender&#125; &lt;/if&gt;&lt;/select&gt; 第二种优化 DyanmicSQLMapper.xml 123456789101112131415&lt;!-- List&lt;Emp&gt; getEmpByCondition(Emp emp); --&gt;&lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;Emp&quot;&gt; select * from t_emp &lt;where&gt; &lt;if test=&quot;empName!=null and empName!=&#x27;&#x27;&quot;&gt; emp_name=#&#123;empName&#125; &lt;/if&gt; &lt;if test=&quot;age!=null and age!=&#x27;&#x27;&quot;&gt; and age=#&#123;age&#125; &lt;/if&gt; &lt;if test=&quot;gender!=null and gender!=&#x27;&#x27;&quot;&gt; and gender=#&#123;gender&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; where标签的作用： 1.若where标签中有条件成立，会自动生成where关键字 2.会自动将where标签中内容前多余的and去掉,但是后面多余的and无法去掉 3.若where标签中没有任何一个条件成立，则where标签没有任何功能 trim标签第三种方法： DynamicSQLMapper.xml trim标签： prefix,suffix:在标签中内容前面，后面添加指定内容 prefixOverrides,suffixOverrides:在标签中内容前面，后面去掉指定内容 下面这种情况是把and放在后面，这样如果age符合条件，gender是null的话就会出错，所以用trim标签解决 123456789101112131415&lt;!-- List&lt;Emp&gt; getEmpByCondition(Emp emp); --&gt;&lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;Emp&quot;&gt; select * from t_emp &lt;trim prefix=&quot;where&quot; suffixOverrides=&quot;and&quot;&gt; &lt;if test=&quot;empName!=null and empName!=&#x27;&#x27;&quot;&gt; emp_name=#&#123;empName&#125; and &lt;/if&gt; &lt;if test=&quot;age!=null and age!=&#x27;&#x27;&quot;&gt; age=#&#123;age&#125; and &lt;/if&gt; &lt;if test=&quot;gender!=null and gender!=&#x27;&#x27;&quot;&gt; gender=#&#123;gender&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; choose when otherwise标签choose: when: 相当于if或者else if otherwise:相当于else 这个是其中有一个条件成立，其他的都不判断了 DynamicSQLMapper 1234/*使用choose来查询员工信息 */List&lt;Emp&gt; getEmpByChoose(Emp emp); DynamicSQLMapper.xml 这种如果empName成立了，后面也就不会再执行了，所以前面不用加and 1234567891011121314151617&lt;!-- List&lt;Emp&gt; getEmpByChoose(Emp emp); --&gt;&lt;select id=&quot;getEmpByChoose&quot; resultType=&quot;Emp&quot;&gt; select * from t_emp &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;empName!=null and empName!=&#x27;&#x27;&quot;&gt; emp_name=#&#123;empName&#125; &lt;/when&gt; &lt;when test=&quot;age!=null and age!=&#x27;&#x27;&quot;&gt; age=#&#123;age&#125; &lt;/when&gt; &lt;when test=&quot;gender!=null and gender!=&#x27;&#x27;&quot;&gt; gender=#&#123;gender&#125; &lt;/when&gt; &lt;/choose&gt; &lt;/where&gt; test 12345678@Testpublic void testGetEmpByChoose()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class); Emp emp=new Emp(null,&quot;张三&quot;,20,&quot;&quot;); List&lt;Emp&gt; list = mapper.getEmpByChoose(emp); list.forEach(System.out::println);&#125; foreach标签(获取list集合参数)批量添加 获取list形式的参数也用@Param(“emps”)，#{}是在sql语句中使用的用来获得参数的，在标签中不用 实现批量操作 DynamicSQLMapper 12345/*添加多条员工信息参数是一个存储员工信息的集合 */void insertMoreEmp(@Param(&quot;emps&quot;) List&lt;Emp&gt; emps); DynamicSQLMapper.xml collections中是要遍历的集合，item是集合中每一个元素 这里访问对象的属性，不能直接用属性名 要用对象名字.属性名 12345678&lt;!-- void insertMoreEmp(List&lt;Emp&gt; emps);--&gt;&lt;insert id=&quot;insertMoreEmp&quot;&gt; insert into t_emp values &lt;!--separator是每一次循环之间的分隔符的设置--&gt; &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;,&quot;&gt; (null,#&#123;emp.empName&#125;,#&#123;emp.age&#125;,#&#123;emp.gender&#125;,null) &lt;/foreach&gt;&lt;/insert&gt; TEST 12345678910111213@Test public void testInsertMoreEmp()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class); Emp emp1=new Emp(null,&quot;小明1&quot;,20,&quot;男&quot;); Emp emp2=new Emp(null,&quot;小明2&quot;,20,&quot;男&quot;); Emp emp3=new Emp(null,&quot;小明3&quot;,20,&quot;男&quot;); ArrayList&lt;Emp&gt; list1 = new ArrayList&lt;Emp&gt;();list1.add(emp1);list1.add(emp2);list1.add(emp3); mapper.insertMoreEmp(list1); &#125; 批量删除 DynamicSQLMapper 12345/*批量删除参数是存储的员工id的数组 */void deleteMoreEmp(@Param(&quot;empIds&quot;)Integer[] empIds); DynamicSQLMapper.xml empId是Integer类型的所以可以用#{empId}来获取 12345678910&lt;!-- void delteMoreEmp(@Param(&quot;empIds&quot;)Integer[] empIds);--&gt;&lt;delete id=&quot;deleteMoreEmp&quot;&gt; delete from t_emp where emp_id in ( &lt;foreach collection=&quot;empIds&quot; item=&quot;empId&quot; separator=&quot;,&quot;&gt; #&#123;empId&#125; &lt;/foreach&gt; )&lt;/delete&gt; test 1234567@Testpublic void testdeleteMoreEmp()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class); Integer[] empIds=new Integer[]&#123;5,6,7&#125;; mapper.deleteMoreEmp(empIds);&#125; 优化 12345678910&lt;!-- void delteMoreEmp(@Param(&quot;empIds&quot;)Integer[] empIds);--&gt;&lt;delete id=&quot;deleteMoreEmp&quot; &gt; delete from t_emp where emp_id in &lt;foreach collection=&quot;empIds&quot; item=&quot;empId&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; #&#123;empId&#125; &lt;/foreach&gt;&lt;/delete&gt; open和close属性代表循环以什么开始和以什么结束 优化2 123456789101112&lt;!-- void delteMoreEmp(@Param(&quot;empIds&quot;)Integer[] empIds);--&gt;&lt;delete id=&quot;deleteMoreEmp&quot; &gt; &lt;!-- delete from t_emp where emp_id in &lt;foreach collection=&quot;empIds&quot; item=&quot;empId&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; #&#123;empId&#125; &lt;/foreach&gt;--&gt; delete from t_emp where &lt;foreach collection=&quot;empIds&quot; item=&quot;empId&quot; separator=&quot;or&quot;&gt; emp_id=#&#123;empId&#125; &lt;/foreach&gt;&lt;/delete&gt; separator：设置每次循环的数据之间的分隔符，前后会自动加空格 优化2的sql语句 delete from t_emp where emp_id&#x3D;? or emp_id&#x3D;? or emp_id&#x3D;? sql标签就是把sql中每次都用到的片段进行封装，然后用include标签来进行引用，比如说*在mybatis中解析为所有字段名，你可以自己将所有字段名封装起来，然后去引用，也避免了mybatis的解析 123&lt;sql id=&quot;empColumns&quot;&gt; emp_id,emp_name,age,gender,dept_id&lt;/sql&gt; 1select &lt;include refid=&quot;empColumns&quot;&gt;&lt;/include&gt; from t_emp 123456789101112131415161718&lt;sql id=&quot;empColumns&quot;&gt; emp_id,emp_name,age,gender,dept_id&lt;/sql&gt;&lt;!-- List&lt;Emp&gt; getEmpByCondition(Emp emp); --&gt;&lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;Emp&quot;&gt; select &lt;include refid=&quot;empColumns&quot;&gt;&lt;/include&gt; from t_emp &lt;trim prefix=&quot;where&quot; suffixOverrides=&quot;and&quot;&gt; &lt;if test=&quot;empName!=null and empName!=&#x27;&#x27;&quot;&gt; emp_name=#&#123;empName&#125; and &lt;/if&gt; &lt;if test=&quot;age!=null and age!=&#x27;&#x27;&quot;&gt; age=#&#123;age&#125; and &lt;/if&gt; &lt;if test=&quot;gender!=null and gender!=&#x27;&#x27;&quot;&gt; gender=#&#123;gender&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; Mybatis缓存一级缓存：默认就是一级缓存 一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问 sqlSession级别，是指一级缓存生效的条件是同一个sqlSession 虽然执行了两次mapper.getEmpById(1);方法但是只用了一个sql语句这就是一级缓存，注意参数必须相同 test 123456789@Testpublic void testGetEmpById()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); CacheMapper mapper = sqlSession.getMapper(CacheMapper.class); Emp emp1 = mapper.getEmpById(1); System.out.println(emp1); Emp emp = mapper.getEmpById(1); System.out.println(emp);&#125; 一级缓存失效的四种情况 使一级缓存失效的四种情况： 不同的SqlSession对应不同的一级缓存 同一个SqlSession但是查询条件不同 同一个SqlSession两次查询期间执行了任何一次增删改操作 同一个SqlSession两次查询期间手动清空了缓存 test 中间进行了一个删除操作，就会清空一级缓存，这样就是总共执行3个sql语句 12345678910@Testpublic void testGetEmpById()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); CacheMapper mapper = sqlSession.getMapper(CacheMapper.class); Emp emp1 = mapper.getEmpById(1); System.out.println(emp1); mapper.deleteEmpById(4); Emp emp = mapper.getEmpById(1); System.out.println(emp);&#125; test 清空一级缓存用sqlSession.clearCache()方法 1234567891011@Testpublic void testGetEmpById()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); CacheMapper mapper = sqlSession.getMapper(CacheMapper.class); Emp emp1 = mapper.getEmpById(1); System.out.println(emp1); sqlSession.clearCache(); // mapper.deleteEmpById(4); Emp emp = mapper.getEmpById(1); System.out.println(emp);&#125; 二级缓存二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被 缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取 使用同一个SqlSessionFactory创建的sqlSession缓存都有效 二级缓存开启的条件： a&gt;在核心配置文件中，设置全局配置属性cacheEnabled&#x3D;”true”，默认为true，不需要设置 b&gt;在映射文件中设置标签 c&gt;二级缓存必须在SqlSession关闭或提交之后有效 d&gt;查询的数据所转换的实体类类型必须实现序列化的接口 实现接口 1public class Emp implements Serializable &#123; test 先关闭sqlSession才能将数据进入二级缓存 12//sqlSession1关闭之后才能将保存在一级缓存中的数据保存到二级缓存中sqlSession1.close(); 12345678910111213141516171819@Testpublic void testCache() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); SqlSession sqlSession1 = sqlSessionFactory.openSession(true); CacheMapper mapper1 = sqlSession1.getMapper(CacheMapper.class); Emp empById = mapper1.getEmpById(1); System.out.println(empById); //sqlSession1关闭之后才能将保存在一级缓存中的数据保存到二级缓存中 sqlSession1.close(); SqlSession sqlSession2 = sqlSessionFactory.openSession(true); CacheMapper mapper2 = sqlSession2.getMapper(CacheMapper.class); Emp empById2 = mapper2.getEmpById(1); System.out.println(empById2); sqlSession2.close();&#125; 使二级缓存失效的情况： 两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效 先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用。 如果二级缓存没有命中，再查询一级缓存 如果一级缓存也没有命中，则查询数据库 SqlSession关闭之后一级缓存中的数据会写入二级缓存 整合第三方缓存Ehache第三方缓存是在二级缓存的基础上来使用的 1.导入依赖 123456789101112&lt;!-- Mybatis EHCache整合包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- slf4j日志门面的一个具体实现 --&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt; 创建EHCache的配置文件ehcache.xml 在resources文件夹下 设置二级缓存的类型 1&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt; 加入logback日志 存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日 志。 创建logback的配置文件logback.xml 改动：name是自己的方mapper接口的包 1&lt;logger name=&quot;com.atguigu.mybatis.mapper&quot; level=&quot;DEBUG&quot;/&gt; resources下面的logback.xml 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration debug=&quot;true&quot;&gt; &lt;!-- 指定日志输出的位置 --&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;!-- 日志输出的格式 --&gt; &lt;!-- 按照顺序分别是： 时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt; &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;] [%-5level] [%thread] [%logger] [%msg]%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 设置全局日志级别。日志级别按顺序分别是： DEBUG、INFO、WARN、ERROR --&gt; &lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt; &lt;root level=&quot;DEBUG&quot;&gt; &lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt; &lt;appender-ref ref=&quot;STDOUT&quot; /&gt; &lt;/root&gt; &lt;!-- 根据特殊需求指定局部日志级别 --&gt; &lt;logger name=&quot;com.atguigu.mybatis.mapper&quot; level=&quot;DEBUG&quot;/&gt;&lt;/configuration&gt; mybatis的逆向工程正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。 Hibernate是支持正向工 程的。 逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成资源： Java实体类 Mapper接口 Mapper映射文件 先改了以下maven的镜像源 1234567891011&lt;mirror&gt;&lt;id&gt;nexus-aliyun&lt;/id&gt;&lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;name&gt;Nexus aliyun&lt;/name&gt;&lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;&lt;/mirror&gt; 添加依赖 pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;packaging&gt;jar&lt;/packaging&gt;&lt;dependencies&gt; &lt;!--依赖mybaits核心--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- log4j日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;!-- 控制Maven在构建过程中相关配置 --&gt;&lt;build&gt; &lt;!-- 构建过程中用到的插件 --&gt; &lt;plugins&gt; &lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;!-- 插件的依赖 --&gt; &lt;dependencies&gt; &lt;!-- 逆向工程的核心依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 在resources下加入generatorConfig.xml 1.\\是在当前工程目录下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!-- targetRuntime: 执行生成的逆向工程的版本 MyBatis3Simple: 生成基本的CRUD（清新简洁版） MyBatis3: 生成带条件的CRUD（奢华尊享版） --&gt; &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3Simple&quot;&gt; &lt;!-- 数据库的连接信息 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC&quot; userId=&quot;root&quot; password=&quot;root&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- javaBean的生成策略--&gt; &lt;!--targetPackage是生成的文件所在的包名，targetProject是整个包所在的文件夹--&gt; &lt;javaModelGenerator targetPackage=&quot;com.atguigu.mybatis.pojo&quot; targetProject=&quot;.\\src\\main\\java&quot;&gt; &lt;!--这个就是让com.atguigu.mybatis.pojo是多个包层级，而不是一个包的名字--&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;!--把字段前后空格去掉生成对应的属性--&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- SQL映射文件的生成策略 --&gt; &lt;!--下面这些标签的意思都和上面相同--&gt; &lt;sqlMapGenerator targetPackage=&quot;com.atguigu.mybatis.mapper&quot; targetProject=&quot;.\\src\\main\\resources&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- Mapper接口的生成策略 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.atguigu.mybatis.mapper&quot; targetProject=&quot;.\\src\\main\\java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 逆向分析的表 --&gt; &lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt; &lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt; &lt;!--tableName是需要逆向生成的表--&gt; &lt;table tableName=&quot;t_emp&quot; domainObjectName=&quot;Emp&quot;/&gt; &lt;table tableName=&quot;t_dept&quot; domainObjectName=&quot;Dept&quot;/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 点击mybatis-generator:generate进行逆向工程的运行 双击之后就会出现 类中的属性是根据mysql中的字段生成的 emp_id字段会自动生成empId 会自动变成驼峰形式 这个逆向工程不能给类中的对象类型的属性赋值，不支持多表联查的那种形式 byExample就是指通过条件，这个方法是通过条件获得记录数 这个可以通过所有的属性来删除 1234567/** * This method was generated by MyBatis Generator. * This method corresponds to the database table t_emp * * @mbggenerated Thu Oct 20 11:30:05 CST 2022 */int countByExample(EmpExample example); 这个只能通过id来删除 1int deleteByPrimaryKey(Integer empId); insert和insertSelective方法差别是，insert如果插入null，就真的是null，insertSelective如果插入为null，则插入的是mysql默认值 123456789int insert(Emp record);/** * This method was generated by MyBatis Generator. * This method corresponds to the database table t_emp * * @mbggenerated Thu Oct 20 11:30:05 CST 2022 */int insertSelective(Emp record); selectByExample可以通过任意属性来查询 selectByPrimatyKey只可以通过id属性查询 123456789List&lt;Emp&gt; selectByExample(EmpExample example);/** * This method was generated by MyBatis Generator. * This method corresponds to the database table t_emp * * @mbggenerated Thu Oct 20 11:30:05 CST 2022 */Emp selectByPrimaryKey(Integer empId); updateByExampleSelective如果修改哪个字段为null，就不会修改这个字段 updateByExample是null，也会修改这个字段 123456789int updateByExampleSelective(@Param(&quot;record&quot;) Emp record, @Param(&quot;example&quot;) EmpExample example);/** * This method was generated by MyBatis Generator. * This method corresponds to the database table t_emp * * @mbggenerated Thu Oct 20 11:30:05 CST 2022 */int updateByExample(@Param(&quot;record&quot;) Emp record, @Param(&quot;example&quot;) EmpExample example); 这两个是根据主键来实现修改功能 加上Selective那个也是如果属性为null不会给字段赋值 123456789int updateByPrimaryKeySelective(Emp record);/** * This method was generated by MyBatis Generator. * This method corresponds to the database table t_emp * * @mbggenerated Thu Oct 20 11:30:05 CST 2022 */int updateByPrimaryKey(Emp record); test 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.atguigu.mybatis.test;import com.atguigu.mybatis.mapper.EmpMapper;import com.atguigu.mybatis.pojo.Emp;import com.atguigu.mybatis.pojo.EmpExample;import com.atguigu.mybatis.utils.SqlSessionUtil;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import java.util.List;public class MBGTest &#123;@Test public void testMBG()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); //根据id查询数据 /*Emp emp = mapper.selectByPrimaryKey(1); System.out.println(emp); */ /* 根据条件查寻，不加任何条件，就是查询全部 List&lt;Emp&gt; emps = mapper.selectByExample(null); emps.forEach(System.out::println);*、 */ /* 根据条件查询员工信息 example对象就是条件，createCriteria()方法之后加.and然后你想要关于name的条件就.andEmpName然后会有方法 要求条件姓名(是张三，且年龄大于19岁)或者(性别为男) 对应的sql语句： &lt;!--select emp_id, emp_name, age, gender, dept_id from t_emp WHERE ( emp_name = ? and age &gt; ? ) or( gender = ? )--&gt; EmpExample example=new EmpExample(); example.createCriteria().andEmpNameEqualTo(&quot;张三&quot;).andAgeGreaterThan(19); example.or().andGenderEqualTo(&quot;男&quot;); List&lt;Emp&gt; emps = mapper.selectByExample(example);emps.forEach(System.out::println);*/ /* 根据id来修改员工信息，所以emp对象中的id属性要和你想修改的那一行数据的id相同 */ /* updateByPrimaryKeySelective如果修改的属性为null就不会修改了 updateByPrimaryKey如果修改了为null就真是为null */ Emp emp=new Emp(1,&quot;小黑&quot;,null,&quot;女&quot;); // mapper.updateByPrimaryKey(emp);mapper.updateByPrimaryKeySelective(emp);&#125;&#125; 分页插件limit index,pageSize pageSize:每页显示的条数 pageNum:当前页的页码 index:当前页的起始索引 (pageNum-1)*pageSize 要显示的是第九条，那索引就是8 pageSize&#x3D;4，pageNum&#x3D;1，index&#x3D;0 limit 0,4 pageSize&#x3D;4，pageNum&#x3D;3，index&#x3D;8 limit 8,4 pageSize&#x3D;4，pageNum&#x3D;6，index&#x3D;20 limit 8,4 count：总记录数 totalPage：总页数 totalPage &#x3D; count &#x2F; pageSize; if(count % pageSize !&#x3D; 0) { totalPage +&#x3D; 1; } 分页插件的使用步骤添加依赖 pom.xml文件中添加依赖 123456&lt;!--分页插件的依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt;&lt;/dependency&gt; 配置插件分页 在mybatis-config.xml中加入 123&lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;&lt;/plugin&gt;&lt;/plugins&gt; 分页插件的使用这个测试显示的第二页的四条记录 12345678910111213141516171819202122232425262728package com.atguigu.mybatis.test;import com.atguigu.mybatis.mapper.EmpMapper;import com.atguigu.mybatis.pojo.Emp;import com.atguigu.mybatis.utils.SqlSessionUtil;import com.github.pagehelper.PageHelper;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import java.util.List;public class PageTest &#123; @Test public void testPage()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); //开启分页功能，参数是第几页和一页的记录数 //如果只有一个参数，则是每页有几条记录，默认显示第一页 PageHelper.startPage(2,4); //查询功能之前要开启分页功能 List&lt;Emp&gt; emps = mapper.selectByExample(null); emps.forEach(System.out::println); &#125;&#125; 优化 pageInfo是获取分页相关的所有数据比page要更详细一点 1PageInfo&lt;Emp&gt; pageInfo=new PageInfo&lt;&gt;(emps,5); 123456789101112131415161718192021222324252627@Testpublic void testPage()&#123; SqlSession sqlSession = SqlSessionUtil.getSqlSession(); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); //开启分页功能，参数是第几页和一页的记录数 //如果只有一个参数，则是每页有几条记录，默认显示第一页 //page就是分页对象 Page&lt;Object&gt; page = PageHelper.startPage(2, 4); //查询功能之前要开启分页功能 List&lt;Emp&gt; emps = mapper.selectByExample(null); emps.forEach(System.out::println); //查询功能之后可以获取分页相关的所有数据 //navigatePages:导航分页的页码首页上一页【导航页】下一页末页 PageInfo&lt;Emp&gt; pageInfo=new PageInfo&lt;&gt;(emps,5); //输出pageInfo对象 System.out.println(pageInfo); //输出查询之后的分页对象 System.out.println(page);&#125; pageInfo的信息 可以从当中获取分页的信息，在进行分页处理的时候可以直接用 12345678910111213141516171819202122232425 /* pageInfo信息 */ //PageInfo&#123; // pageNum=2, pageSize=4, size=4, // startRow=5, endRow=8, total=30, // pages=8, list=Page&#123;count=true, pageNum=2, pageSize=4, startRow=4, endRow=8, total=30, pages=8, reasonable=false, pageSizeZero=false&#125;[Emp&#123;empId=5, empName=&#x27;a&#x27;, age=null, gender=&#x27;null&#x27;, deptId=null&#125;, Emp&#123;empId=6, empName=&#x27;aa&#x27;, age=null, gender=&#x27;null&#x27;, deptId=null&#125;, Emp&#123;empId=7, empName=&#x27;a&#x27;, age=null, gender=&#x27;null&#x27;, deptId=null&#125;, Emp&#123;empId=8, empName=&#x27;a&#x27;, age=null, gender=&#x27;null&#x27;, deptId=null&#125;], // prePage=1, nextPage=3, isFirstPage=false, // isLastPage=false, hasPreviousPage=true, // hasNextPage=true, navigatePages=5, // navigateFirstPage=1, navigateLastPage=5, navigatepageNums=[1, 2, 3, 4, 5]&#125;/*pageNum：当前页的页码pageSize：每页显示的条数size：当前页显示的真实条数total：总记录数pages：总页数prePage：上一页的页码nextPage：下一页的页码isFirstPage/isLastPage：是否为第一页/最后一页hasPreviousPage/hasNextPage：是否存在上一页/下一页navigatePages：导航分页的页码数navigatepageNums：导航分页的页码，[1,2,3,4,5] */","categories":[],"tags":[]},{"title":"spring","slug":"spring","date":"2022-11-04T15:31:35.000Z","updated":"2022-11-04T02:59:44.637Z","comments":true,"path":"2022/11/04/spring/","link":"","permalink":"http://example.com/2022/11/04/spring/","excerpt":"","text":"SpringSpring是一个轻量级框架 SpringFramework基础框架，其他所有的Spring都是以它为基础的 IOCIOC思想IOC：Inversion of Control，翻译过来是反转控制。 传统的： 在应用程序中的组件需要获取资源时，传统的方式是组件主动的从容器中获取所需要的资源，在这样的 模式下开发人员往往需要知道在具体容器中特定资源的获取方式，增加了学习成本，同时降低了开发效 率。 反转控制ioc： 反转控制的思想完全颠覆了应用程序组件获取资源的传统方式：反转了资源的获取方向——改由容器主 动的将资源推送给需要的组件，开发人员不需要知道容器是如何创建资源对象的，只需要提供接收资源 的方式即可，极大的降低了学习成本，提高了开发的效率。这种行为也称为查找的被动形式。 ioc思想总结 传统方式中需要我们自己去new对象，现在有了spring之后我们需要哪个对象通过springioc容器进行赋值就可以了，这个是通过DI来实现的，依赖哪个对象，就可以以提前定义好的方式（构造器，setter方法），被动的去接受spring所注入的对象 也就是依赖哪个对象，ioc就可以给哪个对象赋值 DI DI：Dependency Injection，翻译过来是依赖注入。 DI是IOC的一种实现方式，即组件以一些预先定义好的方式（例如：setter 方法）接受来自于ioc容器的资源注入。 接受ioc容器的资源注入其实就是接受ioc容器对属性的赋值 ioc容器在spring中的实现两种实现方式： BeanFactory: 这是 IOC 容器的基本实现，是 Spring 内部使用的接口。面向 Spring 本身，不提供给开发人员使用。 ApplicationContext: BeanFactory 的子接口，提供了更多高级特性。面向 Spring 的使用者，几乎所有场合都使用 ApplicationContext 而不是底层的 BeanFactory。 创建一个新的模块，测试spring 在pom.xml中导入依赖 12345678910111213141516&lt;packaging&gt;jar&lt;/packaging&gt;&lt;dependencies&gt; &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ioc的实现类 最常用的是ClassPathXmlApplicationContext是实现类，因为它是从工程路径中读取ioc容器（也就是那个spring的xml配置文件） FileSystemXmlApplicationContext是通过硬盘路径读取ioc容器，之后工程要打包成jar不一定在自己的计算机上执行，所以不用这个 基于xml管理bean入门案例创建module，引入依赖，上面做过了 pom.xml 123456789101112131415&lt;dependencies&gt; &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建类Helloword 在java下新建com.atguigu.spring.pojo包下 12345678package com.atguigu.spring.pojo;public class HelloWorld &#123; public void sayHello()&#123; System.out.println(&quot;hello spring&quot;); &#125;&#125; 创建Spring配置文件在resources文件夹下 applicationContext.xml springioc的配置文件 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- bean:配置一个bean对象，将对象交给ioc容器管理 属性： id: bean的唯一标识 class:设置bean对象所对应的类型的全类名 --&gt; &lt;bean id=&quot;helloworld&quot; class=&quot;com.atguigu.spring.pojo.HelloWorld&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; test 1234567891011121314151617181920package com.atguigu.spring.test;import com.atguigu.spring.pojo.HelloWorld;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class HelloWorldTest &#123; @Test public void test()&#123; //获取IOC容器 //new ClassPathXmlApplicationContext直接定位到targer/classes下，java和resources加载后都在这个下面 ApplicationContext ioc=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //根据bean的id当作name来作为getBean参数获取对象,然后自己强转 HelloWorld helloworld = (HelloWorld) ioc.getBean(&quot;helloworld&quot;); helloworld.sayHello(); &#125;&#125; new ClassPathXmlApplicationContext(“applicationContext.xml”);定位到target&#x2F;classes&#x2F;下，就是java和resources加载之后其实都是在target&#x2F;classes&#x2F;下 ioc容器获取bean的方式重新建一个模块，spring_ioc_xml 创建一个student类在java包下的com.atguigu.spring.pojo包中 Student 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.atguigu.spring.pojo;public class Student &#123;private Integer sid; public Student() &#123; &#125; public Student(Integer sid, String sname, Integer age, String gender) &#123; this.sid = sid; this.sname = sname; this.age = age; this.gender = gender; &#125; public String getGender() &#123; return gender; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;sid=&quot; + sid + &quot;, sname=&#x27;&quot; + sname + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public Integer getSid() &#123; return sid; &#125; public void setSid(Integer sid) &#123; this.sid = sid; &#125; public String getSname() &#123; return sname; &#125; public void setSname(String sname) &#123; this.sname = sname; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; private String sname;private Integer age;private String gender;&#125; ioc创建对象原理就是反射，配置文件中给了全类名之后用.forName()方法获得这个类的Class对象，然后再newInstance创建实体类对象 所以pojo类中一定要有无参构造，通过反射创建对象大部分都是用无参构造 获取bean对象的三种方法 1.通过bean的id获取 2.根据bean的类型 3.根据bean的id和bean的类型 test 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.atguigu.spring.test;import com.atguigu.spring.pojo.Person;import com.atguigu.spring.pojo.Student;import com.sun.glass.ui.Application;import com.sun.org.apache.bcel.internal.util.ClassPath;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import sun.security.mscapi.CPublicKey;public class IOCByXMLTest &#123; @Test public void testIOC() &#123; //获取ioc容器 ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean //根据id来获取 //Student studentOne = (Student)ioc.getBean(&quot;studentOne&quot;); //通过类型来获取(用的多，因为一个类型的bean只需要写一次就够了) /* &lt;bean id=&quot;studentOne&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;studentTwo&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt;&lt;/bean&gt; 如果就是有两个id不一样但是class相同的bean就没法通过类型来获取，会报错NoUniqueBeanDefinitionException 如果没有相匹配的bean,也会报NoSuchBeanDefinitionException错 Student studentOne = ioc.getBean(Student.class); */ /* 根据bean的id和类型来获取 Student studentOne = ioc.getBean(&quot;studentOne&quot;, Student.class); */ /* 当有一个接口只有一个实现类的时候，可以通过接口的类型获取这个接口实现类的对象，同时是把这个实现类对象赋值给接口引用变量 */ Person studentOne = ioc.getBean(Person.class); System.out.println(studentOne); &#125;&#125; 当有一个接口只有一个实现类的时候，可以通过接口的类型获取这个接口实现类的对象，同时是把这个实现类对象赋值给接口引用变量 Person接口 1234package com.atguigu.spring.pojo;public interface Person &#123;&#125; Student implements Person test 12345/*当有一个接口只有一个实现类的时候，可以通过接口的类型获取这个接口实现类的对象，同时是把这个实现类对象赋值给接口引用变量 */Person studentOne = ioc.getBean(Person.class);System.out.println(studentOne); 小结： 根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 instanceof 指定的类 型』的返回结果，只要返回的是true就可以认定为和类型匹配，能够获取到。 即通过bean的类型，只被bean继承的类的类型，只被bean所实现的接口的类型都可以获取bean 依赖注入setter注入Student类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.atguigu.spring.pojo;public class Student implements Person &#123;private Integer sid; public Student() &#123; &#125; public Student(Integer sid, String sname, Integer age, String gender) &#123; this.sid = sid; this.sname = sname; this.age = age; this.gender = gender; &#125; public String getGender() &#123; return gender; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;sid=&quot; + sid + &quot;, sname=&#x27;&quot; + sname + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public Integer getSid() &#123; return sid; &#125; public void setSid(Integer sid) &#123; this.sid = sid; &#125; public String getSname() &#123; return sname; &#125; public void setSname(String sname) &#123; this.sname = sname; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; private String sname;private Integer age;private String gender;&#125; applicationContext.xml 123456789101112&lt;bean id=&quot;studentTwo&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt; &lt;!-- property:通过成员变量的set方法进行赋值 name:设置需要赋值的属性名(和set方法有关) value:设置为属性所附的值 --&gt; &lt;property name=&quot;sid&quot; value=&quot;1001&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sname&quot; value=&quot;张三&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/property&gt;&lt;/bean&gt; test 123456789@Testpublic void testDI()&#123; //获取ioc容器 ApplicationContext ioc= new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean Student student = ioc.getBean(&quot;studentTwo&quot;, Student.class); System.out.println(student);&#125; 结果： Student{sid&#x3D;1001, sname&#x3D;’张三’, age&#x3D;23, gender&#x3D;’男’} 依赖注入之构造器注入applicationContext.xml 1234567&lt;bean id=&quot;studentThree&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt; &lt;constructor-arg value=&quot;1002&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;李四&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;24&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;女&quot; &gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 这个的赋值顺序就是按照构造器的中参数顺序进行赋值的 123456public Student(Integer sid, String sname, Double score, String gender) &#123; this.sid = sid; this.sname = sname; this.gender=gender; this.score=score;&#125; 如果有两个参数个数重复且不一样的参数的地方类型可兼容的构造器，可以用name属性 12345678910111213public Student(Integer sid, String sname, Integer age, String gender) &#123; this.sid = sid; this.sname = sname; this.age = age; this.gender = gender;&#125;public Student(Integer sid, String sname, Double score, String gender) &#123; this.sid = sid; this.sname = sname; this.gender=gender; this.score=score;&#125; applicationContext.xml name是指构造器的参数的名字，这样即使调用的给age赋值的构造器，而不是给score赋值的构造器 1234567&lt;bean id=&quot;studentThree&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt; &lt;constructor-arg value=&quot;1002&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;李四&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;24&quot; name=&quot;age&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;女&quot; &gt;&lt;/constructor-arg&gt;&lt;/bean&gt; test 123456789@Testpublic void testDI2()&#123; //获取ioc容器 ApplicationContext ioc= new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean Student student = ioc.getBean(&quot;studentThree&quot;, Student.class); System.out.println(student);&#125; 如果不确定的话 其实可以把bean对象全都加上name标签，这样就可以一一对应了 特殊值处理1,给属性赋值字面量 什么是字面量？ int a &#x3D; 10; 声明一个变量a，初始化为10，此时a就不代表字母a了，而是作为一个变量的名字。当我们引用a 的时候，我们实际上拿到的值是10。 而如果a是带引号的：’a’，那么它现在不是一个变量，它就是代表a这个字母本身，这就是字面量。所以字面量没有引申含义，就是我们看到的这个数据本身。 12&lt;!-- 使用value属性给bean的属性赋值时，Spring会把value属性的值看做字面量 --&gt;&lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt; 2.给属性设置null值 123456789&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt; &lt;property name=&quot;sid&quot; value=&quot;100&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sname&quot; value=&quot;王五&quot;&gt;&lt;/property&gt; &lt;!--给属性设置null--&gt; &lt;property name=&quot;gender&quot;&gt; &lt;null /&gt; &lt;/property&gt;&lt;/bean&gt; 注意： 以下写法，为name所赋的值是字符串nul 1&lt;property name=&quot;name&quot; value=&quot;null&quot;&gt;&lt;/property&gt; 3.xml实体 &lt;和&gt;在xml中是特殊字符， 1所以得用&amp;lt;和&amp;gt;代替 1234567891011121314&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt; &lt;property name=&quot;sid&quot; value=&quot;100&quot;&gt;&lt;/property&gt; &lt;!-- &lt;: &amp;lt; &gt;: &amp;gt; --&gt; &lt;property name=&quot;sname&quot; value=&quot;&amp;lt;王五&amp;gt;&quot;&gt;&lt;/property&gt; &lt;!--给属性设置null--&gt; &lt;property name=&quot;gender&quot;&gt; &lt;null /&gt; &lt;/property&gt;&lt;/bean&gt; 12输出Student&#123;sid=100, score=null, sname=&#x27;&lt;王五&gt;&#x27;, age=null, gender=&#x27;null&#x27;&#125; 4.CDATA节 用CDATA节要把value属性拿出来，在里面用作标签，然后中间内容可以随便写 1&lt;![CDATA[中间]]&gt; 1234567&lt;property name=&quot;sname&quot;&gt; &lt;!-- 解决方案二：使用CDATA节 --&gt; &lt;!-- CDATA中的C代表Character，是文本、字符的含义，CDATA就表示纯文本数据 --&gt; &lt;!-- XML解析器看到CDATA节就知道这里是纯文本，就不会当作XML标签或属性来解析 --&gt; &lt;!-- 所以CDATA节中写什么符号都随意 --&gt; &lt;value&gt;&lt;![CDATA[&lt;王五&gt;]]&gt;&lt;/value&gt; &lt;/property&gt; 123456789101112131415161718192021&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt; &lt;property name=&quot;sid&quot; value=&quot;100&quot;&gt;&lt;/property&gt; &lt;!-- &lt;: &amp;lt; &gt;: &amp;gt; --&gt; &lt;property name=&quot;sname&quot;&gt; &lt;!-- 解决方案二：使用CDATA节 --&gt; &lt;!-- CDATA中的C代表Character，是文本、字符的含义，CDATA就表示纯文本数据 --&gt; &lt;!-- XML解析器看到CDATA节就知道这里是纯文本，就不会当作XML标签或属性来解析 --&gt; &lt;!-- 所以CDATA节中写什么符号都随意 --&gt; &lt;value&gt;&lt;![CDATA[&lt;王五&gt;]]&gt;&lt;/value&gt; &lt;/property&gt; &lt;!--给属性设置null--&gt; &lt;property name=&quot;gender&quot;&gt; &lt;null /&gt; &lt;/property&gt;&lt;/bean&gt; 为类类型属性赋值给Student加一个clazz对象属性 第一种方式（用的多）：引入外部的bean 这个是属性是一个类的对象的赋值操作 applicationContext.xml 123456789101112131415&lt;bean id=&quot;studentFive&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt; &lt;property name=&quot;sid&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sname&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/property&gt; &lt;!--给对象属性进行赋值--&gt; &lt;!--应用当前ioc中某一个bean的id来为clazz对象赋值--&gt; &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;clazzOne&quot; class=&quot;com.atguigu.spring.pojo.Clazz&quot;&gt; &lt;property name=&quot;cid&quot; value=&quot;1111&quot;&gt;&lt;/property&gt; &lt;property name=&quot;cname&quot; value=&quot;最强王者班&quot;&gt;&lt;/property&gt;&lt;/bean&gt; test 123456789@Testpublic void testDI2()&#123; //获取ioc容器 ApplicationContext ioc= new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean Student student = ioc.getBean(&quot;studentFive&quot;, Student.class); System.out.println(student);&#125; 结果：Student{sid&#x3D;1004, score&#x3D;null, clazz&#x3D;Clazz{cid&#x3D;1111, cname&#x3D;’最强王者班’}, sname&#x3D;’赵六’, age&#x3D;26, gender&#x3D;’男’} 第二种方法： 级联的方式，但提前要为clazz属性赋值 1234567891011&lt;bean id=&quot;studentFive&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt; &lt;property name=&quot;sid&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sname&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/property&gt; &lt;!--ref:应用ioc容器中的某一个bean的值--&gt; &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazz.cid&quot; value=&quot;222&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazz.cname&quot; value=&quot;远大前程班&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 第三种方法： 这个是通过内部bean的方式进行赋值的，这个内部bean只能在它外部bean的内部来使用，不能通过ioc容器来直接获取 1234567891011121314&lt;bean id=&quot;studentFive&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt; &lt;property name=&quot;sid&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sname&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazz&quot;&gt; &lt;!--内部bean的使用--&gt; &lt;bean id=&quot;clazzInner&quot; class=&quot;com.atguigu.spring.pojo.Clazz&quot;&gt; &lt;property name=&quot;cid&quot; value=&quot;222&quot;&gt;&lt;/property&gt; &lt;property name=&quot;cname&quot; value=&quot;远大前程班&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 为数组类型的属性赋值给Student加一个private String[]hobby属性 当数组中是字面量类型的数据的时候，用value标签 12345678910111213141516171819202122&lt;bean id=&quot;studentFive&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt; &lt;property name=&quot;sid&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sname&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazz&quot;&gt; &lt;bean id=&quot;clazzInner&quot; class=&quot;com.atguigu.spring.pojo.Clazz&quot;&gt; &lt;property name=&quot;cid&quot; value=&quot;222&quot;&gt;&lt;/property&gt; &lt;property name=&quot;cname&quot; value=&quot;远大前程班&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!--给数组变量赋值--&gt; &lt;property name=&quot;hobby&quot;&gt; &lt;array&gt; &lt;value&gt;抽烟&lt;/value&gt; &lt;value&gt;喝酒&lt;/value&gt; &lt;value&gt;烫头&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 给Clazz加一个private Student[] stus属性，给元素是对象的数组赋值用ref 12345678910&lt;bean id=&quot;clazzTwo&quot; class=&quot;com.atguigu.spring.pojo.Clazz&quot;&gt; &lt;property name=&quot;cid&quot; value=&quot;2222&quot;&gt;&lt;/property&gt; &lt;property name=&quot;cname&quot; value=&quot;好办&quot;&gt;&lt;/property&gt; &lt;property name=&quot;stus&quot;&gt; &lt;array&gt; &lt;ref bean=&quot;studentFive&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;studentFour&quot;&gt;&lt;/ref&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; test 123456789@Testpublic void testDI2()&#123; //获取ioc容器 ApplicationContext ioc= new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean Clazz clazz = ioc.getBean(&quot;clazzTwo&quot;, Clazz.class); System.out.println(clazz);&#125; 结果：Clazz{cid&#x3D;2222, stus&#x3D;[Student{sid&#x3D;1004, hobby&#x3D;[抽烟, 喝酒, 烫头], score&#x3D;null, clazz&#x3D;Clazz{cid&#x3D;222, stus&#x3D;null, cname&#x3D;’远大前程班’}, sname&#x3D;’赵六’, age&#x3D;26, gender&#x3D;’男’}, Student{sid&#x3D;100, hobby&#x3D;null, score&#x3D;null, clazz&#x3D;null, sname&#x3D;’&lt;王五&gt;’, age&#x3D;null, gender&#x3D;’null’}], cname&#x3D;’好办’} 为集合类型的属性进行赋值为list集合赋值 第一种： 这个是对list集合中如果存储的是对象类型的数据时list标签中用ref ，如果list集合中存储的是字面量类型的那就是用value标签，和上面的数组类型差不多 12345678910111213&lt;!--list集合中存储的是对象类型的进行赋值--&gt;&lt;bean id=&quot;clazzOne&quot; class=&quot;com.atguigu.spring.pojo.Clazz&quot;&gt; &lt;property name=&quot;cid&quot; value=&quot;1111&quot;&gt;&lt;/property&gt; &lt;property name=&quot;cname&quot; value=&quot;最强王者班&quot;&gt;&lt;/property&gt; &lt;property name=&quot;students&quot; &gt; &lt;list&gt; &lt;ref bean=&quot;studentFive&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;studentFour&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;studentThree&quot;&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 第二种： 用list类型的bean对它直接进行赋值 1234567891011121314&lt;!--list集合中存储的是对象类型的进行赋值--&gt;&lt;bean id=&quot;clazzOne&quot; class=&quot;com.atguigu.spring.pojo.Clazz&quot;&gt; &lt;property name=&quot;cid&quot; value=&quot;1111&quot;&gt;&lt;/property&gt; &lt;property name=&quot;cname&quot; value=&quot;最强王者班&quot;&gt;&lt;/property&gt; &lt;property name=&quot;students&quot; ref=&quot;studentsList&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--配置一个集合类型的bean，需要使用util的约束，也就是util的标签--&gt;&lt;!--util是标签得前缀，用来区分各种list标签--&gt;&lt;util:list id=&quot;studentsList&quot;&gt; &lt;ref bean=&quot;studentOne&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;studentTwo&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;studentThree&quot;&gt;&lt;/ref&gt;&lt;/util:list&gt; test 123456789@Testpublic void testDI2()&#123; //获取ioc容器 ApplicationContext ioc= new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean Clazz clazz = ioc.getBean(&quot;clazzOne&quot;, Clazz.class); System.out.println(clazz);&#125; 为map集合类型的属性赋值 创建一个Teacher类 给Student中添加一个private Map&lt;String,Teacher&gt; teacherMap;对象用来存储老师的map集合 第一种方式： 12345678910111213141516171819202122&lt;bean id=&quot;studentFive&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt; &lt;property name=&quot;sid&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sname&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/property&gt; &lt;property name=&quot;teacherMap&quot;&gt; &lt;!--一个entry表示一个键值对，key如果是字面量就用key属性，如果是对象就用key-ref value也是同理--&gt; &lt;map&gt; &lt;entry key=&quot;10086&quot; value-ref=&quot;teacherOne&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;10010&quot; value-ref=&quot;teacherTwo&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;teacherOne&quot; class=&quot;com.atguigu.spring.pojo.Teacher&quot;&gt; &lt;property name=&quot;tid&quot; value=&quot;10086&quot;&gt;&lt;/property&gt; &lt;property name=&quot;tname&quot; value=&quot;大宝&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;teacherTwo&quot; class=&quot;com.atguigu.spring.pojo.Teacher&quot;&gt; &lt;property name=&quot;tid&quot; value=&quot;10011&quot;&gt;&lt;/property&gt; &lt;property name=&quot;tname&quot; value=&quot;小宝&quot;&gt;&lt;/property&gt;&lt;/bean&gt; test 123456789@Testpublic void testDI()&#123; //获取ioc容器 ApplicationContext ioc= new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean Student student = ioc.getBean(&quot;studentFive&quot;, Student.class); System.out.println(student);&#125; 第二种方式： 设置一个map类型的bean，然后直接进行引用赋值 1234567891011121314151617181920212223 &lt;bean id=&quot;studentFive&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt; &lt;property name=&quot;sid&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sname&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/property&gt; &lt;!--直接对map类型的bean进行引用--&gt; &lt;property name=&quot;teacherMap&quot; ref=&quot;teacherMap&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--创建一个map类型的bean--&gt;&lt;util:map id=&quot;teacherMap&quot;&gt; &lt;entry key=&quot;10086&quot; value-ref=&quot;teacherOne&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;10010&quot; value-ref=&quot;teacherTwo&quot;&gt;&lt;/entry&gt;&lt;/util:map&gt; &lt;bean id=&quot;teacherOne&quot; class=&quot;com.atguigu.spring.pojo.Teacher&quot;&gt; &lt;property name=&quot;tid&quot; value=&quot;10086&quot;&gt;&lt;/property&gt; &lt;property name=&quot;tname&quot; value=&quot;大宝&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;teacherTwo&quot; class=&quot;com.atguigu.spring.pojo.Teacher&quot;&gt; &lt;property name=&quot;tid&quot; value=&quot;10011&quot;&gt;&lt;/property&gt; &lt;property name=&quot;tname&quot; value=&quot;小宝&quot;&gt;&lt;/property&gt; &lt;/bean&gt; test 12345678910@Testpublic void testDI()&#123; //获取ioc容器 ApplicationContext ioc= new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean Student student = ioc.getBean(&quot;studentFive&quot;, Student.class); System.out.println(student);&#125; 依赖注入之p命名空间12&lt;bean id=&quot;studentSix&quot; class=&quot;com.atguigu.spring.pojo.Student&quot; p:sid=&quot;1005&quot; p:sname=&quot;张三&quot; p:teacherMap-ref=&quot;teacherMap&quot;&gt;&lt;/bean&gt; p属性中每一个类的属性都由两种选项，p:属性名 p:属性名-ref 第一种是直接给字面量类型的属性赋值 第二种是给对象类型的属性赋值，引入bean，给list或者map集合类型赋值也用到这个 test 123456789@Testpublic void testDI()&#123; //获取ioc容器 ApplicationContext ioc= new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean Student student = ioc.getBean(&quot;studentSix&quot;, Student.class); System.out.println(student);&#125; Spring管理数据源合引入外部属性文件（spring连接数据库）说白了就是用spring去连接数据库 ①加入依赖 123456789101112&lt;!-- MySQL驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 数据源 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.31&lt;/version&gt;&lt;/dependency&gt; 创建jdbc.properties存储连接数据库的信息 1234jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=UTCjdbc.username=rootjdbc.password=root spring-datasource.xml 1234567891011&lt;!--引入jdbc.properties文件,之后可以通过$&#123;key&#125;的方式进行访问--&gt;&lt;!--在同一个文件下，可以直接访问--&gt;&lt;context:property-placeholder location=&quot;jdbc.properties&quot;&gt;&lt;/context:property-placeholder&gt;&lt;!--这个class是DataSource接口的实现类--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt;&lt;/bean&gt; test 12345678@Testpublic void testDataSource() throws SQLException &#123; ApplicationContext ioc= new ClassPathXmlApplicationContext(&quot;spring-datasource.xml&quot;); //创建了一个dataSource类型对象 DruidDataSource bean = ioc.getBean(DruidDataSource.class); //获取连接并输出 System.out.println(bean.getConnection());&#125; bean的作用域在Spring中可以通过配置bean标签的scope属性来指定bean的作用域范围，各取值含义参加下表： 默认是单例模式 就是通过同一个bean得到的对象都是同一个对象 新创建了一个spring-scope.xml 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;student&quot; class=&quot;com.atguigu.spring.pojo.Student&quot;&gt; &lt;property name=&quot;sid&quot; value=&quot;1001&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sname&quot; value=&quot;张三&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; test 输出结果是true所以就是单例模式 12345678910111213141516/*验证spring所管理的bean默认是单例模式，就是每次 */@Testpublic void testScope()&#123; ApplicationContext ioc=new ClassPathXmlApplicationContext(&quot;spring-scope.xml&quot;); Student student1 = ioc.getBean(Student.class); Student student2=ioc.getBean(Student.class); /* 正常==和equals方法都是相同的都是比较地址 但String中重写了equals方法变成了比较内容 */ System.out.println(student1.equals(student2));//true&#125; 现在要把这个bean改为多例模式，就是同一个bean每次获取的对象都不一样 在bean中加一个属性scope设置多例就可以 12345678910&lt;!--scope来设置bean的作用域--&gt;&lt;!--scope=singleton/prototype 单例模式/多例模式singleton（单例）:表示获取该bean所对应的对象都是同一个prototype（多例）:表示获取bean所对应的对象都不是同一个--&gt;&lt;bean id=&quot;student&quot; class=&quot;com.atguigu.spring.pojo.Student&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;sid&quot; value=&quot;1001&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sname&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;&lt;/bean&gt; test 12345678910111213@Testpublic void testScope()&#123; ApplicationContext ioc=new ClassPathXmlApplicationContext(&quot;spring-scope.xml&quot;); Student student1 = ioc.getBean(Student.class); Student student2=ioc.getBean(Student.class); /* 正常==和equals方法都是相同的都是比较地址 但String中重写了equals方法变成了比较内容 */ System.out.println(student1.equals(student2));&#125; 输出是false 除了singleton和prototype还有两种不常用的 bean的生命周期创建User对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.atguigu.spring.pojo;public class User &#123; private Integer id; private String username; private String password; private Integer age; public User() &#123; System.out.println(&quot;生命周期：1、创建对象&quot;); &#125; public User(Integer id, String username, String password, Integer age) &#123; this.id = id; this.username = username; this.password = password; this.age = age; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; System.out.println(&quot;生命周期：2、依赖注入&quot;); this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void initMethod() &#123; System.out.println(&quot;生命周期：3、初始化&quot;); &#125; public void destroyMethod() &#123; System.out.println(&quot;生命周期：5、销毁&quot;); &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 1.实例化 2.依赖注入 3.初始化，需要通过bean的init-method属性指定初始化方法 4.可以使用创建的对象 5.ioc容器关闭时销毁，需要通过bean的destroy-method属性指定销毁方法 1init-method=&quot;initMethod&quot; destroy-method=&quot;destroyMethod&quot; 123456&lt;bean id=&quot;user&quot; class=&quot;com.atguigu.spring.pojo.User&quot; init-method=&quot;initMethod&quot; destroy-method=&quot;destroyMethod&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;admin&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;&lt;/bean&gt; test 123456789@Testpublic void test()&#123; //ConfigurableApplicationContext是ApplicationContext的子接口扩展了刷新和关闭容器的方法，所以这地方用它关闭ioc ConfigurableApplicationContext ioc= new ClassPathXmlApplicationContext(&quot;spring-lifecycle.xml&quot;); User user = ioc.getBean(User.class); System.out.println(&quot;生命周期：4.使用对象&quot;); ioc.close();&#125; 不同作用域对bean的生命周期的影响注意： 若bean的作用域为单例时，生命周期的前三个步骤会在获取ioc容器的时候执行 因为如果是单例，直接就能知道要获取什么对象可以提前创建出来 若bean的作用域为多例时，生命周期的前三个步骤会在获取bean时执行 多例的话，每次都是创建新的对象，所以不会提前创建，而且销毁方法也不由ioc绝顶 bean的后置处理器在java下新建com.atguigu.spring.process包下创建BeanpostProfessor 要实现BeanPostProcessor接口，才能做后置处理器，实现两个方法 可以利用这两个方法对要获取的bean对象进行操作 1234567891011121314151617181920package com.atguigu.spring.process;import org.springframework.beans.BeansException;public class BeanPostProcessor implements org.springframework.beans.factory.config.BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; //此方法在bean的生命周期初始化之前执行 //这个参数bean就是那个要获得的对象，你可以在这里面对它进行一些操作 System.out.println(&quot;后置处理器---&gt;postProcessBeforeInitialization&quot;); return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; //此方法在bean的生命周期初始化之后执行 System.out.println(&quot;后置处理器---&gt;postProcessAfterInitialization&quot;); return bean; &#125;&#125; 在ioc中配置也就是spring-lifecycle.xml中配置后置处理器 注意：这个后置处理器对ioc中的每一个bean都生效 1&lt;bean class=&quot;com.atguigu.spring.process.BeanPostProcessor&quot;&gt;&lt;/bean&gt; test 12345678@Testpublic void test()&#123; //ConfigurableApplicationContext是ApplicationContext的子接口扩展了刷新和关闭容器的方法，所以这地方用它关闭ioc ConfigurableApplicationContext ioc= new ClassPathXmlApplicationContext(&quot;spring-lifecycle.xml&quot;); User user = ioc.getBean(User.class); System.out.println(&quot;生命周期：4.使用对象&quot;); ioc.close();&#125; 结果： 生命周期：1、创建对象生命周期：2、依赖注入：为属性赋值后置处理器—&gt;postProcessBeforeInitialization生命周期：3、初始化后置处理器—&gt;postProcessAfterInitialization生命周期：4.使用对象生命周期：5、销毁 具体的生命周期的所有过程 FactoryBean原本是BeanFactory是先获得工厂，在获取工厂所提供的bean FactoryBean是一个接口：需要创建一个类实现接口 其中三个方法： getObject():提供一个对象交给ioc容器管理 getObjectType():设置所提供对象的类型 isSingleton():所提供的对象是否单例 当我们把FactoryBean的实现类配置为bean时，会将我们当前类中的getObject()方法所返回的对象交给ioc容器管理 现在是把FactoryBean配置到ioc直接获得FactoryBean所提供的bean，节省了获取工厂这个环节 UserFactoryBean实现了FactoryBean接口 1234567891011121314151617package com.atguigu.spring.factory;import com.atguigu.spring.pojo.User;import org.springframework.beans.factory.FactoryBean;public class UserFactoryBean implements FactoryBean&lt;User&gt; &#123; @Override public User getObject() throws Exception &#123; return new User(); &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return User.class; &#125;&#125; 在spring-factory中配置 12&lt;!--其实真正交给ioc来管理的是getObject方法中返回的对象--&gt;&lt;bean class=&quot;com.atguigu.spring.factory.UserFactoryBean&quot;&gt;&lt;/bean&gt; test 1234567@Testpublic void testFactoryBean()&#123; ApplicationContext ioc=new ClassPathXmlApplicationContext(&quot;spring-factory.xml&quot;); User user=ioc.getBean(User.class); System.out.println(user);&#125; 普通工厂需要先把工厂配置成一个bean，然后获取ioc容器，获取工厂对应的对象，再获取工厂所提供的对象 基于xml的自动装配之场景模拟自动装配： 根据指定的策略，在IOC容器中匹配某一个bean，自动为指定的bean中所依赖的类类型或接口类型属性赋值 控制层（javaweb中是servlet，现在是controller）调用service进行业务逻辑，service层调用dao实现持久化操作 UserController（相当于Servlet） 123456789101112131415161718192021package com.atguigu.spring.Controller;import com.atguigu.spring.service.UserService;public class UserController &#123; private UserService userService; public UserService getUserService() &#123; return userService; &#125; public void setUserService(UserService userService) &#123; this.userService = userService; &#125; public void saveuser()&#123; userService.saveUser(); &#125;&#125; UserDao 123456789package com.atguigu.spring.dao;public interface UserDao &#123; /* 保存用户信息 */ void saveUser();&#125; UserDaoImpl 12345678910package com.atguigu.spring.dao.Impl;import com.atguigu.spring.dao.UserDao;public class UserDaoImpl implements UserDao &#123; @Override public void saveUser() &#123; System.out.println(&quot;保存成功&quot;); &#125;&#125; UserService 123456789package com.atguigu.spring.service;public interface UserService &#123; /* 保存用户信息 */ void saveUser();&#125; UserServiceImpl 123456789101112131415161718192021222324package com.atguigu.spring.service.impl;import com.atguigu.spring.dao.UserDao;import com.atguigu.spring.service.UserService;public class UserServiceImpl implements UserService &#123;private UserDao userDao; public UserDao getUserDao() &#123; return userDao; &#125; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; /* 保存用户信息 */ @Override public void saveUser() &#123; userDao.saveUser(); &#125;&#125; spring配置文件 spring-autowire-xml.xml 控制层（javaweb中是servlet，现在是controller）调用service进行业务逻辑，service层调用dao实现持久化操作 实现controller层依赖service层，service层依赖dao层 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;userController&quot; class=&quot;com.atguigu.spring.Controller.UserController&quot;&gt; &lt;property name=&quot;userService&quot; ref=&quot;userService&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.atguigu.spring.service.impl.UserServiceImpl&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.atguigu.spring.dao.Impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; UserController中有用到userService对象属性，这里可以给他进行赋值 UserService中用到userDao对象属性，这里可以给它赋值 这样如果userService属性要改变的话，可以直接在这里改bean，而不是去改源代码 test 12345678910111213141516package com.atguigu.spring.test;import com.atguigu.spring.Controller.UserController;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AutowireByXMLTest &#123; @Test public void testAutowire()&#123; ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;spring-autowire-xml.xml&quot;); UserController userController = ioc.getBean(UserController.class); userController.saveuser(); &#125;&#125; 基于xml自动装配值自动装配必须要有这个属性的get和set方法，主要set方法 其实自动装配用得很多，但是基于xml的自动装配用的很少，因为用了xml的自动装配，你所有的类类型属性的赋值都会遵循自动装配，所以很难用 所以常用的是注解类型的自动装配 12345678910111213自动装配： 根据指定的策略，在ioc容器中匹配某一个bean，为当前设置了自动装配的bean中的类类型的属性或者接口类型的属性赋值 自动装配的策略： no，default：表示不装配，即设置策略的bean中的属性不会自动匹配某个ioc中的bean为属性赋值，此时属性使用默认值（默认值也就是类中用代码的死赋值，如果没有就是null） byType:根据当前要进行赋值的属性的类型去ioc容器中匹配一个类型相同(接口的实现类或者子类)的bean进行赋值 注意：若在ioc一个类型匹配的bean都找不到，此时不装配，属性使用的是默认值 若在ioc中有多个类型匹配的bean就会报错，NoUniqueBeanDefinitionException 总结：当使用byType实现自动装配的时候，ioc容器有且只有一个类型匹配的bean能够为属性赋值 byName:根据要赋值的属性的属性名作为id来匹配日ioc中的bean，如果二者相同，则可以为属性赋值 如果没有匹配的bean，属性就会使用默认值（默认值也就是类中用代码的死赋值，如果没有就是null） 总结byName一般用在就是byType用不了的时候，比如有多个bean都是同一个类型的情况 byType 用了byType之后，会自动给UserController中的userService属性赋值，只要ioc中有类型相同的bean 1autowire=&quot;byType&quot; spring-autowire-xml.xml 123456789&lt;bean id=&quot;userController&quot; class=&quot;com.atguigu.spring.Controller.UserController&quot; autowire=&quot;byType&quot;&gt; &lt;!--&lt;property name=&quot;userService&quot; ref=&quot;userService&quot;&gt;&lt;/property&gt;--&gt;&lt;/bean&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.atguigu.spring.service.impl.UserServiceImpl&quot; autowire=&quot;byType&quot;&gt; &lt;!--&lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;--&gt;&lt;/bean&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.atguigu.spring.dao.Impl.UserDaoImpl&quot;&gt;&lt;/bean&gt; byName 12345678910111213&lt;bean id=&quot;userController&quot; class=&quot;com.atguigu.spring.Controller.UserController&quot; autowire=&quot;byName&quot;&gt; &lt;!--&lt;property name=&quot;userService&quot; ref=&quot;userService&quot;&gt;&lt;/property&gt;--&gt;&lt;/bean&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.atguigu.spring.service.impl.UserServiceImpl&quot; autowire=&quot;byName&quot;&gt; &lt;!--&lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;--&gt;&lt;/bean&gt;&lt;bean id=&quot;userService1&quot; class=&quot;com.atguigu.spring.service.impl.UserServiceImpl&quot; autowire=&quot;byName&quot;&gt; &lt;!--&lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;--&gt;&lt;/bean&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.atguigu.spring.dao.Impl.UserDaoImpl&quot;&gt;&lt;/bean&gt; test 1234567891011121314151617package com.atguigu.spring.test;import com.atguigu.spring.Controller.UserController;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AutowireByXMLTest &#123; @Test public void testAutowire()&#123; ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;spring-autowire-xml.xml&quot;); UserController userController = ioc.getBean(UserController.class); userController.saveuser(); &#125;&#125; 基于注解管理bean注解：和xml配置文件一样，注解本身并不能运行，注解本身仅仅是做一个标记，具体的功能是框架检测 到注解标记的位置，然后针对这个位置按照注解标记的功能来执行具体操作。 本质上：所有一切的操作都是Java代码来完成的，XML和注解只是告诉框架中的Java代码如何执行。 扫描： Spring 为了知道程序员在哪些地方标记了什么注解，就需要通过扫描的方式，来进行检测。然后根据注 解进行后续操作。 注解和扫描新建Module spring_ioc_annotation pom.xml中 添加依赖 123456789101112131415&lt;dependencies&gt; &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建spring配置文件 创建三层架构dao，service，controller 然后分别在这些实现类和controller上加上对应的注解 加上注解的类就相当于在ioc容器中加上了一个这个类的bean，所以注解是要加到实现类上的 标识组件的常用注解： @Component：将类标识为普通组件 @Controller:将类标识为控制层组件 @Service:将类标识为业务层组件 @Repository:将类标识为持久层组件 通过查看源码我们得知，@Controller、@Service、@Repository这三个注解只是在@Component注解 的基础上起了三个新的名字。 对于Spring使用IOC容器管理这些组件来说没有区别。所以@Controller、@Service、@Repository这 三个注解只是给开发人员看的，让我们能够便于分辨组件的作用。 注意：虽然它们本质上一样，但是为了代码的可读性，为了程序结构严谨我们肯定不能随便胡乱标记。 扫描 Spring 为了知道程序员在哪些地方标记了什么注解，就需要通过扫描的方式，来进行检测。然后根据注解进行后续操作。 com.atguigu.spring下的所有文件都要进行扫描 123&lt;!--扫描组件--&gt; &lt;!--base-package属性是规定扫描的包--&gt;&lt;context:component-scan base-package=&quot;com.atguigu.spring&quot;&gt;&lt;/context:component-scan&gt; 扫描组件排除扫描规定包下的某个类，或者只扫描规定包下的某个类 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!--扫描组件--&gt; &lt;!--排除和包含两个标签不能一起用--&gt; &lt;!--base-package属性是规定扫描的包--&gt;&lt;context:component-scan base-package=&quot;com.atguigu.spring&quot; use-default-filters=&quot;false&quot;&gt; &lt;!--这个context:exclude-filter是用来排除规定包下的某一些类的--&gt; &lt;!--expression中用的是注解的全类名或者类的全类名--&gt; &lt;!--type是annotation是根据注解来排除类，排除expression中的注解类型标记过的类--&gt; &lt;!-- &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;--&gt; &lt;!--type是assignable是根据类来排除，排出的是expression中所对应的类--&gt; &lt;!--&lt;context:exclude-filter type=&quot;assignable&quot; expression=&quot;com.atguigu.spring.controller.UserController&quot;/&gt;--&gt; &lt;!--这是规定只引入包下的哪个类--&gt; &lt;!--expression type和上面的都一样--&gt; &lt;!--将外面标签的use-default-filters设置为false，默认是设置为true，表示扫描包下所有组件，所以要设为false--&gt; &lt;!--这种情况是只扫描Controller注解的类--&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt; &lt;/beans&gt; bean的id通过注解+扫描所配置的bean的id，默认值为类的小驼峰，即类名的首字母为小写的结果 比如说UserController类通过注解+扫描所配置的bean的id为userController test 123456@Testpublic void test()&#123; ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;spring-ioc-annotation.xml&quot;); UserController userController = ioc.getBean(&quot;userController&quot;,UserController.class); System.out.println(userController);&#125; 自定义id UserController 12345678910package com.atguigu.spring.controller;import org.springframework.stereotype.Controller;/*给注解的value赋值就是给这个类注解加扫描得到的bean自己定义的id */@Controller(&quot;controller&quot;)public class UserController &#123;&#125; test 123456@Testpublic void test()&#123; ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;spring-ioc-annotation.xml&quot;); UserController userController = ioc.getBean(&quot;controller&quot;,UserController.class); System.out.println(userController);&#125; 基于注解的自动装配①场景模拟 参考基于xml的自动装配 在UserController中声明UserService对象 在UserServiceImpl中声明UserDao对象 这个场景模拟和xml的自动装配一致 UserServiceImpl 用 @Autowired标记要被自动装配的属性 123456789101112131415161718package com.atguigu.spring.service.impl;import com.atguigu.spring.dao.UserDao;import com.atguigu.spring.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowiredprivate UserDao userDao; @Override public void saveUser() &#123; userDao.saveUser(); &#125;&#125; UserService 给userService加上@Autowired标记 123456789101112131415161718package com.atguigu.spring.controller;import com.atguigu.spring.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;/*给注解的value赋值就是给这个类注解加扫描得到的bean自己定义的id */@Controllerpublic class UserController &#123; @Autowired private UserService userService; public void savaUser()&#123; userService.saveUser(); &#125;&#125; @Autowired：实现自动装配功能的注解 1.@Autowired注解能够标识的位置 ​ 成员变量上，此时不需要设置成员变量的set方法（最常用的） ​ 标识在set方法 ​ 为当前成员变量赋值的有参构造上 @Autowired原理 1.默认通过byType的方式，在IOC容器中通过类型匹配某个bean为属性赋值 2.若有多个类型匹配的bean，此时会自动转换为byName的方式实现自动装配的效果 即将要赋值的属性的属性名去匹配某个bean的id，用匹配到的bean为属性赋值 3.若byType和byName的方式都无法实现自动匹配，即ioc容器中有多个类型匹配的bean（byType不能用），且这些bean的id和要赋值的属性的属性名都不一致（byName不能用）或报错：NoUniqueBeanDefinitionException 此时可以在要赋值的属性上，添加一个注解 1234567 /* 给@Qualifier的value值赋值 这个是指定id为UserDao的bean为userDao属性赋值 */ @Autowired @Qualifier(&quot;UserDao&quot;)private UserDao userDao; 这个时候这个自动装配的@Autowired需要写在属性的上面 @Autowired注意事项用注解实现的自动装配，如果没有匹配的bean则会报NoSuchBeanDefinitionException没有这个值，就是它不会找不到匹配的bean就给它赋默认值 在@Autowired注解中有个属性required，默认值为true，要求必须完成自动装配 可以将required设置为false，此时能装配则装配，无法装配则使用默认值 1@Autowired(required = false) test 1234567891011121314151617package com.atguigu.spring.test;import com.atguigu.spring.controller.UserController;import com.atguigu.spring.service.UserService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class IOCByAnnotationTest &#123; @Test public void test()&#123; ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;spring-ioc-annotation.xml&quot;); UserController userController = ioc.getBean(UserController.class); userController.savaUser(); &#125;&#125; AOP场景模拟计算器 1234567891011121314151617181920212223242526272829303132333435363738394041package com.atguigu.spring.proxy;public class CalculatorImpl implements Calculator &#123; @Override public int add(int i, int j) &#123; System.out.println(&quot;[日志] add 方法开始了，参数是：&quot; + i + &quot;,&quot; + j); int result=i+j; System.out.println(&quot;方法内部，result:&quot;+result); System.out.println(&quot;[日志] add 方法结束了，结果是：&quot; + result); return result; &#125; @Override public int sub(int i, int j) &#123; System.out.println(&quot;[日志] sub 方法开始了，参数是：&quot; + i + &quot;,&quot; + j); int result=i-j; System.out.println(&quot;方法内部，result:&quot;+result); System.out.println(&quot;[日志] sub 方法结束了，结果是：&quot; + result); return result; &#125; @Override public int mul(int i, int j) &#123; System.out.println(&quot;[日志] mul 方法开始了，参数是：&quot; + i + &quot;,&quot; + j); int result=i*j; System.out.println(&quot;方法内部，result:&quot;+result); System.out.println(&quot;[日志] mul 方法结束了，结果是：&quot; + result); return result; &#125; @Override public int div(int i, int j) &#123; System.out.println(&quot;[日志] div 方法开始了，参数是：&quot; + i + &quot;,&quot; + j); int result=i/j; System.out.println(&quot;方法内部，result:&quot;+result); System.out.println(&quot;[日志] div 方法结束了，结果是：&quot; + result); return result; &#125;&#125; 问题： 1.以下这些代码在每个方法中是重复的，正常应该封装，但它不是连续的，封装只能封装连续的代码，所以不能封装，所以这个地方就用到了代理模式 1234System.out.println(&quot;[日志] mul 方法开始了，参数是：&quot; + i + &quot;,&quot; + j);System.out.println(&quot;方法内部，result:&quot;+result);System.out.println(&quot;[日志] mul 方法结束了，结果是：&quot; + result); 2.int result&#x3D;i运算符j才是核心业务，但每个方法中既实现了日志业务又实现了运算，分散程序员重心 3.日志这种附加代码在各个方法中重复，不好维护 ③困难 解决问题的困难：要抽取的代码在方法内部，不连续分布，靠以前把子类中的重复代码抽取到父类的方式没法解决。 所以需要引入新的技术。 代理模式它的作用就是提供一个代理类，当我们去调用一个方法的时候，不是直接调用这个方法，而是通过代理类间接的来调用这个方法，这样可以把程序中非核心代码剥离出来到代理类中这个叫解耦，方便了非核心代码的维护，减少了对核心方法的打扰 代理之前 代理之后 就是调用add方法先调用代理对象的add方法，代理对象调用目标方法（add方法），目标方法返回给代理对象，代理对象把返回值返回给最初调用者 ③相关术语 代理：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法。（） 目标：被代理“套用”了非核心逻辑代码的类、对象、方法。（CalculatorImpl） 静态代理的实现特点：一对一：当前这个代理类只能作为这个目标类的代理 创建一个代理类 CalculatorStaticProxy 因为代理和目标类（CalculatorImpl）必须实现一样的功能，所以CalculatorImpl实现Calculator接口，代理类也实现Calculator接口 并重写方法， private CalculatorImpl target;定义一个目标类属性，用来在代理类中间接调用目标方法，同时代理类中的方法还可以加上一些日志操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.atguigu.spring.proxy;import jdk.nashorn.internal.ir.CallNode;public class CalculatorStaticProxy implements Calculator &#123; private CalculatorImpl target; @Override public int add(int i, int j) &#123; System.out.println(&quot;日志 方法：add，参数：&quot;+i+&quot;,&quot;+j); int result=target.add(i,j); System.out.println(&quot;日志 方法：add，参数：&quot;+i+&quot;,&quot;+j+&quot;=&quot;+result); return 0; &#125; public CalculatorStaticProxy(CalculatorImpl target) &#123; this.target = target; &#125; @Override public int sub(int i, int j) &#123; System.out.println(&quot;日志 方法：add，参数：&quot;+i+&quot;,&quot;+j); int result=target.sub(i,j); System.out.println(&quot;日志 方法：add，参数：&quot;+i+&quot;-&quot;+j+&quot;=&quot;+result); return 0; &#125; @Override public int mul(int i, int j) &#123; System.out.println(&quot;日志 方法：add，参数：&quot;+i+&quot;,&quot;+j); int result=target.mul(i,j); System.out.println(&quot;日志 方法：add，参数：&quot;+i+&quot;*&quot;+j+&quot;=&quot;+result); return 0; &#125; @Override public int div(int i, int j) &#123; System.out.println(&quot;日志 方法：add，参数：&quot;+i+&quot;,&quot;+j); int result=target.div(i,j); System.out.println(&quot;日志 方法：add，参数：&quot;+i+&quot;/&quot;+j+&quot;=&quot;+result); return 0; &#125;&#125; CalculatorImpl 12345678910111213141516171819202122232425262728package com.atguigu.spring.proxy;public class CalculatorImpl implements Calculator &#123; @Override public int add(int i, int j) &#123; int result=i+j; return result; &#125; @Override public int sub(int i, int j) &#123; int result=i-j; return result; &#125; @Override public int mul(int i, int j) &#123; int result=i*j; return result; &#125; @Override public int div(int i, int j) &#123; int result=i/j; return result; &#125;&#125; test 12345678910111213141516package com.atguigu.proxy;import com.atguigu.spring.proxy.CalculatorImpl;import com.atguigu.spring.proxy.CalculatorStaticProxy;import org.junit.Test;public class ProxyTest &#123; @Test public void testProxy()&#123; CalculatorStaticProxy calculatorStaticProxy=new CalculatorStaticProxy(new CalculatorImpl()); calculatorStaticProxy.add(1,2); calculatorStaticProxy.sub(1,2); calculatorStaticProxy.div(1,2); calculatorStaticProxy.mul(1,2); &#125;&#125; 代理中的add方法 1234567891011121314151617@Overridepublic int add(int i, int j) &#123; try &#123; //目标方法执行前 System.out.println(&quot;日志 方法：add，参数：&quot; + i + &quot;,&quot; + j); int result = target.add(i, j); //目标方法执行后 System.out.println(&quot;日志 方法：add，参数：&quot; + i + &quot;,&quot; + j + &quot;=&quot; + result); &#125; catch(Exception e)&#123; //报错之后 &#125; finally &#123; //无论怎样都要执行 &#125; return 0;&#125; 加上trycatchfinally除了目标方法执行前和目标方法执行后又多了报错之后 和 无论怎样都要执行（finally） 静态代理的缺陷：实现的接口和目标类都是固定的，没有灵活性，如果有别的类要实现日志功能，还是无法复用日志功能的代码 提出进一步的需求：将日志功能集中到一个代理类中，将来有任何日志需求，都通过这一个代理 类来实现。这就需要使用动态代理技术了。 动态代理的实现设置一个生成代理类的工程（它不是代理类，但它getProxy()方法的返回值是代理类对象） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.atguigu.spring.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Arrays;public class ProxyFactory &#123; public ProxyFactory(Object target) &#123; this.target = target; &#125; private Object target; public Object getProxy()&#123; /* newProxyInstance:三个参数 ClassLoader loader：指定加载动态生成的代理类（当前所在类）的类加载器 Class&lt;?&gt;[] interfaces：获取目标对象实现的所有接口的class对象的数组 InvocationHandler h：设置代理类中的抽象方法如何重写 */ ClassLoader classLoader = this.getClass().getClassLoader(); Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces(); /* 用匿名内部类来创建 */ InvocationHandler h=new InvocationHandler() &#123; //这个方法设置的是代理类中的抽象方法如何重写 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result=null; try &#123; System.out.println(&quot;日志，方法，&quot; + method.getName() + &quot;,参数：&quot; + Arrays.toString(args)); //proxy表示代理对象，method表示要执行的方法，args表示要执行的方法的参数列表 //这个调用目标对象的方法,method方法在代理中和目标中都是一样因为实现的都是一个接口 result = method.invoke(target, args); System.out.println(&quot;日志，方法，&quot; + method.getName() + &quot;,结果：&quot; + result); &#125; catch(Exception e)&#123; e.printStackTrace(); System.out.println(&quot;日志，方法，&quot; + method.getName() + &quot;,异常：&quot; + e); &#125;finally&#123; System.out.println(&quot;日志，方法&quot;+method.getName()+&quot;,方法执行完毕&quot;); &#125; return result; &#125; &#125;; return Proxy.newProxyInstance(classLoader,interfaces,h); &#125;&#125; test 12345678910111213141516171819202122232425262728package com.atguigu.proxy;import com.atguigu.spring.proxy.Calculator;import com.atguigu.spring.proxy.CalculatorImpl;import com.atguigu.spring.proxy.CalculatorStaticProxy;import com.atguigu.spring.proxy.ProxyFactory;import org.junit.Test;public class ProxyTest &#123; /* 动态代理有两种： 1，jdk动态代理，要求必须有接口，最终生成的代理类和目标类实现相同的接口在com.sun.proxy包下类名为$proxy2 2.cglib动态代理，最终生成的代理类会继承目标类，并且和目标类在相同的包下 */ @Test public void testProxy()&#123; ProxyFactory proxyFactory=new ProxyFactory(new CalculatorImpl()); /* 不知道当前动态代理类生成的类型，但是可以通过用接口类型来进行向上转型，赋值给一个接口变量 */ Calculator proxy = (Calculator) proxyFactory.getProxy(); int add = proxy.div(1, 2); &#125;&#125; AOP概念以及相关术语aop是面向切面变成，oop是面向对象编程，aop是oop的一种补充和完善 aop作用 1.aop用来抽取非核心业务代码，交给切面进行管理 2.实现在不修改源代码的情况 下给程序动态统一添加额外功能的一种技术。 相关术语 横切关注点： 从每个方法中抽取出来的同一类非核心业务 通知： 每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。 非核心代码在目标对象中叫横切关注点，你把它拿出来在切面中进行封装那它就是一个通知方法 通知分类 前置通知：在被代理的目标方法前执行 返回通知：在被代理的目标方法成功结束后执行（寿终正寝） 异常通知：在被代理的目标方法异常结束后执行（死于非命） 后置通知：在被代理的目标方法最终结束后执行（盖棺定论） 环绕通知：使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置 一个环绕通知，等于上面这四种通知 切面： 封装通知方法的类。 目标： 被代理的目标对象，被抽取非核心业务代码的对象 代理： 为当前的目标对象所创建的代理对象 连接点： 横切关注点是从哪切出来的，哪里就是连接点 切入点： 用于定位连接点的方式 Spring 的 AOP 技术可以通过切入点定位到特定的连接点。 切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条 件。 aop作用 自己：抽横切关注点，封装到切面中，他就是一个通知，再通过切入点定位到连接点，然后套用就ok，然后就可以在不改变原来代码的基础上，用切入点表达式把这些通知套用在原本抽取的地方（连接点），实现功能增强 简化代码：把方法中固定位置的重复的代码抽取出来，让被抽取的方法更专注于自己的核心功能， 提高内聚性。 代码增强：把特定的功能封装到切面类中，看哪里有需要，就往上套，被套用了切面逻辑的方法就 被切面给增强了。 基于注解AOP实现的准备工作 动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因 为这个技术要求代理对象和目标对象实现同样的接口（兄弟两个拜把子模式）。 cglib：通过继承被代理的目标类（认干爹模式）实现代理，所以不需要目标类实现接口。 AspectJ：本质上是静态代理，将代理逻辑“织入”被代理的目标类编译得到的字节码文件，所以最 终效果是动态的。weaver就是织入器。Spring只是借用了AspectJ中的注解。 1.添加依赖 在原本ioc基础上添加依赖 123456&lt;!-- spring-aspects会帮我们传递过来aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt; 2.创建目标对象的实现类和接口 计算器接口 1234567public interface Calculator &#123; int add(int i, int j); int sub(int i, int j); int mul(int i, int j); int div(int i, int j);&#125; 计算器实现类 12345678910111213141516171819202122232425262728package com.atguigu.spring.aop.annotation;public class CalculatorImpl implements Calculator &#123; @Override public int add(int i, int j) &#123; int result=i+j; return result; &#125; @Override public int sub(int i, int j) &#123; int result=i-j; return result; &#125; @Override public int mul(int i, int j) &#123; int result=i*j; return result; &#125; @Override public int div(int i, int j) &#123; int result=i/j; return result; &#125;&#125; 3.创建切面类并配置 抽取横切关注点，封装成通知方法，放在切面类中 将目标对象实现类和切面类交给ioc容器管理 CalculatorImpl 加上一个@Component 12345678910111213141516171819202122232425262728293031package com.atguigu.spring.aop.annotation;import org.springframework.stereotype.Component;@Componentpublic class CalculatorImpl implements Calculator &#123; @Override public int add(int i, int j) &#123; int result=i+j; return result; &#125; @Override public int sub(int i, int j) &#123; int result=i-j; return result; &#125; @Override public int mul(int i, int j) &#123; int result=i*j; return result; &#125; @Override public int div(int i, int j) &#123; int result=i/j; return result; &#125;&#125; LoggerAspect 加上@Component 和@Aspect 1234567891011package com.atguigu.spring.aop.annotation;import org.aspectj.lang.annotation.Aspect;import org.springframework.stereotype.Component;@Component@Aspect //将当前组件标识为切面public class LoggerAspect &#123;&#125; aop-annotation.xml 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- AOP的注意事项： 切面类和目标类都需要交给ioc容器管理 切面类必须通过@Aspect注解标识为一个切面 --&gt; &lt;!--进行扫描--&gt; &lt;context:component-scan base-package=&quot;com.atguigu.spring.aop.annotation&quot;&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 基于注解的aop之前置通知在aop-annotation.xml中设置 12&lt;!--开启基于注解的aop功能--&gt;&lt;aop:aspectj-autoproxy/&gt; LoggerAspect 切面类 1234567891011121314151617181920212223242526package com.atguigu.spring.aop.annotation;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.stereotype.Component;@Component@Aspect //将当前组件标识为切面public class LoggerAspect &#123; /* 前置通知 */ /* 在切面中，需要通过指定的注解将方法标识为通知方法 @Before:前置通知，在目标对象方法执行之前执行 参数是 execution 切入点表达式就是连接点的位置，也就是下面这个方法在执行参数中这个方法之前执行 参数:方法类型 返回值类型 方法的全方法名(参数类型...) */ @Before(&quot;execution(public int com.atguigu.spring.aop.annotation.CalculatorImpl.add(int,int))&quot;) public void beforeAdviceMethod()&#123; System.out.println(&quot;LoggerAspect,前置通知&quot;); &#125;&#125; test 123456789101112131415161718192021package com.atguigu.spring.test;import com.atguigu.spring.aop.annotation.Calculator;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AOPTest &#123; @Test public void testAOPByAnnotation()&#123; ApplicationContext ioc=new ClassPathXmlApplicationContext(&quot;aop-annotation.xml&quot;); /* 这个地方获取的应该是代理对象，创建了代理对象之后，只能通过代理对象来访问目标对象，如果用getBean直接获取目标对象就会报错 不知道代理对象的类型，但是它一定实现了Calculator接口，所以用Calculator接口来获取bean 疑问：目标对象和代理对象都实现这个接口，为什么获取的是目标对象？ 因为：目标对象无法获取，获取时报错，所以这个地方只能获取代理对象 */ Calculator calculator = ioc.getBean(Calculator.class); calculator.add(1,2); &#125;&#125; 切入点表达式语法和获取连接点方法信息切入点表达式：execcution中的参数 LoggerAspect 1234567/*第一个*是指方法的类型和返回值任意，后面是包名，中间也可以用到*，代表这个包下所有的类，第二个*是指这个类下所有的方法，(..)是指任意参数类型 */@Before(&quot;execution(* com.atguigu.spring.aop.annotation.CalculatorImpl.*(..))&quot;)public void beforeAdviceMethod()&#123; System.out.println(&quot;LoggerAspect,前置通知&quot;);&#125; 获取连接点方法信息 加了一个joinPoint参数 12345678910111213141516171819/*第一个*是指方法的类型和返回值任意，后面是包名，中间也可以用到*，代表这个包下所有的类，第二个*是指这个类下所有的方法，(..)是指任意参数类型 */@Before(&quot;execution(* com.atguigu.spring.aop.annotation.CalculatorImpl.*(..))&quot;)//加一个joinPoint参数用来获取连接点对应方法的信息public void beforeAdviceMethod(JoinPoint joinPoint)&#123; //获取连接点所对应的方法的签名信息(方法名，返回值类型，修饰符，参数) Signature signature=joinPoint.getSignature(); //获取连接点对应方法的方法名 String name = signature.getName(); //获取连接点所对应方法的参数 Object[] args = joinPoint.getArgs(); System.out.println(&quot;LoggerAspect 方法&quot;+signature.getName()+&quot;:参数:&quot;+ Arrays.toString(args)); System.out.println(&quot;LoggerAspect,前置通知&quot;);&#125; 切入点表达式的重用 @Pointcut声明一个公共的切入点表达式 12@Pointcut(&quot;execution(* com.atguigu.spring.aop.annotation.CalculatorImpl.*(..))&quot;) public void pointCut()&#123; &#125; 使用方式： @After中写的是当前那个声明一个公共的切入点表达式的方法的方法名 12345//切入点表达式的重用 @After(&quot;pointCut()&quot;) public void afterAdviceMethod()&#123; &#125; LoggerAspect 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.atguigu.spring.aop.annotation;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.Signature;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;import java.util.Arrays;@Component@Aspect //将当前组件标识为切面public class LoggerAspect &#123; /* 前置通知 */ /* 在切面中，需要通过指定的注解将方法标识为通知方法 @Before:前置通知，在目标对象方法执行之前执行 参数是 execution 切入点表达式就是连接点的位置，也就是下面这个方法在执行参数中这个方法之前执行 参数:方法类型 返回值类型 方法的全方法名(参数类型...) */ @Pointcut(&quot;execution(* com.atguigu.spring.aop.annotation.CalculatorImpl.*(..))&quot;) public void pointCut()&#123; &#125; /* 第一个*是指方法的类型和返回值任意，后面是包名，中间也可以用到*，代表这个包下所有的类，第二个*是指这个类下所有的方法，(..)是指任意参数类型 */ @Before(&quot;pointCut()&quot;) //加一个joinPoint参数用来获取连接点对应方法的信息 public void beforeAdviceMethod(JoinPoint joinPoint)&#123; //获取连接点所对应的方法的签名信息(方法名，返回值类型，修饰符，参数) Signature signature=joinPoint.getSignature(); //获取连接点对应方法的方法名 String name = signature.getName(); //获取连接点所对应方法的参数 Object[] args = joinPoint.getArgs(); System.out.println(&quot;LoggerAspect 方法&quot;+signature.getName()+&quot;:参数:&quot;+ Arrays.toString(args)); System.out.println(&quot;LoggerAspect,前置通知&quot;); &#125; //切入点表达式的重用 @After(&quot;pointCut()&quot;) public void afterAdviceMethod()&#123; &#125;&#125; 测试 123456789101112131415161718192021package com.atguigu.spring.test;import com.atguigu.spring.aop.annotation.Calculator;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AOPTest &#123; @Test public void testAOPByAnnotation()&#123; ApplicationContext ioc=new ClassPathXmlApplicationContext(&quot;aop-annotation.xml&quot;); /* 这个地方获取的应该是代理对象，创建了代理对象之后，只能通过代理对象来访问目标对象，如果用getBean直接获取目标对象就会报错 不知道代理对象的类型，但是它一定实现了Calculator接口，所以用Calculator接口来获取bean 疑问：目标对象和代理对象都实现这个接口，为什么获取的是目标对象？ 因为：目标对象无法获取，获取时报错，所以这个地方只能获取代理对象 */ Calculator calculator = ioc.getBean(Calculator.class); calculator.div(12,0); &#125;&#125; AOP各种通知的使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.atguigu.spring.aop.annotation;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.Signature;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;import sun.reflect.annotation.ExceptionProxy;import java.util.Arrays;@Component@Aspect //将当前组件标识为切面public class LoggerAspect &#123; /* 前置通知 */ /* 在切面中，需要通过指定的注解将方法标识为通知方法 @Before:前置通知，在目标对象方法执行之前执行 参数是 execution 切入点表达式就是连接点的位置，也就是下面这个方法在执行参数中这个方法之前执行 参数:方法类型 返回值类型 方法的全方法名(参数类型...) */ @Pointcut(&quot;execution(* com.atguigu.spring.aop.annotation.CalculatorImpl.*(..))&quot;) public void pointCut()&#123; &#125; /* 第一个*是指方法的类型和返回值任意，后面是包名，中间也可以用到*，代表这个包下所有的类，第二个*是指这个类下所有的方法，(..)是指任意参数类型 */ @Before(&quot;pointCut()&quot;) //加一个joinPoint参数用来获取连接点对应方法的信息 public void beforeAdviceMethod(JoinPoint joinPoint)&#123; //获取连接点所对应的方法的签名信息(方法名，返回值类型，修饰符，参数) Signature signature=joinPoint.getSignature(); //获取连接点对应方法的方法名 String name = signature.getName(); //获取连接点所对应方法的参数 Object[] args = joinPoint.getArgs(); System.out.println(&quot;LoggerAspect 方法&quot;+signature.getName()+&quot;:参数:&quot;+ Arrays.toString(args)); System.out.println(&quot;LoggerAspect,前置通知&quot;); &#125;//@After:后置通知，在目标对象方法的finally子句中执行 //切入点表达式的重用 @After(&quot;pointCut()&quot;) public void afterAdviceMethod(JoinPoint joinPoint)&#123; //获取连接点所对应的方法的签名信息(方法名，返回值类型，修饰符，参数) Signature signature=joinPoint.getSignature(); //获取连接点对应方法的方法名 String name = signature.getName(); System.out.println(&quot;LoggerAspect，方法后置通知&quot;+signature.getName()+&quot;,执行完毕&quot;); &#125; //@AfterReturning是：返回通知：在当前目标方法返回值之后执行，如果报错，无法返回，则也无法执行 //在返回通知中若要获取目标对象方法的返回值 //只需要通过@AfterReturning注解的returning属性 //就可以将通知方法的某个参数指定为接受目标对象方法的返回值的参数（就是保证returning中的值和方法中那个参数名字一样，就可以，另外切入点表达式得用value=） @AfterReturning(value=&quot;pointCut()&quot;,returning=&quot;result&quot;) public void afterReturningAdviceMethod(JoinPoint joinPoint,Object result)&#123; //获取连接点所对应的方法的签名信息(方法名，返回值类型，修饰符，参数) Signature signature=joinPoint.getSignature(); //获取连接点对应方法的方法名 String name = signature.getName(); System.out.println(&quot;LoggerAspect:方法返回通知&quot;+signature.getName()+&quot;，结果:&quot;+result); &#125; //@AfterThrowing:异常通知，在目标对象方法的catch子句中执行 //在异常通知中若要获取目标对象方法的异常 //只需要通过AfterThrowing注解的returning属性 //就可以将通知方法的某个参数指定为接收目标对象方法的返回值的参数 //就是用throwing接受目标对象方法中的异常信息，只要下面方法参数和throwing中的内容相同就可以@AfterThrowing(value=&quot;pointCut()&quot;,throwing=&quot;ex&quot;)public void afterThrowingAdviceMethod(JoinPoint joinPoint, Exception ex)&#123; //获取连接点所对应的方法的签名信息(方法名，返回值类型，修饰符，参数) Signature signature=joinPoint.getSignature(); //获取连接点对应方法的方法名 String name = signature.getName(); System.out.println(&quot;LoggerAspect,方法异常通知&quot;+signature.getName()+&quot;,异常信息&quot;+ex);&#125;&#125; 测试 123456789101112131415161718192021package com.atguigu.spring.test;import com.atguigu.spring.aop.annotation.Calculator;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AOPTest &#123; @Test public void testAOPByAnnotation()&#123; ApplicationContext ioc=new ClassPathXmlApplicationContext(&quot;aop-annotation.xml&quot;); /* 这个地方获取的应该是代理对象，创建了代理对象之后，只能通过代理对象来访问目标对象，如果用getBean直接获取目标对象就会报错 不知道代理对象的类型，但是它一定实现了Calculator接口，所以用Calculator接口来获取bean 疑问：目标对象和代理对象都实现这个接口，为什么获取的是目标对象？ 因为：目标对象无法获取，获取时报错，所以这个地方只能获取代理对象 */ Calculator calculator = ioc.getBean(Calculator.class); calculator.div(12,0); &#125;&#125; 环绕通知的使用 LoggerAspect切面类 1234567891011121314151617181920212223242526/*环绕通知： @Around(&quot;pointCut()&quot;)通过这个注解 环绕通知是代替了目标对象的方法，所以返回值是Object和目标对象方法的返回值相同，result的类型 添加一个ProceedingJoinPoint类型的参数，通过参数中proceed()方法表示目标对象方法的执行 然后就可以增加在方法执行过程中进行额外的操作 */ @Around(&quot;pointCut()&quot;) public Object aroundAdviceMethod(ProceedingJoinPoint joinPoint)&#123; Object result=null; try &#123; System.out.println(&quot;环绕通知---&gt;前置通知的位置&quot;); //表示目标对象方法的执行 result = joinPoint.proceed(); System.out.println(&quot;环绕通知---&gt;返回通知的位置&quot;); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); System.out.println(&quot;环绕通知---&gt;异常通知的位置&quot;); &#125; finally&#123; System.out.println(&quot;环绕通知---&gt;后置通知的位置&quot;); &#125; return result; &#125; test 1234567891011121314151617181920212223package com.atguigu.spring.test;import com.atguigu.spring.aop.annotation.Calculator;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AOPTest &#123; @Test public void testAOPByAnnotation1()&#123; ApplicationContext ioc=new ClassPathXmlApplicationContext(&quot;aop-annotation.xml&quot;); /* 这个地方获取的应该是代理对象，创建了代理对象之后，只能通过代理对象来访问目标对象，如果用getBean直接获取目标对象就会报错 不知道代理对象的类型，但是它一定实现了Calculator接口，所以用Calculator接口来获取bean 疑问：目标对象和代理对象都实现这个接口，为什么获取的是目标对象？ 因为：目标对象无法获取，获取时报错，所以这个地方只能获取代理对象 */ Calculator calculator = ioc.getBean(Calculator.class); calculator.div(12,1); &#125;&#125; 切面的优先级新建的切面类为ValidateAspect 12345678910111213141516171819202122232425262728package com.atguigu.spring.aop.annotation;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;@Component@Aspect@Order(1)//通过Order来设置切面的优先级，Order的value值越大，优先级越小，value值越小，优先级越大，而且切面类默认order的value为Integer的最大值//所以这里把Order的value设置为1就可以让ValidateAspect的优先级增高public class ValidateAspect &#123; public void cutPoint()&#123; &#125; //@Before(&quot;execution(* com.atguigu.spring.aop.annotation.CalculatorImpl.*(..))&quot;) /* 引入LoggerAspect类中定义的公共方法 */ @Before(&quot;com.atguigu.spring.aop.annotation.LoggerAspect.pointCut()&quot;) public void beforeMethod()&#123; System.out.println(&quot;ValidateAspect---&gt;前置通知&quot;); &#125;&#125; test 1234567891011121314151617181920212223package com.atguigu.spring.test;import com.atguigu.spring.aop.annotation.Calculator;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AOPTest &#123; @Test public void testAOPByAnnotation1()&#123; ApplicationContext ioc=new ClassPathXmlApplicationContext(&quot;aop-annotation.xml&quot;); /* 这个地方获取的应该是代理对象，创建了代理对象之后，只能通过代理对象来访问目标对象，如果用getBean直接获取目标对象就会报错 不知道代理对象的类型，但是它一定实现了Calculator接口，所以用Calculator接口来获取bean 疑问：目标对象和代理对象都实现这个接口，为什么获取的是目标对象？ 因为：目标对象无法获取，获取时报错，所以这个地方只能获取代理对象 */ Calculator calculator = ioc.getBean(Calculator.class); calculator.div(12,1); &#125;&#125; 结果：ValidateAspect—&gt;前置通知 基于xml的aop实现(用不上)声明式事务（JDBCTemplate）简介： Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作 准备工作1.添加依赖 添加模块 spring_transcation 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring 持久化层支持jar包 --&gt; &lt;!-- Spring 在执行持久化层操作、与持久化层技术进行整合过程中，需要使用orm、jdbc、tx三个 jar包 --&gt; &lt;!-- 导入 orm 包就可以通过 Maven 的依赖传递性把其他两个也导入 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring 测试相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据源 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.31&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建jdbc.properties 1234jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=UTCjdbc.username=rootjdbc.password=root spring整合jdbc spring-jdbc.xml spring配置文件 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--引入jdbc.properties文件引入--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;&gt;&lt;/context:property-placeholder&gt; &lt;!--引入数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--JdbcTemplate类中有dataSource属性用上面那个bean赋值给dataSource,dataSource是数据源对象，用来和数据库建立连接--&gt; &lt;bean class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 实现添加功能test 1234567891011121314151617181920212223242526272829package com.atguigu.spring.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;//指定当前测试类在spring的测试环境中执行，也就是Junit环境，此时就可以通过注入的方式直接获取ioc容器中的bean//这个也就是实现了一个当前类的属性如果匹配ioc中的bean就可以给赋值@RunWith(SpringJUnit4ClassRunner.class)//用来设置当前spring测试环境的配置文件//classpath就是类路径，target/classes/@ContextConfiguration(&quot;classpath:spring-jdbc.xml&quot;)public class JdbcTemplateTest &#123; //自动装配jdbcTemplate @Autowiredprivate JdbcTemplate jdbcTemplate; @Test public void testInsert()&#123; String sql=&quot;insert into t_user values(null,?,?,?,?,?)&quot;; //既能实现增加也能实现修改和删除 //第一个参数是sql语句，，第二个参数是sql占位符的内容 jdbcTemplate.update(sql,&quot;root&quot;,&quot;123&quot;,&quot;23&quot;,&quot;女&quot;,&quot;123@qq.com&quot;); &#125;&#125; 实现查询功能添加了一个pojo类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.atguigu.spring.pojo;public class User &#123; private Integer id; private String username; private String password; public Integer getId() &#123; return id; &#125; public User() &#123; &#125; public void setId(Integer id) &#123; this.id = id; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; + &quot;, email=&#x27;&quot; + email + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; private Integer age; private String gender; private String email;&#125; 查询的时候类型的属性名和查询的字段名必须相同，或者用起列名来保持相同，而且User类必须要有无参构造方法 123456789101112131415161718192021222324252627//根据id查找用户信息 @Test public void testGetUserById()&#123; String sql=&quot;select *from t_user where id=?&quot;; //这个也是字段名和属性名一致才能赋值,第二个参数是要映射的实体类类型,第三个参数是sql语句的占位符 //必须得有无参构造方法，要不然无法创建对象 User user = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(User.class),1); System.out .println(user); &#125; //查找全部的用户信息 @Test public void testGetAllUser()&#123; String sql=&quot;select *from t_user&quot;; List&lt;User&gt; query = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(User.class)); query.forEach(System.out::println); &#125; //查询单个数据 @Test public void testGetCount()&#123; String sql=&quot;select count(*) from t_user&quot;; //第二个参数指定查询出来的数据转换为什么类型 Integer integer = jdbcTemplate.queryForObject(sql, Integer.class); System.out.println(integer); &#125; 声明式事务的概念编程式事务 所有的事务操作都是通过自己编程操作实现的 123456789101112131415 Connection conn = ...;try &#123;// 开启事务：关闭事务的自动提交 conn.setAutoCommit(false);// 核心操作// 提交事务 conn.commit(); &#125;catch(Exception e)&#123;// 回滚事务 conn.rollBack(); &#125;finally&#123; // 释放数据库连接conn.close();&#125; 编程式的实现方式存在缺陷： 细节没有被屏蔽：具体操作过程中，所有细节都需要程序员自己来完成，比较繁琐。 代码复用性不高：如果没有有效抽取出来，每次实现功能都需要自己编写代码，代码就没有得到复 用。 声明式事务 事务控制的代码都是差不多的，可以用框架进行封装，消除了冗余的代码 封装起来后，我们只需要在配置文件中进行简单的配置即可完成操作。 基于注解的声明式事务引入依赖 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring 持久化层支持jar包 --&gt; &lt;!-- Spring 在执行持久化层操作、与持久化层技术进行整合过程中，需要使用orm、jdbc、tx三个 jar包 --&gt; &lt;!-- 导入 orm 包就可以通过 Maven 的依赖传递性把其他两个也导入 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring 测试相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据源 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.31&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; jdbc.properties 1234jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=UTCjdbc.username=rootjdbc.password=root 创建Spring-jdbc.xml 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--引入jdbc.properties文件引入--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;&gt;&lt;/context:property-placeholder&gt; &lt;!--引入数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--JdbcTemplate类中有dataSource属性用上面那个bean赋值给dataSource,dataSource是数据源对象，用来和数据库建立连接--&gt; &lt;bean class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 创建表 12345678910111213141516CREATE TABLE `t_book` (`book_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;,`book_name` varchar(20) DEFAULT NULL COMMENT &#x27;图书名称&#x27;,`price` int(11) DEFAULT NULL COMMENT &#x27;价格&#x27;,`stock` int(10) unsigned DEFAULT NULL COMMENT &#x27;库存（无符号）&#x27;,PRIMARY KEY (`book_id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;insert into `t_book`(`book_id`,`book_name`,`price`,`stock`) values (1,&#x27;斗破苍穹&#x27;,80,100),(2,&#x27;斗罗大陆&#x27;,50,100);CREATE TABLE `t_user` (`user_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;,`username` varchar(20) DEFAULT NULL COMMENT &#x27;用户名&#x27;,`balance` int(10) unsigned DEFAULT NULL COMMENT &#x27;余额（无符号）&#x27;,PRIMARY KEY (`user_id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;insert into `t_user`(`user_id`,`username`,`balance`) values (1,&#x27;admin&#x27;,50); 为了让余额和库存都保证大于零，可以给这个字段加一个关键字unsigned，如果余额不足或者库存不足就可以从mysql层面直接抛出一个异常 BookDao 123456789101112131415161718package com.atguigu.spring.dao;public interface BookDao &#123; /* 根据图书的id查询图书的价格 */ Integer getPriceByBookId(); /* 更新图书的库存 */ void updateStock(Integer bookId); /* 更新用户的余额 */ void updateBalance(Integer userId,Integer price);&#125; BookDaoImpl 123456789101112131415161718192021222324252627282930313233package com.atguigu.spring.dao.Impl;import com.atguigu.spring.dao.BookDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;@Repositorypublic class BookDaoImpl implements BookDao &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public Integer getPriceByBookId() &#123; String sql=&quot;select price from t_book where book_id=?&quot;; //第一个参数sql语句，第二个参数是要得到的类型，第三个参数是占位符 return jdbcTemplate.queryForObject(sql,Integer.class,1); &#125; @Override public void updateStock(Integer bookId) &#123;String sql=&quot;update t_book set stock=stock-1 where book_id=?&quot;;//第一个参数是sql语句，第二个参数是id占位符jdbcTemplate.update(sql, bookId); &#125; @Override public void updateBalance(Integer userId,Integer price) &#123; String sql=&quot;update t_user set balance-? where user_id=?&quot;; jdbcTemplate.update(sql,price,userId); &#125;&#125; BookService 12345package com.atguigu.spring.service;public interface BookService &#123; void buyBook(Integer userId, Integer bookId);&#125; BookServiceImpl 1234567891011121314151617181920212223package com.atguigu.spring.service.impl;import com.atguigu.spring.dao.BookDao;import com.atguigu.spring.service.BookService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class BookServiceImpl implements BookService &#123; //自动装配 @Autowired private BookDao bookDao; @Override public void buyBook(Integer userId, Integer bookId) &#123; //查询图书的价格 Integer price=bookDao.getPriceByBookId(); //更新图书的库存 bookDao.updateStock(bookId); //更新用户的余额 bookDao.updateBalance(userId,price); &#125;&#125; BookController 123456789101112131415161718package com.atguigu.spring.controller;import com.atguigu.spring.service.BookService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;@Controllerpublic class BookController &#123; @Autowired private BookService bookService; //实现买书功能 public void buyBook(Integer userId,Integer bookId)&#123; bookService.buyBook(userId,bookId); &#125;&#125; 在配置文件中实现的注解ioc和jdbcTemplate 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--引入jdbc.properties文件引入--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;&gt;&lt;/context:property-placeholder&gt; &lt;!--引入数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--JdbcTemplate类中有dataSource属性用上面那个bean赋值给dataSource,dataSource是数据源对象，用来和数据库建立连接--&gt; &lt;bean class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--扫描组件--&gt; &lt;context:component-scan base-package=&quot;com.atguigu.spring&quot;&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; test 123456789101112131415161718192021222324252627package com.atguigu.spring.test;import com.atguigu.spring.controller.BookController;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.awt.print.Book;//为了让bookController能够自动装配ioc中的bean@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:tx-annotation.xml&quot;)public class TxByAnnotationTest &#123; @Autowired private BookController bookController; @Test public void testBuyBook()&#123; //这种情况，用户余额不足无法购买，但还是减少了库存，所以应该用事务 bookController.buyBook(1,1); &#125;&#125; 第三个报错（余额不足），第二行还会执行提交，所以要用事务，保证三个都一起执行成功才能提交 public void buyBook(Integer userId, Integer bookId) &#123; //查询图书的价格 Integer price=bookDao.getPriceByBookId(); //更新图书的库存 bookDao.updateStock(bookId); //更新用户的余额 bookDao.updateBalance(userId,price); &#125; 实现事务功能声明式事务配置步骤： 1.在Spring配置文件中配置事务管理器 2.开启事务的注解驱动 3.在需要被事务管理的方法上，添加@Transactional注解，该方法就会被事务管理，还可以用在类上，对当前类的所有方法进行事务管理 tx-annotation.xml 12345678910111213141516&lt;!--配置事务管理器--&gt; &lt;!--这里面放的是切面类--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--设置数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 开启事务的注解驱动 将使用@Transactional注解所标识的方法或类中所有的方法（连接点）使用事务进行管理 transactionManaget属性设置事务管理器的id 若事务管理器bean的id默认为transactionManager，则该属性可以不写 --&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;​ &lt;!--引入jdbc.properties文件引入--&gt;​ &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;&gt;&lt;/context:property-placeholder&gt;​ &lt;!--引入数据源--&gt;​ &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;​ &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt;​ &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt;​ &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt;​ &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt;​ &lt;/bean&gt;​ &lt;!--JdbcTemplate类中有dataSource属性用上面那个bean赋值给dataSource,dataSource是数据源对象，用来和数据库建立连接--&gt;​ &lt;bean class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;​ &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;​ &lt;/bean&gt;​ &lt;!--扫描组件--&gt;​ &lt;context:component-scan base-package=&quot;com.atguigu.spring&quot;&gt;&lt;/context:component-scan&gt;​ &lt;!--配置事务管理器--&gt;​ &lt;!--这里面放的是切面类--&gt;​ &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;​ &lt;!--设置数据源--&gt;​ &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;​ &lt;/bean&gt;​ &lt;!--​ 开启事务的注解驱动​ 将使用@Transactional注解所标识的方法或类中所有的方法（连接点）使用事务进行管理​ transactionManaget属性设置事务管理器的id​ 若事务管理器bean的id默认为transactionManager，则该属性可以不写​ --&gt;​ &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;&lt;/beans&gt; 在Service类的buyBook方法加上事务管理的注解 123456789101112131415161718192021222324252627package com.atguigu.spring.service.impl;import com.atguigu.spring.dao.BookDao;import com.atguigu.spring.service.BookService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;@Servicepublic class BookServiceImpl implements BookService &#123; //自动装配 @Autowired private BookDao bookDao; //事务管理的注解 @Transactional @Override public void buyBook(Integer userId, Integer bookId) &#123; //查询图书的价格 Integer price=bookDao.getPriceByBookId(); //更新图书的库存 bookDao.updateStock(bookId); //更新用户的余额 bookDao.updateBalance(userId,price); &#125;&#125; test 1234567891011121314151617181920212223242526package com.atguigu.spring.test;import com.atguigu.spring.controller.BookController;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.awt.print.Book;//为了让bookController能够自动装配ioc中的bean@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:tx-annotation.xml&quot;)public class TxByAnnotationTest &#123; @Autowired private BookController bookController; @Test public void testBuyBook()&#123; bookController.buyBook(1,1); &#125;&#125; 事物的属性只读 对于一个查询操作来说，如果把它设置为只读，就能够明确告诉数据库，这个操作不涉及写操作。这样数据库就能够针对查询操作来进行优化 1@Transactional(readOnly = true) 1234567891011//事务管理的注解@Transactional(readOnly = true)@Overridepublic void buyBook(Integer userId, Integer bookId) &#123; //查询图书的价格 Integer price=bookDao.getPriceByBookId(); //更新图书的库存 bookDao.updateStock(bookId); //更新用户的余额 bookDao.updateBalance(userId,price);&#125; 如果当前事务出现增删改操作的时候就会报这个错 Caused by: java.sql.SQLException:Connection is read-only. Queries leading to data modification are not allowed 超时 事务在执行的过程中，遇到了问题，导致程序卡住，始终占用数据库的资源，此时这个很可能出现问题的事务就应该被回滚，让出资源，让其他事务正常进行 1234567891011121314151617181920//事务管理的注解//如果事务三秒钟没有执行完，就强制回滚并抛出异常@Transactional(timeout=3)@Overridepublic void buyBook(Integer userId, Integer bookId) &#123; Integer price=null; try &#123; //中间是SECONDS就是休眠五秒，中间是MINUTES就是休眠五分钟 TimeUnit.SECONDS.sleep(5); //查询图书的价格 price = bookDao.getPriceByBookId(); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; //更新图书的库存 bookDao.updateStock(bookId); //更新用户的余额 bookDao.updateBalance(userId,price);&#125; 报错，如果事务3秒没执行完就会报的错 org.springframework.transaction.TransactionTimedOutException: Transaction timed out: deadline was Thu Oct 27 16:57:05 CST 2022 回滚策略 声明式事务默认对于所有的运行时异常都回滚 就是设置当前事务遇到什么异常的时候会回滚，遇到什么异常的时候不会回滚 前两个是因为什么异常会回滚，后两个是什么异常不会回滚 rollbackFor属性：需要设置一个Class类型的对象 rollbackForClassName属性：需要设置一个字符串类型的全类名 noRollbackFor属性：需要设置一个Class类型的对象 norollbackFor属性：需要设置一个字符串类型的全类名 后两个常用，默认对于所有运行时异常都回滚，要想有一些异常不回滚就得设置后两个 123456789101112131415161718192021//事务管理的注解//这些运行时异常出现时，不回滚@Transactional(noRollbackFor = &#123;ArithmeticException.class&#125;)@Overridepublic void buyBook(Integer userId, Integer bookId) &#123; Integer price=null; try &#123; //中间是SECONDS就是休眠五秒，中间是MINUTES就是休眠五分钟 TimeUnit.SECONDS.sleep(5); //查询图书的价格 price = bookDao.getPriceByBookId(); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; //更新图书的库存 bookDao.updateStock(bookId); //更新用户的余额 bookDao.updateBalance(userId,price); System.out.println(12/0);&#125; 这个能实先下面说的，{ }在只排除一个异常的时候 不是非要有，但是多个的话就得有{} 1@Transactional(noRollbackFor = &#123;ArithmeticException.class&#125;) 出现下面这种12&#x2F;0错误的时候依然能够买书成功 1System.out.println(12/0); 隔离级别 使用方法 123456789@Transactional(isolation = Isolation.DEFAULT)//使用数据库默认的隔离级别 @Transactional(isolation = Isolation.READ_UNCOMMITTED)//读未提交 @Transactional(isolation = Isolation.READ_COMMITTED)//读已提交 @Transactional(isolation = Isolation.REPEATABLE_READ)//可重复读 @Transactional(isolation = Isolation.SERIALIZABLE)//串行化 脏读：一个事务读取到另外一个事务还没有提交的数据 不可重复读：一个事务前后读取同一条记录，但两次读取的数据不同，称之为不可重复读 幻读：幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样. 在mysql中的默认隔离级别（REPEATABLE READ）也不会发生幻读 传播行为 当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。 结账方法调用买书方法，比如说买两本书，如果有一本书买不了，那这个结账方法应该全部回滚，所以买书方法应该用结账方法的事务，但如果想要实现，一本书买不了但另一本书能买，就设置用买书方法自己的回滚，两种设置方式完全不同 默认是使用结账的事务，就是两本书如果有一本买不成，都会回滚 12345678910111213141516171819202122//事务管理的注解//阻止事务的传播，结账的时候如果第一本买了，第二本买不成，那么就回滚第二次买书@Transactional( propagation = Propagation.REQUIRES_NEW)@Overridepublic void buyBook(Integer userId, Integer bookId) &#123; Integer price=null; try &#123; //中间是SECONDS就是休眠五秒，中间是MINUTES就是休眠五分钟 TimeUnit.SECONDS.sleep(5); //查询图书的价格 price = bookDao.getPriceByBookId(); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; //更新图书的库存 bookDao.updateStock(bookId); //更新用户的余额 bookDao.updateBalance(userId,price);&#125; 结账 123456789101112131415161718192021222324package com.atguigu.spring.service.impl;import com.atguigu.spring.service.BookService;import com.atguigu.spring.service.CheckoutService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;@Servicepublic class CheckoutServiceImpl implements CheckoutService &#123; @Autowired private BookService bookService; @Override @Transactional //事务管理 public void checkout(Integer userId, Integer[] bookIds) &#123; for (Integer bookId : bookIds) &#123; bookService.buyBook(userId,bookId); &#125; &#125;&#125; 基于xml的声明式事务（用的少）引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt; 符和tx:attributes中间规定的方法才能被事务管理，其他的不能被事务管理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--引入jdbc.properties文件引入--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;&gt;&lt;/context:property-placeholder&gt; &lt;!--引入数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--JdbcTemplate类中有dataSource属性用上面那个bean赋值给dataSource,dataSource是数据源对象，用来和数据库建立连接--&gt; &lt;bean class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--扫描组件--&gt; &lt;context:component-scan base-package=&quot;com.atguigu.spring&quot;&gt;&lt;/context:component-scan&gt; &lt;!--配置事务管理器--&gt; &lt;!--这里面放的是切面类--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--设置数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置事务通知--&gt; &lt;!-- tx:advice标签：配置事务通知 --&gt; &lt;!-- id属性：给事务通知标签设置唯一标识，便于引用 --&gt; &lt;!-- transaction-manager属性：关联事务管理器 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- tx:method标签：配置具体的事务方法 --&gt; &lt;!-- name属性：指定方法名，可以使用星号代表多个字符 --&gt; &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;query*&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt; &lt;!-- read-only属性：设置只读属性 --&gt; &lt;!-- rollback-for属性：设置回滚的异常 --&gt; &lt;!-- no-rollback-for属性：设置不回滚的异常 --&gt; &lt;!-- isolation属性：设置事务的隔离级别 --&gt; &lt;!-- timeout属性：设置事务的超时属性 --&gt; &lt;!-- propagation属性：设置事务的传播行为 --&gt; &lt;tx:method name=&quot;save*&quot; read-only=&quot;false&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt; &lt;tx:method name=&quot;update*&quot; read-only=&quot;false&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt; &lt;tx:method name=&quot;delete*&quot; read-only=&quot;false&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt; &lt;!--如果有方法不符合上面这些规则的，是不会被事务管理的--&gt; &lt;!--所以加一个下面这个--&gt; &lt;tx:method name=&quot;*&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref=&quot;tx&quot; pointcut=&quot;execution(* com.atguigu.spring.service.impl.*.*(..))&quot;&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt;&lt;/beans&gt;","categories":[],"tags":[]},{"title":"Docker","slug":"Docker实用篇","date":"2022-09-29T15:31:35.000Z","updated":"2023-04-10T13:21:10.410Z","comments":true,"path":"2022/09/29/Docker实用篇/","link":"","permalink":"http://example.com/2022/09/29/Docker%E5%AE%9E%E7%94%A8%E7%AF%87/","excerpt":"","text":"Docker实用篇0.学习目标1.初识Docker1.1.什么是Docker微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。 分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。 在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题 1.1.1.应用部署的环境问题大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题： 依赖关系复杂，容易出现兼容性问题 开发、测试、生产环境有差异 例如一个项目中，部署时需要依赖于node.js、Redis、RabbitMQ、MySQL等，这些服务部署时所需要的函数库、依赖项各不相同，甚至会有冲突。给部署带来了极大的困难。 1.1.2.Docker解决依赖兼容问题而Docker确巧妙的解决了这些问题，Docker是如何实现的呢？ Docker为了解决依赖的兼容问题的，采用了两个手段： 将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包 将每个应用放到一个隔离容器去运行，避免互相干扰 这样打包好的应用包中，既包含应用本身，也保护应用所需要的Libs、Deps，无需再操作系统上安装这些，自然就不存在不同应用之间的兼容问题了。 虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？ 1.1.3.Docker解决操作系统环境差异要解决不同操作系统环境差异问题，必须先了解操作系统结构。以一个Ubuntu操作系统为例，结构如下： 结构包括： 计算机硬件：例如CPU、内存、磁盘等 系统内核：所有Linux发行版的内核都是Linux，例如CentOS、Ubuntu、Fedora等。内核可以与计算机硬件交互，对外提供内核指令，用于操作计算机硬件。 系统应用：操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便。 应用于计算机交互的流程如下： 1）应用调用操作系统应用（函数库），实现各种功能 2）系统函数库是对内核指令集的封装，会调用内核指令 3）内核指令操作计算机硬件 Ubuntu和CentOSpringBoot都是基于Linux内核，无非是系统应用不同，提供的函数库有差异： 此时，如果将一个Ubuntu版本的MySQL应用安装到CentOS系统，MySQL在调用Ubuntu函数库时，会发现找不到或者不匹配，就会报错了： Docker如何解决不同系统环境的问题？ Docker将用户程序与所需要调用的系统(比如Ubuntu)函数库一起打包 Docker运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的Linux内核来运行 如图： 1.1.4.小结Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？ Docker允许开发中将应用、依赖、函数库、配置一起打包，形成可移植镜像 Docker应用运行在容器中，使用沙箱机制，相互隔离 Docker如何解决开发、测试、生产环境有差异的问题？ Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行 Docker是一个快速交付应用、运行应用的技术，具备下列优势： 可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统 运行时利用沙箱机制形成隔离容器，各个应用互不干扰 启动、移除都可以通过一行命令完成，方便快捷 1.2.Docker和虚拟机的区别Docker可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。 两者有什么差异呢？ 虚拟机（virtual machine）是在操作系统中模拟硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。 虚拟机运行一个mysql服务是先调用函数库再调用内置操作系统再传递Hypervisor，然后再传递web操作系统，再与计算机硬件进行交互，这个效率比docker低 Docker仅仅是封装函数库，并没有模拟完整的操作系统，如图： 对比来看： 小结： Docker和虚拟机的差异： docker是一个系统进程；虚拟机是在操作系统中的操作系统 docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般 1.3.Docker架构1.3.1.镜像和容器Docker中有几个重要的概念： 镜像（Image）：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。 容器（Container）：镜像中的应用程序运行后形成的进程就是容器，只是Docker会给容器进程做隔离，对外不可见。 一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的文件。只有运行时，才会加载到内存，形成进程。 而镜像，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。 镜像不会被干扰也不会被影响和改变，例如mysql都是把镜像的数据拷贝一份到容器中，然后对容器中的数据修改，不会对别的容器和镜像产生影响 容器呢，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。因此一个镜像可以启动多次，形成多个容器进程。 例如你下载了一个QQ，如果我们将QQ在磁盘上的运行文件及其运行的操作系统依赖打包，形成QQ镜像。然后你可以启动多次，双开、甚至三开QQ，跟多个妹子聊天。 1.3.2.DockerHub开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如Redis、MySQL镜像放到网络上，共享使用，就像GitHub的代码共享一样。 DockerHub：DockerHub是一个官方的Docker镜像的托管平台。这样的平台称为Docker Registry。 国内也有类似于DockerHub 的公开服务，比如 网易云镜像服务、阿里云镜像库等。 我们一方面可以将自己的镜像共享到DockerHub，另一方面也可以从DockerHub拉取镜像： 1.3.3.Docker架构我们要使用Docker来操作镜像、容器，就必须要安装Docker。 Docker是一个CS架构的程序，由两部分组成： 服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等 客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。 如图： 1.3.4.小结镜像： 将应用程序及其依赖、环境、配置打包在一起 容器： 镜像运行起来就是容器，一个镜像可以运行多个容器 Docker结构： 服务端：接收命令或远程请求，操作镜像或容器 客户端：发送命令或者请求到Docker服务端 DockerHub： 一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry 1.4.安装Docker企业部署一般都是采用Linux操作系统，而其中又数CentOS发行版占比最多，因此我们在CentOS下安装Docker。参考课前资料中的文档： 2.Docker的基本操作2.1.镜像操作2.1.1.镜像名称首先来看下镜像的名称组成： 镜名称一般分两部分组成：[repository]:[tag]。 在没有指定tag时，默认是latest，代表最新版本的镜像 如图： 这里的mysql就是repository，5.7就是tag，合一起就是镜像名称，代表5.7版本的MySQL镜像。 2.1.2.镜像命令常见的镜像操作命令如图： 2.1.3.案例1-拉取、查看镜像需求：从DockerHub中拉取一个nginx镜像并查看 1）首先去镜像仓库搜索nginx镜像，比如DockerHub: 2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx 3）通过命令：docker images 查看拉取到的镜像 2.1.4.案例2-保存、导入镜像需求：利用docker save将nginx镜像导出磁盘，然后再通过load加载回来 1）利用docker xx –help命令查看docker save和docker load的语法 例如，查看save命令用法，可以输入命令： 1docker save --help 结果： 命令格式： 1docker save -o [保存的目标文件名称] [镜像名称] 2）使用docker save导出镜像到磁盘 运行命令： save就相当于把镜像保存在本地，本来要到仓库中去拉取镜像，现在load本地镜像就可以了 1docker save -o nginx.tar nginx:latest 结果如图： 3）使用docker load加载镜像 先删除本地的nginx镜像： 可以通过镜像id或者镜像名称来删除 1docker rmi nginx:latest 然后运行命令，加载本地文件： 1docker load -i nginx.tar 结果： 2.1.5.练习需求：去DockerHub搜索并拉取一个Redis镜像 目标： 1）去DockerHub搜索Redis镜像 2）查看Redis镜像的名称和版本 3）利用docker pull命令拉取镜像 4）利用docker save命令将 redis:latest打包为一个redis.tar包 5）利用docker rmi 删除本地的redis:latest 6）利用docker load 重新加载 redis.tar文件 2.2.容器操作2.2.1.容器相关命令容器操作的命令如图： 容器保护三个状态： 运行：进程正常运行 暂停：进程暂停，CPU不再运行，并不释放内存 停止：进程终止，回收进程占用的内存、CPU等资源 其中： docker run：创建并运行一个容器，处于运行状态 docker pause：让一个运行的容器暂停 docker unpause：让一个容器从暂停状态恢复运行 docker stop：停止一个运行的容器 docker start：让一个停的容器再次运行 docker rm：删除一个容器 2.2.2.案例-创建并运行一个容器创建并运行nginx容器的命令： 1docker run --name containerName -p 80:80 -d nginx 会生成一个容器id：3cbeb066befcf012b34ef91cfab2e4c0c62fb3cded6af9119a2f107d90a11ddb 命令解读： docker run ：创建并运行一个容器 –name : 给容器起一个名字，比如叫做mn -p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口 -d：后台运行容器 nginx：镜像名称，例如nginx 这里的-p参数，是将容器端口映射到宿主机端口。 默认情况下，容器是隔离环境，我们直接访问宿主机的80端口，肯定访问不到容器中的nginx。 现在，将容器的80与宿主机的80关联起来，当我们访问宿主机的80端口时，就会被映射到容器的80，这样就能访问到nginx了： 容器的端口一般是固定的，容器端口选择是根据服务来的，比如mysql是3306，nginx服务是80端口 docker ps查看所有运行的容器 2.2.3.案例-进入容器，修改文件需求：进入Nginx容器，修改HTML文件内容，添加“传智教育欢迎您” 提示：进入容器要用到docker exec命令。 步骤： 1）进入容器。进入我们刚刚创建的nginx容器的命令为： 1docker exec -it mn bash 命令解读： docker exec ：进入容器内部，执行一个命令 -it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互 mn ：要进入的容器的名称 bash：进入容器后执行的命令，bash是一个linux终端交互命令 2）进入nginx的HTML所在目录 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html 容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样： nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。 查看DockerHub网站中的nginx页面，可以知道nginx的html目录位置在/usr/share/nginx/html 我们执行命令，进入该目录： 1cd /usr/share/nginx/html 查看目录下文件： 3）修改index.html的内容 容器中模拟的操作系统，是阉割版的，只要满足了nginx的需求就可以，所以没有vi命令 容器内没有vi命令，无法直接修改，我们用下面的命令来修改： 1sed -i -e &#x27;s#Welcome to nginx#传智教育欢迎您#g&#x27; -e &#x27;s#&lt;head&gt;#&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;#g&#x27; index.html 在浏览器访问自己的虚拟机地址，例如我的是：http://192.168.150.101，即可看到结果： exit命令可以从容器中退出来 docker ps -a能显示所有容器，无论是否在运行，但是容器被删除就不能显示了，容器被stop或者pause都可以看见 删除容器之前正常都需要停止容器 也可以通过强制删除直接删除运行中容器 docker rm -f mn mn是容器名，-f是强制删除运行中容器 2.2.4.小结docker run命令的常见参数有哪些？ –name：指定容器名称 -p：指定端口映射 -d：让容器后台运行 查看容器日志的命令： docker logs 添加 -f 参数可以持续查看日志 查看容器状态： docker ps docker ps -a 查看所有容器，包括已经停止的 2.3.数据卷（容器数据管理）在之前的nginx案例中，修改nginx的html页面时，需要进入nginx内部。并且因为没有编辑器，修改文件也很麻烦。 这就是因为容器与数据（容器内文件）耦合带来的后果。 要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。 2.3.1.什么是数据卷数据卷（volume）是一个虚拟目录，指向宿主机文件系统中的某个目录。 一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。 这样，我们操作宿主机的&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;html目录，就等于操作容器内的&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html目录了 2.3.2.数据集操作命令数据卷操作的基本语法如下： 1docker volume [COMMAND] docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作： create 创建一个volume inspect 显示一个或多个volume的信息 ls 列出所有的volume prune 删除未使用的volume rm 删除一个或多个指定的volume 2.3.3.创建和查看数据卷需求：创建一个数据卷，并查看数据卷在宿主机的目录位置 ① 创建数据卷 1docker volume create html ② 查看所有数据 1docker volume ls 结果： ③ 查看数据卷详细信息卷 1docker volume inspect html 结果： 可以看到，我们创建的html这个数据卷关联的宿主机目录为/var/lib/docker/volumes/html/_data目录。 小结： 数据卷的作用： 将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全 数据卷操作： docker volume create：创建数据卷 docker volume ls：查看所有数据卷 docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置 docker volume rm：删除指定数据卷 docker volume prune：删除所有未使用的数据卷 2.3.4.挂载数据卷我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下： 12345docker run \\ --name mn \\ -v html:/root/html \\ -p 8080:80 nginx \\ 这里的-v就是挂载数据卷的命令： -v html:/root/htm ：把html数据卷挂载到容器内的&#x2F;root&#x2F;html这个目录中 2.3.5.案例-给nginx挂载数据卷需求：创建一个nginx容器，修改容器内的html目录内的index.html内容 分析：上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html ，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容。 提示：运行容器时使用 -v 参数挂载数据卷 步骤： ① 创建容器并挂载数据卷到容器内的HTML目录 html这个卷会自动创建出来 1docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx ② 进入html数据卷所在位置，并修改HTML内容 123456# 查看html数据卷的位置docker volume inspect html# 进入该目录cd /var/lib/docker/volumes/html/_data# 修改文件vi index.html 2.3.6.案例-给MySQL挂载本地目录容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下： 带数据卷模式：宿主机目录 –&gt; 数据卷 —&gt; 容器内目录 直接挂载模式：宿主机目录 —&gt; 容器内目录 如图： 语法： 宿主机目录或者文件也不需要非得像创建数据卷那样创建，自己创建就可以了 目录挂载与数据卷挂载的语法是类似的： -v [宿主机目录]:[容器内目录] -v [宿主机文件]:[容器内文件] 需求：创建并运行一个MySQL容器，将宿主机目录直接挂载到容器 实现思路如下： 1）在将课前资料中的mysql.tar文件上传到虚拟机，通过load命令加载为镜像 2）创建目录&#x2F;tmp&#x2F;mysql&#x2F;data 3）创建目录&#x2F;tmp&#x2F;mysql&#x2F;conf，将课前资料提供的hmy.cnf文件上传到&#x2F;tmp&#x2F;mysql&#x2F;conf 4）去DockerHub查阅资料，创建并运行MySQL容器，要求： ① 挂载&#x2F;tmp&#x2F;mysql&#x2F;data到mysql容器内数据存储目录 ② 挂载&#x2F;tmp&#x2F;mysql&#x2F;conf&#x2F;hmy.cnf到mysql容器的配置文件 ③ 设置MySQL密码 2.3.7.小结docker run的命令中通过 -v 参数挂载文件或目录到容器中： -v volume名称:容器内目录 -v 宿主机文件:容器内文 -v 宿主机目录:容器内目录 数据卷挂载与目录直接挂载的 数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找 目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看 3.Dockerfile自定义镜像常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。 而要自定义镜像，就必须先了解镜像的结构才行。 3.1.镜像结构镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。 我们以MySQL为例，来看看镜像的组成结构： 简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。 我们要构建镜像，其实就是实现上述打包的过程。 3.2.Dockerfile语法构建自定义的镜像时，并不需要一个个文件去拷贝，打包。 我们只需要告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。 而描述上述信息的文件就是Dockerfile文件。 Dockerfile就是一个文本文件，其中包含一个个的**指令(Instruction)**，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。 更新详细语法说明，请参考官网文档： https://docs.docker.com/engine/reference/builder 3.3.构建Java项目3.3.1.基于Ubuntu构建Java项目需求：基于Ubuntu镜像构建一个新镜像，运行一个java项目 步骤1：新建一个空文件夹docker-demo 步骤2：拷贝课前资料中的docker-demo.jar文件到docker-demo这个目录 步骤3：拷贝课前资料中的jdk8.tar.gz文件到docker-demo这个目录 步骤4：拷贝课前资料提供的Dockerfile到docker-demo这个目录 其中的内容如下： 12345678910111213141516171819202122# 指定基础镜像FROM ubuntu:16.04# 配置环境变量，JDK的安装目录ENV JAVA_DIR=/usr/local# 拷贝jdk和java项目的包COPY ./jdk8.tar.gz $JAVA_DIR/COPY ./docker-demo.jar /tmp/app.jar# 安装JDKRUN cd $JAVA_DIR \\ &amp;&amp; tar -xf ./jdk8.tar.gz \\ &amp;&amp; mv ./jdk1.8.0_144 ./java8# 配置环境变量ENV JAVA_HOME=$JAVA_DIR/java8ENV PATH=$PATH:$JAVA_HOME/bin# 暴露端口EXPOSE 8090# 入口，java项目的启动命令ENTRYPOINT java -jar /tmp/app.jar 步骤5：进入docker-demo 将准备好的docker-demo上传到虚拟机任意目录，然后进入docker-demo目录下 步骤6：运行命令： 构建镜像， .是指Dockerfile在当前目录 1docker build -t javaweb:1.0 . 最后访问 http://192.168.150.101:8090/hello/count，其中的ip改成你的虚拟机ip 3.3.2.基于java8构建Java项目虽然我们可以基于Ubuntu基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。 例如，构建java项目的镜像，可以在已经准备了JDK的基础镜像基础上构建。 需求：基于java:8-alpine镜像，将一个Java项目构建为镜像 实现思路如下： ① 新建一个空的目录，然后在目录中新建一个文件，命名为Dockerfile ② 拷贝课前资料提供的docker-demo.jar到这个目录中 ③ 编写Dockerfile文件： a ）基于java:8-alpine作为基础镜像 b ）将app.jar拷贝到镜像中 c ）暴露端口 d ）编写入口ENTRYPOINT 内容如下： 1234FROM java:8-alpineCOPY ./app.jar /tmp/app.jarEXPOSE 8090ENTRYPOINT java -jar /tmp/app.jar ④ 使用docker build命令构建镜像 ⑤ 使用docker run创建容器并运行 3.4.小结小结： Dockerfile的本质是一个文件，通过指令描述镜像的构建过程 Dockerfile的第一行必须是FROM，从一个基础镜像来构建 基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine 4.Docker-ComposeDocker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！ 4.1.初识DockerComposeCompose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下： 1234567891011121314version: &quot;3.8&quot; services: mysql: image: mysql:5.7.25 environment: MYSQL_ROOT_PASSWORD: 123 volumes: - &quot;/tmp/mysql/data:/var/lib/mysql&quot; - &quot;/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf&quot; web: build: . ports: - &quot;8090:8090&quot; 上面的Compose文件就描述一个项目，其中包含两个容器： mysql：一个基于mysql:5.7.25镜像构建的容器，并且挂载了两个目录 web：一个基于docker build临时构建的镜像容器，映射端口时8090 DockerCompose的详细语法参考官网：https://docs.docker.com/compose/compose-file/ 其实DockerCompose文件可以看做是将多个docker run命令写到一个文件，只是语法稍有差异。 4.2.安装DockerCompose参考课前资料 4.3.部署微服务集群需求：将之前学习的cloud-demo微服务集群利用DockerCompose部署 实现思路： ① 查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件 ② 修改自己的cloud-demo项目，将数据库、nacos地址都命名为docker-compose中的服务名 ③ 使用maven打包工具，将项目中的每个微服务都打包为app.jar ④ 将打包好的app.jar拷贝到cloud-demo中的每一个对应的子目录中 ⑤ 将cloud-demo上传至虚拟机，利用 docker-compose up -d 来部署 4.3.1.compose文件查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件，而且每个微服务都准备了一个独立的目录： 内容如下： 123456789101112131415161718192021222324version: &quot;3.2&quot;services: nacos: image: nacos/nacos-server environment: MODE: standalone ports: - &quot;8848:8848&quot; mysql: image: mysql:5.7.25 environment: MYSQL_ROOT_PASSWORD: 123 volumes: - &quot;$PWD/mysql/data:/var/lib/mysql&quot; - &quot;$PWD/mysql/conf:/etc/mysql/conf.d/&quot; userservice: build: ./user-service orderservice: build: ./order-service gateway: build: ./gateway ports: - &quot;10010:10010&quot; 可以看到，其中包含5个service服务： nacos：作为注册中心和配置中心 image: nacos/nacos-server： 基于nacos&#x2F;nacos-server镜像构建 environment：环境变量 MODE: standalone：单点模式启动 ports：端口映射，这里暴露了8848端口 mysql：数据库 image: mysql:5.7.25：镜像版本是mysql:5.7.25 environment：环境变量 MYSQL_ROOT_PASSWORD: 123：设置数据库root账户的密码为123 volumes：数据卷挂载，这里挂载了mysql的data、conf目录，其中有我提前准备好的数据 userservice、orderservice、gateway：都是基于Dockerfile临时构建的 查看mysql目录，可以看到其中已经准备好了cloud_order、cloud_user表： 查看微服务目录，可以看到都包含Dockerfile文件： 内容如下： 123FROM java:8-alpineCOPY ./app.jar /tmp/app.jarENTRYPOINT java -jar /tmp/app.jar 4.3.2.修改微服务配置因为微服务将来要部署为docker容器，而容器之间互联不是通过IP地址，而是通过容器名。这里我们将order-service、user-service、gateway服务的mysql、nacos地址都修改为基于容器名的访问。 如下所示： 1234567891011spring: datasource: url: jdbc:mysql://mysql:3306/cloud_order?useSSL=false username: root password: 123 driver-class-name: com.mysql.jdbc.Driver application: name: orderservice cloud: nacos: server-addr: nacos:8848 # nacos服务地址 4.3.3.打包接下来需要将我们的每个微服务都打包。因为之前查看到Dockerfile中的jar包名称都是app.jar，因此我们的每个微服务都需要用这个名称。 可以通过修改pom.xml中的打包名称来实现，每个微服务都需要修改： 12345678910&lt;build&gt; &lt;!-- 服务打包的最终名称 --&gt; &lt;finalName&gt;app&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 打包后： 4.3.4.拷贝jar包到部署目录编译打包好的app.jar文件，需要放到Dockerfile的同级目录中。注意：每个微服务的app.jar放到与服务名称对应的目录，别搞错了。 user-service： order-service： gateway： 4.3.5.部署最后，我们需要将文件整个cloud-demo文件夹上传到虚拟机中，理由DockerCompose部署。 上传到任意目录： 部署： 进入cloud-demo目录，然后运行下面的命令： 1docker-compose up -d 5.Docker镜像仓库5.1.搭建私有镜像仓库参考课前资料《CentOS7安装Docker.md》 5.2.推送、拉取镜像推送镜像到私有镜像服务必须先tag，步骤如下： ① 重新tag本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080&#x2F; 1docker tag nginx:latest 192.168.150.101:8080/nginx:1.0 ② 推送镜像 1docker push 192.168.150.101:8080/nginx:1.0 ③ 拉取镜像 1docker pull 192.168.150.101:8080/nginx:1.0","categories":[],"tags":[]},{"title":"SpringCloud1","slug":"SpringCloud01","date":"2022-09-29T15:31:35.000Z","updated":"2023-04-10T13:15:09.049Z","comments":true,"path":"2022/09/29/SpringCloud01/","link":"","permalink":"http://example.com/2022/09/29/SpringCloud01/","excerpt":"","text":"SpringCloud011.认识微服务随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。这些架构之间有怎样的差别呢？ 1.0.学习目标了解微服务架构的优缺点 1.1.单体架构单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署。 单体架构的优缺点如下： 优点： 架构简单 部署成本低 缺点： 耦合度高（维护困难、升级困难） 1.2.分布式架构分布式架构：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。 分布式架构的优缺点： 优点： 降低服务耦合 有利于服务升级和拓展 缺点： 服务调用关系错综复杂 分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考： 服务拆分的粒度如何界定？ 服务之间如何调用？ 服务的调用关系如何管理？ 人们需要制定一套行之有效的标准来约束分布式架构。 1.3.微服务微服务的架构特征： 单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责 自治：团队独立、技术独立、数据独立，独立部署和交付 面向服务：服务提供统一标准的接口，与语言和技术无关 隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题 微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。 因此，可以认为微服务是一种经过良好架构设计的分布式架构方案 。 但方案该怎么落地？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案。 其中在Java领域最引人注目的就是SpringCloud提供的方案了。 1.4.SpringCloudSpringCloud是目前国内使用最广泛的微服务框架。官网地址：https://spring.io/projects/spring-cloud。 SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。 其中常见的组件包括： 另外，SpringCloud底层是依赖于SpringBoot的，并且有版本的兼容关系，如下： 我们课堂学习的版本是 Hoxton.SR10，因此对应的SpringBoot版本是2.3.x版本。 1.5.总结 单体架构：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统 分布式架构：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝 微服务：一种良好的分布式架构方案 ①优点：拆分粒度更小、服务更独立、耦合度更低 ②缺点：架构非常复杂，运维、监控、部署难度提高 SpringCloud是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件 2.服务拆分和远程调用任何分布式架构都离不开服务的拆分，微服务也是一样。 2.1.服务拆分原则这里我总结了微服务拆分时的几个原则： 不同微服务，不要重复开发相同业务 微服务数据独立，不要访问其它微服务的数据库 微服务可以将自己的业务暴露为接口，供其它微服务调用 2.2.服务拆分示例以课前资料中的微服务cloud-demo为例，其结构如下： cloud-demo：父工程，管理依赖 order-service：订单微服务，负责订单相关业务 user-service：用户微服务，负责用户相关业务 要求： 订单微服务和用户微服务都必须有各自的数据库，相互独立 订单服务和用户服务都对外暴露Restful的接口 订单服务如果需要查询用户信息，只能调用用户服务的Restful接口，不能查询用户数据库 2.2.1.导入Sql语句首先，将课前资料提供的cloud-order.sql和cloud-user.sql导入到mysql中： cloud-user表中初始数据如下： cloud-order表中初始数据如下： cloud-order表中持有cloud-user表中的id字段。 2.2.2.导入demo工程用IDEA导入课前资料提供的Demo： 项目结构如下： 导入后，会在IDEA右下角出现弹窗： 点击弹窗，然后按下图选择： 会出现这样的菜单： 配置下项目使用的JDK： 2.3.实现远程调用案例在order-service服务中，有一个根据id查询订单的接口： 根据id查询订单，返回值是Order对象，如图： 其中的user为null 在user-service中有一个根据id查询用户的接口： 查询的结果如图： 2.3.1.案例需求：修改order-service中的根据id查询订单业务，要求在查询订单的同时，根据订单中包含的userId查询出用户信息，一起返回。 因此，我们需要在order-service中 向user-service发起一个http的请求，调用http://localhost:8081/user/{userId}这个接口。 大概的步骤是这样的： 注册一个RestTemplate的实例到Spring容器 修改order-service服务中的OrderService类中的queryOrderById方法，根据Order对象中的userId查询User 将查询的User填充到Order对象，一起返回 2.3.2.注册RestTemplate首先，我们在order-service服务中的OrderApplication启动类中，注册RestTemplate实例： 123456789101112131415161718192021package cn.itcast.order;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import org.springframework.web.client.RestTemplate;@MapperScan(&quot;cn.itcast.order.mapper&quot;)@SpringBootApplicationpublic class OrderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderApplication.class, args); &#125; @Bean public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; 2.3.3.实现远程调用修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法： 用restemplate发起http请求 2.4.提供者与消费者在服务调用关系中，会有两个不同的角色： 服务提供者：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务） 服务消费者：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口） 但是，服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。 如果服务A调用了服务B，而服务B又调用了服务C，服务B的角色是什么？ 对于A调用B的业务而言：A是服务消费者，B是服务提供者 对于B调用C的业务而言：B是服务消费者，C是服务提供者 因此，服务B既可以是服务提供者，也可以是服务消费者。 3.Eureka注册中心假如我们的服务提供者user-service部署了多个实例，如图： 大家思考几个问题： order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？ 有多个user-service实例地址，order-service调用时该如何选择？ order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？ 3.1.Eureka的结构和作用这些问题都需要利用SpringCloud中的注册中心来解决，其中最广为人知的注册中心就是Eureka，其结构如下： 回答之前的各个问题。 问题1：order-service如何得知user-service实例地址？ 获取地址信息的流程如下： user-service服务实例启动后，将自己的信息注册到eureka-server（Eureka服务端）。这个叫服务注册 eureka-server保存服务名称到服务实例地址列表的映射关系 order-service根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取 问题2：order-service如何从多个user-service实例中选择具体的实例？ order-service从实例列表中利用负载均衡算法选中一个实例地址 向该实例地址发起远程调用 问题3：order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？ user-service会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态，称为心跳 当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中剔除 order-service拉取服务时，就能将故障实例排除了 注意：一个微服务，既可以是服务提供者，又可以是服务消费者，因此eureka将服务注册、服务发现等功能统一封装到了eureka-client端 因此，接下来我们动手实践的步骤包括： 3.2.搭建eureka-server首先大家注册中心服务端：eureka-server，这必须是一个独立的微服务 3.2.1.创建eureka-server服务在cloud-demo父工程下，创建一个子模块： 填写模块信息： 然后填写服务信息： 3.2.2.引入eureka依赖引入SpringCloud为eureka提供的starter依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; 3.2.3.编写启动类给eureka-server服务编写一个启动类，一定要添加一个@EnableEurekaServer注解，开启eureka的注册中心功能： 12345678910111213package cn.itcast.eureka;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@SpringBootApplication@EnableEurekaServerpublic class EurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaApplication.class, args); &#125;&#125; 3.2.4.编写配置文件上面这些包括这个就是在做eureka服务的注册 编写一个application.yml文件，内容如下： 123456789server: port: 10086spring: application: name: eureka-servereureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka 3.2.5.启动服务启动微服务，然后在浏览器访问：http://127.0.0.1:10086 看到下面结果应该是成功了： instances currently registered with Eureka 这个是指注册到eureka的服务实例（比如userService服务实例，orderService服务实例） 3.3.服务注册下面，我们将user-service注册到eureka-server中去。 1）引入依赖在user-service的pom文件中，引入下面的eureka-client依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 2）配置文件在user-service中，修改application.yml文件，添加服务名称、eureka地址： 1234567spring: application: name: userserviceeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka 3）启动多个user-service实例为了演示一个服务有多个实例的场景，我们添加一个SpringBoot的启动配置，再启动一个user-service。 首先，复制原来的user-service启动配置： 然后，在弹出的窗口中，填写信息： 现在，SpringBoot窗口会出现两个user-service启动配置： 不过，第一个是8081端口，第二个是8082端口。 启动两个user-service实例： 查看eureka-server管理页面： 3.4.服务发现下面，我们将order-service的逻辑修改：向eureka-server拉取user-service的信息，实现服务发现。 1）引入依赖之前说过，服务发现、服务注册统一都封装在eureka-client依赖，因此这一步与服务注册时一致。 在order-service的pom文件中，引入下面的eureka-client依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 2）配置文件服务发现也需要知道eureka地址，因此第二步与服务注册一致，都是配置eureka信息： 在order-service中，修改application.yml文件，添加服务名称、eureka地址： 1234567spring: application: name: orderserviceeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka 3）服务拉取和负载均衡最后，我们要去eureka-server中拉取user-service服务的实例列表，并且实现负载均衡。 不过这些动作不用我们去做，只需要添加一些注解即可。 在order-service的OrderApplication中，给RestTemplate这个Bean添加一个@LoadBalanced注解： 修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法。修改访问的url路径，用服务名代替ip、端口： userservice就是eureka-server端注册的几个ip:port spring会自动帮助我们从eureka-server端，根据userservice这个服务名称，获取实例列表，而后完成负载均衡。 这个userservice应该是项目application.yml文件中的项目name 4.Ribbon负载均衡上一节中，我们添加了@LoadBalanced注解，即可实现负载均衡功能，这是什么原理呢？ 4.1.负载均衡原理SpringCloud底层其实是利用了一个名为Ribbon的组件，来实现负载均衡功能的。 那么我们发出的请求明明是http://userservice/user/1，怎么变成了http://localhost:8081的呢？ 4.2.源码跟踪为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。 显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是LoadBalancerInterceptor，这个类会在对RestTemplate的请求进行拦截，然后从Eureka根据服务id获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务id。 我们进行源码跟踪： 1）LoadBalancerIntercepor 可以看到这里的intercept方法，拦截了用户的HttpRequest请求，然后做了几件事： request.getURI()：获取请求uri，本例中就是 http://user-service/user/8 originalUri.getHost()：获取uri路径的主机名，其实就是服务id，user-service this.loadBalancer.execute()：处理服务id，和用户请求。 这里的this.loadBalancer是LoadBalancerClient类型，我们继续跟入。 2）LoadBalancerClient继续跟入execute方法： 代码是这样的： getLoadBalancer(serviceId)：根据服务id获取ILoadBalancer，而ILoadBalancer会拿着服务id去eureka中获取服务列表并保存起来。 getServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了8082端口的服务 放行后，再次访问并跟踪，发现获取的是8081： 果然实现了负载均衡。 3）负载均衡策略IRule在刚才的代码中，可以看到获取服务使通过一个getServer方法来做负载均衡: 我们继续跟入： 继续跟踪源码chooseServer方法，发现这么一段代码： 我们看看这个rule是谁： 这里的rule默认值是一个RoundRobinRule，看类的介绍： 这不就是轮询的意思嘛。 到这里，整个负载均衡的流程我们就清楚了。 4）总结SpringCloudRibbon的底层采用了一个拦截器，拦截了RestTemplate发出的请求，对地址做了修改。用一幅图来总结一下： 基本流程如下： 拦截我们的RestTemplate请求http://userservice/user/1 RibbonLoadBalancerClient会从请求url中获取服务名称，也就是user-service DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表 eureka返回列表，localhost:8081、localhost:8082 IRule利用内置负载均衡规则，从列表中选择一个，例如localhost:8081 RibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到http://localhost:8081/user/1，发起真实请求 4.3.负载均衡策略4.3.1.负载均衡策略负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类： 不同规则的含义如下： 内置负载均衡规则类 规则描述 RoundRobinRule 简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。 AvailabilityFilteringRule 对以下两种服务器进行忽略： （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。 （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的..ActiveConnectionsLimit属性进行配置。 WeightedResponseTimeRule 为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。 ZoneAvoidanceRule 以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。 BestAvailableRule 忽略那些短路的服务器，并选择并发数较低的服务器。 RandomRule 随机选择一个可用的服务器。 RetryRule 重试机制的选择逻辑 默认的实现就是ZoneAvoidanceRule，是一种轮询方案 4.3.2.自定义负载均衡策略通过定义IRule实现可以修改负载均衡规则，有两种方式： 两种方式是有区别的，第一种是全局的以后不管涉及哪个微服务都是用randomRule实现负载均衡，第二种则是针对指定的微服务进行randomRule的负载均衡 1.代码方式：在order-service中的OrderApplication类中，定义一个新的IRule： 1234@Beanpublic IRule randomRule()&#123; return new RandomRule();&#125; 配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则： 123userservice: # 给某个微服务配置负载均衡规则，这里是userservice服务 ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则 注意，一般用默认的负载均衡规则，不做修改。 4.4.饥饿加载饥饿加载其实就是很多服务在第一次访问的时候才会加载，现在提前到项目启动的时候就加载好，减少第一次访问的时间 Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。 而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载： 1234ribbon: eager-load: enabled: true clients: userservice 如果有多个微服务要饥饿加载 123456ribbon: eager-load: enabled: true clients: - userservice - xxxservice 5.Nacos注册中心国内公司一般都推崇阿里巴巴的技术，比如注册中心，SpringCloudAlibaba也推出了一个名为Nacos的注册中心。 5.1.认识和安装NacosNacos是阿里巴巴的产品，现在是SpringCloud中的一个组件。相比Eureka功能更加丰富，在国内受欢迎程度较高。 安装方式可以参考课前资料《Nacos安装指南.md》 5.2.服务注册到nacosNacos是SpringCloudAlibaba的组件，而SpringCloudAlibaba也遵循SpringCloud中定义的服务注册、服务发现规范。因此使用Nacos和使用Eureka对于微服务来说，并没有太大区别。 主要差异在于： 依赖不同 服务地址不同 1）引入依赖在cloud-demo父工程的pom文件中的&lt;dependencyManagement&gt;中引入SpringCloudAlibaba的依赖： 1234567&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt; 然后在user-service和order-service中的pom文件中引入nacos-discovery依赖： 1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt; 注意：不要忘了注释掉eureka的依赖。 2）配置nacos地址在user-service和order-service的application.yml中添加nacos地址： 1234spring: cloud: nacos: server-addr: localhost:8848 注意：不要忘了注释掉eureka的地址 3）重启重启微服务后，登录nacos管理页面，可以看到微服务信息： 5.3.服务分级存储模型一个服务可以有多个实例，例如我们的user-service，可以有: 127.0.0.1:8081 127.0.0.1:8082 127.0.0.1:8083 假如这些实例分布于全国各地的不同机房，例如： 127.0.0.1:8081，在上海机房 127.0.0.1:8082，在上海机房 127.0.0.1:8083，在杭州机房 Nacos就将同一机房内的实例 划分为一个集群。 也就是说，user-service是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图： 微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如： 杭州机房内的order-service应该优先访问同机房的user-service。 5.3.1.给user-service配置集群修改user-service的application.yml文件，添加集群配置： 123456spring: cloud: nacos: server-addr: localhost:8848 discovery: cluster-name: HZ # 集群名称 重启两个user-service实例后，我们可以在nacos控制台看到下面结果： 方法一： 再创建一个8083端口的userservice服务，然后把配置文件application.yml集群名称那改为SH，上海，然后再启动也是一样的效果 方法二： 我们再次复制一个user-service启动配置，添加属性： 1-Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH 配置如图所示： 启动UserApplication3后再次查看nacos控制台： 5.3.2.同集群优先的负载均衡默认的ZoneAvoidanceRule并不能实现根据同集群优先来实现负载均衡。 因此Nacos中提供了一个NacosRule的实现，可以优先从同集群中挑选实例，再在集群中随机选取 1）给order-service配置集群信息 修改order-service的application.yml文件，添加集群配置： 123456spring: cloud: nacos: server-addr: localhost:8848 discovery: cluster-name: HZ # 集群名称 2）修改负载均衡规则 修改order-service的application.yml文件，修改负载均衡规则： NacosRule优先选择本地服务，在本地这些服务中再采取随机的方式选取 123userservice: ribbon: NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule # 负载均衡规则 5.4.权重配置实际部署中会出现这样的场景： 服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。 但默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。 因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。 在nacos控制台，找到user-service的实例列表，点击编辑，即可修改权重： 在弹出的编辑窗口，修改权重： 注意：如果权重修改为0，则该实例永远不会被访问 5.5.环境隔离Nacos提供了namespace来实现环境隔离功能。 nacos中可以有多个namespace namespace下可以有group、service等 不同namespace之间相互隔离，例如不同namespace的服务互相不可见 5.5.1.创建namespace默认情况下，所有service、data、group都在同一个namespace，名为public： 我们可以点击页面新增按钮，添加一个namespace： 然后，填写表单： 就能在页面看到一个新的namespace： 5.5.2.给微服务配置namespace给微服务配置namespace只能通过修改配置来实现。 例如，修改order-service的application.yml文件： 1234567spring: cloud: nacos: server-addr: localhost:8848 discovery: cluster-name: HZ namespace: 492a7d5d-237b-46a1-a99a-fa8e98e4b0f9 # 命名空间，填ID 重启order-service后，访问控制台，可以看到下面的结果： 此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错： 5.6.Nacos与Eureka的区别Nacos的服务实例分为两种l类型： 临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。 非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。 配置一个服务实例为永久实例： 12345spring: cloud: nacos: discovery: ephemeral: false # 设置为非临时实例 Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异： Nacos与eureka的共同点 都支持服务注册和服务拉取，不是每次都会进行服务拉取，也是会有一个服务列表缓存，定时更新服务列表缓存，所以可能会导致服务列表缓存更新不及时 都支持服务提供者心跳方式做健康检测 Nacos与Eureka的区别 Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式 临时实例心跳不正常会被剔除，非临时实例则不会被剔除 Nacos支持服务列表变更的消息推送模式，服务列表缓存更新更及时 Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式","categories":[],"tags":[]},{"title":"SpringCloud2","slug":"SpringCloud实用篇02","date":"2022-09-29T15:31:35.000Z","updated":"2023-04-10T13:00:30.160Z","comments":true,"path":"2022/09/29/SpringCloud实用篇02/","link":"","permalink":"http://example.com/2022/09/29/SpringCloud%E5%AE%9E%E7%94%A8%E7%AF%8702/","excerpt":"","text":"SpringCloud实用篇020.学习目标1.Nacos配置管理Nacos除了可以做注册中心，同样可以做配置管理来使用。 1.1.统一配置管理当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。 Nacos一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。 1.1.1.在nacos中添加配置文件如何在nacos中管理配置呢？ 然后在弹出的表单中，填写配置信息： 注意：项目的核心配置，需要热更新的配置才有放到nacos管理的必要。基本不会变更的一些配置还是保存在微服务本地比较好。 1.1.2.从微服务拉取配置微服务要拉取nacos中管理的配置，并且与本地的application.yml配置合并，才能完成项目启动。 但如果尚未读取application.yml，又如何得知nacos地址呢？ 因此spring引入了一种新的配置文件：bootstrap.yaml文件，会在application.yml之前被读取，流程如下： 1）引入nacos-config依赖 首先，在user-service服务中，引入nacos-config的客户端依赖： 12345&lt;!--nacos配置管理依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt; 2）添加bootstrap.yaml 然后，在user-service中添加一个bootstrap.yaml文件，内容如下： 12345678910spring: application: name: userservice # 服务名称 profiles: active: dev #开发环境，这里是dev cloud: nacos: server-addr: localhost:8848 # Nacos地址 config: file-extension: yaml # 文件后缀名 这里会根据spring.cloud.nacos.server-addr获取nacos地址，再根据 $&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;作为文件id，来读取配置。 本例中，就是去读取userservice-dev.yaml： userservice-dev.yaml就是nacos中配置文件的id 服务名称，开发环境和文件后缀名就能组成nacos中配置文件的id 3）读取nacos配置 在user-service中的UserController中添加业务逻辑，读取pattern.dateformat配置： 完整代码： 12345678910111213141516171819202122232425262728293031package cn.itcast.user.web;import cn.itcast.user.pojo.User;import cn.itcast.user.service.UserService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.*;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;@Slf4j@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Autowired private UserService userService; //这个注解可以获取配置文件中的内容 @Value(&quot;$&#123;pattern.dateformat&#125;&quot;) private String dateformat; @GetMapping(&quot;now&quot;) public String now()&#123; //这个代码是获取当前时间并按照dateformat进行日期格式化 return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat)); &#125; // ...略&#125; 在页面访问，可以看到效果： 1.2.配置热更新我们最终的目的，是修改nacos中的配置后，微服务中无需重启即可让配置生效，也就是配置热更新。 要实现配置热更新，可以使用两种方式： 1.2.1.方式一在@Value注入的变量所在类上添加注解@RefreshScope： 1.2.2.方式二使用@ConfigurationProperties注解代替@Value注解。 在user-service服务中，添加一个类，读取patterrn.dateformat属性： 12345678910111213package cn.itcast.user.config;import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Component@Data//prefix前缀和属性拼接就可以把类中属性进行自动装配@ConfigurationProperties(prefix = &quot;pattern&quot;)public class PatternProperties &#123; private String dateformat;&#125; 在UserController中使用这个类代替@Value： 完整代码： 12345678910111213141516171819202122232425262728293031323334package cn.itcast.user.web;import cn.itcast.user.config.PatternProperties;import cn.itcast.user.pojo.User;import cn.itcast.user.service.UserService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;@Slf4j@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Autowired private UserService userService; //自动装配PatternProperties这个类的实例，然后获取dateformat @Autowired private PatternProperties patternProperties; @GetMapping(&quot;now&quot;) public String now()&#123; return LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.getDateformat())); &#125; // 略&#125; 1.3.配置共享其实微服务启动时，会去nacos读取多个配置文件，例如： [spring.application.name]-[spring.profiles.active].yaml，例如：userservice-dev.yaml [spring.application.name].yaml，例如：userservice.yaml 而[spring.application.name].yaml不包含环境，因此可以被多个环境共享。 下面我们通过案例来测试配置共享 1）添加一个环境共享配置我们在nacos中添加一个userservice.yaml文件： 2）在user-service中读取共享配置在user-service服务中，修改PatternProperties类，读取新添加的属性： 在user-service服务中，修改UserController，添加一个方法： 3）运行两个UserApplication，使用不同的profile修改UserApplication2这个启动项，改变其profile值： 这样，UserApplication(8081)使用的profile是dev，UserApplication2(8082)使用的profile是test。 启动UserApplication和UserApplication2 访问http://localhost:8081/user/prop，结果： 访问http://localhost:8082/user/prop，结果： 可以看出来，不管是dev，还是test环境，都读取到了envSharedValue这个属性的值。 4）配置共享的优先级当nacos、服务本地同时出现相同属性时，优先级有高低之分： 1.4.搭建Nacos集群Nacos生产环境下一定要部署为集群状态，部署方式参考课前资料中的文档： 2.Feign远程调用Feign自动实现了负载均衡 先来看我们以前利用RestTemplate发起远程调用的代码： 存在下面的问题： •代码可读性差，编程体验不统一 •参数复杂URL难以维护 Feign是一个声明式的http客户端，官方地址：https://github.com/OpenFeign/feign 其作用就是帮助我们优雅的实现http请求的发送，解决上面提到的问题。 2.1.Feign替代RestTemplateFegin的使用步骤如下： 1）引入依赖我们在order-service服务的pom文件中引入feign的依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 2）添加注解在order-service的启动类添加注解开启Feign的功能： 3）编写Feign的客户端在order-service中新建一个接口，内容如下： 123456789101112package cn.itcast.order.client;import cn.itcast.order.pojo.User;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;@FeignClient(&quot;userservice&quot;)public interface UserClient &#123; @GetMapping(&quot;/user/&#123;id&#125;&quot;) User findById(@PathVariable(&quot;id&quot;) Long id);&#125; 这个客户端主要是基于SpringMVC的注解来声明远程调用的信息，比如： 服务名称：userservice 请求方式：GET 请求路径：&#x2F;user&#x2F;{id} 请求参数：Long id 返回值类型：User 这样，Feign就可以帮助我们发送http请求，无需自己使用RestTemplate来发送了。 4）测试修改order-service中的OrderService类中的queryOrderById方法，使用Feign客户端代替RestTemplate： 是不是看起来优雅多了。 5）总结使用Feign的步骤： ① 引入依赖 ② 添加@EnableFeignClients注解 ③ 编写FeignClient接口 ④ 使用FeignClient中定义的方法代替RestTemplate 2.2.自定义配置Feign可以支持很多的自定义配置，如下表所示： 类型 作用 说明 feign.Logger.Level 修改日志级别 包含四种不同的级别：NONE、BASIC、HEADERS、FULL feign.codec.Decoder 响应结果的解析器 http远程调用的结果做解析，例如解析json字符串为java对象 feign.codec.Encoder 请求参数编码 将请求参数编码，便于通过http请求发送 feign. Contract 支持的注解格式 默认是SpringMVC的注解 feign. Retryer 失败重试机制 请求失败的重试机制，默认是没有，不过会使用Ribbon的重试 一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的@Bean覆盖默认Bean即可。 下面以日志为例来演示如何自定义配置。 2.2.1.配置文件方式基于配置文件修改feign的日志级别可以针对单个服务： 12345feign: client: config: userservice: # 针对某个微服务的配置 loggerLevel: FULL # 日志级别 也可以针对所有服务： 12345feign: client: config: default: # 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置 loggerLevel: FULL # 日志级别 而日志的级别分为四种： NONE：不记录任何日志信息，这是默认值。 BASIC：仅记录请求的方法，URL以及响应状态码和执行时间 HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息 FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。 2.2.2.Java代码方式这个类可以放在config包下 也可以基于Java代码来修改日志级别，先声明一个类，然后声明一个Logger.Level的对象： 123456public class DefaultFeignConfiguration &#123; @Bean public Logger.Level feignLogLevel()&#123; return Logger.Level.BASIC; // 日志级别为BASIC &#125;&#125; 如果要全局生效，将其放到启动类的@EnableFeignClients这个注解中： 1@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class) 如果是局部生效，则把它放到对应的@FeignClient（UserClient接口上）这个注解中： 1@FeignClient(value = &quot;userservice&quot;, configuration = DefaultFeignConfiguration .class) 2.3.Feign使用优化Feign底层发起http请求，依赖于其它的框架。其底层客户端实现包括： •URLConnection：默认实现，不支持连接池 •Apache HttpClient ：支持连接池 •OKHttp：支持连接池 因此提高Feign的性能主要手段就是使用连接池代替默认的URLConnection。 这里我们用Apache的HttpClient来演示。 1）引入依赖 在order-service的pom文件中引入Apache的HttpClient依赖： 12345&lt;!--httpClient的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt; &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;&lt;/dependency&gt; 2）配置连接池 在order-service的application.yml中添加配置： 123456789feign: client: config: default: # default全局的配置 loggerLevel: BASIC # 日志级别，BASIC就是基本的请求和响应信息 httpclient: enabled: true # 开启feign对HttpClient的支持 max-connections: 200 # 最大的连接数 max-connections-per-route: 50 # 每个路径的最大连接数 接下来，在FeignClientFactoryBean中的loadBalance方法中打断点： Debug方式启动order-service服务，可以看到这里的client，底层就是Apache HttpClient： 总结，Feign的优化： 1.日志级别尽量用basic 2.使用HttpClient或OKHttp代替URLConnection ① 引入feign-httpClient依赖 ② 配置文件开启httpClient功能，设置连接池参数 2.4.最佳实践所谓最近实践，就是使用过程中总结的经验，最好的一种使用方式。 自习观察可以发现，Feign的客户端与服务提供者的controller代码非常相似： feign客户端： UserController： 有没有一种办法简化这种重复的代码编写呢？ 2.4.1.继承方式一样的代码可以通过继承来共享： 1）定义一个API接口，利用定义方法，并基于SpringMVC注解做声明。 2）Feign客户端和Controller都集成改接口 优点： 简单 实现了代码共享 缺点： 服务提供方、服务消费方紧耦合 参数列表中的注解映射并不会继承，因此Controller中必须再次声明方法、参数列表、注解 2.4.2.抽取方式将Feign的Client抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用。 例如，将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有微服务引用该依赖包，即可直接使用。 2.4.3.实现基于抽取的最佳实践1）抽取首先创建一个module，命名为feign-api： 项目结构： 在feign-api中然后引入feign的starter依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 然后，order-service中编写的UserClient、User、DefaultFeignConfiguration都复制到feign-api项目中 2）在order-service中使用feign-api首先，删除order-service中的UserClient、User、DefaultFeignConfiguration等类或接口。 在order-service的pom文件中中引入feign-api的依赖： 12345&lt;dependency&gt; &lt;groupId&gt;cn.itcast.demo&lt;/groupId&gt; &lt;artifactId&gt;feign-api&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; 修改order-service中的所有与上述三个组件有关的导包部分，改成导入feign-api中的包 3）重启测试重启后，发现服务报错了： 这是因为UserClient现在在cn.itcast.feign.clients包下， 而order-service的@EnableFeignClients注解是在cn.itcast.order包下，不在同一个包，无法扫描到UserClient。 4）解决扫描包问题下面两种方式都是在原来基础上增加了包扫描的内容，方式二可以精确到具体加入哪几个Client，参数是一个Client的数组，方式一会把包下所有的client都引入进来 方式一： 指定Feign应该扫描的包： 1@EnableFeignClients(basePackages = &quot;cn.itcast.feign.clients&quot;) 方式二： 指定需要加载的Client接口： 1@EnableFeignClients(clients = &#123;UserClient.class&#125;) 3.Gateway服务网关Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。 这个Gateway服务网关有点类似nginx反向代理的操作 3.1.为什么需要网关Gateway网关是我们服务的守门神，所有微服务的统一入口。 网关的核心功能特性： 请求路由 权限控制 限流 架构图： 权限控制：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。 路由和负载均衡：一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。 限流：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。 在SpringCloud中网关的实现包括两种： gateway zuul Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。 3.2.gateway快速入门下面，我们就演示下网关的基本路由功能。基本步骤如下： 创建SpringBoot工程gateway，引入网关依赖 编写启动类 编写基础配置和路由规则 启动网关服务进行测试 1）创建gateway服务，引入依赖创建服务： 引入依赖： 12345678910&lt;!--网关--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--nacos服务发现依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt; 2）编写启动类123456789101112package cn.itcast.gateway;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class GatewayApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(GatewayApplication.class, args); &#125;&#125; 3）编写基础配置和路由规则创建application.yml文件，内容如下： 123456789101112131415server: port: 10010 # 网关端口spring: application: name: gateway # 服务名称 cloud: nacos: server-addr: localhost:8848 # nacos地址 gateway: routes: # 网关路由配置 - id: user-service # 路由id，自定义，只要唯一即可 # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址 uri: lb://userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称 predicates: # 路由断言，也就是判断请求是否符合路由规则的条件 - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求 我们将符合Path 规则的一切请求，都代理到 uri参数指定的地址。 本例中，我们将 /user/**开头的请求，代理到lb://userservice，lb是负载均衡，根据服务名拉取服务列表，实现负载均衡。 4）重启测试重启网关，访问http://localhost:10010/user/1时，符合`/user/**`规则，请求转发到uri：http://userservice/user/1，得到了结果： 5）网关路由的流程图整个访问的流程如下： 总结： 网关搭建步骤： 创建项目，引入nacos服务发现和gateway依赖 配置application.yml，包括服务基本信息、nacos地址、路由 路由配置包括： 路由id：路由的唯一标示 路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡 路由断言（predicates）：判断路由的规则， 路由过滤器（filters）：对请求或响应做处理 接下来，就重点来学习路由断言和路由过滤器的详细知识 3.3.断言工厂我们在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件 例如Path&#x3D;&#x2F;user&#x2F;**是按照路径匹配，这个规则是由 org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory类来 处理的，像这样的断言工厂在SpringCloudGateway还有十几个: 名称 说明 示例 After 是某个时间点后的请求 - After&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver] Before 是某个时间点之前的请求 - Before&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai] Between 是某两个时间点之前的请求 - Between&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver], 2037-01-21T17:42:47.789-07:00[America&#x2F;Denver] Cookie 请求必须包含某些cookie - Cookie&#x3D;chocolate, ch.p Header 请求必须包含某些header - Header&#x3D;X-Request-Id, \\d+ Host 请求必须是访问某个host（域名） - Host&#x3D;.somehost.org,.anotherhost.org Method 请求方式必须是指定方式 - Method&#x3D;GET,POST Path 请求路径必须符合指定规则 - Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;** Query 请求参数必须包含指定参数 - Query&#x3D;name, Jack或者- Query&#x3D;name RemoteAddr 请求者的ip必须是指定范围 - RemoteAddr&#x3D;192.168.1.1&#x2F;24 Weight 权重处理 我们只需要掌握Path这种路由工程就可以了。 3.4.过滤器工厂GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理： 3.4.1.路由过滤器的种类Spring提供了31种不同的路由过滤器工厂。例如： 名称 说明 AddRequestHeader 给当前请求添加一个请求头 RemoveRequestHeader 移除请求中的一个请求头 AddResponseHeader 给响应结果中添加一个响应头 RemoveResponseHeader 从响应结果中移除有一个响应头 RequestRateLimiter 限制请求的流量 3.4.2.请求头过滤器下面我们以AddRequestHeader 为例来讲解。 需求：给所有进入userservice的请求添加一个请求头：Truth&#x3D;itcast is freaking awesome! 只需要修改gateway服务的application.yml文件，添加路由过滤即可： 1234567891011spring: cloud: gateway: routes: - id: user-service uri: lb://userservice predicates: - Path=/user/** filters: # 过滤器 - AddRequestHeader=Truth, Itcast is freaking awesome! # 添加请求头 #key是Truth，value是Itcast is freaking awesome 当前过滤器写在userservice路由下，因此仅仅对访问userservice的请求有效。 3.4.3.默认过滤器如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下： 12345678910spring: cloud: gateway: routes: - id: user-service uri: lb://userservice predicates: - Path=/user/** default-filters: # 默认过滤项 - AddRequestHeader=Truth, Itcast is freaking awesome! 3.4.4.总结过滤器的作用是什么？ ① 对路由的请求或响应做加工处理，比如添加请求头 ② 配置在路由下的过滤器只对当前路由的请求生效 defaultFilters的作用是什么？ ① 对所有路由都生效的过滤器 3.5.全局过滤器上一节学习的过滤器，网关提供了31种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。 3.5.1.全局过滤器作用全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。区别在于GatewayFilter通过配置定义，处理逻辑是固定的；而GlobalFilter的逻辑需要自己写代码实现。 定义方式是实现GlobalFilter接口。 12345678910public interface GlobalFilter &#123; /** * 处理当前请求，有必要的话通过&#123;@link GatewayFilterChain&#125;将请求交给下一个过滤器处理 * * @param exchange 请求上下文，里面可以获取Request、Response等信息 * @param chain 用来把请求委托给下一个过滤器 * @return &#123;@code Mono&lt;Void&gt;&#125; 返回标示当前过滤器业务结束 */ Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain);&#125; 在filter中编写自定义逻辑，可以实现下列功能： 登录状态判断 权限校验 请求限流等 3.5.2.自定义全局过滤器需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件： 参数中是否有authorization， authorization参数值是否为admin 如果同时满足则放行，否则拦截 实现： 在gateway中定义一个过滤器： 1234567891011121314151617181920212223242526272829303132package cn.itcast.gateway.filters;import org.springframework.cloud.gateway.filter.GatewayFilterChain;import org.springframework.cloud.gateway.filter.GlobalFilter;import org.springframework.core.annotation.Order;import org.springframework.http.HttpStatus;import org.springframework.stereotype.Component;import org.springframework.web.server.ServerWebExchange;import reactor.core.publisher.Mono;//@Order注解指定过滤器优先级，这个value的数越小优先级越高@Order(-1)@Componentpublic class AuthorizeFilter implements GlobalFilter &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; // 1.获取请求参数 MultiValueMap&lt;String, String&gt; params = exchange.getRequest().getQueryParams(); // 2.获取authorization参数 String auth = params.getFirst(&quot;authorization&quot;); // 3.校验 if (&quot;admin&quot;.equals(auth)) &#123; // 放行 return chain.filter(exchange); &#125; // 4.拦截 // 4.1.禁止访问，设置状态码 exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN); // 4.2.结束处理 return exchange.getResponse().setComplete(); &#125;&#125; 3.5.3.过滤器执行顺序请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter 请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器： 排序的规则是什么呢？ 每一个过滤器都必须指定一个int类型的order值，order值越小，优先级越高，执行顺序越靠前。 GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定 路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。 12345678910 filters: # 过滤器 - AddRequestHeader=Truth, Itcast is freaking awesome! # 添加请求头,order值为1 - AddRequestHeader=Truth, Itcast is freaking awesome1 ! # 添加请求头，order值为2 - id: order-service uri: lb://orderservice predicates: - Path=/order/**default-filters: # 默认过滤项 - AddRequestHeader=Truth, Itcast is freaking awesome! # 添加请求头,order值为1 - AddRequestHeader=Truth, Itcast is freaking awesome1 ! # 添加请求头，order值为2 当过滤器的order值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行。 详细内容，可以查看源码： org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()方法是先加载defaultFilters，然后再加载某个route的filters，然后合并。 org.springframework.cloud.gateway.handler.FilteringWebHandler#handle()方法会加载全局过滤器，与前面的过滤器合并后根据order排序，组织过滤器链 3.6.跨域问题3.6.1.什么是跨域问题跨域：域名不一致就是跨域，主要包括： 域名不同： www.taobao.com 和 www.taobao.org 和 www.jd.com 和 miaosha.jd.com 域名相同，端口不同：localhost:8080和localhost8081 跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题 解决方案：CORS，这个以前应该学习过，这里不再赘述了。不知道的小伙伴可以查看https://www.ruanyifeng.com/blog/2016/04/cors.html 3.6.2.模拟跨域问题找到课前资料的页面文件： 放入tomcat或者nginx这样的web服务器中，启动并访问。 可以在浏览器控制台看到下面的错误： 从localhost:8090访问localhost:10010，端口不同，显然是跨域的请求。 3.6.3.解决跨域问题在gateway服务的application.yml文件中，添加下面的配置： 12345678910111213141516171819spring: cloud: gateway: # 。。。 globalcors: # 全局的跨域处理 add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题 corsConfigurations: &#x27;[/**]&#x27;: allowedOrigins: # 允许哪些网站的跨域请求 - &quot;http://localhost:8090&quot; allowedMethods: # 允许的跨域ajax的请求方式 - &quot;GET&quot; - &quot;POST&quot; - &quot;DELETE&quot; - &quot;PUT&quot; - &quot;OPTIONS&quot; allowedHeaders: &quot;*&quot; # 允许在请求中携带的头信息 allowCredentials: true # 是否允许携带cookie maxAge: 360000 # 这次跨域检测的有效期","categories":[],"tags":[]},{"title":"idea的debug方法","slug":"IDEA-DeBug","date":"2022-09-29T15:31:35.000Z","updated":"2023-04-10T12:59:08.001Z","comments":true,"path":"2022/09/29/IDEA-DeBug/","link":"","permalink":"http://example.com/2022/09/29/IDEA-DeBug/","excerpt":"","text":"01_Debug简介和意义 什么是程序DeBug？ Debug，是程序开发人员必会的一项调试程序的技能。 企业中程序开发和程序调试的比例为1:1.5，可以说如果你不会调试程序，你就没有办法从事编程工作。 Debug能帮助我们做什么？ 追踪代码的运行流程。 程序运行异常定位。 线上问题追踪。 Debug对于程序学习者的意义 通过调试能够更好的查看程序的执行流程。 复杂的程序逻辑，通过老师的口述讲解，很难理解清楚，这个时候借助调试能够很好的帮助同学们理解程序。 定位问题，提高自我解决问题的能力。 02_IDEA中的Debug步骤 设置断点（F9） 调试程序（8个按钮） 按钮 说明 (Alt + F10)：如果你的光标在其它行或其它页面，点击这个按钮可跳转到当前代码执行的行 (F8)：步过，一行一行地往下走，如果这一行上有方法不会进入方法。 (F7)：步入。如果当前行有方法，可以进入方法内部，一般用于进入自定义方法内，不会进入官方类库的方法。 (Alt + Shift + F7)：强制步入，能进入任何方法，查看底层源码的时候可以用这个进入官方类库的方法。 (Shift + F8)：步出，从步入的方法内退出到方法调用处，此时方法已执行完毕，只是还没有完成赋值。 回退断点。 (Alt + F9)：运行到光标处，你可以将光标定位到你需要查看的那一行，然后使用这个功能，代码会运行至光标行，而不需要打断点。 (Alt + F8)：计算表达式。 观察变量 查看变量有三种方式： 程序区查看变量 Debugger的Variables中查看变量 鼠标悬停到变量名上会弹出当前变量的值 查看输出 03_跳转到当前代码执行的行 跳转到当前代码执行的行（Alt + F10） 作用 使程序窗口切换到当前正在运行的程序处。 04_步过调试的使用 步过调试 步过调试按钮（F8） 作用 步过，一行一行地往下走，如果这一行上有方法不会进入方法。 常用于调试过程中不想进入调用的方法体的情况。 05_步入调试的使用 步入调试 步过调试按钮（F7） 作用 步入，一行一行地往下走，如果这一行上有方法，则进入方法内部。 一般用于进入自定义方法内，不会进入官方类库的方法。 06_强制步入调试的使用 强制步入调试 强制步入调试按钮（Alt + Shift + F7） 作用 进入官方类库方法 帮助我们学习和查看JDK源码 07_步出调试的使用 步出调试 步出调试按钮（Shift + F8） 作用 从方法内退出到方法调用处。 调试的时候，有时候会跳入到自己不想查看的方法体，这个时候使用步出。 08_回退断点调试的使用 回退断点 回退断点按钮 作用 回退到当前方法的调用处。 当想重新查看该方法体的执行过程时，不用重新启动Debug，可以使用回退断点方式。 09_运行到光标处 运行到光标处 运行光标处按钮 （F9） 作用 使程序运行到光标处，而无需设置断点。 10_计算表达式 计算表达式 计算表达式按钮（Alt + F8） 作用 设置变量，在计算表达式的框里，可以改变变量的值，这样有时候就能很方便我们去调试各种值的情况了。 11_条件断点 条件断点 右键单击断点处，可以设置进入断点的条件 作用 通过设置断点条件，在满足条件时，才停在断点处，否则直接运行。 12_多线程调试 步骤 多线程调试，需要调整断点挂起级别为Thread Frame中选择线程进行调试","categories":[],"tags":[]},{"title":"docker","slug":"docker","date":"2022-09-29T15:31:35.000Z","updated":"2023-04-10T13:21:27.722Z","comments":true,"path":"2022/09/29/docker/","link":"","permalink":"http://example.com/2022/09/29/docker/","excerpt":"","text":"1.基础linux命令 Docker概述Docker为什么会出现一致产品：开发..上线 两套环境 应用环境 应用配置 ！ Docker通过镜像，和容器相互隔离的机制，将服务器利用到极致 Docker的历史2010年，几个搞it的年轻人，在美国成立了一家公司 dotclound 做一些pass的云计算服务 Docker能干嘛kernel是内核的意思，lib是环境的意思 Docker可以将项目打包为一个镜像，带着环境直接跑起来 Docker安装Docker的基本组成 client,客户端 docker_host ，docker的服务器 registry远程仓库 镜像：(image)docker镜像就好比是一个模板，可以通过这个模板来创建容器服务，tomcat镜像&#x3D;&#x3D;&#x3D;&gt;run(运行)&#x3D;&#x3D;&gt;tomcat1容器（提供服务器） 通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的）。 容器：(container)Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建的 容器可以启动，停止，删除(这些属于是基本命令) 目前就可以把这个容器理解为就是一个简易的linux系统 仓库：(repostory)仓库就是用来存放镜像的地方 仓库分为共有仓库和私有仓库 Docker Hub（默认是国外的） 阿里云 ….都有咱们的容器服务（配置镜像加速） 安装docker1环境准备 1.会一点点linux基础 2，CentOS7 3，我们使用Xshell连结远程服务器进行操作 环境查看 查看系统的内核： uname -r 系统内核版本为3.10.0 [root@iZwz99sm8v95sckz8bd2c4Z ~]# uname -r3.10.0-957.21.3.el7.x86_6412查看系统配置 cat &#x2F;etc&#x2F;os-release [root@iZwz99sm8v95sckz8bd2c4Z ~]# cat &#x2F;etc&#x2F;os-releaseNAME&#x3D;”CentOS Linux”VERSION&#x3D;”7 (Core)”ID&#x3D;”centos”ID_LIKE&#x3D;”rhel fedora”VERSION_ID&#x3D;”7”PRETTY_NAME&#x3D;”CentOS Linux 7 (Core)”ANSI_COLOR&#x3D;”0;31”CPE_NAME&#x3D;”cpe:&#x2F;o:centos:centos:7”HOME_URL&#x3D;”https://www.centos.org/&quot;BUG_REPORT_URL&#x3D;”https://bugs.centos.org/&quot; CENTOS_MANTISBT_PROJECT&#x3D;”CentOS-7”CENTOS_MANTISBT_PROJECT_VERSION&#x3D;”7”REDHAT_SUPPORT_PRODUCT&#x3D;”centos”REDHAT_SUPPORT_PRODUCT_VERSION&#x3D;”7” Docker的安装步骤： 1）卸载旧的版本 yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine（2）下载需要的安装包 yum install -y yum-utils（3）设置镜像的仓库 12345678910yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo #国外的地址 # 设置阿里云的Docker镜像仓库yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo #国内的地址 4）更新yum软件包索引 1yum makecache fast （5）安装docker相关的配置 1234docker-ce 是社区版，docker-ee 企业版 1 yum install docker-ce docker-ce-cli containerd.io出现了completed即安装成功。 （6）启动Docker 123456789systemctl start docker查看当前版本号，是否启动成功docker version设置开机自启动systemctl enable docker 卸载docker步骤[root@iZ2zeh7i9iup2d5futu12tZ &#x2F;]# systemctl stop docker [root@iZ2zeh7i9iup2d5futu12tZ &#x2F;]# yum -y remove docker-ce docker-ce-cli containered.io 下载helloworld镜像 1#docker run hello-world (7) 查看下载的hello world镜像 1234[root@iZwz99sm8v95sckz8bd2c4Z lib]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEhello-world latest bf756fb1ae65 11 months ago 13.3kB 阿里云镜像加速（1）进入阿里云官网，搜索容器镜像服务 （2）依次执行官方的这四条命令 sudo mkdir -p &#x2F;etc&#x2F;docker sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-‘EOF’{ “registry-mirrors”: [“https://axvfsf7e.mirror.aliyuncs.com&quot;]} EOF sudo systemctl daemon-reload sudo systemctl restart docker 重新启用docker HelloWorld流程Docker容器运行流程 下面的图解释了上面hello-world镜像的设置 底层原理Docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上，通过Socket从客户端访问！Docker Server接收到Docker-Client的指令，就会执行这个指令！ Docker为什么比vm快1.Docker有着比虚拟机更少的抽象层 2.docker利用的是宿主机的内核，vm需要的是GuestOS 所以说，新建一个容器的时候，docker不需要想虚拟机一样重新加载一个操作系统内核，避免引导，虚拟机时加载Guest OS ，分钟级别的，而docker是利用宿主机的操作系统吗，省略了这个复杂的过程，秒级 之后学习完毕所有的命令，再回头看这段理论，就会很清晰 Docker常用命令帮助命令docker version 显示docker的版本信息 docker info 显示docker的系统信息 docker 命令 –help 帮助命令 docker –help 显示很多docker的命令 帮助文档的地址 镜像命令images就是镜像的意思 docker images 查看所有本地主机上的镜像1234567891011121314151617181920212223docker images --help 可以查看所有选项```REPOSITORY TAG IMAGE ID CREATED SIZEhello-world latest feb5d9fea6a5 5 months ago 13.3kB```REPOSITORY 镜像的仓库源TAG 镜像的标签IMAGE ID镜像的idCREATED 镜像的创建时间SIZE 镜像的大小可选项 -a, --all 列出所有镜像 -q, --quiet 只显示镜像的id docker search 搜索镜像这个搜索和在网页的dockerhub上搜索镜像是一样的 12345678910111213141516171819[root@iZ2zeh7i9iup2d5futu12tZ ~]# docker search mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 12239 [OK] mariadb MariaDB Server is a high performing open sou… 4702 [OK] docker search --helpptions: -f, --filter filter Filter output based on conditsions provided --format string Pretty-print search using a Go template --limit int Max number of search results (default 25) --no-trunc Don&#x27;t truncate output# 可选项，通过搜藏来过滤docker search mysql --filter=STARS=3000 搜索出来的镜像就是STARS大于3000的mysql这其实就是一个镜像名 docker pull下载镜像123456789101112131415161718192021222324252627282930313233343536373839404142下载镜像 docker pull 镜像名[:tag]后面可以加版本，tag就是版本[root@iZ2zeh7i9iup2d5futu12tZ ~]# docker pull mysqlUsing default tag: latest #如果不写tag默认就是，默认就是latestlatest: Pulling from library/mysql72a69066d2fe: Pull complete #分层下载，docker image的核心 联合文件系统93619dbc5b36: Pull complete 99da31dd6142: Pull complete 626033c43d70: Pull complete 37d5d7efb64e: Pull complete ac563158d721: Pull complete d2ba16033dad: Pull complete 688ba7d5c01a: Pull complete 00e060b6d11d: Pull complete 1c04857f594f: Pull complete 4d7cfa90e6ea: Pull complete e0431212d27d: Pull complete Digest: sha256:e9027fe4d91c0153429607251656806cc784e914937271037f7738bd5b8e7709Status: Downloaded newer image for mysql:latestdocker.io/library/mysql:latest #docker .io就是真实地址底下两个命令是一样的docker pull mysqldocker pull docker.io/library/mysql:latest#指定版本下载[root@iZ2zeh7i9iup2d5futu12tZ ~]# docker pull mysql:5.75.7: Pulling from library/mysql72a69066d2fe: Already exists #前面几个层因为和刚才下载的指定版本的mysql重复，所以这里不会重复下载93619dbc5b36: Already exists 99da31dd6142: Already exists 626033c43d70: Already exists 37d5d7efb64e: Already exists ac563158d721: Already exists d2ba16033dad: Already exists 0ceb82207cd7: Pull complete 37f2405cae96: Pull complete e2482e017e53: Pull complete 70deed891d42: Pull complete Digest: sha256:f2ad209efe9c67104167fc609cca6973c8422939491c9345270175a300419f94Status: Downloaded newer image for mysql:5.7docker.io/library/mysql:5.7 docker rmi 删除镜像12345678可以通过id或者是名字删除[root@iZ2zeh7i9iup2d5futu12tZ ~]# docker rmi -f 镜像id 删除指定id的镜像[root@iZ2zeh7i9iup2d5futu12tZ ~]# docker rmi -f 镜像id 镜像id 镜像id 删除多个镜像[root@iZ2zeh7i9iup2d5futu12tZ ~]# docker rmi -f $(docker images -aq) 删除所有的镜像 容器命令说明：我们有了镜像才可以创建容器，linux，下载一个centos镜像来测试学习 1docker pull centos 新建容器并启动1234567891011121314151617181920212223242526272829303132333435363738docker run [可选参数] images 参数说明--name =“Name” 容器名字 tomcat01 tomcat02 用来区分容器-d 后台方式运行-i 使用交互方式运行，进入容器查看内容-P 指定容器的端口 -p 8080：8080​ -P ip：主机端口：容器端口​ -P 容器端口​ -P ip:主机端口 ：容器端口-p 随机指定端口[root@iZ2zeh7i9iup2d5futu12tZ ~]# docker run -it centos /bin/bash # 启动并进入容器进入容器是还是要操控linux系统，所以后面跟一个途径，bash就是一个shell在bin文件夹底下[root@b72a55625460 /]# ls 查看容器内的centos，基础版本，很多命令都是不完善的bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var[root@b72a55625460 /]#exit #退出容器的命令，从容器中退回到主机exit[root@iZ2zeh7i9iup2d5futu12tZ ~]# ls[root@iZ2zeh7i9iup2d5futu12tZ ~]# ls /bin boot dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var 列出所有运行中的容器·1234[root@iZ2zeh7i9iup2d5futu12tZ ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[root@iZ2zeh7i9iup2d5futu12tZ ~]# docker ps -q 列出所有运行中的容器的编号 列出所有运行过的容器123456[root@iZ2zeh7i9iup2d5futu12tZ ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb72a55625460 centos &quot;/bin/bash&quot; 8 minutes ago Exited (0) 3 minutes ago upbeat_black595660410c8b feb5d9fea6a5 &quot;/hello&quot; 5 hours ago Exited (0) 5 hours ago quizzical_wilbur[root@iZ2zeh7i9iup2d5futu12tZ ~]# docker ps -aq 显示所有运行过的容器的编号 显示最近创建的容器12345[root@iZ2zeh7i9iup2d5futu12tZ ~]# docker ps -n=1 这是显示最近创建的一个容器n的参数是几就是显示最近创建的几个容器[root@iZ2zeh7i9iup2d5futu12tZ ~]# docker ps -a -n=1 显示运行过的当中最近创建的一个，可以改变n的参数来决定几个 退出容器123exit #直接停止容器并退出ctrl +P +Q 容器不停止退出 删除容器12345docker rm 容器id 删除指定的容器，不能删除正在运行的容器，如果要强制删除就要rm -fdocker rm -f $(docker ps -aq) 删除所有的容器docker ps -a -q|xargs docker rm #也可以删除所有的容器 启动和停止容器的操作1234567docker start 容器id #启动容器docker restart 容器id #重启容器docker stop 容器id #停止当前正在运行的容器docker kill 容器id #强制停止运行的容器，如果docker stop报错，就用docker kill强制停止 常用其他命令1234567891011后台启动容器#命令 docker run -d 镜像名[root@iZ2zeh7i9iup2d5futu12tZ ~]# docker run -d centos #问题 docker ps，发现 centos停止了#常见的坑，docker 容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动给停止#nagix ，容器启动后，大仙自己没有提供服务，就会立刻停止，就是没有程序了 查看日志1234567891011121314151617docker logs -tf --tails 容器，没有日志##自己编写一段shell脚本[root@iZwz99sm8v95sckz8bd2c4Z ~]*# docker run -d centos /bin/sh -c &quot;while true;do echo hi;sleep 5;done“ 每五秒更新一条日志[root@iZ2zeh7i9iup2d5futu12tZ ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESaae6ff6dcd3c centos &quot;/bin/sh -c &#x27;while t…&quot; 5 minutes ago Up 5 minutes fervent_blackburn#显示日志--tail number #要显示日志的条数-tf # 显示日志[root@iZ2zeh7i9iup2d5futu12tZ ~]# docker logs -tf --tail 10 aae6ff6dcd3c 查看内容器中的进程信息 ps12345678top命令docker top 容器idroot@iZ2zeh7i9iup2d5futu12tZ ~]# docker top aae6ff6dcd3cUID PID PPID C STIME TTY TIME CMDroot 4128 4109 0 16:12 ? 00:00:00 /bin/sh -c while true;do echo kuangshen;sleep 1;doneroot 4899 4128 0 16:24 ? 00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1 查看镜像的元数据1docker inspect 容器id 进入当前正在进行的容器1234567891011121314151617181920212223242526我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置#命令 docker exec -it 容器id bashshell#实例[root@iZ2zeh7i9iup2d5futu12tZ ~]# docker exec -it aae6ff6dcd3c&quot;docker exec&quot; requires at least 2 arguments.See &#x27;docker exec --help&#x27;.Usage: docker exec [OPTIONS] CONTAINER COMMAND [ARG...]Run a command in a running container[root@iZ2zeh7i9iup2d5futu12tZ ~]# docker exec -it aae6ff6dcd3c /bin/bash[root@aae6ff6dcd3c /]# ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 08:12 ? 00:00:00 /bin/sh -c while true;do echo kuangshen;sleep 1;doneroot 1792 0 0 08:42 pts/0 00:00:00 /bin/bashroot 1836 1 0 08:43 ? 00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1root 1837 1792 0 08:43 pts/0 00:00:00 ps -ef第二种docker attache 容器id[root@iZ2zeh7i9iup2d5futu12tZ ~]# docker attach aae6ff6dcd3c #docker exec 进入容器后开启一个新的终端，可以在里面操作（常用） #docker attach 进入容器正在执行的终端，不会启动新的进程 从容器内拷贝文件到我们的主机上面12345678910111213141516171819202122232425262728docker cp 容器id：容器的路径 目的的主机路径#进入当前主机目录下[root@iZ2zeh7i9iup2d5futu12tZ ~]# cd /home[root@iZ2zeh7i9iup2d5futu12tZ home]# ls[root@iZ2zeh7i9iup2d5futu12tZ home]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES532a01da75ac centos &quot;/bin/bash&quot; 5 minutes ago Up 5 minutes happy_jonesaae6ff6dcd3c centos &quot;/bin/sh -c &#x27;while t…&quot; 45 minutes ago Up 45 minutes fervent_blackburn#进入docker容器内部[root@iZ2zeh7i9iup2d5futu12tZ home]# docker attach 532a01da75ac#进入当前容器home目录下[root@532a01da75ac /]# cd /home#查看当前容器home目录下的文件夹[root@532a01da75ac home]# ls#在容器中创建test.java文件[root@532a01da75ac home]# touch test.java[root@532a01da75ac home]# exitexit[root@iZ2zeh7i9iup2d5futu12tZ home]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESaae6ff6dcd3c centos &quot;/bin/sh -c &#x27;while t…&quot; 46 minutes ago Up 46 minutes fervent_blackburn#将文件拷贝出来到我们的主机上[root@iZ2zeh7i9iup2d5futu12tZ home]# docker cp 532a01da75ac:/home/test.java /home[root@iZ2zeh7i9iup2d5futu12tZ home]# lskuangshen.java test.java拷贝是一个手动过程，未来我们使用-v卷的技术，可以实现，自动同步 Docker 安装 Nginx#1，搜索镜像 docker search 建议大家去docker搜索，可以看到帮助文件 #2，下载镜像 docker pull nginx #3. 运行测试 #-d是后台运行 #–name 给容器命名 #-p 宿主机端口 ：容器内部端口 只有开了22端口服务器才能远程连接linux系统服务器 [root@iZ2zeh7i9iup2d5futu12tZ ~]# docker run -d –name nginx01 -p 3344:80 nginx9934308fc48792506c7d69fa8068c59394a7bceebd6f7686ef43c753949a10cc[root@iZ2zeh7i9iup2d5futu12tZ ~]# curl localhost:3344 #3344端口是可以启动成功的 端口暴露的概念：先通过外网来请求大的Linux，大的linux系统要开启3344端口，因为是阿里云服务器，要在安全组上开3344端口，通过镜像开启nignx容器(一个小的服务器隔离的)开通了80端口，用-p 3344:80相当于打通了阿里云服务器的3344端口和nginx容器(一个linux系统服务器)的80端口,这样就可以通过外网访问3344测试访问到nginx容器的80端口 相当于打通了阿里云服务器的3344端口和nginx容器(一个linux系统服务器)的80端口 #进入容器 [root@iZ2zeh7i9iup2d5futu12tZ ~]# docker exec -it 9934308fc487 &#x2F;bin&#x2F;bash #找nginx的配置文件root@9934308fc487:&#x2F;# whereis nginxnginx: &#x2F;usr&#x2F;sbin&#x2F;nginx &#x2F;usr&#x2F;lib&#x2F;nginx &#x2F;etc&#x2F;nginx &#x2F;usr&#x2F;share&#x2F;nginxroot@9934308fc487:&#x2F;# cd &#x2F;etc&#x2F;nginxroot@9934308fc487:&#x2F;etc&#x2F;nginx# lsconf.d fastcgi_params mime.types modules nginx.conf scgi_params uwsgi_paramsroot@9934308fc487:&#x2F;etc&#x2F;nginx# 可以通过39.105.5.187:3344来访问，前面是外网ip后面是端口号 思考:我们每次改动nginx配置文件，都需要进入容器内部？十分的麻烦，我要是可以再容器外部提供一个映射路径，到达在容器修改文件名，容器内部就可以自动修改？ Docker 来装tomcat12345678910111213141516171819202122232425262728293031#官方的使用docker run -it --rm tomcat:9.0#我们之前的启动都是后台，停止了容器之后，容器还是可以查到的 docker run -it --rm ,一般用来测试，用完就删除，用docker ps -a不能够查到记录#下载再启动docker pull tomcat#启动运行docker run -d -p 3355:8080 --name tomcat01 tomcat#测试访问没有问题访问 39.105.5.187:3355#进入容器docker exec -it tomcat01 /bin/bash 进入刚刚创建的容器#发现问题1linux命令少了 2.webapps下没有东西（tomcat的项目都在webapps下）阿里云镜像的原因，默认是最小的镜像，所有不必要的都剔除掉。保证最小可运行的环境思考问题：我们以后要部署项目，如果每次都要进入容器不是十分麻烦？我要是可以在容器外部提供一个映射途径，webapps，我们在外部放置项目，就自动同步到我们内部就好了 docker装 es+kibana123456789101112131415161718#es 暴露的端口很多#es 十分的耗内存#es 的数据一般要放置到安全目录！挂载# --net somenetwork 网络配置# -e是一个集群默认是单个极点#下载并启动 elasticsearch$ docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:7.6.2#启动了之后，linux服务器就很卡docker stats 查看 cpu的状态#测试一下es是否是成功了#成功了赶紧关闭，增加内存的限制，修改配置文件 -e 环境配置修改,这样做内存就会变得很小docker run -d --name elasticsearch02 -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch:7.6.2 Docker镜像详解12.1 什么是镜像镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需要的所有内容，包括代码，运行时（一个程序在运行或者在被执行的依赖）、库，环境变量和配置文件。 12.2 Docker镜像加载原理 分层理解 提交镜像12345docker commit 提交容器成为一个新的副本命令和git原理类似docker commit -m=”提交的描述信息“ -a=”作者“ 容器id 目标镜像名 ：版本 #实战 1234567891011121314151617181920212223242526#启动一个默认的tomcat#发现这个默认的tomcat 是没有webapps应用 镜像的原因，官方的镜像默认 webapps下面是没有文件的#我自己拷贝进去了基本的文件#将我们操作过的容器通过提交作为一个镜像，我们以后就是用我们修改过的镜像即可，这就是我们自己的一个修改过的镜像[root@iZ2zeh7i9iup2d5futu12tZ ~]# docker commit -a=&quot;iZ2zeh7i9iup2d5futu12tZ&quot; -m=&quot;add webapps app&quot;&quot;docker commit&quot; requires at least 1 and at most 2 arguments.See &#x27;docker commit --help&#x27;.Usage: docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]Create a new image from a container&#x27;s changes[root@iZ2zeh7i9iup2d5futu12tZ ~]# docker commit -a=&quot;iZ2zeh7i9iup2d5futu12tZ&quot; -m=&quot;add webapps app&quot; 6c03766a4902 tomcat02:1.0sha256:8436c4c02f7488ec7e37b016bbc97ea9a067ef7e6e001f926a03430c306b12f3[root@iZ2zeh7i9iup2d5futu12tZ ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEtomcat02 1.0 8436c4c02f74 5 seconds ago 684MBnginx latest 605c77e624dd 2 months ago 141MBtomcat 9.0 b8e65a4d736d 2 months ago 680MBtomcat latest fb5657adc892 2 months ago 680MBcentos latest 5d0da3dc9764 5 months ago 231MBelasticsearch 7.6.2 f29a1ee41030 23 months ago 791MB 就是所有的操作都在容器层，一开始下载的tomcat是镜像层，我们可以通过commit的方式来将其变成一个新的镜像，你就获得一个新的镜像 容器数据卷什么是容器数据卷12345678910111213docker的理念回顾，将应用和环境打包成一个镜像！数据？如果数据都在容器中，那么我们容器删除，数据就会丢失，需求：数据可以持久化mysql ，容器删了，删库跑路！需求：mysql的数据可以储存在本地容器之间可以有一个数据共享的技术！Docker容器中产生的数据，同步到本地！这就是卷技术！目录的挂载，将我们容器内目录，挂载到linux上面！总结一句话：容器的持久化和同步操作！容器间也是可以数据共享 的 使用数据卷#直接使用命令来挂载 docker run -it -v 主机目录：容器内目录 #测试 docker run -it -v &#x2F;home&#x2F;ceshi:&#x2F;home centos &#x2F;bin&#x2F;bash #启动起来的时候， 可以通过docker inspect 容器id #测试文件的同步 在本地进行的可以保存到容器，在容器中进行的可以保存的本地 好处：我们以后修改只需要在本地修改即可，容器会自动同步 安装mysql123456789101112131415161718192021#获取镜像docker pull mysql:5.7#运行容器，需要做数据挂载，配一下mysql密码的配置-e是配置了mysql的密码 -v是容器卷-p是端口映射docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7启动之后可以用navicat来连接一下navicat连接到服务器的3310 ，3310和容器内的3306映射，这个时候我们就可以连结上了我们在本地测试创建一个数据库，查看一下我们映射的路径是否ok假设我们将容器删除，发现我们挂载到本地的数据卷依旧没有丢失，这就实现了容器数据持久化的功能 具名和匿名挂载#匿名挂载 -v 容器内路径！ -P是随机设置端口 docker run -d -P –name nginx01 -v &#x2F;etc&#x2F;nginx nginx #查看所有卷的情况 docker volume ls local 3dff6f3d9261f4b09404131549700aab1e1e63da41ea3eac842d5660500d5dd1 #这里发现，这种匿名的挂载，我们在-v只写了容器内的路径，没有写容器外的路径 #具名挂载 docker run -d -P –name nginx01 -v &#x2F;etc&#x2F;nginx nginx03 -v juming-nginx:&#x2F;etc&#x2F;nginx nginx 1234567[root@iZ2zeh7i9iup2d5futu12tZ ~]# docker run -d -P --name nginx03 -v juming-nginx:/etc/nginx nginxfff943c4e6199680f71f7be56f03437387cab3108dff45f6551928ada289fc88[root@iZ2zeh7i9iup2d5futu12tZ ~]# docker volume lsDRIVER VOLUME NAMElocal 3dff6f3d9261f4b09404131549700aab1e1e63da41ea3eac842d5660500d5dd1local juming-nginx[root@iZ2zeh7i9iup2d5futu12tZ ~]# 通过 -v 卷名:容器内路径 #查看一下这个卷的路径[root@iZ2zeh7i9iup2d5futu12tZ ~]# docker volume inspect juming-nginx[ { “CreatedAt”: “2022-03-14T15:03:13+08:00”, “Driver”: “local”, “Labels”: null, “Mountpoint”: “&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;juming-nginx&#x2F;_data”, “Name”: “juming-nginx”, “Options”: null, “Scope”: “local” }] 所有的docker容器内的卷，没有指定目录的情况下都是在 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;juming-nginx&#x2F;_data juming-nginx是我自己起的 我们通过具名挂载可以方便的找到我们的一个卷，大多数情况在使用的具名挂载 #如何确定是匿名挂载，还是具名挂载，还是指定路径挂载 -v 容器内路径 #匿名挂在 -v 卷名：容器内路径 #具名挂载 -v &#x2F;宿主机路径::容器内路径 #指定路径挂载 拓展： 12345678910111213#通过 -v 容器内路径：ro rw 改变读写权限ro readonly #只读rw readwrite #可读可写#一旦设置了容器权限，容器对我们挂载出来的内容就有限定了docker run -d -P --name nginx01 -v /etc/nginx:ro nginx docker run -d -P --name nginx01 -v /etc/nginx:rw nginx#ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内是无法操作的 初始dockerfile123456789101112131415161718192021222324252627282930313233343536373839Dockerfile就是用来构建docker 镜像的构建文件！就是一段命令脚本，先体验一下通过这个脚本可以生成镜像，镜像是一层层的，脚本是一个个的命令，每个命令都是一层#脚本#创建一个dockerfile文件，名字可以随机，简议Dockerfile#文件中的内容 指令（大写） 参数FROM centosVOLUME [&quot;volume01&quot;,&quot;volume02&quot;] #这个是直接创建了两个数据卷，容器内的这是，相当于匿名挂载CMD echo&quot;end.....&quot; CMD /bin/bash #用这个shell来运行#每一个命令就是镜像的一层​ [root@iZ2zeh7i9iup2d5futu12tZ docker-test-volume]# docker build -f /home/docker-test-volume/dockerfile1 -t zzh/centos:1.0 .Sending build context to Docker daemon 2.048kBStep 1/4 : FROM centos ---&gt; 5d0da3dc9764Step 2/4 : VOLUME [&quot;volume01&quot;,&quot;volume02&quot;] ---&gt; Running in 8885080fc842Removing intermediate container 8885080fc842 ---&gt; a779f93ccab1Step 3/4 : CMD echo&quot;end.....&quot; ---&gt; Running in 456e6a3d6766Removing intermediate container 456e6a3d6766 ---&gt; 335a8cdf4353Step 4/4 : CMD /bin/bash ---&gt; Running in 57deb9cf34b2Removing intermediate container 57deb9cf34b2 ---&gt; 86578e5f83a8Successfully built 86578e5f83a8Successfully tagged zzh/centos:1.0 启动自己的容器 用docker inspect 容器id 就可以看到对应的本机的数据卷 在volume1文件（在容器的根目录下）里改动的也会同步到映射的本机文件 这种方式我们未来会使用的特别多，因为我们通常会构建自己的镜像，假设构建镜像时候没有挂载，要手动镜像挂载， -v 卷名:容器内路径 数据卷容器多个容器同步数据 例子：多个mysql同步数据 contain01已经是启动好的 docker run -it –name container02 –volumes from container01 镜像名&#x2F;id # 将两个容器进行挂载 对container01进行的操作可以同步到container02 如果删掉了container01 container02中的文件也不会消失的 #两个mysql数据库实现数据共享 docker run -d -p 3310:3306 -v &#x2F;etc&#x2F;mysql&#x2F;conf.d -v &#x2F;var&#x2F;lib&#x2F;mysql -e MYSQL_ROOT_PASSWORD&#x3D;123456 –name mysql01 mysql:5.7 docker run -d -p 3310:3306 docker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD&#x3D;123456 –name mysql02 –volumes-form mysql01 mysql:5.7 结论： 容器之间配置信息的传递，数据容器卷的生命周期一直持续到没有容器使用为止。 但是一旦你持久化到了本地，这个时候，本地的数据是不会删除的！ DockerFiledockerfile是用来构建docker镜像的文件! 命令参数脚本 每一个官网上的镜像都是dockerfile构建的 构建步骤： 1，编写一个dockerfile文件 2，docker build 构建成为一个镜像 3，docker run 运行镜像 4，docker push 发布镜像（DockerHub、阿里云镜像仓库！） 官方的一个centos镜像的dockfile 官方可以制作镜像，我们自己也可以制作镜像 DockerFile构建过程Dockerfile命令命令 效果FROM 基础镜像：Centos&#x2F;UbuntuMAINTAINER 镜像作者+邮箱RUN 镜像构建的时候需要运行的命令ADD 为镜像添加内容（压缩包）WORKDIR 镜像工作目录（进入容器时的目录）VOLUME 挂载的目录EXPOSE 暴露端口配置CMD&#x2F;ENTRYPOINT 指定这个容器启动时要运行的命令（CMD替代先前命令，ENTRYPOINT在先前命令后追加）COPY 类似于ADD，将文件拷贝到镜像中ENV 构建时设置环境变量 基础知识1.每个关键字指令都是必须是大写字母 2.执行从上到下顺序执行 3，#表示注释 4，每一个指令都会创建提交一个新的镜像层，并提交 可写容器中储存了指令 dockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简单 Docker镜像逐渐成为了企业交付的一个标准，必须要掌握！ 步骤：开发，部署，运维，缺一不可 DockerFile：构建文件，定义了一切的步骤，源代码 Dockerimages：通过DockerFile构建生成的镜像，最终发布和运行的产品 Docker容器:容器就是镜像运行起来提供服务器 使用别人的也可以自己做 DockerFile指令说明命令 效果FROM 基础镜像：Centos&#x2F;Ubuntu一切从这里开始构建MAINTAINER 镜像作者+邮箱，告诉大家是谁提交的镜像RUN 镜像构建的时候需要运行的命令ADD 为镜像添加内容（压缩包） ，添加tomcat的压缩包WORKDIR 镜像工作目录（进入容器时的目录）VOLUME 挂载的目录EXPOSE 暴露端口配置CMD&#x2F;ENTRYPOINT 指定这个容器启动时要运行的命令（CMD替代先前命令，ENTRYPOINT在先前命令后追加）COPY 类似于ADD，将文件拷贝到镜像中ENV 构建时设置环境变量 ONBUILD #当构建一个被继承 DockerFile 这个时候就会运行ONBUILD 的指令，除法指令 COPY #类似ADD，将我们的文件拷贝到镜像中 实战测试：构建自己的centosDockerHub中%99的镜像都是从这个基础镜像过来的FROM scratch 然后配置需要的软件和配置来进行的构建 scratch是一个基础镜像 第二行是加入了一个centos压缩包 #创建一个自己的centos #1,编写dockerfile文件 FROM centos MAINTAINER zzh&#51;&#50;&#52;&#49;&#53;&#x32;&#53;&#x30;&#51;&#x36;&#64;&#113;&#x71;&#46;&#x63;&#x6f;&#x6d; ENV MYPATH &#x2F;user&#x2F;local WORKDIR $MYPATH 设置工作目录 RUN yum -y install vim #让vim命令可以用 RUN yum -y install net-tools #让ifconfig命令可以用 EXPOSE 80 CMD echo $MYPATH CMD echo “—end—“ CMD &#x2F;bin&#x2F;bash 2，通过这个文件构建镜像 #命令 docker build -f dockerfile文件路径 -t 镜像名:[tag] tag是版本的意思 3，测试运行一下 对比：之前的原生的centos ，工作目录默认是根目录，没有ifconfig vim这些命令 我们增加之后的镜像是都有的 我们可以列出本地进行的镜像变更历史 docker history cmd和entrypoint的区别 cmd #指定这个容器启动时要运行的命令，只有最后一个会生效，可被替代 entrypoint #指定这个容器启动的时候要运行的命令，可以追加命令 #编写dockerfile文件 [root@iZ2zeh7i9iup2d5futu12tZ dockerfile]# vim mydockerfile FROM centosCMD [“ls”,”-a”] #构建镜像 [root@iZ2zeh7i9iup2d5futu12tZ dockerfile]# docker build -f dockerfile-cmd-test -t cmdtest . #run运行 [root@iZ2zeh7i9iup2d5futu12tZ dockerfile]# docker run e633f13583fb....dockerenvbindevetchomeliblib64lost+foundmediamntoptprocrootrunsbinsrvsystmpusrvar 直接执行了ls -a这个命令 #想追加一个命令 #docker run e633f13583fb -l docker: Error response from daemon: failed to create shim: OCI runtime create failed: container_linux.go:380: starting container process caused: exec: “-l”: executable file not found in $PATH: unknown. #cmd的情况下 -l替换了cmd[“ls”,”-a”]命令，-l 不是命令所以会报错 测试entrypoint #编写文件 [root@iZ2zeh7i9iup2d5futu12tZ dockerfile]# vim dockerfile-cmd-entrypoint[root@iZ2zeh7i9iup2d5futu12tZ dockerfile]# cat dockerfile-cmd-entrypointFROM centosENTRYPOINT [“ls”,”-a”] #创建镜像 直接执行ls -a这个命令 #追加命令， docker run 容器id -l #这个命令是直接拼接在我们的entrypoint命令的后面 发布自己的镜像1，地址dockerhub注册自己的账号 2.确定这个账号可以登录 3，在我们服务器上提交自己的镜像 [root@iZ2zeh7i9iup2d5futu12tZ ~]# docker login –help Usage: docker login [OPTIONS] [SERVER] Log in to a Docker registry.If no server is specified, the default is defined by the daemon. Options: -p, –password string Password –password-stdin Take the password from stdin -u, –username string Username [root@iZ2zeh7i9iup2d5futu12tZ ~]# docker login -u zpq12987462332142Password:WARNING! Your password will be stored unencrypted in &#x2F;root&#x2F;.docker&#x2F;config.json.Configure a credential helper to remove this warning. Seehttps://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded[root@iZ2zeh7i9iup2d5futu12tZ ~]# 4 登陆完毕后就可以提交镜像了，就是一步，docker push [root@iZ2zeh7i9iup2d5futu12tZ ~]# docker push iZ2zeh7i9iup2d5futu12tZ&#x2F;cmdtest:latestThe push refers to repository [docker.io&#x2F;library&#x2F;cmdtest]74ddd0ec08fa: Preparingdenied: requested access to the resource is denied#被拒绝了 #解决，增加一个tag docker tag 容器id iZ2zeh7i9iup2d5futu12tZ&#x2F;cmdtest:1.0 #docker push 上去即可，自己发布的镜像尽量带上版本号 docker push iZ2zeh7i9iup2d5futu12tZ&#x2F;cmdtest:1.0 #提交的时候也是按镜像的层级来提交的 Docker compose简介问题是：做项目或者微服务的时候，绝对不止启动一个容器，如果每一个都build run就会很麻烦，并且有些容器之间存在依赖关系，手动的去启停会很慢 解决问题：Docker compose 来轻松高效的管理容器，定义运行多个容器 作用:批量容器编排 自己的理解： Compose是docker官方的开源项目，需要安装 dockerfile可以让程序在任何地方运行。 一个web服务可以包含redis，mysql，nginx等多个容器 一个yml文件，可以将多个关联容器写入并且同时启动 1234567services: webapp: image: examples/web ports: - &quot;8000:8000&quot; volumes: - &quot;/data&quot; Compose：重要概念 ​ 服务services: 容器。(web,redis,mysql…) ​ 项目project：一组关联的容器。博客。web ，mysql ​ 用docker-compose up可以同时启动这些关联服务 docker-compose 安装下载 curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.5/docker-compose-`uname -s-uname -m&#96; &gt; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose bin目录下的绿色的docker-compose是真的docker-compose文件 授权 sudo chmod +x docker-compose 在bin目录下用这个命令即可 sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose 正常用这个命令 bin下出现docker-compose，而且授权成功 体验Get started with Docker Compose | Docker Documentation 大步骤1.应用app.py Dockerfile应用打包镜像 3，Docker-compose yml文件（定义整个服务，需要的环境，web redis） 完整的上线服务 4，启动compose项目（docker-compose up） 流程： 1.创建网络 2.执行docker-compose.yaml文件 3，启动服务。 Creating composetest_web_1 …done Creating composetest_redis_1 …done 这两句话的意思：1.文件名composetest 2，服务 12345678version: &quot;3.9&quot;services: web: build: . ports: - &quot;8000:5000&quot; redis: image: &quot;redis:alpine&quot; 图示就是两个容器启动成功，compose启动成功 curl localhost:5000 就可以判断服务是否正常 默认的服务器的名 文件名_服务名 _num 比如说要用多个redis，集群或者怎么样，就可以有1，2，3等副本 3，网络规则 docker network ls 启动docker-compose的时候自动生成一个网络 一个项目有十个服务（容器）（项目的所有内容都在同一个网络下。可以用域名访问） docker network inspect composetest_default #查看网络具体情况 这是app.py文件中的内容 ，host&#x3D;redis说明可以用域名访问 1234567891011121314151617181920212223import timeimport redisfrom flask import Flaskapp = Flask(__name__)cache = redis.Redis(host=&#x27;redis&#x27;, port=6379)def get_hit_count(): retries = 5 while True: try: return cache.incr(&#x27;hits&#x27;) except redis.exceptions.ConnectionError as exc: if retries == 0: raise exc retries -= 1 time.sleep(0.5)@app.route(&#x27;/&#x27;)def hello(): count = get_hit_count() return &#x27;Hello World! I have been seen &#123;&#125; times.\\n&#x27;.format(count) 如果在同一个网络下，我们可以直接通过域名访问。 停止compose停止：docker-compose down 在有docker-compose.yml文件的目录下使用这个命令才行 法二;用ctrl+c也可以停止compose，都是在有docker-compose.yml文件的目录下使用这个命令才行 以前都是单个docker run 启动容器 docker-compose。通过docker-compose编写yaml配置文件，可以通过compose一键启动所有服务，停止 小细节 1.cd &#x2F;home 1mkdir composetest 1cd composetest 看上面官方文档步骤即可 之后所有的文件都是放在&#x2F;home&#x2F;composetest 一个docker-compose.yml文件 12345678version: &quot;3.9&quot;代表用的是哪个版本services: web: build: . ports: - &quot;8000:5000&quot; #web服务 redis: image: &quot;redis:alpine&quot; #redis服务 比如说composetest文件下有docker-compose.yml文件，才能在composetest目录下启动docker-compose 用docker-compose up命令， Docker小结： 1，Docker镜像，run&#x3D;&gt;容器 2，DockerFile 构建镜像（服务打包） 3，docker-compose启动项目（编排多个微服务&#x2F;服务） 4，Docker 网络 yaml规则docker-compose.yaml核心 1，三层 version：‘ ’ #版本 service： #服务 服务1：web #服务配置 images build network depends_on是用来规定容器的启动顺序，比如web服务器需要依赖于redis 就depends_on: redis 这样就会先启动redis再启动web服务 服务2：redis … 服务3：redis #其他配置，网络配置&#x2F;卷，全局规则 volumes： network： configs： 这里可以看到很多第二层的服务配置 多看 compose.yaml配置 1，官网 Compose file version 3 reference | Docker Documentation 2，开源项目 compose.yaml redis ,mysql 使用compose一键部署博客下载程序，安装数据库，配置…… compose 应用。&#x3D;&gt;一建启用 wordpress是一个开源博客系统 cd &#x2F;home mkdir my_wordpress cd my_wordpress&#x2F; vim docker-compose.yml 文件内容 12345678910111213141516171819202122232425262728293031version: &quot;3.3&quot; services: db: image: mysql:5.7 volumes: - db_data:/var/lib/mysql restart: always environment: MYSQL_ROOT_PASSWORD: somewordpress MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress wordpress: depends_on: - db image: wordpress:latest volumes: - wordpress_data:/var/www/html ports: - &quot;8000:80&quot; restart: always environment: WORDPRESS_DB_HOST: db WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress WORDPRESS_DB_NAME: wordpressvolumes: db_data: &#123;&#125; wordpress_data: &#123;&#125; 1下载项目（docker-compose.yaml） 2,如果需要文件。Dockerfile，自己写一个 3.文件准备齐全，直接一键启动项目 docker compose","categories":[],"tags":[]},{"title":"git和github","slug":"git使用和github","date":"2022-09-29T15:31:35.000Z","updated":"2023-04-10T12:58:50.944Z","comments":true,"path":"2022/09/29/git使用和github/","link":"","permalink":"http://example.com/2022/09/29/git%E4%BD%BF%E7%94%A8%E5%92%8Cgithub/","excerpt":"","text":"所有操作之前先提交原版文件 1.4.分布式和集中式区别 分布式就是每个人手里都有一份项目完整的历史记录，而集中式只是集中服务器上有所有人的记录 1.5.工作机制： 工作区就是代码在本地磁盘的位置 3.4.2 git rm –cached 文件名 从暂存区移除文件 3.5.1 提交后有版本号 3.7.1 Head-&gt;master在哪，就说明当前处于这个版本 git控制台之中选中之后，就是复制，然后点击鼠标滚轮就是粘贴 5.1 师傅先push代码到代码托管中心，并开放权限给大弟子，大弟子可以clone代码到本地，自己修改后，也可以push到代码托管中心，然后师傅可以pull这个代码到本地库 5.2 东方不败可以把师傅远程库的代码fork到自己的远程库，然后东方不败从自己远程库clone到本地库，东方不败在本地库修改之后再push到东方不败远程库，然后东方不败需要Pull request向师傅发起请求，师傅先审核，然后审核通过就可以merge东方不败的版本过来到师傅的远程库，然后师傅可以pull远程库中的版本到本地库中 $ vim hello&#x2F;hello1.txt 这样可以修改仓库中hello文件夹下的hello1.txt文件 6.2.1 这个master这里是你提交分支的名字 当有人改了你远程库文件时，你发现远程库和本地库不同，可以 pull下来，pull下来之后会把那个文件自动提交本地库 6.2.3 git clone -b master http://gitslab.yiqing.com/declare/about.git -b是指定克隆的分支 7.1 git.config文件我放在C:&#x2F;Users 目录下 7.6 修改之后再提交，上面那一串0a开头的字符串是指这个版本号 idea可以提示修改的内容 8.2 分项项目到github等于，先把项目代码添加到本地库然后创建远程库，再push 8.3 push commits的时候，那个github是之前提交的那个连接别名，默认是https这个链接，所以要把它换为ssh免密登录那个链接，重新修改别名来push 提交到本地库之后才能够push 8.4 pull到本地库的时候它自动就是一个新的版本，如果觉得他的不好还可以再改回来原来版本再提交到本地库，再push 小结：commit是保存在本地库，push是将本地库中的版本保存到远程库，包括直接分项也是将本地库中版本保存到远程库， pull的时候有可能会发生冲突 在对本地代码进行修改的时候，最好先pull一下远程库中的代码，pull就是又新建了一个版本在本地库中 当进行了版本回调的时候，本地库会变为原来的版本，虽然master分支那个指针还是在新的版本上，但本地库和页面都是原来的版本 ，但现在不能直接push项目，push只能push某一个分支的代码，而不能说是单纯的哪一个版本，而没有分支在那 github所有连接都用ssh的，分享项目的时侯建立的那个链接默认是https的，可能会push不成功，你可以通过自己手动push，这个时候就可以自己制定连接了，不过要提前自己创建好库 你提交了一次之后，又对代码进行了修改，此时你又要想回到之前那次提交的代码，你要先把修改过的提交了，此时你处于第二个版本，才能够彻底回到前一个版本，通过切换版本的方法 在本地可以有多个分支，每个分支都可以单独提交到远程库，在远程库也可以查看不同分支 我们有一个master分支，然后又创价了一个新的分支dev，我们对dev进行不断的修改完善，然后准备把他俩合并，现在面临一个问题，就是我们是在master分支合并dev，还是在dev分支合并master，两者的区别在于在master分支合并dev会让master指向合并后的新提交，而dev还是指向原本合并之前的，所以我们基本都是在master合并dev git使用你新建了一个文件夹，原本里面用于存放刚才的各种版本文件，现在要用git对该文件夹进行接管。当你修改了文件点击保存之后，就用git的相关命令，提交给git，让git帮你管理，git就会产生一个快照，记录你现在保存的状态，之后不论你对原文件进行任何修改（包括删除），只要你没有删除git文件，就都可以随时恢复。 如下，当前只显示一个文件，但你使用git log命令，就可以看到你保存的各种版本的文件。 每个版本的文件，都会显示该版本修改的内容，当然这个内容是你自己添加的说明。 每个版本都有独特的一串代码（黄色字体的那串代码），要恢复对应版本的，就用那个代码。 现在你手中就只需要管理一个文件，其它的文件你只是备用，可能用到，可能用不到。到最终他们都用不到，因为地形就只有一个。 以上只是介绍大致的一个情况，git可以控制电脑上所有格式的文件doc、excel、dwg、dgn、rvt等等。原文链接：https://blog.csdn.net/weixin_45684343/article/details/103697678 常用命令git的用户名和邮箱和github一样 $ git config –global user.name “zhaozihj”，设置用户名 $ git config –global user.email &#x33;&#x32;&#52;&#x31;&#x35;&#50;&#53;&#x30;&#x33;&#54;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#x6d; 设置邮箱 $ git config –list 看自己所设置的所有配置 git init 初始化git生成git仓库，生成一个隐藏的.git文件夹git status 查看git状态，可以看到哪些文件在暂缓区，哪些不在git add 添文件到暂存区,后面就是个文件名也不用加引号什么的git add . 加入所有文件到暂存区 所有文件是指与git文件在同一目录下的所有文件git commit -m “message” 提交文件到本地仓库message是一些状态的补充信息，提交到git仓库中 git log 能查看是谁在什么时候对版本进行了改动 进行这个操作以后commit后面跟的值，就像是commit的身份证 git reflog 这个是git log的精简版，内容比较少 git reset 将尚没有commite之前加入到暂存区的文件重新拉回 git reset –hard&#x2F;–soft&#x2F;–mixed回到前几次中某一次修改的版本 –hard:不保存所有变更 –soft:保存变更且变更内容处于staged –mixed:保留变更且变更内容处于modified –soft:保留变更且变更内容处于staged 上面的变更是指reset之后的操作 git reflog 查看所有的操作记录，在当中找到你想回退的那个版本的id再用git reset (适用于你找不到新版的id) 分支有关命令 git checkout -b name是这个分支的名字，第二个参数是以哪个分支或者master为模板，继承其操作，但是每个分支之间分支与master之间的操作并不互通 git checkout master 从分支切回master git branch 查看所有分支 亮的条目表示我们现在所处的分支 git merge 合并分支的变更到当前所处的分支 文件状态：1.没有被add过的文件叫untracked2.add之后文件处于staged状态等待commite3.commit之后文件处于unmodified 这里之所以有可能变成modified是因为文件会跟仓库中的文件对比4.当unmodified的文件被修改则会变为modified状态5.modified之后的文件add之后将继续变为staged状态6.unmodifed的文件还有一种可能是已经不再需要了，那么可以remove它不再追踪变为untracked状态 如何恢复修改前的文件(18条消息) 修改txt文件某行_GIT，如何恢复修改过的文件，回到过去呢？_weixin_39846378的博客-CSDN博客 文章中只有第三种方法是好用的 先add文件再commit文件再修改文件（可以直接在原文件修改也可以用linux命令方法下面补充里有），再add文件，再commit，这时如果想回到最初版本，再用上面的第三种方法 本地仓库git工作区域 1.工作区，添加编辑修改文件等动作 2，git仓库，最终确定的文件保存到仓库，成为一个新的版本对他人可见 3，暂存区，暂存已经修改的文件最后统一提交到git仓库中 初始化一个新的git仓库 1.新建文件夹 2.在文件内右击点git bash here，再在命令行中输入git init就生成一个.git隐藏文件夹，存储本地仓库信息 补充 创建文件 touch a1.php 创建一个名为a1.php的文件 修改文件也可以用命令进行，文件进入暂存区之后， vi a1.php（a1.php为文件名）修改文件 删除文件1.删除文件 rm a1.php 2，从git中删除文件 git rm a1.php 3,git commit -m “提交描述” githubhttps://github.com/zhaozihj/test github目的：借助github托管项目的代码 github.com后面跟的是仓库的主人名字在后面是仓库的名字这样可以直接访问一个仓库 repository 仓库，存放项目代码 star 收藏 fork 复制克隆项目，复制之后自己就会出现一个一样的仓库，且是单独存在 watch 关注，关注某个项目后，这个项目有任何更新自己都会收到第一时间提醒 issue 事务卡片比如一个项目，别人发现你的项目中有漏洞，他就可以给你提一个issue，看到这些问题可以逐个去修复，修复ok就可以close掉 pull request（发起请求）意思和作用“有一个仓库，叫Repo A。你如果要往里贡献代码，首先要Fork这个Repo，于是在你的Github账号下有了一个Repo A2,。然后你在这个A2下工作，Commit，push等。然后你希望原始仓库Repo A合并你的工作，你可以在Github上发起一个Pull Request，意思是请求Repo A的所有者从你的A2合并分支。如果被审核通过并正式合并，这样你就为项目A做贡献了” 建立pull request是克隆之后，在克隆产生的那个仓库中请求pull request git管理远程仓库使用远程仓库目的作用：备份，实现代码共享集中化管理 1.工作区，workspace 2，暂存区，index 3，git仓库，repository 4.用git push将本地仓库提交到远程仓库Remote git克隆操作目的：将远程仓库（github对应的项目）复制到本地代码：给git clone 仓库地址，仓库地址是在github那个code选项中找到的 将本地仓库同步到git远程仓库中git push 先对文件进行修改，完成操作后commit命令，再用git push，然后会让你进行一个验证 个人站点访问 https:&#x2F;&#x2F;用户名.github.io 搭建步骤 1，创建个人站点 -&gt; 新建仓库（仓库名必须是【用户名.github.io】） 2.在仓库下新建index.html的文件即可 github pages 仅支持静态网页 仓库里面只能是静态网页 project pages 项目站点https:&#x2F;&#x2F;用户名.github.io&#x2F;仓库名 搭建步骤 1，进入项目主页，点击setting 2，再settings页面，点击pages 再点击choose themes 选择主题，可以改变内容 ，再自动生成主题页面","categories":[],"tags":[]},{"title":"javascript","slug":"javascript学习","date":"2022-09-29T15:31:35.000Z","updated":"2023-04-10T12:59:40.293Z","comments":true,"path":"2022/09/29/javascript学习/","link":"","permalink":"http://example.com/2022/09/29/javascript%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"javascript学习javascript是一种弱类型脚本语言，其源代码不需经过编译，而是由浏览器解释运行，用于控制网页的行为 前端后端都有所应用 css：绝定网页的表现样式 html：决定网页的结构和内容 ECMAScript它可以理解为是Javascript的一个标准最新版本已经到es6了，但是大部分浏览器还是只停留在es5代码上 具有交互性：就像那个输入密码不符合规范，然后反馈给用户 快速入门javascript的使用方式 第一种 ，需要在head标签或者body标签中用script标签书写javascript代码 第二种：引入javascript文件 但是一个标签中只能左两者中的任意一个，不能同时都做 123456789101112131415161718192021222324252627&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;tile&gt;Title&lt;/tile&gt;&gt;&lt;script&gt;​ alert(&#x27;hello world&#x27;);//跳出一个hello world的弹窗​ &lt;/script&gt;&lt;!--在script标签内写javascript代码--&gt;&lt;!--外部引入 --&gt;&lt;script src=&quot;123.com/1.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&gt;&lt;/html&gt; 2基本语法入门浏览器必备调试须知 点一下代码左侧序号就是增加断点，这时刷新页面程序就会在断点处暂停 //变量类型只有var var num = 1; var zzz=2;//一行俩分号也行 var name=\"zzh\"; alert(num); //条件控制,这块所有的几乎都和c语言一样 if(2>1) { alert(\"true\"); if(2>1) { alert(\"true\"); } } 1&lt;/script&gt; ### 3.数据类型 javascript中的特殊值 undefined 未定义，所有js变量未赋予初始值的时候，默认值都是undefined null 空值 NAN 非数字 数值，文本，图形，音频，视频 #### numbe类型r js不区分小数和整数 1234567891011123 //整数123123.1 //浮点数123.11.123e3//科学计数法-99 //负数NaN //not a numberInfinity //表述无限大，超出javascript正常使用了 #### 字符串类型 1用单引号双引号包裹 2注意转义字符 \\ 转义字符\\ 后的内容是一个正常的字符串没有特殊含义 ​ 12345 \\n换行，\\u4e2d 这个是unicode字符 格式是\\u####\\x41 Ascll字符&#x27;abc&#x27; &quot;abc&quot; 3多行字符串编写（tab键上面的反引号） 12345 var msg=`asbssabslfjsdlf `; 原样输出两行 4，模板字符串 let msg=`你好呀，${a}`; esc6里面的 5.字符串长度 var student=\"student\"; console.log(student.length);//字符串长度 6.字符串的可变性，不可变 不能用改变数组元素的方法来改变字符串中的内容 7.大小写转换 console.log(student.toUpperCase()) console.log(student.toLowerCase()) ![image-20220327165556516](https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291641802.png) 在控制台里输入这个，后面就会出来一堆方法，类似于java #### 布尔值 true ，false #### 逻辑运算 在javascript中所有的变量，都可以作为一个boolean类型的变量去使用 0，null，undefined，“”都认为是false && 第一种：当表达式全为真时，返回最后一个表达式的值 第二种：当表达式中，有一个为假时，返回第一个为假的表达式的值 123456789 var a = &quot;abc&quot;; var b = true; var d = false; var c = null;// alert( a &amp;&amp; b );//true// alert( b &amp;&amp; a );//abc// alert( a &amp;&amp; d ); // false// alert( a &amp;&amp; c ); // null || 123|| 或运算 第一种情况：当表达式全为假时，返回最后一个表达式的值 第二种情况：只要有一个表达式为真。就会把回第一个为真的表达式的值*/ 12345// alert( d || c ); // null// alert( c|| d ); //false// alert( a || c ); //abc// alert( b || c ); //true ！ #### 比较运算符 = 赋值号 == 等于（类型不一样，值一样也会判断为true） === 绝对等于(类型一样，值一样) NAN与所有的数值都不相等，包括自己 只能通过isNaN(NaN)来判断这个数是否是NaN #### 浮点数问题 console.log((1/3) === (1-2/3))这个的返回值是faulse 尽量避免使用浮点数进行运算，存在精度问题 null空 undefined未定义 #### 数组 快速入门数组 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var arr = [true,1]; // 定义一个空数组 // alert( arr.length ); // 0 arr[0] = 12; // alert( arr[0] );//12 // alert( arr.length ); // 0 // javaScript语言中的数组，只要我们通过数组下标赋值，那么最大的下标值，就会自动的给数组做扩容操作。 //其中没有进行赋值的元素是undefined arr[2] = &quot;abc&quot;; alert(arr.length); //3 // alert(arr[1]);// undefined // 数组的遍历 for (var i = 0; i &lt; arr.length; i++)&#123; alert(arr[i]); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; var arr=[1,2,4,'hello'];可以是不同类型的内容在一个数组中 console.log(arr[0]) 在控制台显示数组的第一个元素，去数组下标，如果越界了，就会undifined 改变第一个元素的值 arr[0]=1 1.长度 arr.length 注意:假如给arr.length赋值，数组大小就会发生变化，如果赋值过小，元素就会丢失 2.indexOf arr.indexOf(2)返回的是2这个数字在数组中的下标索引 字符串“1”和数字1是不同的 3.slice()截取array的一部分，返回一个新数组 arr.slice(1)把第一个元素去掉，然后界取后面的 4.arr.push(),和arr.pop的使用 ![image-20220327171226523](https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291641803.png) arr.push是往最后加，arr.pop()是将数组最后面那个弹出 5.unshift(),shift() 头部 ![image-20220327171637863](https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291641804.png) unshift:压入到头部 shift:弹出头部的一个元素 6.sort() 排序 ![image-20220327171906070](https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291641805.png) 9，连接符join 打印拼接数组，使用特定的字符串连接 12arr.join(&#x27;-&#x27;)&#x27;1-2-4-a-b-hello&#x27; 10，多维数组 arr=[[1,2],[3,4],[\"4\",\"5\"]] ![image-20220327173426046](https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291641806.png) 取值 #### 对象 对象是大括号，数组是中括号 var person={ name:\"qinjiang\", age:3, tags:['js','java']//数组 } var 对象名={ 属性名：属性值， 属性名：属性值 } 取对象的值 console.log(person.name) 1.对象赋值 person.name=\"qinjiang\" 2.使用一个不存在的对象属性，不会报错 只会出现一个undefined 3，动态的删减属性,通过delete删除对象的属性 delete person.nametrueperson.nameundefined 4，动态的添加，直接给新的属性添加值即可 person.haha=\"haha\"'haha'person{age: 3, tags: Array(2), haha: 'haha'} 5，判断属性值是否是在这个对象中 xxx in xxx! 'age' in persontrue 'toString' in persontrue 6.判断一个属性是否是这个对象自身拥有的 person.hasOwnProperty('toString')falseperson.hasOwnProperty('age')true toString这种是每一个对象都会有的属性，但age这种是自己加的 流程控制while,for,dowhile循环与java c语言都一样 forEach遍历数组有所差别 12345678arr.forEach(function (value)&#123; console.log(value);&#125;)这是一个函数这种 for循环遍历数组 1234567for(var num in arr)&#123; console.log(arr[num]);&#125; arr是数组，num是下标 1 3.5Map和SetMap使用 123456var map=new Map([[&#x27;tom&#x27;,100],[&#x27;jack&#x27;,90],[&#x27;haha&#x27;,80]])var name= map.get(&#x27;tom&#x27;);//返回值是100，通过key获得valueconsole.log(name);map.delete(&quot;tom&quot;);//删除一个元素 123map.set(&#x27;admin&#x27;,123456); //在map里新增一个元素console.log(name); Set使用:无序不重复的集合 var set=new Set([3,1,1,1,1]); set.add(2);//添加某个元素 set.delete(1);//删除某个元素 console.log(set.has(3));//看是否有3在这个里面 3.6 iterator遍历数组 123456789var arr=[1,2,3,4,5];for(var x of arr)&#123; console.log(x)&#125; 遍历map 123456789var map= new Map([[&quot;tom&quot;,100][&quot;jack&quot;,90]]);for(var x of map)&#123; console.log(x)&#125; 遍历set 12345678var set=new Set([3,1,1,1,1]);for(var x of set)&#123; console.log(x);&#125; 4，函数定义方式一 绝对值函数 1234567891011121314151617181920212223//定义函数function abs(x)&#123; if(x&gt;=0) &#123;​ return x; &#125; else &#123;​ return -x; &#125;&#125; 如果没有执行return，函数执行完也会返回结果，结果就是undefined 有参函数 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 定义一个无参函数 function fun()&#123; alert(&quot;无参函数fun()被调用了&quot;); &#125; // 函数调用===才会执行 // fun(); function fun2(a ,b) &#123; alert(&quot;有参函数fun2()被调用了 a=&gt;&quot; + a + &quot;,b=&gt;&quot;+b); &#125; // fun2(12,&quot;abc&quot;); // 定义带有返回值的函数 function sum(num1,num2) &#123; var result = num1 + num2; return result; &#125; alert( sum(100,50) ); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 定义方式二 123456789101112131415161718192021var abs1 =function(x)&#123; if(x&gt;=0) &#123;​ return x; &#125; else &#123;​ return -x; &#125;&#125; function(x){.....}这是一个匿名函数，通过abs1就可以调用函数 方式一和方式二等价 调用函数 abs1(10) //10 abs1(-10) //10 参数问题：javascript可以传任意个参数，也可以不传递参数 js中函数不能进行重载，在js中重载会覆盖掉上一次的定义 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function fun(a,b) &#123; alert(&quot;有参函数fun(a,b)&quot;); &#125; function fun() &#123; alert(&quot;无参函数fun()&quot;); &#125; fun(1,&quot;ad&quot;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 可以手动抛出异常 1234567891011121314151617181920212223242526272829var abs2 = function(x)&#123; if(typeof x!==&#x27;number&#x27;) &#123;​ throw &#x27;not a number&#x27;; &#125; if(x&gt;=0) &#123;​ return x; &#125; else &#123;​ return -x; &#125;&#125; arguments 字符串和数字相加的时候同样是字符串的拼接 这个东西叫隐形参数，就是在function函数中不需要定义，但却可以直接用来获取所有参数的 arguments可以获得传进来的所有参数，是一个数组 这个例子其实x只是第一个传进来的参数 包括第一个参数在内的其他参数都是在arguments数组中的 123456789101112131415161718192021222324252627282930313233var abs3=function(x)&#123; console.log(&quot;x&gt;=&quot;+x); for(var i=0;i&lt;arguments.length;i++) &#123;​ console.log(arguments[i]); &#125; if(x&gt;=0) &#123;​ return x; &#125; if(x&lt;=0) &#123;​ return -x; &#125;&#125; 问题：arguments包含所有的参数，我们有时候想用多余的参数来进行附加操作，需要排除己有操作 123456789101112// 需求：要求 编写 一个函数。用于计算所有参数相加的和并返回function sum(num1,num2) &#123; var result = 0; for (var i = 0; i &lt; arguments.length; i++) &#123; if (typeof(arguments[i]) == &quot;number&quot;) &#123;//这一步操作删除了数组当中的所有的不是数字的类型的元素 result += arguments[i]; &#125; &#125; return result;&#125;alert( sum(1,2,3,4,&quot;abc&quot;,5,6,7,8,9) ); rest关键字 1234567891011function aaa(a,b,...rest)&#123; console.log(&quot;a&gt;=&quot;+a); console.log(&quot;b&gt;=&quot;+b); console.log(rest);&#125; 第三个数组就是rest，就是没有被使用的参数 rest参数只能写在最后一个参数,前面要加... 变量的作用域var定义的变量实际是由作用域的，在函数体中声明，则在函数体外是不可以使用的(非要实现后面可以研究闭包) 如果两个函数使用了相同的变量名，只要在函数内部，就不冲突 两个函数进行嵌套，内部函数可以访问外部函数的成员，反之则不行 假设javascript中函数查找变量从自身函数开始，由内向外查找，假设外部存在这个同名的函数变量，则内部函数就会频闭外部函数的变量。 提升变量的作用域，在函数的一开头就把所有的需要加的变量都加上去，便于代码维护，不要乱放 全局变量12345678910111213var ab=1;function f()&#123; console.log(ab);&#125;f();console.log(ab); 全局对象123456789101112131415161718192021var x=&#x27;xxx&#x27;;alert(x);alert(window.x);//默认所有的全局变量，就会自动绑定在window对象下var old_alert=window.alert;//alert是window对象下的一个方法old_alert(x);window.alert = function ()&#123;&#125;alert(123);//发现alert()失效了window.alert= old_alert;window.alert(456);//发现alert()又恢复了 javascript实际上只有一个全局作用域，任何变量（函数也可以视为变量），假设没有在函数作用范围内找到，就会向外查找，如果在全局作用域都没有找到，就会报错，refrenceerror 规范 由于我们所有的全局变量都会绑定到我们的window上，如果不同的js文件，使用了相同的全局变量，冲突，如何能够减少冲突 123456789101112131415//唯一的全局变量var zzh =&#123;&#125;;//定义全局变量zzh.name=&quot;zzh&quot;;zzh.add= function(a,b)&#123; return a+b;//把自己的代码全部放入自己定义的唯一空间名字中，降低全局命名冲突的问题 局部作用域 let 123456789101112131415function a()&#123; for(let i=0;i&lt;100;i++) &#123;​ console.log(i); &#125; console.log(i+1);&#125;a() 因为是let所以i只在for循环里好用，在外面就不好使，所以就输出到99，没有101 123456789101112131415function b()&#123; for(var i=0;i&lt;100;i++) &#123;​ console.log(i); &#125; console.log(i+1);&#125;b(); 用了var就可以输出到101了 常量 const 在es6之前，只有用全部大写字母命名的变量就是常量，建议不要修改这样的值 但也是可以进行修改的 在es6引入了常量关键字 123const PI=3.14;console.log(PI); 如果要改变PI的值的话就会报错 5.面向对象编程Object形式的自定义对象 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 对象的定义： // var 变量名 = new Object(); // 对象实例（空对象） // 变量名.属性名 = 值; // 定义一个属性 // 变量名.函数名 = function()&#123;&#125; // 定义一个函数 var obj = new Object(); obj.name = &quot;华仔&quot;; obj.age = 18; obj.fun = function () &#123; alert(&quot;姓名：&quot; + this.name + &quot; , 年龄：&quot; + this.age); &#125; // 对象的访问： // 变量名.属性 / 函数名(); // alert( obj.age ); obj.fun(); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 方法就是把函数放在对象的里面，对象只有两个东西，属性和方法 123456789101112131415161718192021var zzh=&#123; name:&#x27;zzh&#x27;, birth:2000, age: function()&#123;​ //今年-出生的年​ var now=new Date().getFullYear(); //这就相当于调用Date()类中的getfullyear方法，这就是new一个date对象调用里面的方法​ return now-this.birth; &#125;&#125;//属性调用console.log(zzh.name);//方法调用，一定要带括号console.log(zzh.age()); 1234567891011121314151617181920212223function getAge()&#123; //今年-出生的年 var now=new Date().getFullYear();​ return now-this.birth;&#125;getAge.apply(zzh1,[])//this，指向了zzh1这个对象var zzh1=&#123; name:&#x27;zzh&#x27;, birth:2000, age:getAge //拉取外部的函数就不用加括号了&#125;console.log(zzh1.age())//但这里调用对象里的方法还是需要括号的 Java中:this是无法指向的，是默认指向调用它的那个对象 javascript中:apply函数可以控制this的指向，但默认的话依旧是指向调用它的那个对象 内部对象 12345678910111213141516171819date的基本使用var now=new Date();输入 now.之后会出现所有的date对象的方法console.log(now.getFullYear());//年console.log(now.getMonth());//月console.log(now.getDate());//日console.log(now.getDay());//星期几console.log(now.getHours());//时console.log(now.getMinutes());//分console.log(now.getSeconds());//秒console.log(now.getTime()); //时间戳,全世界统一 JSON对象Json是什么 JSON 是轻量级的文本数据交换格式 JSON 具有自我描述性，更易理解 JSON 独立于语言：JSON 使用 Javascript语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 目前非常多的动态（PHP，JSP，.NET）编程语言都支持JSON。 在javascript中一切皆为对象，任何js支持的类型都可以用json来表示； 格式： 对象都用{} 数组都用[] 所有的键值对 都是用key:value JSON字符串和JS对象的转化 1234567891011121314151617var user =&#123;name:&quot;qinjiang&quot;,age:3,sex:&#x27;男&#x27;&#125;//将对象转化为json字符串 &#x27;&#123;&quot;name&quot;:&quot;qinjiang&quot;,&quot;age&quot;:3,&quot;sex&quot;:&quot;男&quot;&#125;&#x27;var jsonUser=JSON.stringify(user);//json字符串转化为对象 参数为json字符串 &#x27;&#123;&quot;name&quot;:&quot;qinjiang&quot;,&quot;age&quot;:3,&quot;sex&quot;:&quot;男&quot;&#125;&#x27;var obj=JSON.parse(&#x27;&#123;&quot;name&quot;:&quot;qinjiang&quot;,&quot;age&quot;:3,&quot;sex&quot;:&quot;男&quot;&#125;&#x27;); 123456789101112131415161718192021222324//原型对象var student =&#123; name:&quot;qinjiang&quot;, age:3, run:function()&#123;​ console.log(this.name+&quot;run....&quot;) &#125;&#125;;var xiaoming=&#123; name:&quot;xiaoming&quot;&#125;;//小明的原型是studentxiaoming.__proto__=student; class继承 class关键字是在es6引入的 1.定义一个类，属性，方法 //定义一个学生的类 12345678910111213141516171819class Student&#123;constructor(name)&#123;​ this.name=name;&#125;//这里就是一个构造器相当于给了一个类的一个成员变量hello()&#123; allert(&#x27;hello&#x27;);&#125;&#125;var xiaoming= new Student(&quot;xiaoming&quot;);var xiaohong=new Student(&quot;xiaohong&quot;); 2.继承 12345678910111213141516171819202122232425262728293031323334353637383940414243//定义一个学生的类class Student&#123;constructor(name)&#123;​ this.name=name;&#125;//这里就是一个构造器相当于给了一个类的一个成员变量hello()&#123; allert(&#x27;hello&#x27;);&#125;&#125;class XiaoStudent extends Student&#123; //这是一个继承的操作 constructor(name,grade)&#123;​ super(name);//继承父类的name​ this.grade=grade; &#125; myGrade()&#123;​ alert(&#x27;我是一名小学生&#x27;); &#125;&#125;var xiaoming= new Student(&quot;xiaoming&quot;);var xiaohong=new XiaoStudent(&quot;xiaohong&quot;,1); 本质:查看对象原型，student就是xiaoxtudent的原型对象 6.js中的事件事件是电脑输入设备与页面进行交互的响应，我们称之为事件 常用的事件 onload 加载完成事件 页面加载完成之后，常用于做页面js代码初始化操作 onclick 单击事件 常用于按钮的点击反馈响应操作 onblur 失去焦点事件 常用于输入框失去焦点后验证其输入内容是否合法 onchange 内容发生改变事件 常用于下拉列表和输入框内容发生改变后操作 onsubmit 表单提交事件 常用于表单调教前，验证所有表单项是否合法 事件的注册又分为静态注册和动态注册两种： 事件的注册（绑定）就是告诉浏览器，当事件响应后要执行哪些操作代码 静态注册事件 通过html标签的事件属性直接赋值于事件响应后的代码，这种方式我们叫做静态注册 动态注册事件 先通过js代码得到标签的dom对像，再通过dom对象.事件名=functino(){}这种形式赋予事件响应后的代码，叫动态注册 动态注册基本步骤： 1.获取标签对象 2.标签对象.事件名=function(){} onload事件 静态注册 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; // onload事件的方法 function onloadFun() &#123; alert(&#x27;静态注册onload事件，所有代码&#x27;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;!--静态注册onload事件 onload事件是浏览器解析完页面之后就会自动触发的事件 &lt;body onload=&quot;onloadFun();&quot;&gt;//静态注册的使用方法--&gt;&lt;body onload=&quot;onloadFun();&quot;&gt;&lt;/body&gt;&lt;/html&gt; 动态注册 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt;// onload事件动态注册。是固定写法window.onload = function () &#123; alert(&quot;动态注册的onload事件&quot;);&#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; onclick 静态注册 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function onclickFun() &#123; alert(&quot;静态注册onclick事件&quot;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!--静态注册onClick事件--&gt; &lt;button onclick=&quot;onclickFun();&quot;&gt;按钮1&lt;/button&gt; &lt;button id=&quot;btn01&quot;&gt;按钮2&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 动态注册 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 动态注册onclick事件window.onload = function () &#123; // 1 获取标签对象 /* * document 是JavaScript语言提供的一个对象（文档）&lt;br/&gt; * get 获取 * Element 元素（就是标签） * By 通过。。 由。。经。。。 * Id id属性 * * getElementById通过id属性获取标签对象 **/ var btnObj = document.getElementById(&quot;btn01&quot;); // alert( btnObj ); // 2 通过标签对象.事件名 = function()&#123;&#125; btnObj.onclick = function () &#123; alert(&quot;动态注册的onclick事件&quot;); &#125;&#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn01&quot;&gt;按钮2&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; onblur 静态动态代码在一起 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 静态注册失去焦点事件 function onblurFun() &#123; // console是控制台对象，是由JavaScript语言提供，专门用来向浏览器的控制器打印输出， 用于测试使用 // log() 是打印的方法 console.log(&quot;静态注册失去焦点事件&quot;); &#125; // 动态注册 onblur事件 window.onload = function () &#123; //1 获取标签对象 var passwordObj = document.getElementById(&quot;password&quot;); // alert(passwordObj); //2 通过标签对象.事件名 = function()&#123;&#125;; passwordObj.onblur = function () &#123; console.log(&quot;动态注册失去焦点事件&quot;); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 用户名:&lt;input type=&quot;text&quot; onblur=&quot;onblurFun();&quot;&gt;&lt;br/&gt; 密码:&lt;input id=&quot;password&quot; type=&quot;text&quot; &gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; onchange事件 当你改变选项的时候 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function onchangeFun() &#123; alert(&quot;女神已经改变了&quot;); &#125; window.onload = function () &#123; //1 获取标签对象 var selObj = document.getElementById(&quot;sel01&quot;); // alert( selObj ); //2 通过标签对象.事件名 = function()&#123;&#125; selObj.onchange = function () &#123; alert(&quot;男神已经改变了&quot;); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 请选择你心中的女神： &lt;!--静态注册onchange事件--&gt; &lt;select onchange=&quot;onchangeFun();&quot;&gt; &lt;option&gt;--女神--&lt;/option&gt; &lt;option&gt;芳芳&lt;/option&gt; &lt;option&gt;佳佳&lt;/option&gt; &lt;option&gt;娘娘&lt;/option&gt; &lt;/select&gt; 请选择你心中的男神： &lt;select id=&quot;sel01&quot;&gt; &lt;option&gt;--男神--&lt;/option&gt; &lt;option&gt;国哥&lt;/option&gt; &lt;option&gt;华仔&lt;/option&gt; &lt;option&gt;富城&lt;/option&gt; &lt;/select&gt;&lt;/body&gt;&lt;/html&gt; onsubmit事件 return false可以阻止表单提交，阻止默认事件的发生比如a标签不让跳转，表单不让提交 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; &gt; // 静态注册表单提交事务 function onsubmitFun()&#123; // 要验证所有表单项是否合法，如果，有一个不合法就阻止表单提交 alert(&quot;静态注册表单提交事件----发现不合法&quot;); return false; &#125; window.onload = function () &#123; //1 获取标签对象 var formObj = document.getElementById(&quot;form01&quot;); //2 通过标签对象.事件名 = function()&#123;&#125; formObj.onsubmit = function () &#123; // 要验证所有表单项是否合法，如果，有一个不合法就阻止表单提交 alert(&quot;动态注册表单提交事件----发现不合法&quot;); return false; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!--return false 可以阻止 表单提交 --&gt; &lt;form action=&quot;http://localhost:8080&quot; method=&quot;get&quot; onsubmit=&quot;return onsubmitFun();&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;静态注册&quot;/&gt; &lt;/form&gt; &lt;form action=&quot;http://localhost:8080&quot; id=&quot;form01&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;动态注册&quot;/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 7.操作bom对象（重点）浏览器介绍 Javascript和浏览器的关系 Javascript诞生就是为了让他能够在浏览器中运行 BOM:浏览器对象模型 浏览器:IE 6~11 chrome Safari FireFox Opera window window代表浏览器窗口 这个可以用来调整浏览器窗口试试。。。 navigator navigator，封装了浏览器的信息 12345678910navigator.appName&#x27;Netscape&#x27;navigator.appVersion&#x27;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.74 Safari/537.36 Edg/99.0.1150.55&#x27;navigator.userAgent&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.74 Safari/537.36 Edg/99.0.1150.55&#x27;navigator.platform&#x27;Win32&#x27; 大多数时候，我们不会使用navigator对象，因为会被人为修改 不建议使用这些属性来判断和编写代码 screen 代表屏幕的尺寸 1536px 960px就是像素 location（重要） location代表当前页面的url信息 host: 'www.baidu.com&#39; href: 'https://www.baidu.com/?tn=88093251_61_hao_pg&#39; protocol: 'https:' reload: ƒ reload() //重新加载，刷新网页在控制台输入location.reload() //设置新的地址 location.assign('一个url'); document document代表当前的页面，HTML DOM文档文档树 document.title'百度一下，你就知道' document.title='狂神说' //改网站的标题 获取具体的文档数节点 java> javase javaaee var dl=document.getElementById('app'); 也能动态的增加节点，和删除节点 而且还可以获得cookie document.cookie 服务器段可以设置cookie:httpOnly history（不建议使用） history代表浏览器的历史记录 history.back() //后退 history.forward() //前进 8.操作DOM把文档中的标签属性文本转换为对象来管理 DOM：文档对象模型 浏览器网页就是一个Dom树型结构 第一点：document管理了所有的html文档内容 第二点：document它是一种树结构的文档，有层级关系 第三点：它让我们把所有的标签都对象化 第四点：我们可以通过document访问所有的标签对象 document主要方法介绍 1.getElementById方法 得到的对象就是dom对象 innerHTML属性是指起始标签和结束标签中的内容 这个例子是网上常见的两种就是因为用户名输入错误而报错的例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; &gt; /* * 需求：当用户点击了较验按钮，要获取输出框中的内容。然后验证其是否合法。&lt;br/&gt; * 验证的规则是：必须由字母，数字。下划线组成。并且长度是5到12位。 * */ function onclickFun() &#123; // 1 当我们要操作一个标签的时候，一定要先获取这个标签对象。 var usernameObj = document.getElementById(&quot;username&quot;); // [object HTMLInputElement] 它就是dom对象 //获取数据框中的内容 var usernameText = usernameObj.value; // 如何 验证 字符串，符合某个规则 ，需要使用正则表达式技术 var patt = /^\\w&#123;5,12&#125;$/; /* * test()方法用于测试某个字符串，是不是匹配我的规则 ， * 匹配就返回true。不匹配就返回false. * */ var usernameSpanObj = document.getElementById(&quot;usernameSpan&quot;); // innerHTML 表示起始标签和结束标签中的内容 // innerHTML 这个属性可读，可写 usernameSpanObj.innerHTML = &quot;国哥真可爱！&quot;; if (patt.test(usernameText)) &#123; // alert(&quot;用户名合法！&quot;); // usernameSpanObj.innerHTML = &quot;用户名合法！&quot;; usernameSpanObj.innerHTML = &quot;&lt;img src=\\&quot;right.png\\&quot; width=\\&quot;18\\&quot; height=\\&quot;18\\&quot;&gt;&quot;; &#125; else &#123; // alert(&quot;用户名不合法！&quot;); // usernameSpanObj.innerHTML = &quot;用户名不合法！&quot;; usernameSpanObj.innerHTML = &quot;&lt;img src=\\&quot;wrong.png\\&quot; width=\\&quot;18\\&quot; height=\\&quot;18\\&quot;&gt;&quot;; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot; value=&quot;wzg&quot;/&gt; &lt;span id=&quot;usernameSpan&quot; style=&quot;color:red;&quot;&gt; &lt;/span&gt; &lt;button onclick=&quot;onclickFun()&quot;&gt;较验&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 正则表达式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 表示要求字符串中，是否包含字母e // var patt = new RegExp(&quot;e&quot;); // var patt = /e/; // 也是正则表达式对象 // 表示要求字符串中，是否包含字母a或b或c // var patt = /[abc]/; // 表示要求字符串，是否包含小写字母 // var patt = /[a-z]/; // 表示要求字符串，是否包含任意大写字母 // var patt = /[A-Z]/; // 表示要求字符串，是否包含任意数字 // var patt = /[0-9]/; // 表示要求字符串，是否包含字母，数字，下划线 // var patt = /\\w/; // 表示要求 字符串中是否包含至少一个a // var patt = /a+/; // 表示要求 字符串中是否 *包含* 零个 或 多个a // var patt = /a*/; // 表示要求 字符串是否包含一个或零个a // var patt = /a?/; // 表示要求 字符串是否包含连续三个a // var patt = /a&#123;3&#125;/; // 表示要求 字符串是否包 至少3个连续的a，最多5个连续的a // var patt = /a&#123;3,5&#125;/; // 表示要求 字符串是否包 至少3个连续的a， // var patt = /a&#123;3,&#125;/; // 表示要求 字符串必须以a结尾 // var patt = /a$/; // 表示要求 字符串必须以a打头 // var patt = /^a/; // 要求字符串中是否*包含* 至少3个连续的a // var patt = /a&#123;3,5&#125;/; // 要求字符串，从头到尾都必须完全匹配 // var patt = /^a&#123;3,5&#125;$/; var patt = /^\\w&#123;5,12&#125;$/; var str = &quot;wzg168[[[&quot;; alert( patt.test(str) ); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 2.getElementByName方法 根据name属性来得到一个有很多对象的集合，就是有很多个标签的name为一样的，然后集合每一个元素都是dom对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 全选 function checkAll() &#123; // 让所有复选框都选中 // document.getElementsByName();是根据 指定的name属性查询返回多个标签对象集合 // 这个集合的操作跟数组 一样 // 集合中每个元素都是dom对象 // 这个集合中的元素顺序是他们在html页面中从上到下的顺序 var hobbies = document.getElementsByName(&quot;hobby&quot;); // checked表示复选框的选中状态。如果选中是true，不选中是false // checked 这个属性可读，可写 for (var i = 0; i &lt; hobbies.length; i++)&#123; hobbies[i].checked = true; &#125; &#125; //全不选 function checkNo() &#123; var hobbies = document.getElementsByName(&quot;hobby&quot;); // checked表示复选框的选中状态。如果选中是true，不选中是false // checked 这个属性可读，可写 //就是这个checked属性即使原本没有，也可以这样直接加上 for (var i = 0; i &lt; hobbies.length; i++)&#123; hobbies[i].checked = false; &#125; &#125; // 反选 function checkReverse() &#123; var hobbies = document.getElementsByName(&quot;hobby&quot;); for (var i = 0; i &lt; hobbies.length; i++) &#123; hobbies[i].checked = !hobbies[i].checked; // if (hobbies[i].checked) &#123; // hobbies[i].checked = false; // &#125;else &#123; // hobbies[i].checked = true; // &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 兴趣爱好： &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;cpp&quot; checked=&quot;checked&quot;&gt;C++ &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;java&quot;&gt;Java &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;js&quot;&gt;JavaScript &lt;br/&gt; &lt;button onclick=&quot;checkAll()&quot;&gt;全选&lt;/button&gt; &lt;button onclick=&quot;checkNo()&quot;&gt;全不选&lt;/button&gt; &lt;button onclick=&quot;checkReverse()&quot;&gt;反选&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; getElementsByTagName方法 返回带有指定标签名的对象集合，集合中也是dom对象 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; // alert( document.getElementById(&quot;btn01&quot;) ); &#125; // 全选 function checkAll() &#123; alert( document.getElementById(&quot;btn01&quot;) ); // document.getElementsByTagName(&quot;input&quot;); // 是按照指定标签名来进行查询并返回集合 // 这个集合的操作跟数组 一样 // 集合中都是dom对象 // 集合中元素顺序 是他们在html页面中从上到下的顺序。 var inputs = document.getElementsByTagName(&quot;input&quot;); for (var i = 0; i &lt; inputs.length; i++)&#123; inputs[i].checked = true; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!--as --&gt; 兴趣爱好： &lt;input type=&quot;checkbox&quot; value=&quot;cpp&quot; checked=&quot;checked&quot;&gt;C++ &lt;input type=&quot;checkbox&quot; value=&quot;java&quot;&gt;Java &lt;input type=&quot;checkbox&quot; value=&quot;js&quot;&gt;JavaScript &lt;br/&gt; &lt;button id=&quot;btn01&quot; onclick=&quot;checkAll()&quot;&gt;全选&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 三个方法的主意事项 必须在页面加载完成之后再调用这三个方法，否则可能得不到对应的标签对象，得到null，因为代码是从上到下进行的 节点的常用属性和方法 就是一个标签的dom对象的方法和属性 方法：通过具体的元素节点调用getElementsByTagName() 方法，获取当前节点的指定标签名孩子节点 appendChild(oChildNode)方法，可以添加一个孩子结点，oChildNode是要添加的孩子节点 属性： 1.childnodes 获取当前节点的所有子结点 2.firstChild获取当前节点的第一个子结点 3lastChild获取当前节点的最后一个子结点 4.parentNode 获取当前节点的父节点 5.nextSibling获取当前节点的下一个兄弟结点 6.previousSibling 获取当前节点的上一个兄弟节点 7.className 用于获取或设置标签的class属性值 8.innerHTML表示获取或者设置其实标签和结束标签中的内容，这个不止是文本可能是图片超链接啊之类的 9.innerText表示获取或者设置起始标签和结束标签中的文本 dom查询的练习 #phone是指id为phone 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;dom查询&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style/css.css&quot; /&gt;&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; //1.查找#bj节点 document.getElementById(&quot;btn01&quot;).onclick = function () &#123; var bjObj = document.getElementById(&quot;bj&quot;); alert(bjObj.innerHTML); &#125; //2.查找所有li节点 var btn02Ele = document.getElementById(&quot;btn02&quot;); btn02Ele.onclick = function()&#123; var lis = document.getElementsByTagName(&quot;li&quot;); alert(lis.length) &#125;; //3.查找name=gender的所有节点 var btn03Ele = document.getElementById(&quot;btn03&quot;); btn03Ele.onclick = function()&#123; var genders = document.getElementsByName(&quot;gender&quot;); alert(genders.length) &#125;; //4.查找#city下所有li节点 var btn04Ele = document.getElementById(&quot;btn04&quot;); btn04Ele.onclick = function()&#123; //1 获取id为city的节点 //2 通过city节点.getElementsByTagName按标签名查子节点 var lis = document.getElementById(&quot;city&quot;).getElementsByTagName(&quot;li&quot;); alert(lis.length) &#125;; //5.返回#city的所有子节点 var btn05Ele = document.getElementById(&quot;btn05&quot;); btn05Ele.onclick = function()&#123; //1 获取id为city的节点 //2 通过city获取所有子节点 //3 空白字符也可以算作子结点，所以是9个 alert(document.getElementById(&quot;city&quot;).childNodes.lengthc); &#125;; //6.返回#phone的第一个子节点 var btn06Ele = document.getElementById(&quot;btn06&quot;); btn06Ele.onclick = function()&#123; // 查询id为phone的节点 alert( document.getElementById(&quot;phone&quot;).firstChild.innerHTML ); &#125;; //7.返回#bj的父节点 var btn07Ele = document.getElementById(&quot;btn07&quot;); btn07Ele.onclick = function()&#123; //1 查询id为bj的节点 var bjObj = document.getElementById(&quot;bj&quot;); //2 bj节点获取父节点 alert( bjObj.parentNode.innerHTML ); &#125;; //8.返回#android的前一个兄弟节点 var btn08Ele = document.getElementById(&quot;btn08&quot;); btn08Ele.onclick = function()&#123; // 获取id为android的节点 // 通过android节点获取前面兄弟节点 alert( document.getElementById(&quot;android&quot;).previousSibling.innerHTML ); &#125;; //9.读取#username的value属性值 var btn09Ele = document.getElementById(&quot;btn09&quot;); btn09Ele.onclick = function()&#123; alert(document.getElementById(&quot;username&quot;).value); &#125;; //10.设置#username的value属性值 var btn10Ele = document.getElementById(&quot;btn10&quot;); btn10Ele.onclick = function()&#123; document.getElementById(&quot;username&quot;).value = &quot;国哥你真牛逼&quot;; &#125;; //11.返回#bj的文本值 var btn11Ele = document.getElementById(&quot;btn11&quot;); btn11Ele.onclick = function()&#123; alert(document.getElementById(&quot;city&quot;).innerHTML); // alert(document.getElementById(&quot;city&quot;).innerText); &#125;; &#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;total&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;p&gt; 你喜欢哪个城市? &lt;/p&gt; &lt;ul id=&quot;city&quot;&gt; &lt;li id=&quot;bj&quot;&gt;北京&lt;/li&gt; &lt;li&gt;上海&lt;/li&gt; &lt;li&gt;东京&lt;/li&gt; &lt;li&gt;首尔&lt;/li&gt; &lt;/ul&gt; &lt;br&gt; &lt;br&gt; &lt;p&gt; 你喜欢哪款单机游戏? &lt;/p&gt; &lt;ul id=&quot;game&quot;&gt; &lt;li id=&quot;rl&quot;&gt;红警&lt;/li&gt; &lt;li&gt;实况&lt;/li&gt; &lt;li&gt;极品飞车&lt;/li&gt; &lt;li&gt;魔兽&lt;/li&gt; &lt;/ul&gt; &lt;br /&gt; &lt;br /&gt; &lt;p&gt; 你手机的操作系统是? &lt;/p&gt; &lt;ul id=&quot;phone&quot;&gt;&lt;li&gt;IOS&lt;/li&gt;&lt;li id=&quot;android&quot;&gt;Android&lt;/li&gt;&lt;li&gt;Windows Phone&lt;/li&gt;&lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;inner&quot;&gt; gender: &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot;/&gt; Male &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;/&gt; Female &lt;br&gt; &lt;br&gt; name: &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;username&quot; value=&quot;abcde&quot;/&gt; &lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;btnList&quot;&gt; &lt;div&gt;&lt;button id=&quot;btn01&quot;&gt;查找#bj节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn02&quot;&gt;查找所有li节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn03&quot;&gt;查找name=gender的所有节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn04&quot;&gt;查找#city下所有li节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn05&quot;&gt;返回#city的所有子节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn06&quot;&gt;返回#phone的第一个子节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn07&quot;&gt;返回#bj的父节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn08&quot;&gt;返回#android的前一个兄弟节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn09&quot;&gt;返回#username的value属性值&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn10&quot;&gt;设置#username的value属性值&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn11&quot;&gt;返回#bj的文本值&lt;/button&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 创建一个新的结点 创建一个新结点，让它显示在页面中 这个document.body要在文档加载之后去用，否则都不知道什么是body 文本也能封装成为一个节点，并且是一个正常标签结点的子结点 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function () &#123; // 现在需要我们使用js代码来创建html标签，并显示在页面上 // 标签的内容就是：&lt;div&gt;国哥，我爱你&lt;/div&gt; var divObj = document.createElement(&quot;div&quot;); // 在内存中 &lt;div&gt;&lt;/div&gt; var textNodeObj = document.createTextNode(&quot;国哥，我爱你&quot;); // 有一个文本节点对象 #国哥，我爱你 divObj.appendChild(textNodeObj); // &lt;div&gt;国哥，我爱你&lt;/div&gt; // divObj.innerHTML = &quot;国哥，我爱你&quot;; // &lt;div&gt;国哥，我爱你&lt;/div&gt;,但，还只是在内存中 // 添加子元素 document.body.appendChild(divObj);//让它显示在页面中 &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 核心 更新:更新Dom节点 遍历:得到Dom节点 删除节点：删除一个Dom节点 添加:添加一个新的节点 要操作一个Dom节点，就必须要获取这个Dom节点 获得dom节点 标题一 p1 p2 ​ var h1=document.getElementsByTagName('h1'); ​ var p1=document.getElementById('p1'); ​ var p2=document.getElementsByClassName('p2'); ​ var father=document.getElementById('father'); ​ var childrens =father.children;//获取父节点下的所有子节点 更新节点 var id1=document.getElementById('id1'); id1.innerText='456';//修改文本的值 id1.innerHTML='123';//可以解析html文本标签 id1.style.color='red';//将id1的内容改为红色 id1.style.fontsize='20px'//大小，以像素为单位的 删除Dom节点 删除节点的步骤:先获取父节点，再通过父节点删除自己 第一种方法 标题一 p1 p2 12345678var h1=document.getElementsByTagName(&#x27;h1&#x27;);//这个地方是值特定的名字，唯一，比如body等都可以用这种TagName直接用标签名获取该Dom节点var p1=document.getElementById(&#x27;p1&#x27;);var p2=document.getElementsByClassName(&#x27;p2&#x27;);var father=document.getElementById(&#x27;father&#x27;);var childrens =father.children;//获取父节点下的所有子节点var self =document.getElementById(&#x27;p1&#x27;);//获取要删除的节点var father =p1.parentElement;//获取要删除的节点的父节点father.removeChild(self);//用父节点的方法来删除子节点 第二种方法 //删除是一个动态的过程 father.removeChild(father.children[1]) //这是通过下标的方式来删除节点 注意:删除多个节点的时候，children是在时刻变化的，删除节点的时候一定要注意！ 追加存在的节点到父节点下 Javascript JavaSE JavaEE JavaME var js=document.getElementById('js');//获取子节点 var list=document.getElementById('list');//将js这个节点追加到list这个父节点下 list.appendChild(js); 前面一些代码的显示 insert &lt;p id=&quot;se&quot;&gt;JavaSE&lt;/p&gt; &lt;p id=&quot;ee&quot;&gt;JavaEE&lt;/p&gt; &lt;p id=&quot;me&quot;&gt;JavaME&lt;/p&gt; var ee=document.getElementById('ee'); var js=document.getElementById('js'); var list=document.getElementById('list'); //要包含的节点，insertBefore(newNode,targetNode) list.insertBefore(js,ee);//将js也插入到list下，并且放在ee的前面 操作表单表单是什么 form 也是dom的节点 文本框 text 下拉框select 单选框radio 多选框checkbox 隐藏域hidden 密码框password 表单的目的：提交信息 我们是要获得表单的信息 //这里的action当成了method 用户名 var input_text=document.getElementById('username'); //得到输入框的值 input_text.value //得到之后自然也可以修改 input_text.value='123'; 单选框表单信息 用户名 性别: 男 女 var boy_radio=document.getElementById('boy'); var girl_radio=document.getElementById('girl'); boy_radio.value; girl_radio.value;//这种只能得到值，不能判断有没有被选中 boy_radio.checked; girl_radio.checked;//检测这个单选按钮有没有被选中，选中就返回true girl_radio.checked=true; 提交表单 用户名 密码: 提交 ​ function aaa() { var uname=document.getElemenById('username'); var pwd=document.gerElemenById('password'); console.log(uname.value); console.log(pwd.value); //md5算法 pwd.value=md5(pwd.value); console.log(pwd.value); } Javascript的一点小总结javascript有DOM，BOM和emascript DOM是用来获取网页文档信息，主要使用document对象 BOM则是主要用来获取浏览器窗口信息，主要使用window对象，同时window对象是javascript的全局对象使用的时候可以省略，window对象下面还有什么navigator对象很多 emascript则是规定了Java script的语法结构，node中只保留了javascript的这一块 nodenode与javascript的异同nodeJs和javascript的基础语法大致相同，不同在于他们的顶层对象不同。 相同点：-- 基础语法 1、ECMAScript 2、语法 3、内置对象、方法 不同点：-- 顶层对象 -- javascript ：window -- nodejs ： global javascript中，用var定义的一个参数就属于全局变量，属于window下的； node中比较特殊： 1、一个文件就是一个模块； 2、每个模块都有自己的作用域。 所以node中我们受用var来申明的变量，他并不是全局的，而是属于当前模块下的，外界是不能直接访问的。 node中没有window对象。window是浏览器的规范，并非js语言规范，所以在nodejs当然不能用。 不过nodejs有个类似的全局变量，叫golgal，当然了，它内部的内容和浏览器中的window很不一样就是了。 node中定义一个全局变量 123global.a=1;console.log(a); node基本在vscode终端中进入到js文件的目录，然后输入npm init -y,会自动生成node的配置文件 进程和线程进程:-进程负责为程序的运行提供必备的环境 ​ 进程就相当于工厂中的车间 线程: 线程是计算机中最小的一个计算单位，线程负责执行保存到进程中的程序 ​ 线程就相当于工厂中的工人 单线程:js和浏览器是单线程的，单线程是一次只能执行一个任务 ，执行晚上一个任务才能执行下一个 多线程:多线程是一起执行很多任务 ​ I/O进程相当于厨师炒菜，会很慢，是从磁盘中读取数据，这个是有瓶颈的很难提升其速度 传统服务器:是客户每发送一个请求，就创建一个线程，有几个请求就有几个线程，同时这个任务不结束，这个线程不能去干别的事，I/O又很慢就会有很多线程什么也不干就等着，同时还占了磁盘的内存，这个叫做进程堵塞 node服务器:单线程，只有一个线程，不管多少个请求就只有这一个进程 任务密集型介绍CPU密集型（CPU-bound）CPU密集型也叫计算密集型，指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作大部分的状况是CPU Loading 100%，CPU要读/写I/O(硬盘/内存)，I/O在很短的时间就可以完成，而CPU还有许多运算要处理，CPU Loading很高 计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。 计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。 IO密集型（I/O bound）IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操作，此时CPU Loading并不高。 IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差 IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。 node.js中的response.writehead用法向请求的客户端发送响应头。 该函数在一个请求内最多只能调用一次，如果不调用，则会自动生成一个响应头。 因为实际开发中,我们需要返回对应的中文以及对应的的文本格式 所以我们需要设置对应的响应头,响应头决定了对应的返回数据的格式以及编码格式 接收参数： 第一个是HTTP状态码，如200(请求成功），404（未找到）等。 第二个是告诉浏览器发送的数据类型 第三个就是具体发送的是什么数据 该格式可以识别HTML结构，编码格式是UTF-8 12res.writeHead(200,&#123;‘Content-Type’:‘text/html;charset=UTF8’&#125;); 该格式不可以识别HTML结构 12res.writeHead(200,&#123;‘Content-Type’:‘text/plain;charset=UTF8’&#125;); 该格式识别图片 12res.writeHead(200,&#123;‘Content-Type’:‘image/jpg;charset=UTF8’&#125;); 该格式识别样式 12res.writeHead(200,&#123;‘Content-Type’:‘text/css;charset=UFT8’&#125;); 最后一个告诉浏览器使用什么编码解析 node.js中的response.end的用法语法： response.end([data], [encoding]) 接收参数： data ： end()执行完毕后要输出的字符，如果指定了 data 的值，那就意味着在执行完 response.end() 之后，会接着执行一条 response.write(data , encoding); encoding： 对应data的字符编码 例子： 代码如下: 123456var http = require(&#x27;http&#x27;);http.createServer(function(req, res)&#123; res.writeHead(200, &#123;&#x27;Content-type&#x27; : &#x27;text/html&#x27;&#125;); res.write(&#x27;&lt;h1&gt;Node.js&lt;/h1&gt;&#x27;); res.end(&#x27;&lt;p&gt;Hello World&lt;/p&gt;&#x27;);&#125;).listen(3000); 模块化模块化是指解决一个问题的时候，自顶向下逐层把系统划分为若干模块的过程，对于整个系统来说，模块是可组合，分解，更换的单元 遵守模块化的规则，把一个大文件拆成独立且相互依赖的多个小模块 模块的分类 内置模块：fs，path，http 自定义模块，每个用户创建的.js文件，就是自定义模块 第三方模块:由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载 当使用require()方法加载其他模块的时候，会执行被加载模块中的代码 index.JS文件内容 123const a=require(&quot;./hello.js&quot;)console.log(a); hello.js的内容 1console.log(&quot;123&quot;) nodejs中模块作用域 在自定义模块中定义的变量方法等，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域，即使是导入模块也不能够访问 模块作用域好处 防止全局变量污染这个问题 向外共享模块作用域中的成员 1.moudule对象 在每个.js自定义模块中都有一个module对象，它里面存储了和当前模块有关的信息， module.exports对象 在定义的模块中，可以使用module.exports对象，将模块内的成员分享出来，供外界使用 外界使用require方法导入自定义模块时，得到的就是module.exports所指向的对象 如何共享 1234567891011121314hello.php//在一个自定义模块中默认情况下，module.exports=&#123;&#125;是一个空对象//向module.exports对象上挂载username属性module.exports.uername=&quot;张三&quot;module.exports.sayHello=function()&#123; console.log(&quot;helllp&quot;);&#125; 12345678index.js//在外界使用require方法，导入一个自定义模块的时候，得到的成员//就是那个模块中，通过module.exports指向那个对象const m=require(&quot;./hello.js&quot;)console.log(m) 共享成员时候的注意点 使用require()方法导入模块时，导入的结果，永远以module.exports指向的对象为准 module.exports.age=1这种是在原本指向的对象添加一个元素，module.exports={}这种是新建了一个对象覆盖原本的 改一下hello.js 123456789101112131415161718192021//在一个自定义模块中默认情况下，module.exports=&#123;&#125;是一个空对象//向module.exports对象上挂载username属性module.exports.uername=&quot;张三&quot;module.exports.sayHello=function()&#123; console.log(&quot;helllp&quot;);&#125;//让module.exports指向一个全新的对象module.exports=&#123; nickname:&quot;小黑&quot;, sayHi()&#123;​ console.log(&quot;Hi!&quot;) &#125;&#125; 结果为 { nickname: '小黑', sayHi: [Function: sayHi] } exports对象 由于module.exports单词写起来比较复杂，为了简化向外共享成员的代码，node提供了exports对象，默认情况下，exports和module.exports指向同一个对象，最终共享的结果，还是以module.exports指向的对象为准 exports和module.exports的使用误区 时刻切记，require()模块时，得到的永远是module.exports指向的对象 nodejs1中的模块化规范 nodejs尊选了commonjs模块化规范，commonjs规范了模块的特性和各模块之间如何相互依赖 1.每个模块内部，module变量代表当前模块 2.module变量是一个对象，它的exports属性是对外接口 3。加载某个模块，其实是加载该模块的module.exports属性。require()方法用于加载模块 nodejs的第三方模块就叫做包 npm的使用 npm install 模块名 下载本地模块 npm uninstall 模块名 删除本地模块 格式化时间的传统方法 12345678910111213141516171819202122232425262728293031323334353637383940414243hello.js//定义格式化时间的方法function dateFormat(dtStr)&#123; const dt=new Date(drStr) const y=dt.getFullYear(); const m=padZero(dt.getMonth()+1) const d=padZero(dt.getDate()); const hh=padZero(dt.getHours()) const mm=padZero(dt.getMinutes()); const ss=padZero(dt.getSeconds()); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`&#125;//定义一个补零的函数function padZero(n)&#123; return n&gt;9?n:&#x27;0&#x27;+n&#125;module.exports=&#123; dateFormat&#125; index.js 123456789101112131415const TIME=require(&quot;./hello.js&quot;)//调用方法，进行实践的格式化const dt=new Date()//console.log(dt)const newDT=TIME.dateFormat(dt)console.log(newDT)### npm使用与包 格式化时间的高级做法 123456789//1.导入安装的包//注意，导入的名称就是安装包的时候的名称const moment=require(&#x27;moment&#x27;)const dt=moment().format(&quot;YYYY-MM-DD HH:mm:ss&quot;);console.log(dt) 参照官方文件去使用第三方的包 安装指定版本的包 默认情况下，使用npm install命令安装包的时候，会自动安装最新版本的包，如果需要安装指定版本的包，可以在包名之后，通过@符号指定具体的版本，例如: npm i &#x6d;&#x6f;&#109;&#101;&#x6e;&#x74;&#x40;&#x32;&#46;&#50;&#x32;&#46;&#x32; package.json文件 可以用来记录你都用到了哪些包，npm包管理工具提供了一个快捷命令，可以在执行命令时所处的目录中，快速创建packge.json这个包管理配置文件 npm init -y package.json文件的dependencies节点 123456789 &quot;dependencies&quot;: &#123; &quot;express&quot;: &quot;^4.18.1&quot;, &quot;moment&quot;: &quot;^2.22.2&quot; &#125;&#125; 刚建立package.json文件的时候是没有这个节点的，当安装包之后，这个节点就专门用来记录您使用npm install安装了哪些包 一次性安装所有的包 npm install 命令会一次性读取所有依赖包，根据package.json文件 卸载包 npm uninstall 包名 devDependencies节点 如果某些包只在项目开发阶段会用到，在项目上线之后不会用到，则建议把这些包记录到devDependencies节点中 与之对应的，如果某些包开发和项目上线之后都需要用到，则建议把这些包记录到dependencies节点中 npm i 包名 -D 这个命令是把包安装到devDependencies节点中 nrm 为了更方便的切换下包的镜像源，我们可以安装nrm这个小工具，利用nrm提供的终端命令，可以快速查看和切换下包的镜像源 //通过npm包管理器，将nrm安装为全局可用的工具 npm i nrm -g //查看所有可用的镜像源 nrm ls //将下包的镜像源切换为taobao镜像 nrm use taobao 包的分类 项目包 被安装到项目的node_modules目录中的包，就是项目包 项目包又分为两类：开发依赖包(devDependencies)和核心依赖包(dependencies) 全局包 再执行npm install命令的时候，如果提供了-g参数，则会把包安装为全局包 npm install 包名 -g npm uninstall 包名 -g 1.只有工具性质的包才有全局安装的必要性，因为他们提供了好用的终端命令 2.判断某个包是否需要全局安装后才能使用，可以参考官方提供的说明即可 i5ting_toc的使用 npm install -g i5ting_toc先安装 作用是将md文件转换为html文件 使用命令：i5ting_toc -f 文件路径 -o -o的意思是命令执行结束之后直接在浏览器中打开这个html文件 规范的包结构 1.包必须以单独的目录存在 2.包的顶级目录下必须要包含package.json这个包管理配置文件 3.package.json中必须包含name，version，main这三个属性，分别包含包的名字，版本号，包的入口 nodejs的http模块用来创建web服务器的模块，通过http模块提供的http.createServer()方法，就能方便的把一台普通的电脑，变成一台web服务器，对外提供web资源 进一步理解http模块的作用 服务器和普通电脑的区别，服务器上安装了web服务器软件例如IIS，Apache，通过安装这些服务器软件，就能把一台普通的电脑变成一台web服务器 在node.js中，我们不需要使用IIS，Apache等这些第三方服务器软件，因为我们可以基于node.js提供的http模块，通过几行简单的代码就可以轻松地手写一个服务器软件，从而对外提供web服务 服务器相关的概念 IP地址就是互联网上每台计算机的唯一地址，只有在知道对方ip地址的前提下，才能与对应的电脑之间进行数据通信 注意: 1.互联网中每台web服务器都有自己的ip地址，在windows终端中与您修改ping www.baidu.com 命令，即可查看到百度服务器的ip地址 2.在开发期间，自己的电脑即是一台服务器，也是一个客户端，为了方便测试，可以在自己的浏览器中输入127.0.0.1这个IP地址，就能把自己的电脑当作一台服务器进行访问了 域名和域名服务器 ip地址和域名是一一对应的关系，这份对应关系存放在一种叫做域名服务器（DNS）的电脑中，使用者只需通过好记的域名访问对应的服务器即可，对应的转换工作由域名服务器实现，因此，域名服务器提供IP地址和域名之间的转换服务的服务器 注意：单纯使用ip地址，互联网中的电脑能够正常工作，但是有了域名的加持，能让互联网的世界变得更加方便 2.在开发测试期间，127.0.0.1对应的域名是localhost，他们都代表我们自己的这台电脑，在使用效果上没有任何区别 端口号 像是现实生活中的门牌号，通过门牌号可以把外卖准确的送到你手中 在一台电脑中，可以运行成百上千个web服务，每个web服务都对应一个唯一的端口号，客户端发送过来的网络请求，通过端口号，可以被准确地交给对应的web服务器进行处理 注意：每个端口号不能被多个web服务进行处理，只有80端口在被访问的时候是可以被省略的 创建一个服务器 菜鸟教程 12345678910111213const http=require(&quot;http&quot;);const &#123; listenerCount &#125; = require(&quot;process&quot;);http.createServer(function(request,response)&#123; response.writeHead(200,&#123;&#x27;Content-type&#x27;:&#x27;text/plain&#x27;&#125;); response.end(&quot;hello world\\n&quot;);&#125;).listen(8888);console.log(&quot;Server running at http://127.0.0.1:8888/&quot;); 黑马视频 1234567891011121314151617181920212223//导入http模块const http =require(&quot;http&quot;)//创建web服务器实例const server=http.createServer();//为服务器实例绑定request事件，监听客户端的请求server.on(&quot;request&quot;,function(req,res)&#123; console.log(&quot;someone visit the webserver&quot;)&#125;)//启动服务器server.listen(8080,function()&#123; console.log(&quot;server running at http://127.0.0.1:8080&quot;)&#125;) req请求对象只要服务器收到了客户端的请求，就会调用通过server.on()为服务器绑定地request事件处理函数 如果想在事件处理函数中，访问与客户端有关的数据和属性，可以使用如下的方式 req请求对象的使用 123456789101112131415161718192021222324252627const http =require(&quot;http&quot;)const server=http.createServer();//req是请求对象，包含了与客户端相关的数据和属性server.on(&quot;request&quot;,(req)=&gt;&#123; //req.url是客户端请求的url地址 const url=req.url const method=req.method const str=`your request url is $&#123;url&#125; and request method is $&#123;method&#125;` console.log(str)&#125;)server.listen(12,function()&#123; console.log(&quot;server running at http://127.0.0.1:12&quot;)&#125;) res响应对象：在服务器地request事件处理中，如果想访问与服务器相关的数据或属性，可以使用如下的方式： 当调用res.end()方法中，向客户端发送中文内容的时候，会出现乱码问题，此时，需要手动设置内容的编码格式 1234567891011121314151617181920212223242526272829303132const http =require(&quot;http&quot;)const server=http.createServer();//req是请求对象，包含了与客户端相关的数据和属性server.on(&quot;request&quot;,(req,res)=&gt;&#123; //req.url是客户端请求的url地址 const url=req.url const method=req.method const str=`your我我 request url is $&#123;url&#125; and request method is $&#123;method&#125;` console.log(str) //使用res.setHeader()方式，设置Content-Type响应头，解决中文乱码的问题 res.setHeader(&quot;Content-Type&quot;,&quot;text/html; charset=utf-8&quot;) //调用res.end()方法，向客户端响应一些内容,并结束这次请求的处理过长城 res.end(str)&#125;)server.listen(12,function()&#123; console.log(&quot;server 我running at http://127.0.0.1:12&quot;)&#125;) 根据不同的url响应不同的html内容 异步编程在很多时候，我们在进程中使用单一线程从头到尾地执行程序，这种简单模式会导致性能和用户体验另人难以接受。 比如程序向另外一台服务器发出请求，由于网络等外部原因，此种通信任务往往会耗费大量时间，进程如果在此期间仅仅只能等待网络或网络上其他机器的响应，将严重地降低了性能。程序不应该浪费等待的时间，而应该更加高效地利用，在等待的时间执行其他任务，回复到达后在继续执行第一个任务。 如果程序调用某个方法，等待其执行全部处理后才能继续执行，我们称其为同步的。相反，在处理完成之前就返回调用方法则是异步的。 我们在编程语言的流程中添加了异步控制的部分，这部分的编程可以称之为异步编程。 JS单线程多个任务并发执行。JS执行异步任务时，不需要等待响应返回。可以继续执行其他任务，在响应返回时，会得到通知，执行回调或事件处理程序。JS并发执行的基础是：JS拥有一个基于事件循环的并发模型。 回调函数回调函数一般作为函数的最后一个参数出现： node.js中回调函数格式是约定俗成的，它有两个参数，第一个参数为err，第二个参数为data，顾名思义，err是错误信息，data则是返回的数据，示例如下: 非阻塞代码示例 12345678910111213var fs=require(&quot;fs&quot;);fs.readFile(&#x27;input.txt&#x27;,function(err,data)&#123; if(err) return console.error(err); console.log(data.toString());&#125;);console.log(&quot;程序执行结束&quot;); 阻塞代码实例 1234567var fs=require(&quot;fs&quot;);var data=fs.readFileSync(&quot;input.txt&quot;);console.log(data.toString());console.log(&quot;程序执行结束&quot;); 以上两个实例我们了解了阻塞与非阻塞调用的不同。第二个实例在文件读取完后才执行程序。 第一个实例我们不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。 因此，阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内。 nodejs的事件循环12345678910111213141516171819202122232425var events=require(&quot;events&quot;);var eventEmitter=new events.EventEmitter();var connectHandler=function connected()&#123; console.log(&quot;连接成功&quot;); eventEmitter.emit(&quot;data_received&quot;);&#125;eventEmitter.on(&quot;connection&quot;,connectHandler);eventEmitter.on(&quot;data_received&quot;,function()&#123; console.log(&quot;数据接收成功&quot;);&#125;);eventEmitter.emit(&quot;connection&quot;); Node.js.EventEmitter类EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。 当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。 让我们以下面的例子解释这个过程： 12345678910//event.js 文件var events = require(&#x27;events&#x27;); var emitter = new events.EventEmitter(); emitter.on(&#x27;someEvent&#x27;, function(arg1, arg2) &#123; console.log(&#x27;listener1&#x27;, arg1, arg2); &#125;); emitter.on(&#x27;someEvent&#x27;, function(arg1, arg2) &#123; console.log(&#x27;listener2&#x27;, arg1, arg2); &#125;); emitter.emit(&#x27;someEvent&#x27;, &#x27;arg1 参数&#x27;, &#x27;arg2 参数&#x27;); Node.js Buffer(缓冲区)Node.js.Stream从流中读取数据1234567891011121314151617181920212223var fs = require(&quot;fs&quot;);var data = &#x27;&#x27;;// 创建可读流var readerStream = fs.createReadStream(&#x27;input.txt&#x27;);// 设置编码为 utf8。readerStream.setEncoding(&#x27;UTF8&#x27;);// 处理流事件 --&gt; data, end, and errorreaderStream.on(&#x27;data&#x27;, function(chunk) &#123; data += chunk;&#125;);readerStream.on(&#x27;end&#x27;,function()&#123; console.log(data);&#125;);readerStream.on(&#x27;error&#x27;, function(err)&#123; console.log(err.stack);&#125;);console.log(&quot;程序执行完毕&quot;); 写入数据12345678910111213141516171819202122var fs = require(&quot;fs&quot;);var data = &#x27;菜鸟教程官网地址：www.runoob.com&#x27;;// 创建一个可以写入的流，写入到文件 output.txt 中var writerStream = fs.createWriteStream(&#x27;output.txt&#x27;);// 使用 utf8 编码写入数据writerStream.write(data,&#x27;UTF8&#x27;);// 标记文件末尾writerStream.end();// 处理流事件 --&gt; finish、errorwriterStream.on(&#x27;finish&#x27;, function() &#123; console.log(&quot;写入完成。&quot;);&#125;);writerStream.on(&#x27;error&#x27;, function(err)&#123; console.log(err.stack);&#125;);console.log(&quot;程序执行完毕&quot;); 管道流将一个文件的内容读取到另一个文件当中 12345678910111213var fs = require(&quot;fs&quot;);// 创建一个可读流var readerStream = fs.createReadStream(&#x27;input.txt&#x27;);// 创建一个可写流var writerStream = fs.createWriteStream(&#x27;output.txt&#x27;);// 管道读写操作// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中readerStream.pipe(writerStream);console.log(&quot;程序执行完毕&quot;); nodejs fs文件系统模块fs模块是用来操作文件的模块 var fs=require(\"fs\") 这个模块里的方法使用时多用回调函数 123456789101112131415var fs = require(&quot;fs&quot;);// 异步读取fs.readFile(&#x27;input.txt&#x27;,&#x27;utf8&#x27;,function (err, data) &#123; if (err) &#123; return console.error(err); &#125; console.log(&quot;异步读取: &quot; + data.toString());&#125;);// 同步读取var data = fs.readFileSync(&#x27;input.txt&#x27;);console.log(&quot;同步读取: &quot; + data.toString());console.log(&quot;程序执行完毕。&quot;); 1.fs.readFile()函数读取指定文件中的内容 参数1：必选参数，表示文件的路径 参数3：必选参数，文件读取完成后，通过回调函数拿到读取结果 参数2：表世用什么编码格式来读取文件 12345678910var fs=require(&quot;fs&quot;)fs.readFile(&#x27;input1.txt&#x27;,&#x27;utf8&#x27;,function (err, data) &#123; //如果读取成功，则err的值为null //如果读取失败，则err的值为错误对象，data的值为undefined if (err) &#123; console.log(&quot;文件读取失败&quot;); return console.error(err); &#125; console.log(&quot;异步读取: &quot; + data.toString());&#125;); 2.fs.writeFile()函数向指定文件中写入内容 1.可以创建不存在的文件，但不能创建不存在的路径 2.重复调用fs.writeFile()写入同一个文件，新写入的内容会覆盖之前的内容 参数1：必选参数，需要制定一个文件路径的字符串，表示文件的存放路径 参数2：必选参数，表示要写入的内容 参数3：可选参数，表示以什么格式写入文件内容，默认是utf8 123456789101112const fs=require(&quot;fs&quot;)fs.writeFile(&quot;input1.txt&quot;,&quot;hello node js&quot;,function(err)&#123;console.log(err)//如果写入文件成功，则err的值为null//如果文件写入失败，则err的值为一个错误对象if(err)&#123;return console.log(&quot;写入文件失败&quot;+err.message);&#125;console.log(&quot;写入文件成功&quot;)&#125;) 3.联系，使用fs文件系统模块整体考试数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const fs =require(&quot;fs&quot;)fs.readFile(&quot;input.txt&quot;,&#x27;utf-8&#x27;,function(err,datastr)&#123;if(err)&#123;return console.log(&quot;读取文件失败&quot;+message);&#125;//先把成绩的数据，按照空格进行分割,形成一个数组const arrOld=datastr.split(&#x27; &#x27;)console.log(arrOld)//循环分割后的数组，进行字符串替换操作const arrNew=[]arrOld.forEach(item=&gt;&#123;arrNew.push(item.replace(&quot;=&quot;,&quot;: &quot;))&#125;)console.log(arrNew) //这是另一种foreach循环的写法 //arrOld.forEach(function(item)&#123;//arrNew.push(item.replace(&quot;=&quot;,&quot;: &quot;))&#125;)//吧数组中的每一项进行合并，得到一个新的字符串const newStr=arrNew.join(&quot;\\r\\n&quot;)console.log(newStr)fs.writeFile(&quot;input1.txt&quot;,newStr,function(err)&#123;if(err)&#123; return console.log(&quot;写入文件失败&quot;+err.message)&#125;console.log(&quot;成绩写入成功&quot;)&#125;)&#125; ) 4.fs模块 路径动态拼接的问题 当以./或者../开头的时候（相对路径）代码在运行的时候，会以执行node命令时所处的目录，动态拼接出被操作的文件的完整路径 用完整路径就可以解决这个问题（但这种解决方法移植性非常差，不利于维护） 12345const fs =require(&quot;fs&quot;)//__dirname 表示当前文件所处的目录console.log(__dirname) 用__dirname改写文件的路径 nodejs path路径模块path模块是由node.js官方提供的，用来处理路径的模块，它提供了一系列的方法和属性，用来满足用户对路径的处理需求 1.path.join的使用方式 123456const path=require(&quot;path&quot;)const pathStr=path.join(&quot;/a&quot;,&quot;/b/c&quot;,&quot;../&quot;,&quot;./d&quot;,&quot;e&quot;)../会抵消前面的路静console.log(pathStr)输出:\\a\\b\\d\\e 2.path.basename()的使用方式 第一个是必选参数，表示文件的路径的一个字符串 第二个是可选参数，表示文件的扩展名 1234567const path=require(&quot;path&quot;)const fpath=&quot;/a/b/c/index.html&quot;const fullName=path.basename(fpath)console.log(fullName) 不想要后缀名，只想要文件名 1234567891011const path=require(&quot;path&quot;)const fpath=&quot;/a/b/c/index.html&quot;const fullName=path.basename(fpath)const Name=path.basename(fpath,&quot;.html&quot;)console.log(fullName)console.log(Name) 3.path.extname() 第一个参数是存放文件的路径 1234567const path=require(&quot;path&quot;)const fpath=&quot;/a/b/c/index.html&quot;const fext=path.extname(fpath)console.log(fext) EXPRESS什么是express express是基于nodejs平台，快速开放极简的web开发框架，express的作用给和nodejs内置的http模块类似，是专门用来创建web服务器的 express能做什么 两种常见服务器分为：web网站服务器：专门对外提供web网站资源的服务器 API接口服务器：专门对外提供API接口的服务器 使用express，我们可以方便快捷的创建web网站的服务器和API接口的服务器 基本使用 监听getpost请求处理参数 12345678910111213141516171819202122232425262728293031//1.导入expressconst express=require(&quot;express&quot;)//2.创建web服务器const app=express()//4.监听客户端的getpost请求，并向客户端相应具体内容app.get(&#x27;/user&#x27;,(req,res)=&gt;&#123; //调用express提供的res.send()方法，向客户端响应一个JSON对象 res.send(&#123;name:&#x27;zs&#x27;,age:20,gender:&quot;男&quot;&#125;)&#125;)app.post(&#x27;/user&#x27;,(req,res)=&gt;&#123; //调用express提供的res.send()方法，向客户端相应一个文本字符串 res.send(&#x27;请求成功&#x27;)&#125;)app.listen(8080,()=&gt;&#123; console.log(&quot;service running at http://127.0.0.1:8080&quot;)&#125;) 获取url中携带的查询参数 通过req.query对象，可以访问到客户端通过查询字符串的形式，发送到服务器的数据 1234567891011121314151617181920212223242526272829303132333435363738394041//1.导入expressconst express=require(&quot;express&quot;)//2.创建web服务器const app=express()//4.监听客户端的getpost请求，并向客户端相应具体内容app.get(&#x27;/user&#x27;,(req,res)=&gt;&#123; //调用express提供的res.send()方法，向客户端响应一个JSON对象 res.send(&#123;name:&#x27;zs&#x27;,age:20,gender:&quot;男&quot;&#125;)&#125;)app.post(&#x27;/user&#x27;,(req,res)=&gt;&#123; //调用express提供的res.send()方法，向客户端相应一个文本字符串 res.send(&#x27;请求成功&#x27;)&#125;)app.get(&#x27;/&#x27;,(res,req)=&gt;&#123; //通过req.query可以获取客户端发送过来的查询参数 //注意，默认情况下req.query是一个空对象 console.log(req.query)&#125;)app.listen(8080,()=&gt;&#123; console.log(&quot;service running at http://127.0.0.1:8080&quot;)&#125;) express.static() express提供了一个非常好用的函数，叫做express.static通过它，我们可以非常方便的创建一个静态资源服务器，可以规定访问一个目录下的所有文件 12345678910111213const express=require(&#x27;express&#x27;)const app=express();//在这里调用express.static()方法，快速的对外提供静态资源app.use(express.static(&#x27;./1&#x27;))app.listen(8080,()=&gt;&#123; console.log(&quot;serving running at http://127.0.0.1:8080&quot;)&#125;) 托管多个静态资源的目录 多次调用express.static()函数 app.use(express.static('./1')) app.use(express.static('./2')) 访问静态资源文件的时候，express.static()函数会根据目录的添加顺序查找所需的文件 挂载路径前缀 如果希望在托管的静态资源访问路径之前，挂载路径前缀，则可以使用如下的方式 app.use('/1',express.static('./1')) 现在就可以通过带有/1前缀地址来访问1目录中的文件了 nodemon 在编写调试nodejs项目中，如果修改了项目的代码，则需要频繁的手动close掉，然后再重新启动，非常繁琐 现在，当代码被修改后，nodemon会自动帮我们重启项目，极大方便了开发和调试 安装nodemon npm install -g nodemon 使用nodemon nodemon+文件名 然后每次修改文件之后则会自动运行 Express 路由1.什么是路由 广义上来说，路由就是映射关系 在express中，路由就是客户端的请求与服务器处理函数之间的映射关系 express中的路由分3部分组成，分别是请求的类型，请求的url地址，以及对应的处理函数。格式 app.METHOD(PATH,HANDLER) 一个根据url不同返回不同的页面 1234567891011121314151617app.post(&#x27;/user&#x27;,(req,res)=&gt;&#123; //调用express提供的res.send()方法，向客户端相应一个文本字符串 res.send(&#x27;请求成功&#x27;)&#125;)app.get(&#x27;/&#x27;,(res,req)=&gt;&#123; //通过req.query可以获取客户端发送过来的查询参数 //注意，默认情况下req.query是一个空对象 console.log(req.query)&#125;) 2.路由的匹配过程 每当一个请求达到服务器之后，需要先经过路由的匹配，只有匹配成功之后，才会调用对应的处理函数，在匹配时，会按照路由的顺序进行匹配，如果请求类型和请求的url同时匹配成功，则express会将这次请求，转交给对应的functon函数进行处理 3.最简单的用法 123456789101112131415161718//挂载路由app.post(&#x27;/user&#x27;,(req,res)=&gt;&#123; //调用express提供的res.send()方法，向客户端相应一个文本字符串 res.send(&#x27;请求成功&#x27;)&#125;)app.get(&#x27;/&#x27;,(res,req)=&gt;&#123; //通过req.query可以获取客户端发送过来的查询参数 //注意，默认情况下req.query是一个空对象 console.log(req.query)&#125;) 模块化路由 方便对路由进行模块化的管理，express不建议将路由直接挂载到app上，而是推荐将路由抽离为单独的模块 将路由抽离为单独模块步骤如下： 1.创建路由模块对应的.js文件 2.调用express.Router()函数创建路由对象 3.向路由对象上挂载具体的路由 4.使用module.exports向外共享路由对象 5.使用app.use()函数注册路由模块 1234567891011121314151617const express= require(&#x27;express&#x27;)const app=express()//导入路由模块const router=require(&#x27;./hello.js&#x27;)//注册路由模块app.use(router)app.listen(8080,()=&gt;&#123; console.log(&quot;http://127.0.0.1:8080&quot;)&#125;) //注意：app.use()函数的作用，就是来注册全局中间件 为路由模块添加前缀 类似于托管静态资源时，为静态资源统一挂载访问前缀一样，路由模块添加前缀的方式也非常简单： 12345const userRouter=require(&#x27;./router/user.js&#x27;)//使用app.use()注册路由模块，并添加统一的访问前缀 /apiapp.use(&#x27;/api&#x27;,userRouter) express中间件 中间件（Middleware）,特指业务流程中的中间处理环节 express中间件的调用流程 当一个请求到达express服务之后，可以连续调用多个中间件，从而对这次请求进行预处理 express中间件的格式 express的中间件，本质上就是一个function处理函数，express中间件的格式如下 如果函数中包含next形参，则这个函数是一个中间件函数，这个next形参也是一个函数，可以被调用 next函数的作用 next函数是实现多个中间件连续调用的关键，他表示把流转关系转交给下一个中间件或路由 定义中间件函数 123456789101112131415161718192021const express=require(&quot;express&quot;)const app=express()//定义一个最简单的中间件const mw=function(req,res,next)&#123; console.log(&quot;这是最简单的中间件函数&quot;) //吧流转关系，转交给下一个中间件或路由&#125;app.listen(8080,()=&gt;&#123; console.log(&quot;service running at http://127.0.0.1&quot;)&#125;) 全局生效的中间件 客户端发起的任何请求，到达服务器之后，都会触发的中间件，叫做全局生效的中间件 通过调用app.use(中间件函数)，即可定义一个全局生效的中间件，示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637const express=require(&quot;express&quot;)const app=express()//定义一个最简单的中间件const mw=function(req,res,next)&#123; console.log(&quot;这是最简单的中间件函数&quot;) //吧流转关系，转交给下一个中间件或路由&#125;//将mw注册为全局生效的中间件,无论访问什么url都先要经过这个中间件，输出这句话app.use(mw)app.get(&#x27;/&#x27;,(req,res)=&gt;&#123; res.send(&quot;home page&quot;)&#125;)app.get(&#x27;/user&#x27;,(req,res)=&gt;&#123; res.send(&quot;user page&quot;)&#125;)app.listen(8080,()=&gt;&#123; console.log(&quot;service running at http://127.0.0.1&quot;)&#125;) 定义全局中间件的简化形式 1234567//app.use((req,res,next)=&gt;&#123;//console.log(&quot;这是最简单的中间件函数&quot;)//next()//&#125;) 中间件的作用 多个中间件之间，是可以共享一份req和res，基于这样的特性，我们可以在上游的中间件中，统一为req或res对象添加自定义个属性或方法，供下游的中间件或路由进行使用 路由和多个中间件之间都是共享同一份res和req的 123456789101112131415161718192021222324252627282930313233343536373839404142//在中间件中定义的req.startTime可以在下游路由或者后面的中间件中被访问const express=require(&quot;express&quot;)const app=express()//定义一个最简单的中间件const mw=function(req,res,next)&#123; //获取请求到达服务器的时间 const time=Date.now()//为req对象挂载自定义属性，从而把时间共享给后面的所有路由req.startTime=time&#125;//将mw注册为全局生效的中间件,无论访问什么url都先要经过这个中间件，输出这句话app.use(mw)app.get(&#x27;/&#x27;,(req,res)=&gt;&#123; res.send(&quot;home page&quot;+req.startTime)&#125;)app.get(&#x27;/user&#x27;,(req,res)=&gt;&#123; res.send(&quot;user page&quot;+req.startTime)&#125;)app.listen(8080,()=&gt;&#123; console.log(&quot;service running at http://127.0.0.1&quot;)&#125;) 定义多个全局中间件 可以使用app.use()连续定义多个全局中间件，客户端请求到达服务器之后，会按照中间件的定义的先后顺序依次进行调用，实例代码如下 局部生效的中间件 不适用app.use()定义的中间件，就叫做局部生效的中间件，示例代码如下","categories":[],"tags":[]},{"title":"jdbc","slug":"jdbc","date":"2022-09-29T15:31:35.000Z","updated":"2023-04-10T13:20:56.481Z","comments":true,"path":"2022/09/29/jdbc/","link":"","permalink":"http://example.com/2022/09/29/jdbc/","excerpt":"","text":"JDBC核心技术 讲师：宋红康 微博：尚硅谷-宋红康 第1章：JDBC概述1.1 数据的持久化 持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。 持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。 用数据库存储大量数据，方便快捷高效 1.2 Java中的数据存储技术 在Java中，数据库存取技术可分为如下几类： JDBC直接访问数据库 JDO (Java Data Object )技术 第三方O&#x2F;R工具，如Hibernate, Mybatis 等 JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。 1.3 JDBC介绍 JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口（一组API），定义了用来访问数据库的标准Java类库，（java.sql,javax.sql）使用这些类库可以以一种标准的方法、方便地访问数据库资源。 JDBC为访问不同的数据库提供了一种统一的途径，为开发者屏蔽了一些细节问题。 JDBC的目标是使Java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。 如果没有JDBC，那么Java程序访问数据库时是这样的： 有了JDBC，Java程序访问数据库时是这样的： 总结如下： 1.4 JDBC体系结构 JDBC接口（API）包括两个层次： 面向应用的API：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。 面向数据库的API：Java Driver API，供开发商开发数据库驱动程序用。 JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。 不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。 ————面向接口编程 1.5 JDBC程序编写步骤 补充：ODBC(Open Database Connectivity，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。 第2章：获取数据库连接2.1 要素一：Driver接口实现类2.1.1 Driver接口介绍 java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。 在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。 Oracle的驱动：oracle.jdbc.driver.OracleDriver mySql的驱动： com.mysql.jdbc.Driver 导入这些驱动的方法在csdn的收藏里有 2.1.2 加载与注册JDBC驱动 加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名 Class.forName(“com.mysql.jdbc.Driver”); 注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序 使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动 通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码： 2.2 要素二：URL JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。 JDBC URL的标准由三部分组成，各部分间用冒号分隔。 jdbc:子协议:子名称 协议：JDBC URL中的协议总是jdbc 子协议：子协议用于标识一个数据库驱动程序 子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了定位数据库提供足够的信息。包含主机名(对应服务端的ip地址)，端口号，数据库名 举例： 几种常用数据库的 JDBC URL MySQL的连接URL编写方式： jdbc:mysql:&#x2F;&#x2F;主机名称:mysql服务端口号&#x2F;数据库名称?参数&#x3D;值&amp;参数&#x3D;值 jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;atguigu jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;atguigu**?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集） jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;atguigu?user&#x3D;root&amp;password&#x3D;123456 Oracle 9i的连接URL编写方式： jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称 jdbc:oracle:thin:@localhost:1521:atguigu SQLServer的连接URL编写方式： jdbc:sqlserver:&#x2F;&#x2F;主机名称:sqlserver服务端口号:DatabaseName&#x3D;数据库名称 jdbc:sqlserver:&#x2F;&#x2F;localhost:1433:DatabaseName&#x3D;atguigu 2.3 要素三：用户名和密码 user,password可以用“属性名&#x3D;属性值”方式告诉数据库 可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接 2.4 数据库连接方式举例2.4.1 连接方式一12345678910111213141516171819202122@Test public void testConnection1() &#123; try &#123; //1.提供java.sql.Driver接口实现类的对象 Driver driver = null; driver = new com.mysql.jdbc.Driver(); //2.提供url，指明具体操作的数据 String url = &quot;jdbc:mysql://localhost:3306/test&quot;; //3.提供Properties的对象，指明用户名和密码 Properties info = new Properties(); info.setProperty(&quot;user&quot;, &quot;root&quot;); info.setProperty(&quot;password&quot;, &quot;root&quot;); //4.调用driver的connect()，获取连接 Connection conn = driver.connect(url, info); System.out.println(conn); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; 说明：上述代码中显式出现了第三方数据库的API Class.forName的介绍Class 类加载的形式常见类加载的方式 执行一个类自己的main方法这个类也会被加载 1 类名.Class2 new 对象3 Class.forName(“类的全路径”) ps(有个点注意一下)在执行的时候加上以下一句JVM的运行参数，可以观看类加载过程-XX:+TraceClassLoading例，用idea就这样添加来吧，小伙子们，上代码~ 第一种形式，类名.Classclass ClassTest{ static { System.out.println(“执行了静态代码块”); }}public class ClassLoderTest { public static void main(String[] args) throws ClassNotFoundException { Class&lt;?&gt; aClass2 &#x3D; ClassTest.class; }} 运行结果如下 ClassTest 这个类有被加载器加载，但是并没有输出语句，所以并没有被执行。 第二种形式， new 对象new 一个对象，以及利用这个对象调用成员变量方法等，就不在一一赘述。 class ClassTest{ static { System.out.println(“执行了静态代码块”); }}public class ClassLoderTest { public static void main(String[] args) throws ClassNotFoundException { new ClassTest(); }} 运行结果如下 ClassTest 这个 类有被加载，并且静态块语句有被输出，所以，这种方式会执行静态代码块。 第三种形式 ，Class.forName(“类的全路径”)class ClassTest{ static { System.out.println(“执行了静态代码块”); }}public class ClassLoderTest { public static void main(String[] args) throws ClassNotFoundException { Class&lt;?&gt; aClass3 &#x3D; Class.forName(“com.management.JavassistTest.ClassTest”); }} 运行结果如下 ClassTest 这个 类有被加载，并且静态块语句有被输出，所以，这种方式会执行静态代码块。 第三种形式的特殊用法但是第三种的形式有另一种方式使得它不执行。如下： class ClassTest{ static { System.out.println(“执行了静态代码块”); }}public class ClassLoderTest { public static void main(String[] args) throws ClassNotFoundException { Class&lt;?&gt; aClass3 &#x3D; Class.forName(“com.management.JavassistTest.ClassTest”, false,&#x2F;&#x2F;true的时候会执行 ClassLoader.getSystemClassLoader()); }} 2.4.2 连接方式二方式二，对方式一的迭代：在如下的程序中不出现第三方的api，使得程序具有更好的可移植性 123456789101112131415public void testConnection2() throws Exception &#123; //1.获取Driver实现类对象，使用反射 Class clazz = Class.forName(&quot;com.mysql.jdbc.Driver&quot;); Driver driver= (Driver) clazz.newInstance(); //2.提供要链接的数据库 String url=&quot;jdbc:mysql://localhost:3306/test&quot;; //3.提供连接需要的用户名和密码 Properties info=new Properties(); info.setProperty(&quot;user&quot;,&quot;root&quot;); info.setProperty(&quot;password&quot;,&quot;root&quot;); //4.获取连接 Connection connect = driver.connect(url, info); System.out.println(connect);&#125; 说明：相较于方式一，这里使用反射实例化Driver，不在代码中体现第三方数据库的API。体现了面向接口编程思想。 2.4.3 连接方式三12345678910111213141516171819202122@Test public void testConnection3() &#123; try &#123; //1.数据库连接的4个基本要素： String url = &quot;jdbc:mysql://localhost:3306/test&quot;; String user = &quot;root&quot;; String password = &quot;root&quot;; String driverName = &quot;com.mysql.jdbc.Driver&quot;; //2.实例化Driver Class clazz = Class.forName(driverName); Driver driver = (Driver) clazz.newInstance(); //3.注册驱动 DriverManager.registerDriver(driver); //4.获取连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 说明：使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。 2.4.4 连接方式四但这个地方最好不要用这个，mysql好使可能其他的就不好使了 123456789101112131415161718192021222324252627282930313233343536373839@Test public void testConnection4() &#123; try &#123; //1.数据库连接的4个基本要素： String url = &quot;jdbc:mysql://localhost:3306/test&quot;; String user = &quot;root&quot;; String password = &quot;root&quot;; String driverName = &quot;com.mysql.jdbc.Driver&quot;; //下面这一步是把com.mysql.jdbc.Driver类加载到内存中，一加载就执行静态代码块，进行了注册驱动和实例化 //2.加载驱动 （①实例化Driver ②注册驱动） Class.forName(driverName); //Driver driver = (Driver) clazz.newInstance(); //3.注册驱动 //DriverManager.registerDriver(driver); /* 可以注释掉上述代码的原因，是因为在mysql的Driver类中声明有： Driver类中的静态代码块 static &#123; try &#123; DriverManager.registerDriver(new Driver()); &#125; catch (SQLException var1) &#123; throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;); &#125; &#125; */ //3.获取连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 说明：不必显式的注册驱动了。因为在DriverManager的源码中已经存在静态代码块，实现了驱动的注册。 当类加载的时候会执行静态代码块 2.4.5 连接方式五(最终版)将数据库连接需要的四个基本信息声明在配置文件中，通过读取配置文件的格式，获取连接 123456789101112131415161718192021222324252627282930313233343536import java.io.File;import java.io.FileInputStream;import java.io.InputStream;import java.sql.Connection;import java.sql.Driver;import java.sql.DriverManager;import java.sql.SQLException;import java.util.Properties;class Main&#123; public static void main(String[] args) throws Exception &#123; testConnection5(); &#125; public static void testConnection5() throws Exception &#123; //1.加载配置文件 InputStream is=JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); Properties pros = new Properties(); pros.load(is); //2.读取配置信息 String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); String url = pros.getProperty(&quot;url&quot;); String driverClass = pros.getProperty(&quot;driverClass&quot;); //3.加载驱动 Class.forName(driverClass); //4.获取连接 Connection conn = DriverManager.getConnection(url, user, password); return conn; &#125;&#125; 其中，配置文件声明在工程的src目录下：【jdbc.properties】 1234user=rootpassword=abc123url=jdbc:mysql://localhost:3306/testdriverClass=com.mysql.jdbc.Driver 说明：使用配置文件的方式保存配置信息，在代码中加载配置文件 使用配置文件的好处： ①实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码②如果修改了配置信息，省去重新编译的过程也就是避免程序重新打包。 第3章：使用PreparedStatement实现CRUD操作crud就是增删改查 PreparedStatement是Statement的子接口 3.1 操作和访问数据库 数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。 在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式： Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。 CallableStatement：用于执行 SQL 存储过程 3.2 使用Statement操作数据表的弊端 通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。 Statement 接口中定义了下列方法用于执行 SQL 语句： 12int excuteUpdate(String sql)：执行更新操作INSERT、UPDATE、DELETEResultSet executeQuery(String sql)：执行查询操作SELECT 但是使用Statement操作数据表存在弊端： 问题一：存在拼串操作，繁琐 问题二：存在SQL注入问题 SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user&#x3D;’a’ OR 1 &#x3D; ‘ AND password &#x3D; ‘ OR ‘1’ &#x3D; ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。 对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public class StatementTest &#123; // 使用Statement的弊端：需要拼写sql语句，并且存在SQL注入的问题 @Test public void testLogin() &#123; Scanner scan = new Scanner(System.in); System.out.print(&quot;用户名：&quot;); String userName = scan.nextLine(); System.out.print(&quot;密 码：&quot;); String password = scan.nextLine(); // SELECT user,password FROM user_table WHERE USER = &#x27;1&#x27; or &#x27; AND PASSWORD = &#x27;=&#x27;1&#x27; or &#x27;1&#x27; = &#x27;1&#x27;; //上面这个是一个sql注入的语句让AND条件失效，or满足一个即可执行，最后一个恒能执行 String sql = &quot;SELECT user,password FROM user_table WHERE user = &#x27;&quot; + userName + &quot;&#x27; AND password = &#x27;&quot; + password+ &quot;&#x27;&quot;; User user = get(sql, User.class); if (user != null) &#123; System.out.println(&quot;登陆成功!&quot;); &#125; else &#123; System.out.println(&quot;用户名或密码错误！&quot;); &#125; &#125; // 使用Statement实现对数据表的查询操作 public &lt;T&gt; T get(String sql, Class&lt;T&gt; clazz) &#123; T t = null; Connection conn = null; Statement st = null; ResultSet rs = null; try &#123; // 1.加载配置文件 InputStream is = StatementTest.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); Properties pros = new Properties(); pros.load(is); // 2.读取配置信息 String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); String url = pros.getProperty(&quot;url&quot;); String driverClass = pros.getProperty(&quot;driverClass&quot;); // 3.加载驱动 Class.forName(driverClass); // 4.获取连接 conn = DriverManager.getConnection(url, user, password); st = conn.createStatement(); rs = st.executeQuery(sql); // 获取结果集的元数据 ResultSetMetaData rsmd = rs.getMetaData(); // 获取结果集的列数 int columnCount = rsmd.getColumnCount(); if (rs.next()) &#123; t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) &#123; // //1. 获取列的名称 // String columnName = rsmd.getColumnName(i+1); // 1. 获取列的别名 String columnName = rsmd.getColumnLabel(i + 1); // 2. 根据列名获取对应数据表中的数据 Object columnVal = rs.getObject(columnName); // 3. 将数据表中得到的数据，封装进对象 Field field = clazz.getDeclaredField(columnName); field.setAccessible(true); field.set(t, columnVal); &#125; return t; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭资源 if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (st != null) &#123; try &#123; st.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return null; &#125;&#125; User类 12345678910111213141516171819202122232425262728293031323334package com.atguigu2.statement.crud;public class User &#123; private String user; private String password; public User() &#123; &#125; public User(String user, String password) &#123; this.user = user; this.password = password; &#125; public String toString() &#123; return &quot;User [user=&quot; + this.user + &quot;, password=&quot; + this.password + &quot;]&quot;; &#125; public String getUser() &#123; return this.user; &#125; public void setUser(String user) &#123; this.user = user; &#125; public String getPassword() &#123; return this.password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 综上： 3.3 PreparedStatement的使用3.3.1 PreparedStatement介绍 可以通过调用 Connection 对象的 preparedStatement(String sql) 方法获取 PreparedStatement 对象 PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句 PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值 3.3.2 PreparedStatement vs Statement 代码的可读性和可维护性。 PreparedStatement 能最大可能提高性能： DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。 在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样每执行一次都要对传入的语句编译一次。 (语法检查，语义检查，翻译成二进制命令，缓存) PreparedStatement 可以防止 SQL 注入 3.3.3 Java与SQL对应数据类型转换表 Java类型 SQL类型 boolean BIT byte TINYINT short SMALLINT int INTEGER long BIGINT String CHAR,VARCHAR,LONGVARCHAR byte array BINARY , VAR BINARY java.sql.Date DATE java.sql.Time TIME java.sql.Timestamp TIMESTAMP 获取连接和关闭资源很常用所以进行封装 InputStream is&#x3D;JDBCUtils.class.getClassLoader().getResourceAsStream(“jdbc.properties”); 这个方法是用来锁定src目录下的内容 如果jdbc.properties在基础目录下，参数就应该变为 基础&#x2F;jdbc.properties 在idea java中路径都是使用&#x2F; 做斜杠，只有用到io用到整个windows系统的绝对路径时用\\斜杠来表示路径，而此时也不要用相对路径了，直接用绝对路径 在idea中文件中相对路径都用&#x2F; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124package 基础;import org.apache.commons.dbutils.DbUtils;import com.alibaba.druid.pool.DruidDataSource;import java.io.InputStream;import java.sql.*;import java.util.Properties;public class JDBCUtils &#123; /* 封装的是获取连接的操作 */ public static Connection getConnection() throws Exception&#123; //1.加载配置文件 InputStream is=JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); Properties pros = new Properties(); pros.load(is); //2.读取配置信息 String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); String url = pros.getProperty(&quot;url&quot;); String driverClass = pros.getProperty(&quot;driverClass&quot;); //3.加载驱动 Class.forName(driverClass); //4.获取连接 Connection conn = DriverManager.getConnection(url, user, password); return conn; &#125; /* 封装的是关闭资源的操作 */ public static void closeResource(Connection conn, Statement ps)&#123; //这个地方就不仅仅一定是mysql了所以用Statement try &#123; if (ps != null) &#123; ps.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(conn!=null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /* 封装的是查询时关闭资源的操作 */ public static void closeResource(Connection conn, Statement ps,ResultSet rs)&#123; //这个地方就不仅仅一定是mysql了所以用Statement try &#123; if (ps != null) &#123; ps.close(); &#125; &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; try &#123; if(conn!=null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; try &#123; if (rs != null) &#123; rs.close(); &#125; &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; //用DBUtils关闭资源 public static void closeResource1(Connection conn,Statement ps,ResultSet rs)&#123; DbUtils.closeQuietly(conn); DbUtils.closeQuietly(ps); DbUtils.closeQuietly(rs); &#125; private static DruidDataSource dataSource; /*static &#123; try&#123; Properties properties=new Properties(); //奇怪的是这个地方不能用绝对路径 InputStream inputStream=JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); properties.load(inputStream); dataSource= (DruidDataSource) DruidDataSourceFactory.createDataSource(properties); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;*/ //获取数据库连接池中的连接，如果返回null就是获取失败，有值就是获取成功 public static Connection getConnection3()&#123; Connection conn=null; try &#123; conn=dataSource.getConnection(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return conn; &#125;&#125; 3.3.4 使用PreparedStatement实现增、删、改操作更新数据 123456789101112131415161718import java.sql.*;public class ConnectionTest &#123; public void testupdate() throws Exception &#123; //获取数据库连接 Connection conn = JDBCUtils.getConnection(); //预编译sql语句，返回PreparedStarement实例 String sql=&quot;update customers set name= ? where id = ?&quot;; PreparedStatement ps=conn.prepareStatement(sql); //填充占位符 ps.setString(1,&quot;莫扎特&quot;); ps.setInt(2,18); //执行 ps.execute(); //资源的关闭 JDBCUtils.closeResource(conn,ps); &#125;&#125; 增加数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//向customers表中添加一条记录//没用自己封装的方法public void testInsert() &#123; Connection conn=null; PreparedStatement ps=null;try &#123; //一.获取连接 //1.加载配置文件 InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); Properties pros = new Properties(); pros.load(is); //2.读取配置信息 String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); String url = pros.getProperty(&quot;url&quot;); String driverClass = pros.getProperty(&quot;driverClass&quot;); //3.加载驱动 Class.forName(driverClass); //4.获取连接 conn = DriverManager.getConnection(url, user, password); System.out.println(conn); //5.预编译sql语句，返回PreparedStatement的实例 String sql = &quot;insert into customers(name,email,birth)values(?,?,?)&quot;;//?占位符 ps = conn.prepareStatement(sql); //6.填充占位符,第一个参数索引是从1开始的 ps.setString(1, &quot;哪吒&quot;); ps.setString(2, &quot;nezha&quot;); ps.setDate(3, new Date(32235235325L)); //7.执行操作 ps.execute();&#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; //8.关闭资源 try &#123; if (ps != null) &#123; ps.close(); &#125; &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; try &#123; conn.close(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125;&#125;&#125; 1234567891011121314151617181920212223242526272829//增删改通用方法 //用到了自己封装的方法//通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表）//可变形参args的个数应该和sql语句中的占位符数量相等 public void update(String sql,Object ... args)&#123; Connection conn = null; PreparedStatement ps = null; try &#123; //1.获取数据库的连接 conn = JDBCUtils.getConnection(); //2.获取PreparedStatement的实例 (或：预编译sql语句) ps = conn.prepareStatement(sql); //3.填充占位符 for(int i = 0;i &lt; args.length;i++)&#123; ps.setObject(i + 1, args[i]); &#125; //4.执行sql语句 ps.execute(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; //5.关闭资源 JDBCUtils.closeResource(conn, ps); &#125; &#125; 增删改通用方法的测试 123456789public static void main(String[] args) &#123; String sql=&quot;update `order` set order_name = ? where order_id=?&quot;; try &#123; update(sql,&quot;DD&quot;,&quot;2&quot;); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125;&#125; 3.3.5 使用PreparedStatement实现查询操作更复杂，因为查询之后会返回一个结果集 第一种 这个是针对customers表中的一种操作，并不是通用customers表的通用操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void testQuery1() &#123; Connection conn=null; ResultSet resultSet=null; PreparedStatement ps=null; try &#123; conn = JDBCUtils.getConnection(); //预编译sql语句 String sql = &quot;select id,name,email,birth from customers where id=?&quot;; ps = conn.prepareStatement(sql); //写满填充符 ps.setObject(1,1); //执行,并返回结果集 resultSet = ps.executeQuery(); //处理结果集 if (resultSet.next()) &#123;//判断结果集的下一条是否有数据，如果有数据返回true，并指针下移 //获取当前这条数据的各个字段的值 int id = resultSet.getInt(1); String name = resultSet.getString(2); String email = resultSet.getString(3);//获得当前这条的第三个字段 Date birth = resultSet.getDate(4); //方式一 System.out.println(&quot;id=&quot; + id + &quot;,name=&quot; + name + &quot;,email=&quot; + email + &quot;,birth&quot; + birth); //方式二 Object[] data = new Object[]&#123;id, name, email, birth&#125;; System.out.println(Arrays.toString(data)); //方式三 Customer customer = new Customer(id, name, email, birth); System.out.println(customer); &#125; &#125; catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; //关闭资源 JDBCUtils.closeResource(conn, ps, resultSet); &#125;&#125; 这种根据数据库设计的类就是JavaBean类 Customer类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class Customer &#123; /* ORM编程思想 一个数据表对应一个java类 表中的一条记录对应java类的一个对象 表中的一个字段对应java类的一个属性 */ public Customer(int id, String name, String email, Date birth) &#123; this.id = id; this.name = name; this.email = email; this.birth = birth; &#125; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Date getBirth() &#123; return birth; &#125; public void setBirth(Date birth) &#123; this.birth = birth; &#125; private String email; private Date birth; @Override public String toString() &#123; return &quot;Customer&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, email=&#x27;&quot; + email + &#x27;\\&#x27;&#x27; + &quot;, birth=&quot; + birth + &#x27;&#125;&#x27;; &#125;&#125; 第二种 针对customers表的一个通用操作 123456789101112131415161718192021222324252627282930313233343536373839404142public static Customer queryForCustomers(String sql,Object...args) throws Exception &#123; Connection conn=null; PreparedStatement ps=null; ResultSet rs=null; try &#123; conn = JDBCUtils.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; rs = ps.executeQuery(); //获取结果集的元数据 ResultSetMetaData rsmd = rs.getMetaData(); //得到结果集的列数 int columnCount = rsmd.getColumnCount(); if (rs.next()) &#123;//判断结果集是否还有下一行 Customer cust = new Customer(); //处理结果集一行数据中的每一个列 for (int i = 0; i &lt; columnCount; i++) &#123; Object value = rs.getObject(i + 1); //获取每个列的列名 String columnName = rsmd.getColumnName(i + 1); //给cust对象指定的columnName属性，赋值为value，通过反射 //获得的是Customer的columnName代指这个属性 Field field = Customer.class.getDeclaredField(columnName); field.setAccessible(true);//让这个属性可以被访问 field.set(cust, value); &#125; return cust; &#125; &#125;catch(Exception e)&#123;e.printStackTrace();&#125;finally &#123; JDBCUtils.closeResource(conn,ps,rs); &#125; return null; &#125; 这个地方如果字段名和Customer类中的属性名不一致将字段名起别名这样结果集就的字段名就和属性名一致了 用order表做例子 1String sql=&quot;select order_id orderId,order_name orderName,order_date orderDate from `order` where id=?&quot;; 这样就将order_id字段起别名为orderId 同时要将getColumnName()换成getColumnLabel()获取列的别名 getColumnName()不推荐使用 测试： 12345678910public static void main(String[] args) throws Exception &#123; String sql=&quot;select id,name,birth,email from customers where id = ?&quot;; Customer customer=queryForCustomers(sql,13); System.out.println(customer); String sql1=&quot;select name,email from customers where name=?&quot;; Customer customer1=queryForCustomers(sql1,&quot;周杰伦&quot;); System.out.println(customer1);&#125; 第三种 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 // 通用的针对于不同表的查询:返回表中的一条记录//这是一个泛型方法 public &lt;T&gt; T getInstance(Class&lt;T&gt; clazz, String sql, Object... args) &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; // 1.获取数据库连接 conn = JDBCUtils.getConnection(); // 2.预编译sql语句，得到PreparedStatement对象 ps = conn.prepareStatement(sql); // 3.填充占位符 for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; // 4.执行executeQuery(),得到结果集：ResultSet rs = ps.executeQuery(); // 5.得到结果集的元数据：ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); // 6.1通过ResultSetMetaData得到columnCount(列数),columnLabel(列标签)；通过ResultSet得到列值 int columnCount = rsmd.getColumnCount(); if (rs.next()) &#123;//判断结果集的下一条是否有数据，如果有数据返回true，并指针下移 //如果返回false指针不会下移 T t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) &#123;// 遍历每一个列 // 获取列值 Object columnVal = rs.getObject(i + 1); // 获取列的别名:列的别名，使用类的属性名充当 String columnLabel = rsmd.getColumnLabel(i + 1); // 6.2使用反射，给对象的相应属性赋值 Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columnVal); &#125; return t; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 7.关闭资源 JDBCUtils.closeResource(conn, ps, rs); &#125; return null; &#125; 说明：使用PreparedStatement实现的查询操作可以替换Statement实现的查询操作，解决Statement拼串和SQL注入问题。 测试 12345public static void main(String[] args) &#123; String sql=&quot;select id,name,email from customers where id=?&quot;; Customer instance = getInstance(Customer.class, sql, 12); System.out.println(instance);&#125; 第四种情况 当结果集有多行的时候使用集合来存储 这个不是查询好多次，是一次查询出来很多的时候用 1234567891011121314151617181920212223242526272829303132333435363738394041424344public static&lt;T&gt; List&lt;T&gt; getInstance(Class&lt;T&gt; clazz, String sql, Object...args)&#123; Connection conn=null; PreparedStatement ps=null; ResultSet rs=null; try &#123; conn = JDBCUtils.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; rs = ps.executeQuery(); //获取结果集的元数据 ResultSetMetaData rsmd = rs.getMetaData(); //得到结果集的列数 int columnCount = rsmd.getColumnCount(); //创建集合 ArrayList&lt;T&gt; list = new ArrayList&lt;T&gt;(); while (rs.next()) &#123;//判断结果集是否还有下一行 T t = clazz.newInstance(); //处理结果集一行数据中的每一个列 for (int i = 0; i &lt; columnCount; i++) &#123; Object value = rs.getObject(i + 1); //获取每个列的列名 String columnName = rsmd.getColumnName(i + 1); //给t对象指定的columnName属性，赋值为value，通过反射 Field field = clazz.getDeclaredField(columnName); field.setAccessible(true);//让这个属性可以被访问 field.set(t, value); &#125; list.add(t); &#125; return list; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; JDBCUtils.closeResource(conn,ps,rs); &#125; return null;&#125; 测试 1234567public static void main(String[] args) &#123; String sql=&quot;select id,name,email from customers where id&lt;?&quot;; List&lt;Customer&gt; instance = getInstance(Customer.class, sql, 12); for (Customer customer : instance) &#123; System.out.println(customer); &#125;&#125; PreparedStatement防止了sql注入 主要是对sql语句进行了预编译，and关系就是and关系不可能再变成是or关系 其他好处：1.PreparedStatement操作Blob数据，而Statement做不到 ​ 2.PreparedStatement可以实现更高效的批量操作 3.4 ResultSet与ResultSetMetaData3.4.1 ResultSet 查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象 ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现 ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。 ResultSet 对象维护了一个指向当前数据行的游标，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。 当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。 例如: getInt(1), getString(“name”) 注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。 ResultSet 接口的常用方法： boolean next() getString() … 3.4.2 ResultSetMetaData 可用于获取关于 ResultSet 对象中列的类型和属性信息的对象 ResultSetMetaData meta &#x3D; rs.getMetaData(); getColumnName(int column)：获取指定列的名称 getColumnLabel(int column)：获取指定列的别名 getColumnCount()：返回当前 ResultSet 对象中的列数。 getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。 getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。 isNullable(int column)：指示指定列中的值是否可以为 null。 isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。 问题1：得到结果集后, 如何知道该结果集中有哪些列 ？ 列名是什么？ ​ 需要使用一个描述 ResultSet 的对象， 即 ResultSetMetaData 问题2：关于ResultSetMetaData 如何获取 ResultSetMetaData： 调用 ResultSet 的 getMetaData() 方法即可 获取 ResultSet 中有多少列：调用 ResultSetMetaData 的 getColumnCount() 方法 获取 ResultSet 每一列的列的别名是什么：调用 ResultSetMetaData 的getColumnLabel() 方法 3.5 资源的释放 释放ResultSet, Statement,Connection。 数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是尽量晚创建，尽量早的释放。 可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。 3.6 JDBC API小结 两种思想 面向接口编程的思想 ORM思想(object relational mapping) 一个数据表对应一个java类 表中的一条记录对应java类的一个对象 表中的一个字段对应java类的一个属性 sql是需要结合列名和表的属性名来写。注意起别名。 两种技术 JDBC结果集的元数据：ResultSetMetaData 获取列数：getColumnCount() 获取列的别名：getColumnLabel() 通过反射，创建指定类的对象，获取指定的属性并赋值 章节练习练习题1：从控制台向数据库的表customers中插入一条数据，表结构如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class ConnectionTest &#123; public static void main(String[] args) &#123; Scanner scanner =new Scanner(System.in); System.out.println(&quot;请输入用户名&quot;); String name=scanner.next(); System.out.println(&quot;请输入邮箱&quot;); String email=scanner.next(); System.out.println(&quot;请输入生日&quot;); String birthday=scanner.next();//可以用字符串但是格式一定要正确 String sql=&quot;insert into customers(name,email,birth)values(?,?,?)&quot;; int insertCount=update(sql,name,email,birthday); if(insertCount&gt;0)&#123; System.out.println(&quot;添加成功&quot;); &#125; else &#123; System.out.println(&quot;添加失败&quot;); &#125; &#125; public static int update(String sql,Object...args)&#123; Connection conn=null; PreparedStatement ps=null; try&#123; conn=JDBCUtils.getConnection(); ps=conn.prepareStatement(sql); for(int i=0;i&lt;args.length;i++)&#123; ps.setObject(i+1,args[i]); &#125; //如果执行的是查询操作有返回结果，则此方法返回true //如果执行的是增删改操作，没有返回结果，则此方法返回false //方式一 //return ps.execute(); //方式二 return ps.executeUpdate();//返回的是影响的行数,增删改都可以是这个，同时也可以执行sql语句 &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; finally&#123; JDBCUtils.closeResource(conn,ps); &#125; return 0; &#125;//这种id是递增的可以默认不添加也会自增一个，也可以指定id但不能够指定与原表中重复的id， 练习题2：创立数据库表 examstudent，表结构如下： 向数据表中添加如下数据： 代码实现1：插入一个新的student 信息 请输入考生的详细信息 Type:IDCard:ExamCard:StudentName:Location:Grade: 信息录入成功! 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Main&#123; public static int update(String sql,Object ... args)&#123; Connection conn = null; PreparedStatement ps = null; try &#123; //1.获取数据库的连接 conn = JDBCUtils.getConnection(); //2.获取PreparedStatement的实例 (或：预编译sql语句) ps = conn.prepareStatement(sql); //3.填充占位符 for(int i = 0;i &lt; args.length;i++)&#123; ps.setObject(i + 1, args[i]); &#125; return ps.executeUpdate(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; //5.关闭资源 JDBCUtils.closeResource(conn, ps); return 0; &#125; &#125; public static void main(String[] args) throws Exception &#123;//问题一，向examstudent表中添加一条记录 Scanner in=new Scanner(System.in); System.out.print(&quot;四级/六级:&quot;); int type=in.nextInt(); System.out.println(&quot;身份证号&quot;); String IDCard=in.next(); System.out.println(&quot;准考证号&quot;); String examCard=in.next(); System.out.print(&quot;学生姓名：&quot;); String studentName=in.next(); System.out.println(&quot;所在城市&quot;); String location=in.next(); System.out.println(&quot;考试成绩&quot;); int grade=in.nextInt(); String sql=&quot;insert into examstudent(Type,IDCard,ExamCard,StudentName,Location,Grade)values(?,?,?,?,?,?)&quot;; int insertCount=update(sql,type,IDCard,examCard,studentName,location,grade); if(insertCount&gt;0)&#123; System.out.println(&quot;添加成功&quot;); &#125; else &#123; System.out.println(&quot;添加失败&quot;); &#125; &#125;&#125; 代码实现2：在 eclipse中建立 java 程序：输入身份证号或准考证号可以查询到学生的基本信息。结果如下： 代码实现3：完成学生信息的删除功能 第4章 操作BLOB类型字段4.1 MySQL BLOB类型 MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。 插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。 MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的) 实际使用中根据需要存入的数据大小定义不同的BLOB类型。 需要注意的是：如果存储的文件过大，数据库的性能会下降。 如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： max_allowed_packet&#x3D;16M。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。 4.2 向数据表中插入大数据类型12345678910111213141516171819//获取连接Connection conn = JDBCUtils.getConnection(); String sql = &quot;insert into customers(name,email,birth,photo)values(?,?,?,?)&quot;;PreparedStatement ps = conn.prepareStatement(sql);// 填充占位符ps.setString(1, &quot;徐海强&quot;);ps.setString(2, &quot;xhq@126.com&quot;);ps.setDate(3, new Date(new java.util.Date().getTime()));// 操作Blob类型的变量FileInputStream fis = new FileInputStream(&quot;xhq.png&quot;);ps.setBlob(4, fis);//执行ps.execute(); fis.close();JDBCUtils.closeResource(conn, ps); 4.3 修改数据表中的Blob类型字段1234567891011121314Connection conn = JDBCUtils.getConnection();String sql = &quot;update customers set photo = ? where id = ?&quot;;PreparedStatement ps = conn.prepareStatement(sql);// 填充占位符// 操作Blob类型的变量FileInputStream fis = new FileInputStream(&quot;coffee.png&quot;);ps.setBlob(1, fis);ps.setInt(2, 25);ps.execute();fis.close();JDBCUtils.closeResource(conn, ps); 4.4 从数据表中读取大数据类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import com.mysql.jdbc.JDBC4PreparedStatement;import java.io.*;import java.sql.*;import java.util.*;import java.util.Date;public class Main &#123; public static void main(String[] args) throws Exception &#123; testQueryBlob(); &#125; public static void testQueryBlob() &#123; Connection conn=null; PreparedStatement ps=null; FileOutputStream fos = null; InputStream is = null; try &#123; conn = JDBCUtils.getConnection(); String sql = &quot;select id,name,email,birth,photo from customers where id=?&quot;; ps = conn.prepareStatement(sql); ps.setInt(1, 27); ResultSet rs = ps.executeQuery(); if (rs.next()) &#123; /* 方式一 int id=rs.getInt(1); String name=rs.getString(2); String email=rs.getString(3); Date date=rs.getDate(4); */ int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); String email = rs.getString(&quot;email&quot;); Date birth = rs.getDate(&quot;birth&quot;); Customer cust = new Customer(id, name, email, birth); System.out.println(cust); //将Blob类型的字段下载下来，以文件的方式保存在本地 Blob photo = rs.getBlob(&quot;photo&quot;); is = photo.getBinaryStream(); fos = new FileOutputStream(&quot;D:\\\\同步空间\\\\新建文件夹\\\\java\\\\zz.jpg&quot;); byte[] buffer = new byte[1024]; int len; while ((len = is.read(buffer)) != -1) &#123; fos.write(buffer, 0, len); &#125; &#125; &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; finally &#123; try &#123; if(is!=null) &#123; is.close(); &#125; &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; try &#123; if(fos!=null) &#123; fos.close(); &#125; &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; JDBCUtils.closeResource(conn, ps); &#125; &#125;&#125; 第5章 批量插入5.1 批量执行SQL语句当需要成批插入或者更新记录时，可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率 JDBC的批量处理语句包括下面三个方法： addBatch(String)：添加需要批量处理的SQL语句或是参数； executeBatch()：执行批量处理语句； clearBatch():清空缓存的数据 通常我们会遇到两种批量执行SQL语句的情况： 多条SQL语句的批量处理； 一个SQL语句的批量传参； 5.2 高效的批量插入举例：向数据表中插入20000条数据 数据库中提供一个goods表。创建如下： 1234CREATE TABLE goods(id INT PRIMARY KEY AUTO_INCREMENT,NAME VARCHAR(20)); 5.2.1 实现层次一：使用Statement123456Connection conn = JDBCUtils.getConnection();Statement st = conn.createStatement();for(int i = 1;i &lt;= 20000;i++)&#123; String sql = &quot;insert into goods(name) values(&#x27;name_&#x27; + &quot;+ i +&quot;)&quot;; st.executeUpdate(sql);&#125; 5.2.2 实现层次二：使用PreparedStatement123456789101112131415161718192021222324252627282930313233343536373839import com.mysql.jdbc.JDBC4PreparedStatement;import java.io.*;import java.sql.*;import java.util.*;import java.util.Date;public class Main &#123; public static void main(String[] args) throws Exception &#123; testInsearch(); &#125; public static void testInsearch() &#123; Connection conn=null; PreparedStatement ps=null; try&#123; long start = System.currentTimeMillis(); conn = JDBCUtils.getConnection(); String sql=&quot;insert into goods(name)value(?)&quot;;//预编译sql语句，缓存下来之后每次只需要该改变占位符的值， ps=conn.prepareStatement(sql); for(int i=1;i&lt;=20000;i++) &#123; ps.setObject(1,&quot;name_&quot;+i); ps.execute(); &#125; long end = System.currentTimeMillis(); System.out.println(&quot;花费的时间&quot;+(end-start)); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; finally&#123; JDBCUtils.closeResource(conn,ps); &#125; &#125;&#125; 5.2.3 实现层次三12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * 修改1： 使用 addBatch() / executeBatch() / clearBatch() * 修改2：mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。 * ?rewriteBatchedStatements=true 写在配置文件的url后面 * 修改3：使用更新的mysql 驱动：mysql-connector-java-5.1.37-bin.jar * */import com.mysql.jdbc.JDBC4PreparedStatement;import java.io.*;import java.sql.*;import java.util.*;import java.util.Date;public class Main &#123; public static void main(String[] args) throws Exception &#123; testInsearch(); &#125; public static void testInsearch() &#123; Connection conn=null; PreparedStatement ps=null; try&#123; long start = System.currentTimeMillis(); conn = JDBCUtils.getConnection(); String sql=&quot;insert into goods(name)value(?)&quot;;//预编译sql语句，缓存下来之后每次只需要该改变占位符的值， ps=conn.prepareStatement(sql); for(int i=1;i&lt;=20000;i++) &#123; ps.setObject(1,&quot;name_&quot;+i); //1.攒sql ps.addBatch(); if(i%500==0)&#123; //2.执行batch,每五百次执行一次 ps.executeBatch(); //3.清空batch ps.clearBatch(); &#125; &#125; long end = System.currentTimeMillis(); System.out.println(&quot;花费的时间&quot;+(end-start)); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; finally&#123; JDBCUtils.closeResource(conn,ps); &#125; &#125;&#125; 5.2.4 实现层次四1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** 层次四：在层次三的基础上操作* 使用Connection 的 setAutoCommit(false) / commit()*/import com.mysql.jdbc.JDBC4PreparedStatement;import java.io.*;import java.sql.*;import java.util.*;import java.util.Date;public class Main &#123; public static void main(String[] args) throws Exception &#123; testInsearch(); &#125; public static void testInsearch() &#123; Connection conn=null; PreparedStatement ps=null; try&#123; long start = System.currentTimeMillis(); conn = JDBCUtils.getConnection(); //设置不允许自动提交数据 conn.setAutoCommit(false);//就是那些数据不是立马提交的 String sql=&quot;insert into goods(name)value(?)&quot;;//预编译sql语句，缓存下来之后每次只需要该改变占位符的值， ps=conn.prepareStatement(sql); for(int i=1;i&lt;=20000;i++) &#123; ps.setObject(1,&quot;name_&quot;+i); //1.攒sql ps.addBatch(); if(i%500==0)&#123; //2.执行batch,每五百次执行一次 ps.executeBatch(); //3.清空batch ps.clearBatch(); &#125; &#125; //提交数据 conn.commit();//统一提交所有的数据 long end = System.currentTimeMillis(); System.out.println(&quot;花费的时间&quot;+(end-start)); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; finally&#123; JDBCUtils.closeResource(conn,ps); &#125; &#125;&#125; 第6章： 数据库事务6.1 数据库事务介绍 事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。(一个或多个DML操作) 事务处理（事务操作）：保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都**被提交(commit)，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务回滚(rollback)**到最初状态。 为确保数据库中数据的一致性，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。 6.2 JDBC事务处理 数据一旦提交，就不可回滚。 数据什么时候意味着提交？ 当一个连接对象被创建时，默认情况下是自动提交事务：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。 关闭数据库连接，数据就会自动的提交。如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。 JDBC程序中为了让多个 SQL 语句作为一个事务执行： 调用 Connection 对象的 setAutoCommit(false); 以取消自动提交事务 在所有的 SQL 语句都成功执行后，调用 commit(); 方法提交事务 在出现异常时，调用 rollback(); 方法回滚事务 若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。 【案例：用户AA向用户BB转账100】 AA的账户余额减100，BB的账户余额加100 同时要保证这两个操作要么都进行，要么都不进行 错误案例 123456789101112131415161718192021222324252627282930313233343536import java.sql.Connection;import java.sql.PreparedStatement;class Main &#123; public static void main(String []args)&#123; String sql1=&quot;update user_table set balance=balance-100 where user = ?&quot;;update(sql1,&quot;AA&quot;);//模拟网络异常 System.out.println(10/0);//这个地方出现了异常的话只有AA的钱减100，BB不会增加 String sql2=&quot;update user_table set balance=balance+100 where user = ?&quot;; update(sql2,&quot;BB&quot;); System.out.println(&quot;转账成功&quot;); &#125; //update version1.0 public static int update(String sql, Object... args) &#123; Connection conn = null; PreparedStatement ps = null; try &#123; conn = JDBCUtils.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; return ps.executeUpdate();//返回的是影响的行数,增删改都可以是这个，同时也可以执行sql语句 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(conn, ps); &#125; return 0; &#125;&#125; 正确的方法 原理：1.数据一旦提交，就不可回滚 ​ 哪些操作会导致数据的自动提交 1.DDL操作一旦执行，都会自动提交 2.DML默认情况下，一旦执行，就会自动提交，我们可以通过set autocommit&#x3D;false的方式取消DML操作的自动提交 3.默认在关闭连接的时候，会自动提交数据 正确案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;class Main &#123; public static void main(String []args) &#123; Connection conn = null; try &#123; conn = JDBCUtils.getConnection(); System.out.println(conn.getAutoCommit()); //取消数据的自动提交 conn.setAutoCommit(false);//让他不能自动提交 String sql1 = &quot;update user_table set balance=balance-100 where user = ?&quot;; update(conn, sql1, &quot;AA&quot;);//模拟网络异常 System.out.println(10 / 0); String sql2 = &quot;update user_table set balance=balance+100 where user = ?&quot;; update(conn, sql2, &quot;BB&quot;); System.out.println(&quot;转账成功&quot;); //提交数据 conn.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; conn.rollback();//回滚数据，保证了如果有异常两个都不执行成功 &#125; catch (SQLException ex) &#123; ex.printStackTrace(); &#125; &#125; finally &#123; conn.setAutoCommit(true); JDBCUtils.closeResource(conn, null); &#125; &#125; //update version2.0 public static int update(Connection conn,String sql, Object... args) &#123;//conn作为参数是因为要让几次操作都用一个连接 PreparedStatement ps = null; try &#123; ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; return ps.executeUpdate();//返回的是影响的行数,增删改都可以是这个，同时也可以执行sql语句 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(null, ps); &#125; return 0; &#125;&#125; 6.3 事务的ACID属性 原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency）事务必须使数据库从一个一致性状态变换到另外一个一致性状态。 隔离性（Isolation）事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。 6.3.1 数据库的并发问题 对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题: 脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。 不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段。之后, T1再次读取同一个字段, 值就不同了。 幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。 数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。 一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。 6.3.2 四种隔离级别 数据库提供的4种事务隔离级别： Oracle 支持的 2 种事务隔离级别：READ COMMITED, SERIALIZABLE。 Oracle 默认的事务隔离级别为: READ COMMITED 。 Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: REPEATABLE READ。 6.3.3 在MySql中设置隔离级别 每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。 查看当前的隔离级别: 1SELECT @@tx_isolation; 设置当前 mySQL 连接的隔离级别: 1set transaction isolation level read committed; 设置数据库系统的全局的隔离级别: 1set global transaction isolation level read committed; 补充操作： 创建mysql数据库用户： 1create user tom identified by &#x27;abc123&#x27;; 授予权限 123456#授予通过网络方式登录的tom用户，对所有库所有表的全部权限，密码设为abc123.grant all privileges on *.* to tom@&#x27;%&#x27; identified by &#x27;abc123&#x27;; #给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。grant select,insert,delete,update on atguigudb.* to tom@localhost identified by &#x27;abc123&#x27;; 设置隔离级别演示 （有报错） 防止脏读 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import jdk.nashorn.internal.scripts.JD;import src.User;import java.lang.reflect.Field;import java.sql.*;class Main &#123; public static void main(String []args) throws Exception &#123; testTranscationSelect(); &#125; public static void testTranscationSelect() throws Exception &#123; Connection conn= JDBCUtils.getConnection(); //获得当前的隔离级别 System.out.println(conn.getTransactionIsolation()); //设计数据库的隔离级别 conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED); //取消自动提交 conn.setAutoCommit(false); String sql=&quot;select user,password,balance from user_table where user=?&quot;; Main main=new Main(); User user=main.getInstance(conn, User.class,sql,&quot;CC&quot;); System.out.println(user); &#125; public static void testTranscationUpdate() throws Exception &#123; Connection conn= JDBCUtils.getConnection(); //取消自动提交 conn.setAutoCommit(false); String sql=&quot;update user_table set balance=? where user=?&quot;; update(conn,sql,5000,&quot;CC&quot;); &#125; //考虑上事务的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz, String sql, Object... args) &#123; PreparedStatement ps = null; ResultSet rs = null; try &#123; // 2.预编译sql语句，得到PreparedStatement对象 ps = conn.prepareStatement(sql); // 3.填充占位符 for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; // 4.执行executeQuery(),得到结果集：ResultSet rs = ps.executeQuery(); // 5.得到结果集的元数据：ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); // 6.1通过ResultSetMetaData得到columnCount(列数),columnLabel(列标签)；通过ResultSet得到列值 int columnCount = rsmd.getColumnCount(); if (rs.next()) &#123;//判断结果集的下一条是否有数据，如果有数据返回true，并指针下移 //如果返回false指针不会下移 T t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) &#123;// 遍历每一个列 // 获取列值 Object columnVal = rs.getObject(i + 1); // 获取列的别名:列的别名，使用类的属性名充当 String columnLabel = rsmd.getColumnLabel(i + 1); // 6.2使用反射，给对象的相应属性赋值 Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columnVal); &#125; return t; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 7.关闭资源 JDBCUtils.closeResource(null, ps, rs); &#125; return null; &#125; public static int update(Connection conn,String sql, Object... args) &#123;//conn作为参数是因为要让几次操作都用一个连接 PreparedStatement ps = null; try &#123; ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; return ps.executeUpdate();//返回的是影响的行数,增删改都可以是这个，同时也可以执行sql语句 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(null, ps); &#125; return 0; &#125;&#125; 小结这是关于增删改查询的几种方法，是在外面用conn 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132import java.lang.reflect.Field;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.ResultSetMetaData;import java.util.ArrayList;import java.util.List;public class BaseDao &#123;//增删改通用方法 public static int update(Connection conn, String sql, Object... args) &#123;//conn作为参数是因为要让几次操作都用一个连接 PreparedStatement ps = null; try &#123; ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; return ps.executeUpdate();//返回的是影响的行数,增删改都可以是这个，同时也可以执行sql语句 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(null, ps); &#125; return 0; &#125; //查询返回一条数据的方法 //version2.0 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz, String sql, Object... args) &#123; PreparedStatement ps = null; ResultSet rs = null; try &#123; // 2.预编译sql语句，得到PreparedStatement对象 ps = conn.prepareStatement(sql); // 3.填充占位符 for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; // 4.执行executeQuery(),得到结果集：ResultSet rs = ps.executeQuery(); // 5.得到结果集的元数据：ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); // 6.1通过ResultSetMetaData得到columnCount(列数),columnLabel(列标签)；通过ResultSet得到列值 int columnCount = rsmd.getColumnCount(); if (rs.next()) &#123;//判断结果集的下一条是否有数据，如果有数据返回true，并指针下移 //如果返回false指针不会下移 T t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) &#123;// 遍历每一个列 // 获取列值 Object columnVal = rs.getObject(i + 1); // 获取列的别名:列的别名，使用类的属性名充当 String columnLabel = rsmd.getColumnLabel(i + 1); // 6.2使用反射，给对象的相应属性赋值 Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columnVal); &#125; return t; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 7.关闭资源 JDBCUtils.closeResource(null, ps, rs); &#125; return null; &#125; //查询返回多条数据的方法 //version2.0 public &lt;T&gt; List&lt;T&gt; getForList(Connection conn,Class&lt;T&gt; clazz, String sql, Object...args)&#123; PreparedStatement ps=null; ResultSet rs=null; try &#123; conn = JDBCUtils.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; rs = ps.executeQuery(); //获取结果集的元数据 ResultSetMetaData rsmd = rs.getMetaData(); //得到结果集的列数 int columnCount = rsmd.getColumnCount(); //创建集合 ArrayList&lt;T&gt; list = new ArrayList&lt;T&gt;(); while (rs.next()) &#123;//判断结果集是否还有下一行 T t = clazz.newInstance(); //处理结果集一行数据中的每一个列 for (int i = 0; i &lt; columnCount; i++) &#123; Object value = rs.getObject(i + 1); //获取每个列的列名 String columnName = rsmd.getColumnName(i + 1); //给t对象指定的columnName属性，赋值为value，通过反射 Field field = clazz.getDeclaredField(columnName); field.setAccessible(true);//让这个属性可以被访问 field.set(t, value); &#125; list.add(t); &#125; return list; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; JDBCUtils.closeResource(null,ps,rs); &#125; return null; &#125;&#125; DAO类BaseDAO这是一个封装的所有的查询和增删改的方法的类用作抽象类，提供方法 封装了针对数据表的通用操作，具体表具体实现 BaseDao.class 封装起来，用来给具体的数据表处理类来做父类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153import java.lang.reflect.Field;import java.sql.*;import java.util.ArrayList;import java.util.List;public abstract class BaseDao &#123; public static void main(String[] args) throws Exception &#123; &#125; public static int update(Connection conn, String sql, Object... args) &#123;//conn作为参数是因为要让几次操作都用一个连接 PreparedStatement ps = null; try &#123; ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; return ps.executeUpdate();//返回的是影响的行数,增删改都可以是这个，同时也可以执行sql语句 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(null, ps); &#125; return 0; &#125; //version2.0 public &lt;T&gt; T getInstance(Connection conn, Class&lt;T&gt; clazz, String sql, Object... args) &#123; PreparedStatement ps = null; ResultSet rs = null; try &#123; // 2.预编译sql语句，得到PreparedStatement对象 ps = conn.prepareStatement(sql); // 3.填充占位符 for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; // 4.执行executeQuery(),得到结果集：ResultSet rs = ps.executeQuery(); // 5.得到结果集的元数据：ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); // 6.1通过ResultSetMetaData得到columnCount(列数),columnLabel(列标签)；通过ResultSet得到列值 int columnCount = rsmd.getColumnCount(); if (rs.next()) &#123;//判断结果集的下一条是否有数据，如果有数据返回true，并指针下移 //如果返回false指针不会下移 T t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) &#123;// 遍历每一个列 // 获取列值 Object columnVal = rs.getObject(i + 1); // 获取列的别名:列的别名，使用类的属性名充当 String columnLabel = rsmd.getColumnLabel(i + 1); // 6.2使用反射，给对象的相应属性赋值 Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columnVal); &#125; return t; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 7.关闭资源 JDBCUtils.closeResource(null, ps, rs); &#125; return null; &#125; //version2.0 public &lt;T&gt; List&lt;T&gt; getForList(Connection conn, Class&lt;T&gt; clazz, String sql, Object... args) &#123; PreparedStatement ps = null; ResultSet rs = null; try &#123; conn = JDBCUtils.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; rs = ps.executeQuery(); //获取结果集的元数据 ResultSetMetaData rsmd = rs.getMetaData(); //得到结果集的列数 int columnCount = rsmd.getColumnCount(); //创建集合 ArrayList&lt;T&gt; list = new ArrayList&lt;T&gt;(); while (rs.next()) &#123;//判断结果集是否还有下一行 T t = clazz.newInstance(); //处理结果集一行数据中的每一个列 for (int i = 0; i &lt; columnCount; i++) &#123; Object value = rs.getObject(i + 1); //获取每个列的列名 String columnName = rsmd.getColumnName(i + 1); //给t对象指定的columnName属性，赋值为value，通过反射 Field field = clazz.getDeclaredField(columnName); field.setAccessible(true);//让这个属性可以被访问 field.set(t, value); &#125; list.add(t); &#125; return list; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(null, ps, rs); &#125; return null; &#125; //用于查询一些特殊值的通用方法，就只有一行一列的时候一般用这个 public &lt;E&gt; E getValue(Connection conn, String sql, Object... args) &#123; PreparedStatement ps = null; ResultSet rs = null; try &#123; ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; rs = ps.executeQuery(); if (rs.next()) &#123; return (E) rs.getObject(1); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally&#123; JDBCUtils.closeResource(null, ps, rs); &#125;return null; &#125; CustomerDAO针对Customer接口来设计一个API 具体的类实现的接口 123456789101112131415161718192021222324252627import java.sql.Connection;import java.util.List;import java.sql.Date;//此接口用于规范针对于customers表的常用操作public interface CustomerDAO &#123; //将cust对象添加到数据库中 void insert(Connection conn, Customer cust); //针对指定的id，删除表中的一条记录 void deleteById(Connection conn,int id); //针对内存中的cust对象，去修改数据表中的指定的记录 void update(Connection conn,Customer cust); //针对指定的id查询得到对应的Customer对象 void getCustomerById(Connection conn,int id); //查询表中的所有记录构成的集合 List&lt;Customer&gt; getAll(Connection conn); //返回数据表中数据的条目数 Long getCount(Connection conn); //返回数据表中最大的生日 Date getMaxBirth(Connection conn);&#125; CustomerDAOImpl 针对一个表具体的类，继承了上面的类，实现了上面的接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.sql.Connection;import java.sql.Date;import java.util.List;public class CustomerDAOImpl extends BaseDao implements CustomerDAO&#123; @Override public void insert(Connection conn, Customer cust) &#123; String sql=&quot;insert into customers(name,email,birth)values(?,?,?)&quot;; update(conn,sql,cust.getName(),cust.getEmail(),cust.getBirth()); &#125; @Override public void deleteById(Connection conn, int id) &#123; String sql=&quot;delete from customers where id=?&quot;;update(conn,sql,id); &#125; @Override public void update(Connection conn, Customer cust) &#123; String sql=&quot;update customers set name=?,email=?,birth=? where id=?&quot;; update(conn,sql,cust.getName(),cust.getEmail(),cust.getBirth(),cust.getBirth()); &#125; @Override public Customer getCustomerById(Connection conn, int id) &#123; String sql=&quot;select id,name,email,birth from customers where id=?&quot;; Customer customer=getInstance(conn,Customer.class,sql,id); return customer; &#125; @Override public List&lt;Customer&gt; getAll(Connection conn) &#123; String sql=&quot;select id,name,email,birth from customers&quot;; List&lt;Customer&gt; list=getForList(conn,Customer.class,sql); return list; &#125; @Override public Long getCount(Connection conn) &#123; String sql=&quot;select count(*) from customers&quot;; return getValue(conn,sql); &#125; @Override public Date getMaxBirth(Connection conn) &#123; String sql=&quot;select max(birth) from customers&quot;; return getValue(conn,sql); &#125;&#125; 升级后的DAO在IDEA优化文件夹中写好了,报错 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package 优化;import 基础.BaseDao;import 基础.Customer;import 基础.CustomerDAO;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.sql.Connection;import java.sql.Date;import java.util.List;public class CustomerDAOImpl extends BaseDao&lt;Customer&gt; implements CustomerDAO &#123; @Override public void insert(Connection conn, Customer cust) &#123; String sql=&quot;insert into customers(name,email,birth)values(?,?,?)&quot;; update(conn,sql,cust.getName(),cust.getEmail(),cust.getBirth()); &#125; @Override public void deleteById(Connection conn, int id) &#123; String sql=&quot;delete from customers where id=?&quot;;update(conn,sql,id); &#125; @Override public void update(Connection conn, Customer cust) &#123; String sql=&quot;update customers set name=?,email=?,birth=? where id=?&quot;; update(conn,sql,cust.getName(),cust.getEmail(),cust.getBirth(),cust.getBirth()); &#125; @Override public Customer getCustomerById(Connection conn, int id) &#123; String sql=&quot;select id,name,email,birth from customers where id=?&quot;; Customer customer= getInstance(conn,sql,id); return customer; &#125; @Override public List&lt;Customer&gt; getAll(Connection conn) &#123; String sql=&quot;select id,name,email,birth from customers&quot;; List&lt;Customer&gt; list= getForList(conn,sql); return list; &#125; @Override public Long getCount(Connection conn) &#123; String sql=&quot;select count(*) from customers&quot;; return getValue(conn,sql); &#125; @Override public Date getMaxBirth(Connection conn) &#123; String sql=&quot;select max(birth) from customers&quot;; return getValue(conn,sql); &#125;&#125; DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO 作用：为了实现功能的模块化，更有利于代码的维护和升级。 下面是尚硅谷JavaWeb阶段书城项目中DAO使用的体现： 层次结构： 【BaseDAO.java】下面是用的那个DBUtils来操作的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.atguigu.bookstore.dao;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.sql.Connection;import java.sql.SQLException;import java.util.List;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.apache.commons.dbutils.handlers.ScalarHandler;/** * 定义一个用来被继承的对数据库进行基本操作的Dao * * @author HanYanBing * * @param &lt;T&gt; */public abstract class BaseDao&lt;T&gt; &#123; private QueryRunner queryRunner = new QueryRunner(); // 定义一个变量来接收泛型的类型 private Class&lt;T&gt; type; // 获取T的Class对象，获取泛型的类型，泛型是在被子类继承时才确定 public BaseDao() &#123; // 获取子类的类型 Class clazz = this.getClass(); // 获取父类的类型 // getGenericSuperclass()用来获取当前类的父类的类型 // ParameterizedType表示的是带泛型的类型 ParameterizedType parameterizedType = (ParameterizedType) clazz.getGenericSuperclass(); // 获取具体的泛型类型 getActualTypeArguments获取具体的泛型的类型 // 这个方法会返回一个Type的数组 Type[] types = parameterizedType.getActualTypeArguments(); // 获取具体的泛型的类型· this.type = (Class&lt;T&gt;) types[0]; &#125; /** * 通用的增删改操作 * * @param sql * @param params * @return */ public int update(Connection conn,String sql, Object... params) &#123; int count = 0; try &#123; count = queryRunner.update(conn, sql, params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return count; &#125; /** * 获取一个对象 * * @param sql * @param params * @return */ public T getBean(Connection conn,String sql, Object... params) &#123; T t = null; try &#123; t = queryRunner.query(conn, sql, new BeanHandler&lt;T&gt;(type), params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return t; &#125; /** * 获取所有对象 * * @param sql * @param params * @return */ public List&lt;T&gt; getBeanList(Connection conn,String sql, Object... params) &#123; List&lt;T&gt; list = null; try &#123; list = queryRunner.query(conn, sql, new BeanListHandler&lt;T&gt;(type), params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return list; &#125; /** * 获取一个但一值得方法，专门用来执行像 select count(*)...这样的sql语句 * * @param sql * @param params * @return */ public Object getValue(Connection conn,String sql, Object... params) &#123; Object count = null; try &#123; // 调用queryRunner的query方法获取一个单一的值 count = queryRunner.query(conn, sql, new ScalarHandler&lt;&gt;(), params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return count; &#125;&#125; 【BookDAO.java】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.atguigu.bookstore.dao;import java.sql.Connection;import java.util.List;import com.atguigu.bookstore.beans.Book;import com.atguigu.bookstore.beans.Page;public interface BookDao &#123; /** * 从数据库中查询出所有的记录 * * @return */ List&lt;Book&gt; getBooks(Connection conn); /** * 向数据库中插入一条记录 * * @param book */ void saveBook(Connection conn,Book book); /** * 从数据库中根据图书的id删除一条记录 * * @param bookId */ void deleteBookById(Connection conn,String bookId); /** * 根据图书的id从数据库中查询出一条记录 * * @param bookId * @return */ Book getBookById(Connection conn,String bookId); /** * 根据图书的id从数据库中更新一条记录 * * @param book */ void updateBook(Connection conn,Book book); /** * 获取带分页的图书信息 * * @param page：是只包含了用户输入的pageNo属性的page对象 * @return 返回的Page对象是包含了所有属性的Page对象 */ Page&lt;Book&gt; getPageBooks(Connection conn,Page&lt;Book&gt; page); /** * 获取带分页和价格范围的图书信息 * * @param page：是只包含了用户输入的pageNo属性的page对象 * @return 返回的Page对象是包含了所有属性的Page对象 */ Page&lt;Book&gt; getPageBooksByPrice(Connection conn,Page&lt;Book&gt; page, double minPrice, double maxPrice);&#125; 【UserDAO.java】12345678910111213141516171819202122232425262728293031package com.atguigu.bookstore.dao;import java.sql.Connection;import com.atguigu.bookstore.beans.User;public interface UserDao &#123; /** * 根据User对象中的用户名和密码从数据库中获取一条记录 * * @param user * @return User 数据库中有记录 null 数据库中无此记录 */ User getUser(Connection conn,User user); /** * 根据User对象中的用户名从数据库中获取一条记录 * * @param user * @return true 数据库中有记录 false 数据库中无此记录 */ boolean checkUsername(Connection conn,User user); /** * 向数据库中插入User对象 * * @param user */ void saveUser(Connection conn,User user);&#125; 【BookDaoImpl.java】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.atguigu.bookstore.dao.impl;import java.sql.Connection;import java.util.List;import com.atguigu.bookstore.beans.Book;import com.atguigu.bookstore.beans.Page;import com.atguigu.bookstore.dao.BaseDao;import com.atguigu.bookstore.dao.BookDao;public class BookDaoImpl extends BaseDao&lt;Book&gt; implements BookDao &#123; @Override public List&lt;Book&gt; getBooks(Connection conn) &#123; // 调用BaseDao中得到一个List的方法 List&lt;Book&gt; beanList = null; // 写sql语句 String sql = &quot;select id,title,author,price,sales,stock,img_path imgPath from books&quot;; beanList = getBeanList(conn,sql); return beanList; &#125; @Override public void saveBook(Connection conn,Book book) &#123; // 写sql语句 String sql = &quot;insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)&quot;; // 调用BaseDao中通用的增删改的方法 update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(),book.getImgPath()); &#125; @Override public void deleteBookById(Connection conn,String bookId) &#123; // 写sql语句 String sql = &quot;DELETE FROM books WHERE id = ?&quot;; // 调用BaseDao中通用增删改的方法 update(conn,sql, bookId); &#125; @Override public Book getBookById(Connection conn,String bookId) &#123; // 调用BaseDao中获取一个对象的方法 Book book = null; // 写sql语句 String sql = &quot;select id,title,author,price,sales,stock,img_path imgPath from books where id = ?&quot;; book = getBean(conn,sql, bookId); return book; &#125; @Override public void updateBook(Connection conn,Book book) &#123; // 写sql语句 String sql = &quot;update books set title = ? , author = ? , price = ? , sales = ? , stock = ? where id = ?&quot;; // 调用BaseDao中通用的增删改的方法 update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getId()); &#125; @Override public Page&lt;Book&gt; getPageBooks(Connection conn,Page&lt;Book&gt; page) &#123; // 获取数据库中图书的总记录数 String sql = &quot;select count(*) from books&quot;; // 调用BaseDao中获取一个单一值的方法 long totalRecord = (long) getValue(conn,sql); // 将总记录数设置都page对象中 page.setTotalRecord((int) totalRecord); // 获取当前页中的记录存放的List String sql2 = &quot;select id,title,author,price,sales,stock,img_path imgPath from books limit ?,?&quot;; // 调用BaseDao中获取一个集合的方法 List&lt;Book&gt; beanList = getBeanList(conn,sql2, (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE); // 将这个List设置到page对象中 page.setList(beanList); return page; &#125; @Override public Page&lt;Book&gt; getPageBooksByPrice(Connection conn,Page&lt;Book&gt; page, double minPrice, double maxPrice) &#123; // 获取数据库中图书的总记录数 String sql = &quot;select count(*) from books where price between ? and ?&quot;; // 调用BaseDao中获取一个单一值的方法 long totalRecord = (long) getValue(conn,sql,minPrice,maxPrice); // 将总记录数设置都page对象中 page.setTotalRecord((int) totalRecord); // 获取当前页中的记录存放的List String sql2 = &quot;select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? limit ?,?&quot;; // 调用BaseDao中获取一个集合的方法 List&lt;Book&gt; beanList = getBeanList(conn,sql2, minPrice , maxPrice , (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE); // 将这个List设置到page对象中 page.setList(beanList); return page; &#125;&#125; 【UserDaoImpl.java】123456789101112131415161718192021222324252627282930313233343536373839package com.atguigu.bookstore.dao.impl;import java.sql.Connection;import com.atguigu.bookstore.beans.User;import com.atguigu.bookstore.dao.BaseDao;import com.atguigu.bookstore.dao.UserDao;public class UserDaoImpl extends BaseDao&lt;User&gt; implements UserDao &#123; @Override public User getUser(Connection conn,User user) &#123; // 调用BaseDao中获取一个对象的方法 User bean = null; // 写sql语句 String sql = &quot;select id,username,password,email from users where username = ? and password = ?&quot;; bean = getBean(conn,sql, user.getUsername(), user.getPassword()); return bean; &#125; @Override public boolean checkUsername(Connection conn,User user) &#123; // 调用BaseDao中获取一个对象的方法 User bean = null; // 写sql语句 String sql = &quot;select id,username,password,email from users where username = ?&quot;; bean = getBean(conn,sql, user.getUsername()); return bean != null; &#125; @Override public void saveUser(Connection conn,User user) &#123; //写sql语句 String sql = &quot;insert into users(username,password,email) values(?,?,?)&quot;; //调用BaseDao中通用的增删改的方法 update(conn,sql, user.getUsername(),user.getPassword(),user.getEmail()); &#125;&#125; 【Book.java】1234567891011121314151617package com.atguigu.bookstore.beans;/** * 图书类 * @author songhongkang * */public class Book &#123; private Integer id; private String title; // 书名 private String author; // 作者 private double price; // 价格 private Integer sales; // 销量 private Integer stock; // 库存 private String imgPath = &quot;static/img/default.jpg&quot;; // 封面图片的路径 //构造器，get()，set()，toString()方法略&#125; 【Page.java】12345678910111213141516package com.atguigu.bookstore.beans;import java.util.List;/** * 页码类 * @author songhongkang * */public class Page&lt;T&gt; &#123; private List&lt;T&gt; list; // 每页查到的记录存放的集合 public static final int PAGE_SIZE = 4; // 每页显示的记录数 private int pageNo; // 当前页// private int totalPageNo; // 总页数，通过计算得到 private int totalRecord; // 总记录数，通过查询数据库得到 【User.java】12345678910111213package com.atguigu.bookstore.beans;/** * 用户类 * @author songhongkang * */public class User &#123; private Integer id; private String username; private String password; private String email; 第8章：数据库连接池8.1 JDBC数据库连接池的必要性 在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤： 在主程序（如servlet、beans）中建立数据库连接 进行sql操作 断开数据库连接 这种模式开发，存在的问题: 普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。数据库的连接资源并没有得到很好的重复利用。若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。 对于每一次数据库连接，使用完后都得断开。否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？） 这种开发不能控制被创建的连接对象数，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 8.2 数据库连接池技术 为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。 数据库连接池的基本思想：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。 数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。 工作原理： 数据库连接池技术的优点 1. 资源重用 由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。 2. 更快的系统反应速度 数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间 3. 新的资源分配手段 对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源 4. 统一的连接管理，避免数据库连接泄漏 在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露 8.3 多种开源的数据库连接池 JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现： DBCP 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。速度相对c3p0较快，但因自身存在BUG，Hibernate3已不再提供支持。 C3P0 是一个开源组织提供的一个数据库连接池，速度相对较慢，稳定性还可以。hibernate官方推荐使用 Proxool 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点 BoneCP 是一个开源组织提供的数据库连接池，速度快 Druid 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快 DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池 DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。 特别注意： 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。 8.3.1 C3P0数据库连接池 获取连接方式一 12345678910111213//使用C3P0数据库连接池的方式，获取数据库的连接：不推荐public static Connection getConnection1() throws Exception&#123; ComboPooledDataSource cpds = new ComboPooledDataSource(); cpds.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); cpds.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;); cpds.setUser(&quot;root&quot;); cpds.setPassword(&quot;abc123&quot;); // cpds.setMaxPoolSize(100); Connection conn = cpds.getConnection(); return conn;&#125; 获取连接方式二 123456//使用C3P0数据库连接池的配置文件方式，获取数据库的连接：推荐private static DataSource cpds = new ComboPooledDataSource(&quot;helloc3p0&quot;);public static Connection getConnection2() throws SQLException&#123; Connection conn = cpds.getConnection(); return conn;&#125; 其中，src下的配置文件为：【c3p0-config.xml】 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;c3p0-config&gt; &lt;named-config name=&quot;helloc3p0&quot;&gt; &lt;!-- 获取连接的4个基本信息 --&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;abc123&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql:///test&lt;/property&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!-- 涉及到数据库连接池的管理的相关属性的设置 --&gt; &lt;!-- 若数据库中连接数不足时, 一次向数据库服务器申请多少个连接 --&gt; &lt;property name=&quot;acquireIncrement&quot;&gt;5&lt;/property&gt; &lt;!-- 初始化数据库连接池时连接的数量 --&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;5&lt;/property&gt; &lt;!-- 数据库连接池中的最小的数据库连接数 --&gt; &lt;property name=&quot;minPoolSize&quot;&gt;5&lt;/property&gt; &lt;!-- 数据库连接池中的最大的数据库连接数 --&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;10&lt;/property&gt; &lt;!-- C3P0 数据库连接池可以维护的 Statement 的个数 --&gt; &lt;property name=&quot;maxStatements&quot;&gt;20&lt;/property&gt; &lt;!-- 每个连接同时可以使用的 Statement 对象的个数 --&gt; &lt;property name=&quot;maxStatementsPerConnection&quot;&gt;5&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; 8.3.2 DBCP数据库连接池 DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件： Commons-dbcp.jar：连接池的实现 Commons-pool.jar：连接池实现的依赖库 Tomcat 的连接池正是采用该连接池来实现的。该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。 配置属性说明 属性 默认值 说明 initialSize 0 连接池启动时创建的初始化连接数量 maxActive 8 连接池中可同时连接的最大的连接数 maxIdle 8 连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制 minIdle 0 连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。 maxWait 无限制 最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待 poolPreparedStatements false 开启池的Statement是否prepared maxOpenPreparedStatements 无限制 开启池的prepared 后的同时最大连接数 minEvictableIdleTimeMillis 连接池中连接，在时间段内一直空闲， 被逐出连接池的时间 removeAbandonedTimeout 300 超过时间限制，回收没有用(废弃)的连接 removeAbandoned false 超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收 获取连接方式一： 1234567891011121314public static Connection getConnection3() throws Exception &#123; BasicDataSource source = new BasicDataSource(); source.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); source.setUrl(&quot;jdbc:mysql:///test&quot;); source.setUsername(&quot;root&quot;); source.setPassword(&quot;abc123&quot;); // source.setInitialSize(10); Connection conn = source.getConnection(); return conn;&#125; 获取连接方式二： 12345678910111213141516171819202122//使用dbcp数据库连接池的配置文件方式，获取数据库的连接：推荐private static DataSource source = null;static&#123; try &#123; Properties pros = new Properties(); InputStream is = DBCPTest.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;); pros.load(is); //根据提供的BasicDataSourceFactory创建对应的DataSource对象 source = BasicDataSourceFactory.createDataSource(pros); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;public static Connection getConnection4() throws Exception &#123; Connection conn = source.getConnection(); return conn;&#125; 其中，src下的配置文件为：【dbcp.properties】 1234567driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&amp;useServerPrepStmts=falseusername=rootpassword=abc123initialSize=10#... 8.3.3 Druid（德鲁伊）数据库连接池（报错了）Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，可以说是目前最好的连接池之一。 这个是放在JDBCUtils文件里的，这一块的静态代码块有问题 12345678910111213141516private static DataSource source1=null;static&#123; try&#123; Properties pros=new Properties(); InputStream is= new FileInputStream(&quot;D:\\\\IDEAjava工程\\\\JDBC\\\\src\\\\基础\\\\druid.properties&quot;); pros.load(is); source1= DruidDataSourceFactory.createDataSource(pros); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125;&#125;public static Connection getConnection3()throws Exception&#123; Connection conn=source1.getConnection(); return conn;&#125; 测试 123456789101112131415public class DruidTest &#123; public static void main(String[] args) &#123; CustomerDAOImpl dao=new CustomerDAOImpl(); Connection conn=null; try&#123; conn=JDBCUtils.getConnection3(); Customer cust=dao.getCustomerById(conn,3); System.out.println(cust); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 其中，src下的配置文件为：【druid.properties】 123456789url=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=trueusername=rootpassword=rootdriverClassName=com.mysql.jdbc.DriverinitialSize=10maxActive=20maxWait=1000filters=wall 详细配置参数： 配置 缺省 说明 name 配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是：”DataSource-” + System.identityHashCode(this) url 连接数据库的url，不同数据库不一样。例如：mysql : jdbc:mysql:&#x2F;&#x2F;10.20.153.104:3306&#x2F;druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto username 连接数据库的用户名 password 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter driverClassName 根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下) initialSize 0 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 maxActive 8 最大连接池数量 maxIdle 8 已经不再使用，配置了也没效果 minIdle 最小连接池数量 maxWait 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 poolPreparedStatements false 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 maxOpenPreparedStatements -1 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 validationQuery 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 testOnBorrow true 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 testOnReturn false 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testWhileIdle false 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 timeBetweenEvictionRunsMillis 有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明 numTestsPerEvictionRun 不再使用，一个DruidDataSource只支持一个EvictionRun minEvictableIdleTimeMillis connectionInitSqls 物理连接初始化的时候执行的sql exceptionSorter 根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接 filters 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall proxyFilters 类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系 第9章：Apache-DBUtils实现CRUD操作9.1 Apache-DBUtils简介 commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。 API介绍： org.apache.commons.dbutils.QueryRunner org.apache.commons.dbutils.ResultSetHandler 工具类：org.apache.commons.dbutils.DbUtils API包说明： 9.2 主要API的使用9.2.1 DbUtils DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下： public static void close(…) throws java.sql.SQLException： DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。 public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。 public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接 public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断 public static void rollbackAndClose(Connection conn)throws SQLException rollbackAndCloseQuietly(Connection) public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。 9.2.2 QueryRunner类 该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。 QueryRunner类提供了两个构造器： 默认的构造器 需要一个 javax.sql.DataSource 来作参数的构造器 QueryRunner类的主要方法： 更新 public int update(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。 …… 插入 public T insert(Connection conn,String sql,ResultSetHandler rsh, Object… params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys. 返回值: An object generated by the handler.即自动生成的键值 …. 批处理 public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句 public T insertBatch(Connection conn,String sql,ResultSetHandler rsh,Object[][] params)throws SQLException：只支持INSERT语句 ….. 查询 public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。 …… update方法测试 update方法能执行delete update insert语句 123456789101112131415161718192021222324252627282930313233//添加数据import org.apache.commons.dbutils.QueryRunner;import java.sql.Connection;import java.sql.SQLException;public class DbUtilsTest &#123; public static void main(String[] args) &#123;DbUtilsTest list=new DbUtilsTest();list.testInsert(); &#125; public void testInsert() &#123; QueryRunner runner = new QueryRunner(); Connection conn= null; try &#123; conn = JDBCUtils.getConnection(); String sql = &quot;insert into customers(name,email,birth)values(?,?,?)&quot;; int insertCount = runner.update(conn, sql, &quot;易烊千玺&quot;, &quot;3241525035@qq.com&quot;, &quot;1997-09-08&quot;); System.out.println(&quot;添加了&quot; + insertCount + &quot;记录&quot;); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; finally&#123; JDBCUtils.closeResource(conn,null); &#125; &#125;&#125; 12345678910111213// 测试删除@Testpublic void testDelete() throws Exception &#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection(); String sql = &quot;delete from customers where id &lt; ?&quot;; int count = runner.update(conn, sql,3); System.out.println(&quot;删除了&quot; + count + &quot;条记录&quot;); JDBCUtils.closeResource(conn, null);&#125; 9.2.3 ResultSetHandler接口及实现类 该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。 ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。 接口的主要实现类： ArrayHandler：把结果集中的第一行数据转成对象数组。 ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。 BeanHandler：将结果集中的第一行数据封装到一个对应的JavaBean实例中。 BeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。 ColumnListHandler：将结果集中某一列的数据存放到List中。 KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。 MapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。 MapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List ScalarHandler：查询单个值对象 测试 BeanHandler是ResultSetHandler接口的实现类 12345678910111213141516171819/* * 测试查询:查询一条记录 * * 使用ResultSetHandler的实现类：BeanHandler */@Testpublic void testQueryInstance() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection(); String sql = &quot;select id,name,email,birth from customers where id = ?&quot;; // BeanHandler&lt;Customer&gt; handler = new BeanHandler&lt;&gt;(Customer.class); Customer customer = runner.query(conn, sql, handler, 23); System.out.println(customer); JDBCUtils.closeResource(conn, null);&#125; 12345678910111213141516171819/* * 测试查询:查询多条记录构成的集合 * * 使用ResultSetHandler的实现类：BeanListHandler，用于封装表中的多条记录构成的集合 */@Testpublic void testQueryList() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection(); String sql = &quot;select id,name,email,birth from customers where id &lt; ?&quot;; // BeanListHandler&lt;Customer&gt; handler = new BeanListHandler&lt;&gt;(Customer.class); List&lt;Customer&gt; list = runner.query(conn, sql, handler, 23); list.forEach(System.out::println); JDBCUtils.closeResource(conn, null);&#125; 12345678910111213141516171819202122232425262728293031323334353637/* * 自定义ResultSetHandler的实现类 */@Testpublic void testQueryInstance1() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection(); String sql = &quot;select id,name,email,birth from customers where id = ?&quot;; ResultSetHandler&lt;Customer&gt; handler = new ResultSetHandler&lt;Customer&gt;() &#123;//这个地方必须要写后面那个Customer @Override public Customer handle(ResultSet rs) throws SQLException &#123; System.out.println(&quot;handle&quot;);// return new Customer(1,&quot;Tom&quot;,&quot;tom@126.com&quot;,new Date(123323432L)); if(rs.next())&#123; int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); String email = rs.getString(&quot;email&quot;); Date birth = rs.getDate(&quot;birth&quot;); return new Customer(id, name, email, birth); &#125; return null; &#125; &#125;; Customer customer = runner.query(conn, sql, handler, 23); System.out.println(customer); JDBCUtils.closeResource(conn, null);&#125; 1234567891011121314151617181920212223242526/* * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据， * 使用ScalarHandler 这个就是用来返回一些特殊的熟知的和那个BASEDAO中的getValue方法有些类似 * */@Testpublic void testQueryValue() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection(); //测试一：// String sql = &quot;select count(*) from customers where id &lt; ?&quot;;// ScalarHandler handler = new ScalarHandler();// long count = (long) runner.query(conn, sql, handler, 20);// System.out.println(count); //测试二： String sql = &quot;select max(birth) from customers&quot;; ScalarHandler handler = new ScalarHandler(); Date birth = (Date) runner.query(conn, sql, handler); System.out.println(birth); JDBCUtils.closeResource(conn, null);&#125; 12345678910111213用MapHandler这个实现类，返回的是一个map形式的对象将字段及相应字段的值作为map的key和valuepublic void testQuery() throws SQLException &#123; QueryRunner runner = new QueryRunner(); Connection conn=JDBCUtils.getConnection(); String sql=&quot;select id,name,email,birth from customers where id&lt;?&quot;; MapHandler handler=new MapHandler(); Map&lt;String,Object&gt; map=runner.query(conn,sql,handler,23); System.out.println(map);&#125;// &#123;name=汪峰, birth=2010-02-02, id=1, email=wf@126.com&#125;结果 12345678910111213141516打印多个Map，对应表中的多条记录public void testQueryList() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection(); String sql = &quot;select id,name,email,birth from customers where id &lt; ?&quot;; // MapListHandler handler = new MapListHandler(); List&lt;Map&lt;String,Object&gt;&gt; list = runner.query(conn, sql, handler, 23); list.forEach(System.out::println); JDBCUtils.closeResource(conn, null);&#125; 关闭连接，可以放在JDBCUtils类中当作关闭方法 123456//用DBUtils关闭资源public static void closeResource1(Connection conn,Statement ps,ResultSet rs)&#123; DbUtils.closeQuietly(conn); DbUtils.closeQuietly(ps); DbUtils.closeQuietly(rs);&#125; 用 自己用DBUtils实现的BaseDao1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.atguigu.dao.impl;import com.atguigu.utils.JdbcUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.apache.commons.dbutils.handlers.ScalarHandler;import java.sql.Connection;import java.sql.SQLException;import java.util.List;public class BaseDao &#123; //使用DbUtils操作数据库private QueryRunner queryRunner=new QueryRunner();/*update()方法用来执行：insert update delete语句如果返回-1说明执行失败， 否则返回其他表示影响的行数 */ public int update(String sql,Object...args)&#123; Connection conn= JdbcUtils.getConnection(); try &#123; return queryRunner.update(conn, sql, args); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; return -1; &#125; /* 查询返回一个javaBean的sql语句 type为返回对象类型，args是sql对应的参数值，sql是执行的sql语句 &lt;T&gt;返回的类型和泛型 */ public &lt;T&gt; T queryForOne(Class&lt;T&gt; type,String sql,Object...args) &#123; Connection con=JdbcUtils.getConnection(); try &#123; return queryRunner.query(con,sql,new BeanHandler&lt;T&gt;(type),args); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; finally&#123; JdbcUtils.close(con); &#125; return null; &#125; public &lt;T&gt; List&lt;T&gt; queryForList(Class&lt;T&gt; type,String sql,Object...args)&#123; Connection con=JdbcUtils.getConnection(); try &#123; return queryRunner.query(con,sql,new BeanListHandler&lt;T&gt;(type),args); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; return null; &#125; public Object queryForSingleValue(String sql,Object...args)&#123; Connection conn=JdbcUtils.getConnection(); try &#123; return queryRunner.query(conn, sql,new ScalarHandler(), args); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; return null; &#125;&#125; JDBC总结12345678910111213141516171819202122232425262728293031323334353637总结@Testpublic void testUpdateWithTx() &#123; Connection conn = null; try &#123; //1.获取连接的操作（ //① 手写的连接：JDBCUtils.getConnection(); //② 使用数据库连接池：C3P0;DBCP;Druid //2.对数据表进行一系列CRUD操作 //① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \\ version 2.0)//version2.0的增删改public void update(Connection conn,String sql,Object ... args)&#123;&#125;//version2.0的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql,Object ... args)&#123;&#125; //② 使用dbutils提供的jar包中提供的QueryRunner类 //提交数据 conn.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; //回滚数据 conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125;finally&#123; //3.关闭连接等操作 //① JDBCUtils.closeResource(); //② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作 &#125;&#125;","categories":[],"tags":[]},{"title":"springboot","slug":"springboot","date":"2022-09-29T15:31:35.000Z","updated":"2023-04-10T12:59:58.106Z","comments":true,"path":"2022/09/29/springboot/","link":"","permalink":"http://example.com/2022/09/29/springboot/","excerpt":"","text":"Springboot启动类application本身也就是一个配置类 springboot介绍Spring笔记网址 https://www.yuque.com/atguigu/springboot springboot可以帮助整合spring的各种其他的框架，简化了配置文件 springboot2技术栈分为两部分，第一部分是Servlet技术栈（就是spring和springmvc那一套）第二套就是从数据访问这一层的响应式开发，这次课讲得也就是第一个技术栈 Spring优点 能快速创建生产级别的spring项目 springboot内嵌tomcat服务器，不需要把项目打成war包，再到tomcat服务器上去跑 SpringBoot：更新迭代版本快 微服务 微服务是一种架构风格 一个应用拆分为一组小型服务 每个服务运行在自己的进程内，也就是可独立部署和升级 服务之间使用轻量级HTTP交互 服务围绕业务功能拆分 可以由全自动部署机制独立部署 去中心化，服务自治。服务可以使用不同的语言、不同的存储技术 分布式困难： 远程调用 服务发现 负载均衡 服务容错 配置管理 服务监控 链路追踪 日志管理 任务调度 可以用：SpringBoot加SpringCloud解决 Springboot官方文档，进入Springboot页面后，点击那个reference document Spring Boot Reference Documentation Springboot2入门1.重新配置maven的settings.xml 1234567891011121314151617181920212223&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; 2.编写一个HelloWorld 需求：浏览器发送&#x2F;hello请求，响应Hello，Spring Boot 2 主程序类，在com.atguigu.boot下 12345678910111213141516171819package com.atguigu.boot;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import sun.applet.Main;/*@SpringbootApplication标记了的这个叫做主程序的类告诉springboot这是一个Springboot的应用 */@SpringBootApplicationpublic class MainApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MainApplication.class,args); &#125;&#125; 建立controller，在com.atguigu.boot.controller包下 12345678910111213141516package com.atguigu.boot.com.atguigu.boot.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.RestController;@RestController//@RestController是@Controller和@ResponseBody的结合，表示返回的到页面的直接是一个字符串，而不是要跳转的页面public class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String handle01()&#123; return &quot;HELLO,SpringBoot2&quot;; &#125;&#125; 直接运行主程序，就可以启动服务，不需要自己去整合Tomcat 简化配置 在resources下创建application.properties可以修改Tomcat springmvc的一些设置，都可以改 在Springboot的官方文档一进去，那个Applications Properties中有这个具体的配置是怎么进行的 Spring Boot Reference Documentation application.properties中这个内容是指tomacat开放web服务的端口号 1server.port=8888 简化部署 原本是把项目打包成war包，在tomcat上运行 现在是直接打成jar包，里面直接就包含了tomcat的环境 加入依赖 123456789&lt;!--直接把项目打成jar包，方便部署--&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 先选中clean再选中package，然后运行maven就可以打成jar包 jar包就是下面这个boot_01_helloworld-SNAPSHOT.jar 对于ssm项目的时候，只要运行项目就会打成war包，但现在springboot必须按照上面的方式才能打成jar包，直接在目标服务器上执行即可 找到jar包的位置，打开cmd，输入java -jar boot_01_helloworld-1.0-SNAPSHOT.jar,也可以执行jar包，让他生成服务 pom.xml 这是最先用到的这些 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;boot_01_helloworld&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--springboot相关的依赖--&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!--springboot的web相关的依赖--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--直接把项目打成jar包，方便部署--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 依赖管理特性12345678910111213141516依赖管理 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;/version&gt;&lt;/parent&gt;点artifactId中的内容就是下面这个，上面的父项目 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;/version&gt; &lt;/parent&gt; 点artifactId中的内容，查看引入的jar包父项目就是用来管理依赖的几乎声明了所有开发中常用的依赖的版本号,自动版本仲裁机制 一个父项目中的jar包也可以给子项目所使用，springboot就是通过导入父项目，来管理jar包，以及版本号 不想用父项目中规定好的版本号，可以进行重写 1234561、查看spring-boot-dependencies里面规定当前依赖的版本 用的 key。2、在当前项目里面重写配置，重写配置的时候要看源码中是怎么配置的，要用相同的方式引入，就像子类重写父类一样3.这个地方只是重写了父项目默认的mysql版本号，并不是引入mysql，dependencies中该导入依赖还是要导入依赖 &lt;properties&gt; &lt;mysql.version&gt;5.1.43&lt;/mysql.version&gt; &lt;/properties&gt; 12345678910111213141516- 开发导入starter场景启动器1、见到很多 spring-boot-starter-* ： *就某种场景 这个是artifactId的内容，他们的groupId都是org.springframework.boot2、只要引入starter，这个场景的所有常规需要的依赖我们都自动引入3、SpringBoot所有支持的场景https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter4、见到的 *-spring-boot-starter： 第三方为我们提供的简化开发的场景启动器。5、所有场景启动器最底层的依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 1.引入的依赖在父项目中默认了版本号，那么可以不引入版本号 2.如果引入的依赖在父项目中没有写版本号，那么必须引入版本号 自动导入依赖 自动配好Tomcat 引入Tomcat依赖。 配置Tomcat 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; 自动配好SpringMVC 引入SpringMVC全套组件 自动配好SpringMVC常用组件（功能） 自动配好Web常见功能，如：字符编码问题,文件上传等等 SpringBoot帮我们配置好了所有web开发的常见场景 默认的包结构 主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来 无需以前的包扫描配置 想要改变扫描路径，@SpringBootApplication(scanBasePackages&#x3D;“com.atguigu”) 或者@ComponentScan 指定扫描路径（后来演示） 想要改变扫描路径，给主程序上面的scanBasePackages属性赋值 用@SpringBootApplication的时候不能够使用@ComponentScan 1@SpringBootApplication(scanBasePackages = &quot;com.atguigu&quot;) @ComponentScan中的value值是指包扫描路径 12345@SpringBootApplication(&quot;com.atguigu.boot&quot;)等同于@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(&quot;com.atguigu.boot&quot;) 各种配置拥有默认值 默认配置最终都是映射到某个类上，如：MultipartProperties 配置文件的值最终会绑定每个类上，这个类会在容器中创建对象 默认的配置想要改变可以在application.properties（自己创建在resources目录下的）中修改 按需加载所有自动配置项 非常多的starter 引入了哪些场景这个场景的自动配置才会开启 SpringBoot所有的自动配置功能都在 spring-boot-autoconfigure 包里面 只有导入了对应的starter场景导入器，对应的自动配置才会开启，相应的管理的jar包以及文件才会生效 就是只有引入了web场景，有关于web的自动配置才会开启，比如springmvcspring相关的jar包才会生效 这就是引入web场景 12345678&lt;!--springboot的web相关的依赖--&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 底层注解@Configuration告诉springboot这是替代配置文件的类，和springmvc中讲的用法一样 这样配置的bean默认是单实例的 可以获取配置类的bean，外部无论对配置类中的这个组件注册方法（被@Bean标识的方法）调用多少次获取的都是之前注册容器中的单实例对象 基本使用 示例 最佳实战 配置 类组件之间无依赖关系用Lite模式加速容器启动过程，减少判断 配置类组件之间有依赖关系，方法会被调用得到之前单实例组件，用Full模式 上面是配置类，下面是用来测试的主程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#############################Configuration使用示例######################################################配置类/** * 1、配置类里面使用@Bean标注在方法上给容器注册组件，默认也是单实例的 * 2、配置类本身也是组件 * 3、proxyBeanMethods：代理bean的方法 * Full(proxyBeanMethods = true)、【保证每个@Bean方法被调用多少次返回的组件都是单实例的】 * Lite(proxyBeanMethods = false)【每个@Bean方法被调用多少次返回的组件都是新创建的】 * 组件之间有依赖必须使用Full模式默认。其他默认使用Lite模式 * * * */ @Configuration(proxyBeanMethods = false) //告诉SpringBoot这是一个配置类 == 配置文件 public class MyConfig &#123; /** * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象 * @return */ @Bean //给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例 public User user01()&#123; User zhangsan = new User(&quot;zhangsan&quot;, 18); //user组件依赖了Pet组件 //就是如果proxyBeanMethods为true，此时容器中如果有要用的这个Pet的bean就会直接用容器中的，没有才创建新的 //如果proxyBeanMethods为false，不管容器中是否有Pet的bean，都会创建一个新的 zhangsan.setPet(tomcatPet()); return zhangsan; &#125; @Bean(&quot;tom&quot;) public Pet tomcatPet()&#123; return new Pet(&quot;tomcat&quot;); &#125; &#125;################################@Configuration测试代码如下########################################MainApplication主程序@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(&quot;com.atguigu.boot&quot;)public class MainApplication &#123; public static void main(String[] args) &#123; //1、返回我们IOC容器 ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args); //2、查看容器里面的组件 String[] names = run.getBeanDefinitionNames(); for (String name : names) &#123; System.out.println(name); &#125; //3、从容器中获取组件 Pet tom01 = run.getBean(&quot;tom&quot;, Pet.class); Pet tom02 = run.getBean(&quot;tom&quot;, Pet.class); System.out.println(&quot;组件：&quot;+(tom01 == tom02)); //true //4、com.atguigu.boot.config.MyConfig$$EnhancerBySpringCGLIB$$51f1e1ca@1654a892 MyConfig bean = run.getBean(MyConfig.class); System.out.println(bean); //如果@Configuration(proxyBeanMethods = true)代理对象调用方法。SpringBoot总会检查这个组件是否在容器中有。 //保持组件单实例 User user = bean.user01(); User user1 = bean.user01(); System.out.println(user == user1); //proxyBeanMethods = true时是true,proxyBeanMethods = false时就是false//这段是要看一下上面的配置类方法，配置类中把user01实例的Pet做了依赖 User user01 = run.getBean(&quot;user01&quot;, User.class); Pet tom = run.getBean(&quot;tom&quot;, Pet.class); System.out.println(&quot;用户的宠物：&quot;+(user01.getPet() == tom)); //proxyBeanMethods = true时是true,proxyBeanMethods = false时就是false &#125;&#125; @Import导入组件@Import是作用在组件上（就是用@Configuration标注的或者@Controller之类标注的都叫组件） &#96;&#96;&#96; 4、@Import({User.class, DBHelper.class}) 给容器中自动创建出这两个类型的组件、默认组件的名字就是全类名 *&#x2F; @Import({User.class, DBHelper.class})@Configuration(proxyBeanMethods &#x3D; false) &#x2F;&#x2F;告诉SpringBoot这是一个配置类 &#x3D;&#x3D; 配置文件public class MyConfig {} 123456789101112131415 ### @Conditional条件装配条件装配，当满足Conditional指定的条件，则进行组件注入![image-20221117170136032](https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202211171701329.png)ConditonalOnBean：容器中存在指定的bean的时候，我们才干某些事情ConditionalOnMissingBean:当容器中不存在某些bean的时候，我们才干某些事情ConditionalOnClass:当容器中有某一个类的时候才干。。 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;测试条件装配&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;@Configuration(proxyBeanMethods &#x3D; false) &#x2F;&#x2F;告诉SpringBoot这是一个配置类 &#x3D;&#x3D; 配置文件&#x2F;&#x2F;@ConditionalOnBean(name &#x3D; “tom”)&#x2F;&#x2F;当容器中没有tom这个名字的bean的时候，下面这个类中配置的所有bean都不会生效&#x2F;&#x2F;也可以单独给方法加，这样条件就是只能限制@ConditionalOnMissingBean(name &#x3D; “tom”)public class MyConfig { /** * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象 * @return */ @Bean //给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例 public User user01()&#123; User zhangsan = new User(&quot;zhangsan&quot;, 18); //user组件依赖了Pet组件 zhangsan.setPet(tomcatPet()); return zhangsan; &#125; @Bean(&quot;tom22&quot;) public Pet tomcatPet()&#123; return new Pet(&quot;tomcat&quot;); &#125; } 123MainApplication public static void main(String[] args) { &#x2F;&#x2F;1、返回我们IOC容器 ConfigurableApplicationContext run &#x3D; SpringApplication.run(MainApplication.class, args); //2、查看容器里面的组件 String[] names = run.getBeanDefinitionNames(); for (String name : names) &#123; System.out.println(name); &#125; //看看容器中有没有tom这个组件 boolean tom = run.containsBean(&quot;tom&quot;); System.out.println(&quot;容器中Tom组件：&quot;+tom); //看看容器中有没有user01这个组件 boolean user01 = run.containsBean(&quot;user01&quot;); System.out.println(&quot;容器中user01组件：&quot;+user01); //看看容器中有没有tom22这个组件 boolean tom22 = run.containsBean(&quot;tom22&quot;); System.out.println(&quot;容器中tom22组件：&quot;+tom22); &#125; 1234567891011最后结果是false,true,true### @ImportResource在springboot中这种配置文件是无效的，但是可以通过在一个配置类上进行引入，对这个xml文件中的bean进行配置【xml的bean的配置文件beans.xml &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;beans.xml&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &lt;bean id=&quot;haha&quot; class=&quot;com.atguigu.boot.bean.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;hehe&quot; class=&quot;com.atguigu.boot.bean.Pet&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;tomcat&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 1234567测试：看看有没有haha和hehe两个bean @ImportResource(“classpath:beans.xml”)public class MyConfig { boolean haha &#x3D; run.containsBean(“haha”); boolean hehe &#x3D; run.containsBean(“hehe”); System.out.println(“haha：”+haha);&#x2F;&#x2F;true System.out.println(“hehe：”+hehe);&#x2F;&#x2F;true } 123456789101112131415### 配置绑定用java读取properties文件中的内容，并且把它封装到javabean中，供随时使用就像properties存储数据库链接的信息，要用来给bean的属性赋值第一种方法这个是Car类，是组件 &#x2F;** @Component是把这个类加到容器中 只有在容器中的组件，才会拥有SpringBoot提供的强大功能*&#x2F; @Component &#x2F;&#x2F;prefix是指这个类中属性对应文件中内容的前缀@ConfigurationProperties(prefix &#x3D; “mycar”) public class Car { private String brand;private Integer price; public String getBrand() { return brand;} public void setBrand(String brand) { this.brand &#x3D; brand;} public Integer getPrice() { return price;} public void setPrice(Integer price) { this.price &#x3D; price; } @Override public String toString() {return “Car{“ + “brand&#x3D;’” + brand + ‘&#39;‘ + “, price&#x3D;” + price + ‘}’;}} 123 配置文件 123```mycar.brand=BYDmycar.price=1000 如果在Controller中或者哪里用到了这个Car类，可以通过@Autowired来获取通过配置文件赋值好的Car对象 第二种方法 这个就是有时候你用第三方包，人家头上没加@Component就可以用这种 配置类上面要添加注解 12345678910@EnableConfigurationProperties(Car.class)//1、开启Car配置绑定功能//2、把这个Car这个组件自动注册到容器中public class MyConfig &#123;&#125;//Car类上就不用加@Component注解了 //prefix是指这个类中属性对应文件中内容的前缀 @ConfigurationProperties(prefix = &quot;mycar&quot;) public class Car &#123; 自动配置原理这个是@springbootApplication上面的注解 123456789101112131415@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;) 1.@SpringBootConfiguration 下面是它的合成注解信息 12345@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Configuration//代表当前是一个配置类public @interface SpringBootConfiguration &#123; 2.@ComponentScan(…) 指定扫描哪些包 3.@EnableAutoConfiguration 1234567@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123; @AutoConfigurationPackage 自动配置包？指定了默认的包规则 因为Register类中有两个方法，所以i不止导入一个组件 1234567@Import(AutoConfigurationPackages.Registrar.class) //给容器中导入一个组件public @interface AutoConfigurationPackage &#123;&#125;//利用Registrar给容器中导入一系列组件//将指定的一个包下的所有组件导入进来，MainApplication 所在包下。//源码中的方法 AutoConfigurationPackages.register(registry, (String[])(newAutoConfigurationPackages.PackageImports(metadata)).getPackageNames().toArray(new String[0])); @Import(AutoConfigurationImportSelector.class) 12345671、利用getAutoConfigurationEntry(annotationMetadata);给容器中批量导入一些组件2、调用List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes)获取到所有需要导入到容器中的配置类3、利用工厂加载 Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader)；得到所有的组件4、从META-INF/spring.factories位置来加载一个文件。 默认扫描我们当前系统里面所有META-INF/spring.factories位置的文件 spring-boot-autoconfigure-2.3.4.RELEASE.jar包里面也有META-INF/spring.factories 文件里面写死了spring-boot一启动就要给容器中加载的所有配置类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132spring-boot-autoconfigure-2.3.4.RELEASE.jar/META-INF/spring.factories# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRestClientAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.r2dbc.R2dbcDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.r2dbc.R2dbcRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.r2dbc.R2dbcTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.ElasticsearchRestClientAutoConfiguration,\\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\\org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\\org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\org.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\\org.springframework.boot.autoconfigure.r2dbc.R2dbcAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\\org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\\org.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration,\\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\\org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration 按需开启自动配置项 12虽然我们127个场景的所有自动配置启动的时候默认全部加载。xxxxAutoConfiguration按照条件装配规则（@Conditional），最终会按需配置。 最佳实践SpringBoot应用如何编写 引入场景 依赖 https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter 查看自动配置了哪些（选做） 自己分析，引入场景对应的自动配置一般都生效了 配置文件中debug&#x3D;true开启自动配置报告。Negative（不生效）\\Positive（生效） 是否需要修改 参照文档修改配置项 https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#common-application-properties 自己分析。xxxxProperties绑定了配置文件的哪些。 自定义加入或者替换组件 @Bean、@Component。。。 自定义器 XXXXXCustomizer； Lombok简化开发简化javabean的开发 引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; 安装插件 Lomback要生效还要安装lomback的插件，用来自动生成getset方法 程序编译的时候生成，源代码看起来还是会很清晰 Settings–》plugins–&gt;搜索lombok，安装完成后重启idea @Data加上之后除了有参构造其他的都有了 12345678910111213141516171819202122232425===============================简化JavaBean开发===================================//这个是无参构造器@NoArgsConstructor//这个所有属性的有参构造器//@AllArgsConstructor//加上这个注解不用写setter和getter@Data//不用写toString方法@ToString//帮助重写equals和HashCode方法@EqualsAndHashCodepublic class User &#123; private String name; private Integer age; private Pet pet; public User(String name,Integer age)&#123; this.name = name; this.age = age; &#125;&#125; lombok简化日志开发 1234567891011121314================================简化日志开发===================================@Slf4j@RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String handle01(@RequestParam(&quot;name&quot;) String name)&#123; log.info(&quot;请求进来了....&quot;); return &quot;Hello, Spring Boot 2!&quot;+&quot;你好：&quot;+name; &#125;&#125; log.info(“ “)中间内容是可以打印的日志信息 dev-tools加入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 这个就是修改之后方便部署，可以用ctrl+f9来热部署，无论是组件或者静态页面的修改都可以配置 Spring Initailizr项目初始化向导，使用起来会非常方便 新建项目的时候点击Spring Initailizr 自动导入依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.5&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 3.自动编写好主配置类 12345678910111213package com.example.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; 核心功能 配置文件properties同以前的properties用法 yamlAML 是 “YAML Ain’t Markup Language”（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）。 非常适合用来做以数据为中心的配置文件 基本语法 key: value；kv之间有空格 大小写敏感 使用缩进表示层级关系 缩进不允许使用tab，只允许空格 缩进的空格数不重要，只要相同层级的元素左对齐即可 ‘#’表示注释 字符串无需加引号，如果要加，’’与””表示字符串内容 会被 转义&#x2F;不转义 数据类型 字面量：单个的、不可再分的值。date、boolean、string、number、null 1k: v 对象：键值对的集合。map、hash、set、object 123456行内写法： k: &#123;k1:v1,k2:v2,k3:v3&#125;#或k: k1: v1 k2: v2 k3: v3 - 数组：一组按次序排列的值。array、list、queue &#96;&#96;&#96;行内写法： k: [v1,v2,v3]#或者k: v1 v2 v123456789101112131415161718192021222324252627282930313233343536373839 测试：Person```javapackage com.atguigu.boot.bean;import lombok.Data;import lombok.ToString;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;import java.util.Date;import java.util.List;import java.util.Map;import java.util.Set;//这个类中的所有属性和yml文件中所有person开头的项进行绑定@ConfigurationProperties(prefix=&quot;person&quot;)@Component@ToString@Datapublic class Person &#123; private String userName; private Boolean boss; private Date birth; private Integer age; private Pet pet; private String[] interests; private List&lt;String&gt; animal; private Map&lt;String, Object&gt; score; private Set&lt;Double&gt; salarys; private Map&lt;String, List&lt;Pet&gt;&gt; allPets;&#125; Pet 1234567891011121314package com.atguigu.boot.bean;import lombok.Data;import lombok.ToString;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@ToString@Datapublic class Pet &#123; private String name; private Double weight;&#125; application.yml 123456789101112131415161718192021222324252627282930313233343536373839person: userName: &#x27;zhangsan \\n 李四&#x27; #单引号会将\\n作为字符串输出，双引号会将\\n作为换行输出 #双引号不会转义，单引号会转义 boss: true birth: 2019/12/9 age: 10 # interests: [篮球,足球] interests: - 篮球 - 足球 animal: [阿猫,阿狗] #score: # english: 80 # math: 90 score: &#123;english: 80,math: 90&#125; salarys: - 9999.98 - 9999.99 pet: name: 阿狗 weight: 99.99#这个是一个复杂变量 allPets: sick: - &#123;name: 阿狗,weight: 88.88&#125; - name: 阿猫 weight: 88.88 - name: 阿虫 weight: 88.88 health: - &#123;name: 阿花,weight: 88.88&#125; - name: 阿猫 weight: 88.88 - name: 阿虫 weight: 88.88 Controller 1234567891011@RestController//@RestController是@Controller和@ResponseBody的结合，表示返回的到页面的直接是一个字符串，而不是要跳转的页面public class HelloController &#123; @Autowired Person person; @RequestMapping(&quot;/hello&quot;) public Person handle01()&#123; return person; &#125;&#125; 如果properties和yml文件同时生效，那么properties文件的优先级比较高，先按照properties文件进行赋值 自定义类绑定的配置提示，就是在配置文件中写某个类的属性的赋值的时候，可以出来提示 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; pom.xml 修改一下打包jar包的配置，打包的时候不打上面那个依赖，因为这个是开发的时候用的 123456789101112131415&lt;!--直接把项目打成jar包，方便部署--&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configurationprocessor&lt;/artifactId&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; web开发 官网有关web的讲解 Spring Boot Features SpringMVC自动配置概览 Spring Boot provides auto-configuration for Spring MVC that works well with most applications.(大多场景我们都无需自定义配置) The auto-configuration adds the following features on top of Spring’s defaults: Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 内容协商视图解析器和BeanName视图解析器 Support for serving static resources, including support for WebJars (covered later in this document)). 静态资源（包括webjars） Automatic registration of Converter, GenericConverter, and Formatter beans. 自动注册 Converter，GenericConverter，Formatter Support for HttpMessageConverters (covered later in this document). 支持 HttpMessageConverters （后来我们配合内容协商理解原理） Automatic registration of MessageCodesResolver (covered later in this document). 自动注册 MessageCodesResolver （国际化用） Static index.html support. 静态index.html 页支持 Custom Favicon support (covered later in this document). 自定义 Favicon ，浏览器每个网页栏上有一个小图标 Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document). 自动使用 ConfigurableWebBindingInitializer ，（DataBinder负责将请求数据绑定到JavaBean上） If you want to keep those Spring Boot MVC customizations and make more MVC customizations (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. 不用@EnableWebMvc注解。使用 **@Configuration** + **WebMvcConfigurer** 自定义规则 If you want to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, and still keep the Spring Boot MVC customizations, you can declare a bean of type WebMvcRegistrations and use it to provide custom instances of those components. 声明 **WebMvcRegistrations** 改变默认底层组件 If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc, or alternatively add your own @Configuration-annotated DelegatingWebMvcConfiguration as described in the Javadoc of @EnableWebMvc. 使用 **@EnableWebMvc+@Configuration+DelegatingWebMvcConfiguration 全面接管SpringMVC** 路径问题在springboot中默认的项目路径就是&#x2F; 也就是localhost:8080，如果要修改可以自己在配置文件中修改 之前ssm项目路径都是&#x2F;spring &#x2F;springmvc之类的，所以浏览器解析&#x2F;和服务器解析&#x2F;是不一样的 浏览器是把&#x2F;解析为localhost:8080 服务器可以把&#x2F;解析为localhost:8080&#x2F;springmvc 这个是项目目录下 thymeleaf用@{}中&#x2F;永远都解析为项目路径不管项目路径是如何设置的 springboot中项目路径是可以默认访问到静态文件夹下的内容的，也可以把访问静态文件夹的路径给修改掉 12345/*在servlet中可以匹配所有请求，但是在spring家族里面就是只能匹配一层目录比如/user ,/admin但是，在springmvc配置那个DispatcherServlet的时候，用的是/*因为这属于Servlet的配置，在springmvc配置拦截器的路径，就要用/**，因为在springmvc中/**才是全部请求 web开发功能静态资源的访问 类路径下这些文件夹都可以作为静态资源文件夹： /static (or /public or /resources or /META-INF/resources) 访问 ： 当前项目根路径&#x2F; + 静态资源名 原理： 静态映射 &#x2F;**。 当请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面 改变静态资源的文件夹 12345spring: resources: static-locations: [classpath:/haha/] 就是把resources下的haha文件夹设置为静态文件夹，其他的默认都不是静态文件夹了 使用注解方式配置静态资源的访问 用了这个配置类（继承WebMvcConfigurationSupport）之后，springboot对springmvc相关的自动配置都不会实现了，视图解析器，静态资源路径之类的 Spring Boot中只能有一个WebMvcConfigurationSupport配置类是真正起作用的，对于这个问题，其实可以通过implements WebMvcConfigurer来解决，多个不同的类实现这个接口后的配置都可以正常运行。 这是继承WebMvcConfirurationSupport之后配置静态资源 12345678910111213141516171819package com.itheima.reggie.config;import lombok.extern.slf4j.Slf4j;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;@Slf4j@Configurationpublic class WebMvcConfig extends WebMvcConfigurationSupport &#123; @Override protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123; log.info(&quot;开始进行静态资源映射&quot;); //这个的意思是 /backend/**请求对应到 类路径下的backend文件夹下的资源 registry.addResourceHandler(&quot;/backend/**&quot;).addResourceLocations(&quot;classpath:backend/&quot;); registry.addResourceHandler(&quot;/front/**&quot;).addResourceLocations(&quot;classpath:front/&quot;); &#125;&#125; 也可以用类来继承WebMvcConfigurer来配置拦截器和静态资源 123456789101112131415161718192021222324252627282930package com.itheima.reggie.config;import lombok.extern.slf4j.Slf4j;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Slf4j@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; //配置拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginInterceptor()) .addPathPatterns(&quot;/**&quot;) //所有请求都被拦截包括静态资源 .excludePathPatterns(&quot;/employee/login&quot;,&quot;/employee/logout&quot;,&quot;/backend/**&quot;,&quot;/front/**&quot;); //放行的请求 &#125; //配置静态资源的映射 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; log.info(&quot;开始进行静态资源映射&quot;); //这个的意思是 /backend/**请求对应到 类路径下的backend文件夹下的资源 registry.addResourceHandler(&quot;/backend/**&quot;).addResourceLocations(&quot;classpath:backend/&quot;); registry.addResourceHandler(&quot;/front/**&quot;).addResourceLocations(&quot;classpath:front/&quot;); &#125;&#125; 静态资源访问前缀：默认是无前缀 这个访问前缀的设置，只是一个前缀，和静态资源所在哪个文件夹没有关系 application.yml 123spring: mvc: static-path-pattern: /res/** 当前项目+static-path-patter+静态资源文件名才能够访问到静态资源 就是&#x2F;res&#x2F;index.html是去静态文件夹(不一定是res)中找index.html文件 webjars https://www.webjars.org/ pom中导入依赖 就是常用的jQuery css等jar包放在org.webjars包中导入后，可以通过下面的方式访问 &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; 自动映射到 &#x2F;webjars&#x2F;** 问地址：http://localhost:8080/webjars/jquery&#x2F;3.5.1&#x2F;jquery.js 后面地址要按照依赖里面的包路径 因为springboot是每个项目下自带一个tomcat所以可以ip:port&#x2F;文件 欢迎页支持 静态资源路径下index.html 就是工程路径默认访问的是static(静态资源文件夹)下的index.html 可以配置静态资源路径（就是设置静态文件夹为别的而不是static） 但是不可以配置静态资源的访问前缀。否则导致 index.html不能被默认访问 这个会导致这个欢迎页支持失效 123spring: mvc: static-path-pattern: /res/** Favication 这个就是设置浏览器导航栏上的小图标 把想用的图片重命名为favicon.ico favicon.ico 放在静态资源目录下即可。 这个也会导致Favication失效 123spring: mvc: static-path-pattern: /res/** 请求处理获取请求参数的方式和springmvc相同 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475@RestControllerpublic class ParameterTestController &#123; // car/2/owner/zhangsan @GetMapping(&quot;/car/&#123;id&#125;/owner/&#123;username&#125;&quot;) public Map&lt;String,Object&gt; getCar(@PathVariable(&quot;id&quot;) Integer id, @PathVariable(&quot;username&quot;) String name, @PathVariable Map&lt;String,String&gt; pv, @RequestHeader(&quot;User-Agent&quot;) String userAgent, //这个是以map形式获取所有请求头信息 @RequestHeader Map&lt;String,String&gt; header, @RequestParam(&quot;age&quot;) Integer age, @RequestParam(&quot;inters&quot;) List&lt;String&gt; inters, //以map形式获取所有参数 @RequestParam Map&lt;String,String&gt; params, @CookieValue(&quot;_ga&quot;) String _ga, @CookieValue(&quot;_ga&quot;) Cookie cookie)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();// map.put(&quot;id&quot;,id);// map.put(&quot;name&quot;,name);// map.put(&quot;pv&quot;,pv);// map.put(&quot;userAgent&quot;,userAgent);// map.put(&quot;headers&quot;,header); map.put(&quot;age&quot;,age); map.put(&quot;inters&quot;,inters); map.put(&quot;params&quot;,params); map.put(&quot;_ga&quot;,_ga); System.out.println(cookie.getName()+&quot;===&gt;&quot;+cookie.getValue()); return map; &#125; @PostMapping(&quot;/save&quot;) public Map postMethod(@RequestBody String content)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;content&quot;,content); return map; &#125; //1、语法： 请求路径：/cars/sell;low=34;brand=byd,audi,yd //2、SpringBoot默认是禁用了矩阵变量的功能 // 手动开启：原理。对于路径的处理。UrlPathHelper进行解析。 // removeSemicolonContent（移除分号内容）支持矩阵变量的 //3、矩阵变量必须有url路径变量才能被解析 @GetMapping(&quot;/cars/&#123;path&#125;&quot;) public Map carsSell(@MatrixVariable(&quot;low&quot;) Integer low, @MatrixVariable(&quot;brand&quot;) List&lt;String&gt; brand, @PathVariable(&quot;path&quot;) String path)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;low&quot;,low); map.put(&quot;brand&quot;,brand); map.put(&quot;path&quot;,path); return map; &#125; // /boss/1;age=20/2;age=10 @GetMapping(&quot;/boss/&#123;bossId&#125;/&#123;empId&#125;&quot;) public Map boss(@MatrixVariable(value = &quot;age&quot;,pathVar = &quot;bossId&quot;) Integer bossAge, @MatrixVariable(value = &quot;age&quot;,pathVar = &quot;empId&quot;) Integer empAge)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;bossAge&quot;,bossAge); map.put(&quot;empAge&quot;,empAge); return map; &#125;&#125; 单独提没学过的注解，@RequestAttribute 123456789101112131415161718192021222324252627282930313233343536package com.atguigu.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestAttribute;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.RestController;import javax.servlet.http.HttpServletRequest;import java.util.HashMap;import java.util.Map;@Controllerpublic class HelloController &#123;@GetMapping(&quot;/goto&quot;) public String goToPage(HttpServletRequest request)&#123; request.setAttribute(&quot;msg&quot;,&quot;成功了..&quot;); request.setAttribute(&quot;code&quot;,200); return &quot;forward:/success&quot;; //转发到 /success请求&#125;//演示获取请求域中的内容，有两种方式，一种是HttpServletRequest，另一种是@RequestAttribute @ResponseBody //@ResponseBody是用来就是直接把返回值当成内容相应给浏览器 @GetMapping(&quot;/success&quot;) public Map success(@RequestAttribute(&quot;msg&quot;) String msg,HttpServletRequest request)&#123; Object attribute = request.getAttribute(&quot;code&quot;); Map&lt;String,Object&gt; map=new HashMap&lt;&gt;(); map.put(&quot;reMethod_msg&quot;,attribute); map.put(&quot;anotation_msg&quot;,msg); return map;&#125;&#125; @MatrixVariable &#x2F;cars&#x2F;path;low&#x3D;34;brand&#x3D;byd,audi,yd 这个用;分割开的就是矩阵变量 页面开发，cookie仅用了，session里的内容怎么使用? 本来原理：session.set(a,b)—-》每一个session都有一个id保存在cookie中—&gt;cookie每次请求都会发送 现在cookie禁用了，就得用矩阵变量来带cookie内容 url重写：&#x2F;abc;jessionid&#x3D;xxxx 把cookie的值使用矩阵变量的方式传递过来 &#x2F;cars&#x2F;path;low&#x3D;34;brand&#x3D;byd,audi,yd 一个key中有多个value用逗号隔开，每个key之间是分号 12345678910111213141516171819202122232425262728293031//1、语法： 请求路径：/cars/sell;low=34;brand=byd,audi,yd//2、SpringBoot默认是禁用了矩阵变量的功能// 手动开启：原理。对于路径的处理。UrlPathHelper进行解析。// removeSemicolonContent（移除分号内容）支持矩阵变量的//3、矩阵变量必须有url路径变量才能被解析，这个&#123;path&#125;就是url路径变量@GetMapping(&quot;/cars/&#123;path&#125;&quot;)public Map carsSell(@MatrixVariable(&quot;low&quot;) Integer low, @MatrixVariable(&quot;brand&quot;) List&lt;String&gt; brand, @PathVariable(&quot;path&quot;) String path)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;low&quot;,low); map.put(&quot;brand&quot;,brand); map.put(&quot;path&quot;,path); return map;&#125;// /boss/1;age=20/2;age=10// 这个就是矩阵变量要和路径一起看，就是相当于找年龄为20的老板底下年龄为10的员工，1代表老板2代表员工//这个例子是当两个矩阵变量名相同的时候怎么获取@GetMapping(&quot;/boss/&#123;bossId&#125;/&#123;empId&#125;&quot;)//pathVar是public Map boss(@MatrixVariable(value = &quot;age&quot;,pathVar = &quot;bossId&quot;) Integer bossAge, @MatrixVariable(value = &quot;age&quot;,pathVar = &quot;empId&quot;) Integer empAge)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;bossAge&quot;,bossAge); map.put(&quot;empAge&quot;,empAge); return map;&#125; 配置文件 让矩阵变量生效的配置要自己修改 12345678910111213141516171819202122232425262728293031323334353637383940package com.atguigu.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.filter.HiddenHttpMethodFilter;import org.springframework.web.servlet.config.annotation.PathMatchConfigurer;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import org.springframework.web.util.UrlPathHelper;@Configuration(proxyBeanMethods = false)public class WebConfig &#123; //这个是用来把那个发送put请求时候那个所用的参数从_method变为自己想要的 /* @Bean public HiddenHttpMethodFilter hiddenHttpMethodFilter()&#123; HiddenHttpMethodFilter methodFilter=new HiddenHttpMethodFilter(); methodFilter.setMethodParam(&quot;_m&quot;); return methodFilter; &#125; */ /* 让矩阵变量生效的配置 */ @Bean public WebMvcConfigurer webMvcConfigurer()&#123; return new WebMvcConfigurer() &#123; @Override public void configurePathMatch(PathMatchConfigurer configurer) &#123; UrlPathHelper urlPathHelper=new UrlPathHelper(); //不移除;后面的内容，矩阵变量功能可以生效 urlPathHelper.setRemoveSemicolonContent(false); configurer.setUrlPathHelper(urlPathHelper); &#125; &#125;; &#125;&#125; Thymeleaf模板引擎这个地方和springmvc都是一样的 导入starter 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 这个内容就是前缀和后缀 开发页面 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/h1&gt;&lt;h2&gt; &lt;!--这里这个路径为/link 这里/默认是项目的路径 --&gt; &lt;a th:href=&quot;@&#123;link&#125;&quot;&gt;去百度&lt;/a&gt;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 在application.yml中配置 表示当前项目的访问路径为&#x2F;world 123server: servlet: context-path: /world 则此时上面@{link}路径为&#x2F;world&#x2F;link 拦截器可以用preHandler方法进行一个登陆检查 &#x2F;* 登录检查 1、配置好拦截器要拦截哪些请求 2、把这些配置放在容器中*&#x2F;@Slf4j&#x2F;&#x2F;实现HandlerInterceptor让类变成拦截器类public class LoginInterceptor implements HandlerInterceptor { &#x2F;** 目标方法执行之前 @param request @param response @param handler @return @throws Exception*&#x2F;@Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String requestURI &#x3D; request.getRequestURI();&#x2F;&#x2F;log.info方法{}来接受后面的第二个参数log.info(“preHandle拦截的请求路径是{}”,requestURI); &#x2F;&#x2F;登录检查逻辑 HttpSession session &#x3D; request.getSession(); Object loginUser &#x3D; session.getAttribute(“loginUser”); if(loginUser !&#x3D; null){&#x2F;&#x2F;放行return true;} &#x2F;&#x2F;拦截住。未登录。跳转到登录页request.setAttribute(“msg”,”请先登录”);&#x2F;&#x2F; re.sendRedirect(“&#x2F;“);request.getRequestDispatcher(“&#x2F;“).forward(request,response); return false;} &#x2F;** 目标方法执行完成以后 @param request @param response @param handler @param modelAndView @throws Exception*&#x2F;@Overridepublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { &#x2F;&#x2F;log.info方法{}来接受后面的第二个参数log.info(“postHandle执行{}”,modelAndView);} /** * 页面渲染以后 * @param request * @param response * @param handler * @param ex * @throws Exception */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; //log.info方法&#123;&#125;来接受后面的第二个参数 log.info(&quot;afterCompletion执行异常&#123;&#125;&quot;,ex); &#125; &#125; 12345678910111213141516171819202122232425262728293031​ log.info(&quot;postHandle执行&#123;&#125;&quot;,modelAndView);modelAndView对象中view属性存储的是接下来要跳转的视图，model是储存的这个视图中的内容（也就是请求域中的内容）在配置文件中配置拦截器LoginInterceptor类就是上面那个拦截器的类 * ``` /** * 1、编写一个拦截器实现HandlerInterceptor接口 * 2、拦截器注册到容器中（实现WebMvcConfigurer的addInterceptors） * 3、指定拦截规则【如果是拦截所有，静态资源也会被拦截】 */ @Configuration public class AdminWebConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginInterceptor()) .addPathPatterns(&quot;/**&quot;) //所有请求都被拦截包括静态资源 .excludePathPatterns(&quot;/&quot;,&quot;/login&quot;,&quot;/css/**&quot;,&quot;/fonts/**&quot;,&quot;/images/**&quot;,&quot;/js/**&quot;); //放行的请求 &#125; &#125; WebMvcConfigurer和WebMvcSupport AdminWebConfig继承了WebMvcCongfigurer配置拦截器，不会让原本springboot对springmvc的配置失效 Spring Boot中只能有一个WebMvcConfigurationSupport配置类是真正起作用的，对于这个问题，其实可以通过implements WebMvcConfigurer来解决，多个不同的类实现这个接口后的配置都可以正常运行。 文件上传这个真的写的好的文件上传还得看springmvc，和瑞吉外卖文件中的那个 文件上传要springmvc，瑞吉外卖和springboot中三个一起看 文件上传的表单 生活照那里是多文件上传，所以标签后面用multiple 123456789101112131415161718192021222324252627282930313233343536373839处理文件上传的controller```java/** * MultipartFile 自动封装上传过来的文件 * @param email * @param username * @param headerImg * @param photos * @return */@PostMapping(&quot;/upload&quot;)public String upload(@RequestParam(&quot;email&quot;) String email, @RequestParam(&quot;username&quot;) String username, @RequestPart(&quot;headerImg&quot;) MultipartFile headerImg, @RequestPart(&quot;photos&quot;) MultipartFile[] photos) throws IOException &#123; log.info(&quot;上传的信息：email=&#123;&#125;，username=&#123;&#125;，headerImg=&#123;&#125;，photos=&#123;&#125;&quot;, email,username,headerImg.getSize(),photos.length); if(!headerImg.isEmpty())&#123; //保存到文件服务器，OSS服务器 String originalFilename = headerImg.getOriginalFilename(); headerImg.transferTo(new File(&quot;H:\\\\cache\\\\&quot;+originalFilename)); &#125; if(photos.length &gt; 0)&#123; for (MultipartFile photo : photos) &#123; if(!photo.isEmpty())&#123; //拿到原始的文件名 String originalFilename = photo.getOriginalFilename(); //这里的意思是设置文件的保存的位置 photo.transferTo(new File(&quot;H:\\\\cache\\\\&quot;+originalFilename)); &#125; &#125; &#125; return &quot;main&quot;;&#125; 1这里使用文件上传的时候，一定要保证H:\\\\cache 路径存在，后面的文件名字就是上传文件保存到服务器上的名字 max-file-size是修改文件上传单个文件最大为10MB，max-request-size是指上传所有文件最大为100MB 默认max-file-size为1 默认max-request-size为10 12345spring: servlet: multipart: max-file-size: 10MB max-request-size: 100MB 异常处理默认规则 默认情况下，Spring Boot提供/error处理所有错误的映射 对于机器客户端（比如拦包之后看），它将生成JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。对于浏览器客户端，响应一个“ whitelabel”错误视图，以HTML格式呈现相同的数据 非浏览器端 浏览器端 自定义错误页 error&#x2F;404.html error&#x2F;5xx.html；有精确的错误状态码页面就匹配精确，没有就找 4xx.html；如果都没有就触发白页 5xx.html可以对应任何5开头的错误，也就是服务器端错误 404.html则是匹配精确的状态码404 5xx.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;500&lt;/h1&gt;&lt;!--获取错误信息--&gt;&lt;p th:text=&quot;$&#123;message&#125;&quot;&gt;&lt;/p&gt;&lt;!--打印错误的堆栈信息--&gt;&lt;p th:text=&quot;$&#123;trace&#125;&quot;&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 404.html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;404&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 原生组件注入第一种方式，利用各种注解的方式 1.Servlet 在主程序上加上这个注解 &#x2F;&#x2F;这个是把Servlet，Filter，Listener当组件加入进来，要不然不生效，默认扫描的包是主程序所在的包，可以通过basePackages自己设置@ServletComponentScan(basePackages &#x3D; “com.atguigu”) 12345678910111213141516package com.atguigu;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.web.servlet.ServletComponentScan;//这个是把Servlet当组件加入进来，要不然不生效，默认扫描的包是主程序所在的包@ServletComponentScan(basePackages = &quot;com.atguigu&quot;)@SpringBootApplicationpublic class BootWebApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(BootWebApplication.class, args); &#125;&#125; servlet包下的 webServlet 12345678910111213141516171819package com.atguigu;import org.springframework.boot.web.servlet.ServletComponentScan;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@javax.servlet.annotation.WebServlet(&quot;/my&quot;) //这个直接响应没有经过spring的拦截器public class WebServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.getWriter().write(&quot;666&quot;); &#125;&#125; 两个都做到了，Servlet才能够生效 监听器 123456789101112131415161718192021package com.atguigu.servlet;import lombok.extern.slf4j.Slf4j;import javax.servlet.ServletContextEvent;import javax.servlet.annotation.WebListener;@Slf4j@WebListenerpublic class ServletContextListener implements javax.servlet.ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent sce) &#123; log.info(&quot;ServletContextListener监听到项目初始化工程&quot;); &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; log.info(&quot;ServletContextListener监听到项目销毁工程&quot;); &#125;&#125; 过滤器 123456789101112131415161718192021222324252627282930313233package com.atguigu.servlet;import lombok.extern.slf4j.Slf4j;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import java.io.IOException;import java.util.logging.LogRecord;@Slf4j//单*是servlet家的写法，/**是spring家的写法//拦截/css和/images等静态资源的请求@WebFilter(urlPatterns = &#123;&quot;/css/*&quot;,&quot;/images/*&quot;&#125;)public class MyFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123;log.info(&quot;MyFilter初始化完成&quot;); &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; log.info(&quot;MyFilter工作&quot;); filterChain.doFilter(servletRequest,servletResponse); &#125; @Override public void destroy() &#123;log.info(&quot;MyFilter销毁&quot;); &#125;&#125; 第二种方式 使用RegistrationBean 创建一个配置类MygistConfig 123456789101112131415161718192021222324252627282930313233343536373839404142package com.atguigu.servlet;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.boot.web.servlet.ServletListenerRegistrationBean;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.Arrays;@Configurationpublic class MyRegistConfig &#123; //配置Servlet组件 @Beanpublic ServletRegistrationBean myServlet()&#123; WebServlet webServlet = new WebServlet(); return new ServletRegistrationBean(webServlet,&quot;/my&quot;,&quot;/,y02&quot;); &#125; //配置Filter组件 @Bean public FilterRegistrationBean myFilter()&#123; MyFilter myFilter = new MyFilter(); //这个相当于filter拦截的路径和上面的servlet规定的路径是相同的 //return new FilterRegistrationBean(myFilter,myServlet()); FilterRegistrationBean filterRegistrationBean=new FilterRegistrationBean(myFilter); //参数是一个路径的集合 filterRegistrationBean.setUrlPatterns(Arrays.asList(&quot;/my&quot;,&quot;/css/*&quot;)); return filterRegistrationBean; &#125; //配置Listener组件 @Bean public ServletListenerRegistrationBean myListener()&#123; ServletContextListener servletContextListener =new ServletContextListener(); return new ServletListenerRegistrationBean(servletContextListener); &#125;&#125; 一个问题为什么Servlet中的路径没有被spring的拦截器拦截 整合数据源数据源的自动配置 1.导入jdbc场景 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 导入jdbc驱动 12345&lt;!--jdbc驱动--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 当想使用的版本不是8.0.22时的修改方法 就是jdbc驱动的版本和数据库版本要相同 默认版本：&lt;mysql.version&gt;8.0.22&lt;&#x2F;mysql.version&gt; 第一种方法 1、直接依赖引入具体版本（maven的就近依赖原则） 1234567&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.49&lt;/version&gt; &lt;/dependency&gt; 第二种方法 2、重新声明版本（maven的属性的就近优先原则) 123456789 &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;mysql.version&gt;5.1.49&lt;/mysql.version&gt;&lt;/properties&gt; 分析自动配置的类 JdbcTemplateAutoConfiguration：JdbcTemplate的自动配置，可以对数据库crud application.yml 配置： 这个时mysql5的一个配置 123456spring: datasource: url: jdbc:mysql://localhost:3306/db_account username: root password: root driver-class-name: com.mysql.jdbc.Driver 12345678910spring: datasource: url: jdbc:mysql://localhost:3306/db_account username: root password: root driver-class-name: com.mysql.jdbc.Driver #下面这个是配置是修改jdbctemplate，这个写出的是查询时间为3秒 jdbc: template: query-timeout: 3 测试： 1234567891011121314151617181920@Slf4j@SpringBootTestclass Boot05WebAdminApplicationTests &#123; @Autowired JdbcTemplate jdbcTemplate; @Test void contextLoads() &#123;// jdbcTemplate.queryForObject(&quot;select * from account_tbl&quot;)// jdbcTemplate.queryForList(&quot;select * from account_tbl&quot;,) Long aLong = jdbcTemplate.queryForObject(&quot;select count(*) from account_tbl&quot;, Long.class); log.info(&quot;记录总数：&#123;&#125;&quot;,aLong); &#125;&#125; 使用Druid数据源1.官方starter 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.17&lt;/version&gt; &lt;/dependency&gt; 2.配置文件示例 1234567891011121314151617181920212223242526272829303132333435spring: datasource: url: jdbc:mysql://localhost:3306/db_account username: root password: root driver-class-name: com.mysql.jdbc.Driver #这个不确定是否需要 type: com.alibaba.druid.pool.DruidDataSource druid: aop-patterns: com.atguigu.admin.* #监控SpringBean filters: stat,wall # 底层开启功能，stat（sql监控），wall（防火墙） stat-view-servlet: # 配置监控页功能 enabled: true login-username: admin login-password: admin resetEnable: false web-stat-filter: # 监控web enabled: true urlPattern: /* exclusions: &#x27;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&#x27; filter: stat: # 对上面filters里面的stat的详细配置 slow-sql-millis: 1000 logSlowSql: true enabled: true wall: enabled: true config: drop-table-allow: false 整合Mybatis1.导入应用场景 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt; &lt;/dependency&gt; Mapper： 只要我们写的操作MyBatis的接口标准了 @Mapper 就会被自动扫描进来 application.yml 12345#配置mybatis规则mybatis: config-location: classpath:mybatis/mybatis-config.xml #全局配置文件位置 mapper-locations: classpath:mybatis/mapper/*.xml #sql映射文件位置 还是和以前一样，接口写在mapper文件夹中用@Mapper标记，映射文件写在上面规定的位置 可以在Controller里直接通过@Autowired进行自动装配得到mapper接口的代理实现类 Mapper.xml文件，这都和以前一样 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.atguigu.admin.mapper.AccountMapper&quot;&gt;&lt;!-- public Account getAcct(Long id); --&gt; &lt;select id=&quot;getAcct&quot; resultType=&quot;com.atguigu.admin.bean.Account&quot;&gt; select * from account_tbl where id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; Mybatis的全局配置文件 mybatis-config.xml文件还是可以和以前一样，配置文件 也有另外一种方式配置mybatis-config.xml 在application.yml配置文件中修改mybatis.configuration下面的内容，就是在配置mybatis全局配置文件 application.yml 123456789101112# 配置mybatis规则mybatis:# config-location: classpath:mybatis/mybatis-config.xml mapper-locations: classpath:mybatis/mapper/*.xml configuration: #这个就是相当于mybatis全局配置中把数据库字段t_user映射到类的属性中tUser驼峰式 map-underscore-to-camel-case: true 可以不写全局；配置文件，所有全局配置文件的配置都放在configuration配置项中即可 用配置文件修改mybatis全局配置，就要把config-location选项注解掉 整合mybatis的一个大体步骤： 导入mybatis官方starter 编写mapper接口。标准@Mapper注解 编写sql映射文件并绑定mapper接口 在application.yaml中指定Mapper配置文件的位置，以及指定全局配置文件的信息 （建议；配置在mybatis.configuration） Mybatis注解配置混合版注解配置混合版就是简单的方法通过@Select注解直接实现，复杂方法还是mapper映射文件来实现 12345&lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;​ insert into city(`name`,`state`,`country`) values (#&#123;name&#125;,#&#123;state&#125;,#&#123;country&#125;);&lt;/insert&gt; 上面这个映射文件中的sql语句对应的注解版本 @Insert(“insert into city(name,state,country) values (#{name},#{state},#{country})”) @Options(useGeneratedKeys &#x3D; true,keyProperty &#x3D; “id”) public void insert(City city) springboot事务管理12//这里是遇到所有的异常都回滚的意思@Transactional(rollbackFor = Exception.class) 当一个方法中有多个事物的时候就可以加上这个注解 单元测试Spring Boot 2.2.0 版本开始引入 JUnit 5 作为单元测试默认库 测试类和java主程序类必须在同一个包下，也就是包名必须相同 现在的默认的测试使用方法 1234567891011121314151617181920212223242526package com.atguigu.mybatisplus;import com.atguigu.mybatisplus.pojo.User;import com.atguigu.mybatisplus.service.UserService;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.util.ArrayList;import java.util.List;@SpringBootTestpublic class MybatisPlusServiceTest &#123; @Autowired private UserService userService; /* 查询记录个数的测试 */ @Test public void testSelect()&#123; &#125;&#125; 现在导入test的场景 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; springboot整合junit之后就不用再自己导包了 以前： 必须要在类上标注这两个注解 @SpringBootTest + @RunWith(SpringTest.class) SpringBoot整合Junit以后。 编写测试方法：@Test标注（注意需要使用junit5版本的注解） Junit类具有Spring的功能，@Autowired、比如 @Transactional 标注测试方法，测试完成后自动回滚 Junit5常用注解 **@Test :**表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试 **@ParameterizedTest :**表示方法是参数化测试，下方会有详细介绍 **@RepeatedTest :**表示方法可重复执行，下方会有详细介绍 **@DisplayName :**为测试类或者测试方法设置展示名称 **@BeforeEach :**表示在每个单元测试之前执行 **@AfterEach :**表示在每个单元测试之后执行 **@BeforeAll :**表示在所有单元测试之前执行 **@AfterAll :**表示在所有单元测试之后执行 **@Tag :**表示单元测试类别，类似于JUnit4中的@Categories **@Disabled :**表示测试类或测试方法不执行，类似于JUnit4中的@Ignore **@Timeout :**表示测试方法运行如果超过了指定时间将会返回错误 **@ExtendWith :**为测试类或测试方法提供扩展类引用 测试注解的使用方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.atguigu.boot;import org.junit.jupiter.api.*;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.jdbc.core.JdbcTemplate;import javax.sql.rowset.JdbcRowSet;import java.util.concurrent.TimeUnit;//给这个测试类起名字@DisplayName(&quot;juunit功能测试类&quot;)//有了这个注解才能实现springboot的自动装配功能@SpringBootTestpublic class Junit5Test &#123; //点击这个类旁边的执行号，可以执行全部的测试方法 //给这个测试方法起名字 @DisplayName(&quot;测试display注解&quot;) @Test void testDisplayName()&#123; System.out.println(1); &#125; @Disabled @DisplayName(&quot;测试方法二&quot;) @Test void test2()&#123; System.out.println(2); &#125; //规定方法超时时间，超出这个时间就会抛异常 @Timeout(value=500,unit= TimeUnit.MILLISECONDS) @Test void testTimeOut()&#123; Thread.sleep(500L); &#125; @BeforeEach //在执行的测试方法都执行之前进行执行，执行的测试方法可以是一个，也可以是一个类中的所有方法 void testBeforeEach()&#123; System.out.println(&quot;测试就要开始了。。&quot;); &#125; @AfterEach void testAfterEach()&#123; System.out.println(&quot;测试就要结束了&quot;); &#125; @BeforeAll static void testBeaforeAll()&#123; System.out.println(&quot;所有测试就要开始了&quot;); &#125; @AfterAll static void testAfterAll()&#123; System.out.println(&quot;所有测试就要结束了&quot;); &#125; @Test @RepeatedTest(5) //重复执行5次 public void test3()&#123; System.out.println(5); &#125;&#125; 断言","categories":[],"tags":[]},{"title":"SpringMVC","slug":"springmvc","date":"2022-09-29T15:31:35.000Z","updated":"2023-04-10T13:20:03.221Z","comments":true,"path":"2022/09/29/springmvc/","link":"","permalink":"http://example.com/2022/09/29/springmvc/","excerpt":"","text":"SpringMVC（整合themeleaf）Thymeleaf入门 Thymeleaf教程（10分钟入门） (biancheng.net) springMVC的简介mybatis是持久层框架，spring可以利用自己的两大特性来整合框架 SpringMVC就是一种MVC框架，基于servlet的扩展，简化传统的jsp+servlet模式下的web开发方式 1.把传统MVC框架里面的Controller控制器做了拆分，分成了前端控制器DispatcherServlet和后端控制器Controller 2.在视图层面可以接受不同的视图例如jsp和thymeleaf等等 3.springmvc工作流程：浏览器请求首先会去经过spring mvc里面的核心控制器DispatcherServlet，它主要是把请求分发道对应的Controller里面，而Controller里面处理完业务逻辑之后呢，会返回一个ModelAndView然后DispatcherServlet会去寻找一个或者多个ViewResolver视图解析器，找到ModelAndView指定的视图并且把数据展示给客户端 MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分 M：Model，模型层，指工程中的JavaBean，作用是处理数据 JavaBean分为两类： 一类称为实体类Bean：专门存储业务数据的，如 Student、User 等 一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。 V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据 C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器 MVC的工作流程： 用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller 调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果 找到相应的View视图，渲染数据后最终响应给浏览器 什么是SpringMVC 三层架构分为表述层（前端页面和后端servlet），业务逻辑层（service），数据访问层（dao） springMVC就是 Spring 为表述层开发提供的一整套完备的解决方案 springMVC就是封装了Servlet 特点： 1.基于原生的servlet，封装得到了功能强大的前端控制器DispatcherServlet，对请求和响应进行统一 处理 2.Spring 家族原生产品，与 IOC 容器等基础设施无缝对接 3.内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可 入门案例创建web工程 pom.xml 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;spring_mvc_helloworld&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt;&lt;/project&gt; 加上打包方式 1&lt;packaging&gt;war&lt;/packaging&gt; 点击加号创建web.xml 路径为D:\\IDEAjava工程\\ssm\\spring_mvc_helloworld\\src\\main\\webapp\\WEB-INF\\web.xml 引入依赖 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;spring_mvc_helloworld&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- SpringMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- ServletAPI --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring5和Thymeleaf整合包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;version&gt;3.0.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 用thymeleaf专门用的依赖 slf4j日志门面（里面是接口）的实现就是这个logback（里面是实现类） 123456&lt;!-- 日志 --&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt; spring整合thymeleaf 123456&lt;!-- Spring5和Thymeleaf整合包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;version&gt;3.0.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; 配置SpringMVC（整合themeleaf）配置web.xml tomcat中有一个url-pattern以.jsp为结尾的servlet-mapping（它有一个专门处理.jsp结尾的访问的servlet） 所以不能把url-pattern设置为&#x2F;*， 这样所有后缀为.jsp的访问前端控制器就处理不了了 12342.spring mvc中dispatcherServlet配置为/*访问请求转发*.jsp和访问jsp页面的时候访问不到的原因： 默认在%TOMCAT_HOME%/conf/web.xml中配置了*.jsp由JspServelt来处理，当我们将spring mvc的拦截规则配置为/*的时候，按照servlet的匹配规则，则路径匹配会优先于扩展匹配,导致对jsp的请求会被拦截掉。当spring mvc配置为/,表示未默认servelt，只有当请求没有对应的servlet处理时，才交给它处理，当我们请求jsp时，刚好有从%TOMCAT_HOME%/conf/web.xml中继承过来的JspServlet会处理对jsp请求的处理，所以会访问到jsp页面。 url-pattern中&#x2F;和&#x2F;*的区别： &#x2F;:匹配浏览器向服务器发送的所有请求(不包括.jsp) &#x2F;*:匹配浏览器向服务器发送的所有请求(包括.jsp) 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--配置SpringMVC的前端控制器DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 创建请求控制器（控制层） spring-MVC封装了Servlet所以现在不需要我们手动创建Servlet 前端控制器DispatcherServlet对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即请求控制器 请求控制器就由一个POJO（普通的java类担任），因此需要通过@Controller注解将它标识为一个控制层组件，交给springioc管理，此时springmvc才能识别控制器的存在 请求控制器中每一个处理请求的方法成为控制器方法 在java包下com.atguigu.controller下的HelloController类 12345678910package com.atguigu.controller;import org.springframework.stereotype.Controller;//标识为控制层组件@Controllerpublic class HelloController &#123; &#125; 创建SpringMVC配置文件 SpringMVC的配置文件默认的位置和名称： 位置：WEB-INF下（暂时，后来都是resources） 名称：-servlet.xml ，当前配置下的配置文件名为SpringMVC-servlet.xml 这个是指web.xml文件中的前置配置器的的内容 扫描controller下的所有类，让控制类上的@Controller起作用，交给ioc管理 12&lt;!--扫描控制层组件--&gt;&lt;context:component-scan base-package=&quot;com.atguigu.controller&quot;&gt;&lt;/context:component-scan&gt; themeleaf中有一个逻辑视图还有一个物理视图 物理视图：当前要访问的这个页面这个完整的路径 逻辑视图： 物理视图把视图前缀去掉，视图后缀去掉，换句话说逻辑视图加配置文件中的视图前缀和视图后缀就是我们要访问的文件的路径 下面是配置文件中有视图前缀和视图后缀的配置 &#x2F;在web中还是能映射到webapp下面 1234567891011&lt;bean class=&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;&gt; &lt;!-- 视图前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/templates/&quot;/&gt; &lt;!-- 视图后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.html&quot;/&gt; &lt;!--说明是以html5作为我们的视图--&gt; &lt;property name=&quot;templateMode&quot; value=&quot;HTML5&quot;/&gt; &lt;!--说明当前视图的编码是UTF-8--&gt; &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot; /&gt;&lt;/bean&gt; 如果要往&#x2F;WEB-INF&#x2F;templates&#x2F;index.html去跳转，不需要写出这个完整的路径，只需要保留index SpringMVC功能的测试 第一个框是重新启动工程时默认是重新部署，而不是关了重启 第二个框时当前窗口失去焦点的时候，默认就是更新类和资源 现在webapp下没有index.html文件，启动工程是404，我们需要让它直接访问的就是templates下面的index.html 在控制层添加方法 HelloController 123456789101112131415161718package com.atguigu.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;//标识为控制层组件@Controllerpublic class HelloController &#123; //&quot;/&quot;是服务器解析的绝对路径 @RequestMapping(&quot;/&quot;) //这个标识是让对应的请求给这个方法来处理,当请求路径和注解中value值相同就可以用这个方法处理请求public String protal()&#123;//将逻辑视图返回 return &quot;index&quot;;&#125;&#125; thymeleaf@{&#x2F;}的使用这里使用themeleaf能够将&#x2F;按照服务器那样解析，正常html中都是按照浏览器解析的 1&lt;a th:href=&quot;@&#123;/hello&#125;&quot;&gt;测试SpringMVC&lt;/a&gt; index和success都是在&#x2F;WEB-INF&#x2F;templates&#x2F;目录下 index.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;index.html&lt;/h1&gt;&lt;!--这里使用themeleaf能够将/按照服务器那样解析，正常html中都是按照浏览器解析的--&gt;&lt;a th:href=&quot;@&#123;/hello&#125;&quot;&gt;测试SpringMVC&lt;/a&gt;&lt;a href=&quot;/hello&quot;&gt;测试绝对路径&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 使用thymeleaf必须要有这一行 1&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; 控制层HelloController添加方法 1234@RequestMapping(&quot;/hello&quot;)public String hello()&#123; return &quot;success&quot;;&#125; success.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;成功&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;success.html&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 这样点击页面上SpringMVC就可以访问到success.html 入门案例的总结和扩展SpringMVC和Thymeleaf的整合使用 1.浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器 DispatcherServlet处理。 2.前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器， 将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，若匹配成功，该注解所标识的 控制器方法就是处理请求的方法。 3.处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会 被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视 图所对应页面 渲染：就是获取用户传送的数据或者是数据库中的数据在页面上显示 web.xml的扩展 让springmvc的配置文件可以放在resources文件夹下 12345678&lt;init-param&gt; &lt;!--配置的是springmvc配置文件的路径--&gt; &lt;!--这个contextConfigLocation是固定的--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!--classpath指的是类路径，如果没有那指的还是WEB-INF下面--&gt; &lt;!--java和resources包下都是加载在类路径下--&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; 让工程启动时进行DispatcherServlet的初始化 DispatcherServlet初始化过程中，springMVC容器获取完成 1234567 &lt;!--作为框架的核心组件，在启动过程中有大量的初始化操作要做而这些操作放在第一次请求时才执行会严重影响访问速度因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--配置SpringMVC的前端控制器DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!--配置的是springmvc配置文件的路径--&gt; &lt;!--这个contextConfigLocation是固定的--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!--classpath指的是类路径，如果没有那指的还是WEB-INF下面--&gt; &lt;!--java和resources包下都是加载在类路径下--&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--作为框架的核心组件，在启动过程中有大量的初始化操作要做而这些操作放在第一次请求时才执行会严重影响访问速度因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; @RequestMapping注解创建一个新的模块，按照上面那一样 静态页面都在&#x2F;WEB-INF&#x2F;templates下面 @RequestMapping注解的作用就是将请求和处理请求的控制器方法关联 起来，建立映射关系。 SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。 一启动服务器的页面的控制器 12345678910111213package com.atguigu.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class ProtalController &#123; @RequestMapping(&quot;/&quot;) public String protal()&#123; return &quot;index&quot;; &#125;&#125; @RequestMapping注解位置注解加在方法上，控制器方法具体所匹配的请求路径，就是类的注解value加上方法的注解value TestRequestMappingController 123456789101112131415package com.atguigu.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(&quot;/test&quot;)public class TestRequestMappingController &#123; //此时控制器方法所匹配的请求的请求路径为/test/hello @RequestMapping(&quot;/hello&quot;) public String hello()&#123; return &quot;success&quot;; &#125;&#125; @RequestMapping注解的value属性12345678910111213141516171819package com.atguigu.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controller//@RequestMapping(&quot;/test&quot;)public class TestRequestMappingController &#123; //@RequestMapping注解value属性 //作用：通过请求的请求路径匹配请求 //value属性是字符串数组类型，即当前浏览器所发送请求的请求路径匹配value属性中任何一个值 //则当前请求就会被注解所标识的方法进行处理 //value字符串数组任意请求路径匹配到这个控制器方法，都可以调用这个方法 @RequestMapping(&#123;&quot;/hello&quot;,&quot;/abc&quot;&#125;) public String hello()&#123; return &quot;success&quot;; &#125;&#125; index.html 测试 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;index.html&lt;/h1&gt;&lt;a th:href=&quot;@&#123;/hello&#125;&quot;&gt;测试@RequestMapping所标识的位置&lt;/a&gt;&lt;br/&gt;&lt;a th:href=&quot;@&#123;/abc&#125;&quot;&gt;测试@RequestMapping注解的value属性&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; @RequestMapping注解的method属性@RequestMapping注解的method属性通过请求的请求方式（get或post）匹配请求映射 @RequestMapping注解的method属性是一个RequestMethod类型的数组，表示该请求映射能够匹配 多种请求方式的请求 若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错 405：Request method ‘POST’ not supported TestRequestMappingController 12345678910111213141516171819202122package com.atguigu.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;@Controller//@RequestMapping(&quot;/test&quot;)public class TestRequestMappingController &#123;//3.@RequestMapping注解的method属性 //作用：通过请求的请求方法匹配请求 //method属性是RequestMethod类型的数组，即当前浏览器所发送请求的请求方式匹配method属性中的任何一个请求方式 //则当前请求就会被注解所标识的方法进行处理 @RequestMapping( value=&#123;&quot;/hello&quot;,&quot;/abc&quot;&#125;, method=&#123;RequestMethod.POST,RequestMethod.GET&#125; ) public String hello()&#123; return &quot;success&quot;; &#125;&#125; test 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;index.html&lt;/h1&gt;&lt;a th:href=&quot;@&#123;/hello&#125;&quot;&gt;测试@RequestMapping所标识的位置&lt;/a&gt;&lt;br/&gt;&lt;a th:href=&quot;@&#123;/abc&#125;&quot;&gt;测试@RequestMapping注解的value属性&lt;/a&gt;&lt;form th:action=&quot;@&#123;/hello&#125;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;测试@RequestMapping注解的method属性&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 派生注解，在@RequestMapping基础上结合请求方式的一些派生注解： 处理get请求的映射–&gt;@GetMapping 处理post请求的映射–&gt;@PostMapping 处理put请求的映射–&gt;@PutMapping 处理delete请求的映射–&gt;@DeleteMapping 用法就是把上面@RequestMapping换位上面的任意一个，相当于指定了method属性值的注解 2、常用的请求方式有get，post，put，delete 但是目前浏览器只支持get和post，若在form表单提交时，为method设置了其他请求方式的字符 串（put或delete），则按照默认的请求方式get处理 若要发送put和delete请求，则需要通过spring提供的过滤器HiddenHttpMethodFilter，在 RESTful部分会讲到 @RequestMapping注解的params属性 params中可以是任意多个表达式，每种表达式是不同的含义 test 可以看出来thymeleaf的’ ‘单引号里面是纯字符串，” “双引号中可以用各种表达式 123&lt;!--当thymeleaf中的路径带参数的时候两种用法都可以--&gt;&lt;a th:href=&quot;@&#123;/hello?username=admin&#125;&quot;&gt;测试@RequestMapping注解的params属性&lt;/a&gt;&lt;a th:href=&quot;@&#123;/hello(username=&#x27;admin&#x27;)&#125;&quot;&gt;测试@RequestMapping注解的params属性&lt;/a&gt; 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;index.html&lt;/h1&gt;&lt;a th:href=&quot;@&#123;/hello&#125;&quot;&gt;测试@RequestMapping所标识的位置&lt;/a&gt;&lt;br/&gt;&lt;a th:href=&quot;@&#123;/abc&#125;&quot;&gt;测试@RequestMapping注解的value属性&lt;/a&gt;&lt;form th:action=&quot;@&#123;/hello&#125;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;测试@RequestMapping注解的method属性&quot;&gt;&lt;/form&gt;&lt;!--当thymeleaf中的路径带参数的时候两种用法都可以--&gt;&lt;a th:href=&quot;@&#123;/hello?username=admin&#125;&quot;&gt;测试@RequestMapping注解的params属性&lt;/a&gt;&lt;a th:href=&quot;@&#123;/hello(username=&#x27;admin&#x27;)&#125;&quot;&gt;测试@RequestMapping注解的params属性&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; @RequestMapping注解的headers属性 Referer: http://localhost:8080/SpringMVC/ Referer是指请求的来源，从a网站转到b网站，则a网站就是referer 12//请求头信息必须有referer headers=&#123;&quot;referer&quot;&#125; 12345678910111213141516171819202122package com.atguigu.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;@Controller//@RequestMapping(&quot;/test&quot;)public class TestRequestMappingController &#123;//3.@RequestMapping注解的headers属性 @RequestMapping( value=&#123;&quot;/hello&quot;,&quot;/abc&quot;&#125;, //method=&#123;RequestMethod.POST,RequestMethod.GET&#125;, //params=&#123;&quot;username&quot;&#125;, //请求头信息必须有referer headers=&#123;&quot;referer&quot;&#125; ) public String hello()&#123; return &quot;success&quot;; &#125;&#125; 请求和响应头的键都是不区分大小写的 @RequestMapping注解使用ant风格的路径Springmvc支持ant风格的路径 12345？：表示任意的单个字符 *：表示任意的0个或多个字符 **：表示任意层数的任意目录 注意：在使用**时，只能使用/**/xxx的方式 TestRequestMappingController 12345678910//问号可以用来表示任意的单个字符，但是不能表示?本身//@RequestMapping(&quot;/a?a/test/ant&quot;)//*可以用来表示任意个数的字符，但也不能表示问号，也不能表示/(斜线)//@RequestMapping(&quot;/a*a/test/ant&quot;)//**可以用来表示任意层级的目录，但是只能通过/**/xxx的方式来使用@RequestMapping(&quot;/**/test/ant&quot;)public String testAnt()&#123; return &quot;success&quot;;&#125; 测试 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;index.html&lt;/h1&gt;&lt;a th:href=&quot;@&#123;/hello&#125;&quot;&gt;测试@RequestMapping所标识的位置&lt;/a&gt;&lt;br/&gt;&lt;a th:href=&quot;@&#123;/abc&#125;&quot;&gt;测试@RequestMapping注解的value属性&lt;/a&gt;&lt;form th:action=&quot;@&#123;/hello&#125;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;测试@RequestMapping注解的method属性&quot;&gt;&lt;/form&gt;&lt;!--当thymeleaf中的路径带参数的时候两种用法都可以--&gt;&lt;a th:href=&quot;@&#123;/hello?username=admin&#125;&quot;&gt;测试@RequestMapping注解的params属性&lt;/a&gt;&lt;br/&gt;&lt;a th:href=&quot;@&#123;/hello(username=&#x27;admin&#x27;)&#125;&quot;&gt;测试@RequestMapping注解的params属性&lt;/a&gt;&lt;br/&gt;&lt;a th:href=&quot;@&#123;/aaa/test/ant&#125;&quot;&gt;测试@RequestMapping注解支持ant风格的路径&lt;/a&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; @RequestMapping注解使用路径中的占位符传统的路径：&#x2F;test&#x2F;rest?id&#x3D;1 rest路径：&#x2F;test&#x2F;rest&#x2F;1 TestRequestMappingController 123456789101112//@RequestMapping使用路径中的占位符//传统路径：/deleteUser?id=1//rest:/user/delete/1//需要在@RequestMapping注解的value属性中所设置的路径中，使用&#123;xxx&#125;的方式表示路径中的数据//也就是通过占位符&#123;id&#125;和&#123;username&#125;获取路径对应位置的内容，而且对应的内容不能为空，否则404//通过@PathVariable注解，将占位符所标识的值和控制器方法的形参进行绑定，方法参数名和占位符的名一致@RequestMapping(&quot;/test/rest/&#123;id&#125;/&#123;username&#125;&quot;)public String testRest(@PathVariable Integer id,@PathVariable String username)&#123; System.out.println(&quot;id&quot;+&quot;:&quot;+id); System.out.println(&quot;username:&quot;+username); return &quot;success&quot;;&#125; 测试 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;index.html&lt;/h1&gt;&lt;a th:href=&quot;@&#123;/hello&#125;&quot;&gt;测试@RequestMapping所标识的位置&lt;/a&gt;&lt;br/&gt;&lt;a th:href=&quot;@&#123;/abc&#125;&quot;&gt;测试@RequestMapping注解的value属性&lt;/a&gt;&lt;form th:action=&quot;@&#123;/hello&#125;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;测试@RequestMapping注解的method属性&quot;&gt;&lt;/form&gt;&lt;!--当thymeleaf中的路径带参数的时候两种用法都可以--&gt;&lt;a th:href=&quot;@&#123;/hello?username=admin&#125;&quot;&gt;测试@RequestMapping注解的params属性&lt;/a&gt;&lt;br/&gt;&lt;a th:href=&quot;@&#123;/hello(username=&#x27;admin&#x27;)&#125;&quot;&gt;测试@RequestMapping注解的params属性&lt;/a&gt;&lt;br/&gt;&lt;a th:href=&quot;@&#123;/aaa/test/ant&#125;&quot;&gt;测试@RequestMapping注解支持ant风格的路径&lt;/a&gt;&lt;br/&gt;&lt;a th:href=&quot;@&#123;/test/rest/1&#125;&quot;&gt;测试@RequestMapping注解的value属性中的占位符&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; SpringMVC获取请求参数通过ServletAPI获取只需要在控制器方法的形参位置设置HttpServletRequest类型的参数 就可以在控制器方法中使用request对象获取请求参数 12345678910111213141516171819202122package com.atguigu.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpServletRequest;@Controllerpublic class TestParamController &#123; @RequestMapping(&quot;/param/servletAPI&quot;) //当我们浏览器发送请求被Dispathcher处理之后，会和控制层中@RequestMapping中信息匹配 //所以这里可以有request参数，也就是请求对象 public String getParamByServletAPI(HttpServletRequest request)&#123; String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); System.out.println(&quot;username:&quot;+username+&quot;password:&quot;+password); return &quot;success&quot;; &#125;&#125; 测试： 12345&lt;form th:action=&quot;@&#123;/param/servletAPI&#125;&quot; method=&quot;post&quot;&gt; 用户名 &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/form&gt; 通过控制器方法的形参获取请求参数@RequestMapping(“&#x2F;param”)也可以匹配 &#x2F;param?username&#x3D;1&amp;password&#x3D;2这种路径 只需要在控制器方法的形参位置设置一个形参，形参的名字和请求参数的名字一致 TestParamController 1234567@RequestMapping(&quot;/param&quot;)//控制器方法中的参数和请求的参数的名字相同public String getParam(String username,String password)&#123; System.out.println(&quot;username:&quot;+username+&quot;password:&quot;+password); return &quot;success&quot;;&#125; test 12345&lt;form th:action=&quot;@&#123;/param&#125;&quot; method=&quot;post&quot;&gt; 用户名 &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/form&gt; 请求参数的名字和方法形参的名字不一致的时候 @RequestParam @RequestParam是将请求参数和控制器方法的形参创建映射关系 @RequestParam注解一共有三个属性： value：指定为形参赋值的请求参数的参数名 required：设置是否必须传输此请求参数，默认值为true 若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置 defaultValue属性，则页面报错400：Required String parameter ‘xxx’ is not present；若设置为 false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为 null defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值 为””时，则使用默认值为形参赋值 value中指定请求参数的参数名和后面的方法中的参数绑定 123456@RequestMapping(&quot;/param&quot;)public String getParam(@RequestParam(value=&quot;userName&quot;,required=true,defaultValue = &quot;admin&quot;) String username, String password)&#123; System.out.println(&quot;username:&quot;+username+&quot;password:&quot;+password); return &quot;success&quot;;&#125; @RequestHeader @RequestHeader是将请求头信息和控制器方法的形参创建映射关系 @RequestHeader注解一共有三个属性：value、required、defaultValue，用法同@RequestParam 1234567@RequestMapping(&quot;/param&quot;)//用@RequestHeader把请求头的referer信息和 方法参数绑定起来//参数和@RequestParam相同public String getParam(@RequestHeader(value = &quot;referer&quot;,required = true,defaultValue = &quot;referer&quot;) String referer)&#123; System.out.println(&quot;referer:&quot;+referer); return &quot;success&quot;;&#125; @CookieValue 创建或者获取session 1HttpSession session=request.getSession(); @CookieValue是将cookie数据和控制器方法的形参创建映射关系 @CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam 12345678910111213141516171819@RequestMapping(&quot;/param/servletAPI&quot;)//当我们浏览器发送请求被Dispathcher处理之后，会和控制层中@RequestMapping中信息匹配//所以这里可以有request参数，也就是请求对象public String getParamByServletAPI(HttpServletRequest request)&#123; //创建session HttpSession session=request.getSession(); String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); System.out.println(&quot;username:&quot;+username+&quot;password:&quot;+password); return &quot;success&quot;;&#125;@RequestMapping(&quot;/param&quot;)public String getParam(@CookieValue(&quot;JSESSIONID&quot;) String jessionid)&#123; System.out.println(&quot;sessionid：&quot;+jessionid); return &quot;success&quot;;&#125; 测试方法： 先访问&#x2F;param&#x2F;servletAPI ,在访问&#x2F;param 就能得到sessionid的值 通过pojo获取请求参数创建User实体类 养成习惯，当创建了有参构造器，一定要自己再创建一个无参构造器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.atguigu.pojo;public class User &#123; private Integer id; private String username; public User(Integer id, String username, String password) &#123; this.id = id; this.username = username; this.password = password; &#125; public Integer getId() &#123; return id; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public User() &#123; &#125; private String password;&#125; 对于实体类来说，赋值属性的set方法是关键，这里无参或者有参构造器都不必要，但一般都创建 用实体类获取请求的参数，请求的参数可以比实体类中的属性多，这样实体类只接受能接收的参数，请求的参数比实体类中的属性少，也可以，也是只接受能接受的参数 12345678//控制控制器方法的实体类类型的形参获取请求参数//需要在控制器方法的形参位置设置实体类类型的实参，保证实体类中的属性的属性名和请求参数的名字一致//可以通过实体类类型的形参获取请求参数@RequestMapping(&quot;/param/pojo&quot;)public String getParamByPojo(User user)&#123; System.out.println(user); return &quot;success&quot;;&#125; test index.html 也可以接收get请求的 123456&lt;form th:action=&quot;@&#123;/param/pojo&#125;&quot; method=&quot;post&quot;&gt; 用户名 &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br/&gt; id:&lt;input type=&quot;text&quot; name=&quot;id&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/form&gt; 获取一个参数名多个值用数组请求： 要把原来的删除方法改一下，可以用数组来接受这种ids多值传参的情况 1234567891011121314151617181920/*删除对应的信息 */@DeleteMappingpublic R&lt;String&gt; delete( Long ids[])&#123; //删除dish表中数据 //这里removeByIds只能用集合来删除，但接收参数只能用数组 List&lt;Long&gt; list = Arrays.asList(ids); dishService.removeByIds(list); //删除dishflavor表中的数据 for (Long id : ids) &#123; LambdaQueryWrapper&lt;DishFlavor&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper.eq(DishFlavor::getDishId,id); dishFlavorService.remove(lambdaQueryWrapper); &#125; return R.success(&quot;删除成功了&quot;);&#125; 解决获取请求参数的乱码问题响应编码： 服务器发送给客户端文本内容之进行对响应体的编码，可以告诉浏览器你自己所用的编码比如UTF-8（要与浏览器默认编码相同，要不会乱码） 请求编码： 客户端发送给服务器请求之前进行对地址栏参数或者表单内容等的编码，谷歌浏览器默认UTF-8，而tomcat8以后的版本都是默认UTF-8对GET请求进行解码，post请求参数仍然是iso解码，tomcat7及以前不管是GET还是POST都是iso来解码 一般浏拦器发送请求的两种情况 1.在地址栏带参数发送请求，现在谷歌浏览器对参数的编码是UTF-8（浏览器编码是浏览器设置的） 2.在页面点击链接或者提交表单自己填写的内容，但是这个看服务器发送给浏览器的页面是什么编码，如果是UTF-8编码，则请求编码就是UTF-8编码 总结；设置请求编码，不仅把参数编码也是让服务器解码也按照这个请求编码，响应编码是把返回客户端内容编码，然后浏览器再解码 1.首先不能再控制器方法中通过ServletAPI设置编码，因为设置编码有一个要求是设置编码之前不能有任何一个参数的获取 ​ 8.几的tomcat get传参是没有乱码，post传参是有乱码的 web.xml 1234567891011121314151617181920&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!--加上这个就是加上了请求编码，再加下面那个就是加上响应编码--&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;!--配置spring的编码过滤器--&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 在javaweb中用Filter先拦截所有的请求，设置响应和请求的编码之后，再往下进行，SpringMVC也是一样都是用Filter，只不过它不需要我们自己手写的Filter，而是在web.xml中配置SpringMVC自带的编码Filter 注： SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效，放最前面就可以了 域对象中共享数据处理请求的一个过程无非就是获取请求参数，调用service处理业务逻辑，往域对象中共享数据，最后实现页面渲染和跳转页面 用Themyleaf之后就是只用到三个域，request（一次请求），session(一次会话)，application(整个工程) 用ServletAPI向request域对象共享数据12345@RequestMapping(&quot;/testServletAPI&quot;)public String testServletAPI(HttpServletRequest request)&#123; request.setAttribute(&quot;testScope&quot;, &quot;hello,servletAPI&quot;); return &quot;success&quot;;&#125; 使用ModelAndView向request域对象共享数据ModelAndView向request域对象共享数据 TestScopeController 12345678910111213141516//用了ModelAndView之后，方法必须将这个对象返回@RequestMapping(&quot;/test/mav&quot;)public ModelAndView testMDV()&#123; /* ModelAndView包含Model和View功能 Model,向请求域中共享数据 View:设置逻辑视图实现页面跳转 */ ModelAndView mav=new ModelAndView(); //往请求域中共享数据 mav.addObject(&quot;testRequestScope&quot;,&quot;hello,ModelAndView&quot;); //设置逻辑视图，也就是跳转页面 mav.setViewName(&quot;success&quot;); return mav;&#125; 在success中，获得request域对象中的参数 1&lt;p th:text=&quot;$&#123;testRequestScope&#125;&quot;&gt;&lt;/p&gt; 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;success.html&lt;/h1&gt;&lt;p th:text=&quot;$&#123;testRequestScope&#125;&quot;&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; test 1&lt;a th:href=&quot;@&#123;/test/mav&#125;&quot;&gt;测试通过modelandview向请求域共享数据&lt;/a&gt; 使用Model向请求域共享数据TestScopeController 1234567//用Model向request域中添加共享数据 @RequestMapping(&quot;/test/model&quot;) //方法中添加Model类型的参数 public String testModel(Model model)&#123; model.addAttribute(&quot;testRequestScope&quot;,&quot;hello,Model&quot;); return &quot;success&quot;; &#125; 在success中获取request域中参数 1&lt;p th:text=&quot;$&#123;testRequestScope&#125;&quot;&gt;&lt;/p&gt; 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;success.html&lt;/h1&gt;&lt;p th:text=&quot;$&#123;testRequestScope&#125;&quot;&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; test 1&lt;a th:href=&quot;@&#123;/test/mav&#125;&quot;&gt;测试通过model向请求域共享数据&lt;/a&gt; 使用ModelMap向请求域共享数据1234567//用ModelMap向request域中添加共享数据@RequestMapping(&quot;/test/modelMap&quot;)public String testModel(ModelMap modelMap)&#123; //方法中添加ModelMap类型的参数 modelMap.addAttribute(&quot;testRequestScope&quot;,&quot;hello,ModelMap&quot;); return &quot;success&quot;;&#125; success和上面一样 test 1&lt;a th:href=&quot;@&#123;/test/modelMap&#125;&quot;&gt;测试通过modelMap向请求域共享数据&lt;/a&gt; 使用Map向请求域共享数据12345678//用Map向request域中添加共享数据@RequestMapping(&quot;/test/Map&quot;)//加一个Map类型的参数 public String testMap(Map&lt;String,Object&gt; map)&#123; System.out.println(map.getClass().getName()); map.put(&quot;testRequestScope&quot;,&quot;hello,map&quot;); return &quot;success&quot;; &#125; success和上面一样 test 1&lt;a th:href=&quot;@&#123;/test/Map&#125;&quot;&gt;测试通过Map向请求域共享数据&lt;/a&gt; model modelMap map的关系， 其实在底层中，这些类型的形参最终都是通过BindingAwareModelMap类进行创建的，BindingAwareModelMap是他们的子类 public class ModelMap extends LinkedHashMap {} public class ExtendedModelMap extends ModelMap implements Model {} public class BindingAwareModelMap extends ExtendedModelMap {} 在方法执行后，不管用上面的哪种，model（在域中保存的数据）和视图（return 的内容）都会封装在ModelAndView对象中 向session域共享数据12345678//向session域中添加共享数据@RequestMapping(&quot;/test/session&quot;)//在方法参数中添加HttpSession类型的参数public String testSession(HttpSession session) &#123; session.setAttribute(&quot;testSessionScope&quot;, &quot;hello,session&quot;); return &quot;success&quot;;&#125; success 获取session域中的数据 1&lt;p th:text=&quot;$&#123;session.testSessionScope&#125;&quot;&gt;&lt;/p&gt; index 1&lt;a th:href=&quot;@&#123;/test/session&#125;&quot;&gt;测试向session域中共享数据&lt;/a&gt;&lt;br/&gt; 向application域中共享数据123456789//向application域中添加共享数据@RequestMapping(&quot;/test/application&quot;)//在方法参数中添加HttpSession类型的参数public String testApplication (HttpSession session)&#123; ServletContext servletContext = session.getServletContext(); servletContext.setAttribute(&quot;testApplicationScope&quot;,&quot;hello,application&quot;); return &quot;success&quot;;&#125; success 获取application域中的数据 1&lt;p th:text=&quot;$&#123;application.testApplicationScope&#125;&quot;&gt;&lt;/p&gt; index 1&lt;a th:href=&quot;@&#123;/test/application&#125;&quot;&gt;测试向application域中共享数据&lt;/a&gt;&lt;br/&gt; 当重启服务器之后，默认session域中的也是会消失的，这里消失是因为idea，正常关闭浏览器才会消失 想让他不消失的话也有方法 勾选这个Preserve sessions across restarts and redeploys 这样服务器重启，session域中的数据也不会消失了 session的钝化和活化服务器关闭之后，session可以钝化存储在磁盘文件中，这个磁盘文件是tomcat有一个work目录中的文件，如果服务器又重新启动，又会把钝化文件中的这些数据重新加载到当前的session中(活化)，所以只要浏览器不关，session就可以钝化和活化 如果session中存储实例化对象，想让他钝化那必须实现序列化的接口，其实钝化就是一个序列化的过程 SpringMVC中的视图视图技术说白了就是模板技术，和jsp thymyleaf的作用一样，让返回客户端的页面能够动态显示数据，SpringMVC可以设置视图解析器（Thymeleaf），也可以用SpringMVC默认的视图比如转发视图和重定向视图 SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户 SpringMVC视图的种类很多，默认有转发视图和重定向视图 当工程引入jstl的依赖，转发视图会自动转换为JstlView 若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView ThymyleafView视图当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置 的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转 12345678910111213package com.atguigu.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class TestViewController &#123; @RequestMapping(&quot;/test/view/thymeleaf&quot;) public String testThymeleafView()&#123; //这个地方没有任何类似forward，redirect的东西就说明是Thymyleaf视图 return &quot;success&quot;; &#125;&#125; 转发视图SpringMVC中默认的转发视图是InternalResourceView 当控制器方法中所设置的视图名称以”forward:”为前缀时，创建InternalResourceView视图，此时的视 图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”forward:”去掉，剩余部 分作为最终路径通过转发的方式实现跳转 例如”forward:&#x2F;“，”forward:&#x2F;employee” 用的很少 return “success”这种Thymeleaf视图，会经过Thymeleaf渲染，动态显示数据 因为这样转发是在服务器中直接进行转发，确实能转发到templates下的一个html文件，但是这个页面不会经过Thymeleaf的渲染，里面的数据不能够动态显示，Thymeleaf语法不生效,所以在使用Thymeleaf作为视图技术时转发视图很少用 123456@RequestMapping(&quot;/test/view/forward&quot;)public String testInternalResourceView()&#123; //转发视图 return &quot;forward:/test/model&quot;;&#125; &#x2F;test&#x2F;model也是一个绑定了controller方法的路径 12345678//用Model向request域中添加共享数据@RequestMapping(&quot;/test/model&quot;)//方法中添加Model类型的参数public String testModel(Model model) &#123; System.out.println(model.getClass().getName()); model.addAttribute(&quot;testRequestScope&quot;, &quot;hello,Model&quot;); return &quot;success&quot;;&#125; 这个是创建了两个视图一个是InternalResourceView视图，一个是Thymeleaf视图 重定向视图123456@RequestMapping(&quot;/test/view/redirect&quot;)public String testRedirectView()&#123; //重定向地址栏发生改变 return &quot;redirect:/test/model&quot;;&#125; test 1&lt;a th:href=&quot;@&#123;/test/view/redirect&#125;&quot;&gt;测试SpringMVC的重定向视图&lt;/a&gt;&lt;br/&gt; 浏览器中地址是&#x2F;test&#x2F;model,所以证明了重定向是两次请求，第一次请求了重定向视图，第二请求themeleafView，所以是能够被解析的 重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以&#x2F;开头，若是则会自动拼接上下文路径(springboot也是这样) 原本javaweb中重定向 &#x2F;会被浏览器解析为 http://ip:port/ 视图控制器当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示 1234567891011&lt;!--开启MVC的注解驱动--&gt;&lt;!--开启注解驱动的时候选择http://www.springframework.org/schema/mvc的那一种--&gt;&lt;mvc:annotation-driven/&gt;&lt;!--试图控制器：为当前的请求直接设置视图名称实现页面跳转若设置视图控制器，则只有视图控制器设置的请求会被处理，其他的请求将全部404，此时必须再配置一个标签 &lt;mvc:annotation-driven/&gt; 开启MVC注解驱动path:是处理的请求的路径，view-name是视图的名称--&gt;&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;index&quot;&gt;&lt;/mvc:view-controller&gt; RESTfulRESTful的简介与实现 具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。 它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。 REST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。 测试各种功能新建一个web工程，创建spring.xml，pom.xml，前后端控制器，视图控制器等等 为了实现put和delete的请求方式，在web.xml中加上如下代码 12345678910&lt;!--处理请求方式的过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; TestRustController 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.atguigu.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;/*访问用户资源所以路径统一都是/user 请求方式查询所有的用户信息:/user ----&gt;get根据id查询用户信息:/user/1 ----&gt;get添加用户信息 ：/user ---&gt;post 修改用户信息：/user ----&gt;put 删除用户信息:/user/1 ----&gt;delete 注意:浏览器目前只能发送get和post请求 若要发送put和delete请求，需要在web.xml中配置一个过滤器HiddenHttpMethodFilter 配置了过滤器之后，发送的请求需要满足两个条件，才能将请求方式转换为put或delete 1.当前请求必须为post 2.当前请求必须传输请求参数_method,_method的值才是最终的请求方式(详情见index.html) */@Controllerpublic class TestRestController &#123; /* 查询所有用户信息 */ @RequestMapping(value=&quot;/user&quot;,method= RequestMethod.GET) public String getAllUser()&#123; System.out.println(&quot;查询所有的用户信息--&gt;/user---&gt;get&quot;); return &quot;success&quot;; &#125; /* 查询id为1的用户信息 */ @RequestMapping(value=&quot;/user/&#123;id&#125;&quot;,method=RequestMethod.GET) public String getUserById(@PathVariable(&quot;id&quot;) int id)&#123; System.out.println(&quot;根据id查询用户信息:/user/&quot;+id+&quot; ----&gt;get&quot;); return &quot;success&quot;; &#125; /* 添加用户信息 */ @RequestMapping(value=&quot;/user&quot;,method=RequestMethod.POST) public String insertUser()&#123; System.out.println(&quot;添加用户信息 ：/user ---&gt;post&quot;); return &quot;success&quot;; &#125; /*修改用户信息 */ @RequestMapping(value=&quot;/user&quot;,method=RequestMethod.PUT) public String updateUser()&#123; System.out.println(&quot;修改用户信息 ：/user ---&gt;put&quot;); return &quot;success&quot;; &#125; /*删除用户信息*/ @RequestMapping(value=&quot;/user/&#123;id&#125;&quot;,method=RequestMethod.DELETE) public String deleteUser(@PathVariable int id)&#123; System.out.println(&quot;删除用户&quot;+id+&quot;信息 ：/user ---&gt;delete&quot;); return &quot;success&quot;; &#125;&#125; index.html的测试 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;index.html&lt;/h1&gt;&lt;a th:href=&quot;@&#123;/user&#125;&quot;&gt;查询所有的用户信息&lt;/a&gt;&lt;br/&gt;&lt;a th:href=&quot;@&#123;/user/1&#125;&quot;&gt;查询id为1的用户信息&lt;/a&gt;&lt;br/&gt;&lt;!--添加用户信息--&gt;&lt;form th:action=&quot;@&#123;/user&#125;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;添加用户信息&quot;/&gt;&lt;/form&gt;&lt;!--修改用户信息，发送put请求--&gt;&lt;!--两个要求1.method中的值一定要是post2.增加一个 &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot;&gt;标签，value的值是真正的请求方式--&gt;&lt;form th:action=&quot;@&#123;/user&#125;&quot; method=&quot;post&quot;&gt; &lt;!--设置为隐藏域，因为这个标签对用户没有意义--&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;修改用户信息&quot;&gt;&lt;/form&gt;&lt;!--根据id删除用户信息 ,发送delete请求--&gt;&lt;form th:action=&quot;@&#123;/user/1&#125;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;delete&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;删除用户信息&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 用@GetMapping替换 @RequestMapping(value&#x3D;”&#x2F;user”,method&#x3D; RequestMethod.GET)等等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.atguigu.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.*;/*访问用户资源所以路径统一都是/user 请求方式查询所有的用户信息:/user ----&gt;get根据id查询用户信息:/user/1 ----&gt;get添加用户信息 ：/user ---&gt;post 修改用户信息：/user ----&gt;put 删除用户信息:/user/1 ----&gt;delete 注意:浏览器目前只能发送get和post请求 若要发送put和delete请求，需要在web.xml中配置一个过滤器HiddenHttpMethodFilter 配置了过滤器之后，发送的请求需要满足两个条件，才能将请求方式转换为put或delete 1.当前请求必须为post 2.当前请求必须传输请求参数_method,_method的值才是最终的请求方式(详情见index.html) */@Controllerpublic class TestRestController &#123; /* 查询所有用户信息 */ // @RequestMapping(value=&quot;/user&quot;,method= RequestMethod.GET) @GetMapping(&quot;/user&quot;) public String getAllUser()&#123; System.out.println(&quot;查询所有的用户信息--&gt;/user---&gt;get&quot;); return &quot;success&quot;; &#125; /* 查询id为1的用户信息 */ //@RequestMapping(value=&quot;/user/&#123;id&#125;&quot;,method=RequestMethod.GET) @GetMapping(&quot;/user/&#123;id&#125;&quot;) public String getUserById(@PathVariable(&quot;id&quot;) int id)&#123; System.out.println(&quot;根据id查询用户信息:/user/&quot;+id+&quot; ----&gt;get&quot;); return &quot;success&quot;; &#125; /* 添加用户信息 */ //@RequestMapping(value=&quot;/user&quot;,method=RequestMethod.POST) @PostMapping(&quot;/user&quot;) public String insertUser()&#123; System.out.println(&quot;添加用户信息 ：/user ---&gt;post&quot;); return &quot;success&quot;; &#125; /*修改用户信息 */ //@RequestMapping(value=&quot;/user&quot;,method=RequestMethod.PUT) @PutMapping(&quot;/user&quot;) public String updateUser()&#123; System.out.println(&quot;修改用户信息 ：/user ---&gt;put&quot;); return &quot;success&quot;; &#125; /*删除用户信息*/ //@RequestMapping(value=&quot;/user/&#123;id&#125;&quot;,method=RequestMethod.DELETE) @DeleteMapping(&quot;/user/&#123;id&#125;&quot;) public String deleteUser(@PathVariable int id)&#123; System.out.println(&quot;删除用户&quot;+id+&quot;信息 ：/user ---&gt;delete&quot;); return &quot;success&quot;; &#125;&#125; 准备工作构建一个员工实体类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.atguigu.pojo;public class Employee &#123; private Integer id; private String lastName; private String email; //1 male, 0 female private Integer gender; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Integer getGender() &#123; return gender; &#125; public void setGender(Integer gender) &#123; this.gender = gender; &#125; public Employee(Integer id, String lastName, String email, Integer gender) &#123; super(); this.id = id; this.lastName = lastName; this.email = email; this.gender = gender; &#125; public Employee() &#123; &#125;&#125; Dao EmployeeDao 1234567891011121314151617181920212223242526272829303132333435package com.atguigu.dao;import java.util.Collection;import java.util.HashMap;import java.util.Map;import com.atguigu.pojo.Employee;import org.springframework.stereotype.Repository;@Repositorypublic class EmployeeDao &#123; private static Map&lt;Integer, Employee&gt; employees = null; static&#123; employees = new HashMap&lt;Integer, Employee&gt;(); employees.put(1001, new Employee(1001, &quot;E-AA&quot;, &quot;aa@163.com&quot;, 1)); employees.put(1002, new Employee(1002, &quot;E-BB&quot;, &quot;bb@163.com&quot;, 1)); employees.put(1003, new Employee(1003, &quot;E-CC&quot;, &quot;cc@163.com&quot;, 0)); employees.put(1004, new Employee(1004, &quot;E-DD&quot;, &quot;dd@163.com&quot;, 0)); employees.put(1005, new Employee(1005, &quot;E-EE&quot;, &quot;ee@163.com&quot;, 1)); &#125; private static Integer initId = 1006; public void save(Employee employee)&#123; if(employee.getId() == null)&#123; employee.setId(initId++); &#125; employees.put(employee.getId(), employee); &#125; public Collection&lt;Employee&gt; getAll()&#123; return employees.values(); &#125; public Employee get(Integer id)&#123; return employees.get(id); &#125; public void delete(Integer id)&#123; employees.remove(id); &#125;&#125; 实现列表功能（查询所有员工信息）springmvc.xml 使能扫描到controller和dao和pojo下所有的类 在springmvc.xml中添加这个 12&lt;!--扫描控制层组件--&gt;&lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;&lt;/context:component-scan&gt; EmployeeController 1234567891011121314151617181920212223242526272829303132333435363738394041package com.atguigu.controller;import com.atguigu.dao.EmployeeDao;import com.atguigu.pojo.Employee;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import java.util.Collection;/*1.查询所有的员工信息---&gt;/employee ---&gt;GET2.跳转到添加页面---&gt;/to/add ---&gt;GETrest一般用这种一个单词一个单词形式的3.新增员工信息 ---&gt;/employee ---&gt;POST4.跳转到修改页面---&gt;/employee/1 ---&gt;get5.修改员工信息 --&gt;/employee ---&gt;put6.删除员工信息 --&gt;/employee/1 ---&gt;delete */@Controllerpublic class EmployeeController &#123; @Autowired private EmployeeDao employeeDao; //获取所有的员工信息 @RequestMapping(value = &quot;/employee&quot;,method = RequestMethod.GET) public String getAllEmployee(Model model)&#123; //获取所有的员工信息 Collection&lt;Employee&gt; allEmployee = employeeDao.getAll(); //将所有的员工信息在请求域中共享 model.addAttribute(&quot;allEmployee&quot;,allEmployee); return &quot;employee_list&quot;; &#125;&#125; 用Thymeleaf来显示员工信息 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;employlist&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt; &lt;tr&gt; &lt;th colspan=&quot;5&quot;&gt;employee list&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;lastName&lt;/th&gt; &lt;th&gt;email&lt;/th&gt; &lt;th&gt;gender&lt;/th&gt; &lt;th&gt;options&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=&quot;employee:$&#123;allEmployee&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;employee.id&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.lastName&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.email&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.gender&#125;&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;&quot;&gt;update&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html 处理静态资源静态资源应该由默认Servlet来处理，Tomcat中的web.xml中的配置的默认Servlet 默认Servlet 123456789 &lt;!-- The mapping for the default servlet --&gt; &lt;servlet-mapping&gt;​ &lt;servlet-name&gt;default&lt;/servlet-name&gt;​ &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 可以理解为是工程中的web.xml继承于Tomcat中的web.xml，当mvc配置了下面这个的时候，就相当于给&#x2F;路径配置了前端控制器Servlet ，那原来的default的Servlet（处理静态资源的Servlet）就不好使了（因为default的url-pattern也是&#x2F;） 所以这样之后静态资源就没法处理了 1234567891011&lt;!--配置SpringMVC的前端控制器DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; DispatcherServlet处理不了静态资源原因是，它是去找后端控制器中有没有方法的@RequestMapping中的value符合请求，但是静态资源不是这样的配置，它是在工程中的文件夹中，路径也是工程中某个文件夹路径所以不行 例子： 1&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/vue.js&#125;&quot;&gt;&lt;/script&gt; 解决方法： springmvc.xml 123456&lt;!--开启mvc注解驱动--&gt;&lt;!--开启注解驱动的时候选择http://www.springframework.org/schema/mvc的那一种--&gt;&lt;mvc:annotation-driven/&gt;&lt;!--配置默认的servlet处理静态资源--&gt;&lt;mvc:default-servlet-handler/&gt; 这样就是请求先经过DispatcherServlet处理，它处理不了再让默认的Servlet来处理 各种功能实现要求 新增员工之前跳转到添加页面，修改员工之前跳转到修改页面（都是默认get） 查询用get请求 新增用post请求 修改用put请求 删除用delete请求 1234567891011121314151617/*1.查询所有的员工信息---&gt;/employee ---&gt;GET2.跳转到添加页面---&gt;/to/add ---&gt;GETrest一般用这种一个单词一个单词形式的3.新增员工信息 ---&gt;/employee ---&gt;POST4.跳转到修改页面---&gt;/employee/1 ---&gt;get5.修改员工信息 --&gt;/employee ---&gt;put6.删除员工信息 --&gt;/employee/1 ---&gt;delete */ 添加功能employee_list.html 12&lt;!--跳转到填写添加的用户的信息的页面--&gt; &lt;th&gt;options(&lt;a th:href=&quot;@&#123;/to/add&#125;&quot;&gt;add&lt;/a&gt;)&lt;/th&gt; 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;employlist&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt; &lt;tr&gt; &lt;th colspan=&quot;5&quot;&gt;employee list&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;lastName&lt;/th&gt; &lt;th&gt;email&lt;/th&gt; &lt;th&gt;gender&lt;/th&gt; &lt;!--跳转到填写添加的用户的信息的页面--&gt; &lt;th&gt;options(&lt;a th:href=&quot;@&#123;/to/add&#125;&quot;&gt;add&lt;/a&gt;)&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=&quot;employee:$&#123;allEmployee&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;employee.id&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.lastName&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.email&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.gender&#125;&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;&quot;&gt;update&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; springmvc.xml 1&lt;mvc:view-controller path=&quot;/to/add&quot; view-name=&quot;employee_add&quot;&gt;&lt;/mvc:view-controller&gt; 因为&#x2F;to&#x2F;add只需要实现一个页面跳转的功能所以用视图显示器就可以了 employee_add.html 添加员工信息的界面 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;employlist&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form th:action=&quot;@&#123;/employee&#125;&quot; method=&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;th colspan=&quot;2&quot;&gt;add employee&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;lastName&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; name=&quot;lastName&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;email&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;gender&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot;&gt;male &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot;&gt;female &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;add&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; EmployController 123456789101112 //添加员工信息，然后重新跳转列表功能，查看添加的员工信息@RequestMapping(value = &quot;/employee&quot;,method = RequestMethod.POST) //通过实体类获取浏览器传输的数据,添加了一个类型Employee参数，要求属性名和参数名一致 public String addEmployee(Employee employee)&#123; //保存员工信息 employeeDao.save(employee); //重定向到列表功能，就相当于是在浏览器框中输入/employee return &quot;redirect:/employee&quot;; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.atguigu.controller;import com.atguigu.dao.EmployeeDao;import com.atguigu.pojo.Employee;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import java.util.Collection;/*1.查询所有的员工信息---&gt;/employee ---&gt;GET2.跳转到添加页面---&gt;/to/add ---&gt;GETrest一般用这种一个单词一个单词形式的3.新增员工信息 ---&gt;/employee ---&gt;POST4.跳转到修改页面---&gt;/employee/1 ---&gt;get5.修改员工信息 --&gt;/employee ---&gt;put6.删除员工信息 --&gt;/employee/1 ---&gt;delete */@Controllerpublic class EmployeeController &#123; @Autowired private EmployeeDao employeeDao; //获取所有的员工信息 @RequestMapping(value = &quot;/employee&quot;,method = RequestMethod.GET) public String getAllEmployee(Model model)&#123; //获取所有的员工信息 Collection&lt;Employee&gt; allEmployee = employeeDao.getAll(); //将所有的员工信息在请求域中共享 model.addAttribute(&quot;allEmployee&quot;,allEmployee); return &quot;employee_list&quot;; &#125; //添加员工信息，然后重新跳转列表功能，查看添加的员工信息 @RequestMapping(value = &quot;/employee&quot;,method = RequestMethod.POST) //通过实体类获取浏览器传输的数据,添加了一个类型Employee参数，要求属性名和参数名一致 public String addEmployee(Employee employee)&#123; //保存员工信息 employeeDao.save(employee); //重定向到列表功能，就相当于是在浏览器框中输入/employee（默认get请求），相当于重新调用上面那个方法 return &quot;redirect:/employee&quot;; &#125;&#125; 修改功能修改的时候必须是先用id把员工信息查询显示出来，再进行修改 1&lt;a th:href=&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;&gt;update&lt;/a&gt; employee_list.html 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;employlist&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt; &lt;tr&gt; &lt;th colspan=&quot;5&quot;&gt;employee list&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;lastName&lt;/th&gt; &lt;th&gt;email&lt;/th&gt; &lt;th&gt;gender&lt;/th&gt; &lt;!--跳转到填写添加的用户的信息的页面--&gt; &lt;th&gt;options(&lt;a th:href=&quot;@&#123;/to/add&#125;&quot;&gt;add&lt;/a&gt;)&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=&quot;employee:$&#123;allEmployee&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;employee.id&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.lastName&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.email&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.gender&#125;&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;&quot;&gt;delete&lt;/a&gt; &lt;!--直接访问这个员工信息修改页面--&gt; &lt;a th:href=&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;&gt;update&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; EmployController 1234567891011121314151617181920212223//修改员工信息，要先把原来的员工信息显示在页面上，即这就是跳转到修改页面的方法@RequestMapping(value=&quot;/employee/&#123;id&#125;&quot;,method = RequestMethod.GET) public String toUpdate(@PathVariable(&quot;id&quot;) Integer id,Model model)&#123; //根据id查询员工信息 Employee employee = employeeDao.get(id); //将员工信息共享到请求域中 model.addAttribute(&quot;employee&quot;,employee); //跳转到employee_update.html return &quot;employee_update.html&quot;; &#125; //这个是修改员工信息，然后重新跳转到列表功能 @RequestMapping(value=&quot;/employee&quot;,method=RequestMethod.PUT) //通过实体类获取浏览器传输的数据,添加了一个类型Employee参数，要求属性名和参数名一致 public String updateEmployee(Employee employee)&#123; //修改员工信息 employeeDao.save(employee); //重定向到列表功能，就相当于是在浏览器框中输入/employee（默认get请求），相当于重新调用第一个那个方法 return &quot;redirect:/employee&quot;; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.atguigu.controller;import com.atguigu.dao.EmployeeDao;import com.atguigu.pojo.Employee;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import java.util.Collection;/*1.查询所有的员工信息---&gt;/employee ---&gt;GET2.跳转到添加页面---&gt;/to/add ---&gt;GETrest一般用这种一个单词一个单词形式的3.新增员工信息 ---&gt;/employee ---&gt;POST4.跳转到修改页面---&gt;/employee/1 ---&gt;get5.修改员工信息 --&gt;/employee ---&gt;put6.删除员工信息 --&gt;/employee/1 ---&gt;delete */@Controllerpublic class EmployeeController &#123; @Autowired private EmployeeDao employeeDao; //获取所有的员工信息 @RequestMapping(value = &quot;/employee&quot;,method = RequestMethod.GET) public String getAllEmployee(Model model)&#123; //获取所有的员工信息 Collection&lt;Employee&gt; allEmployee = employeeDao.getAll(); //将所有的员工信息在请求域中共享 model.addAttribute(&quot;allEmployee&quot;,allEmployee); return &quot;employee_list&quot;; &#125; @RequestMapping(value = &quot;/employee&quot;,method = RequestMethod.POST) //通过实体类获取浏览器传输的数据,添加了一个类型Employee参数，要求属性名和参数名一致 public String addEmployee(Employee employee)&#123; //保存员工信息 employeeDao.save(employee); //重定向到列表功能 return &quot;redirect:/employee&quot;; &#125; //修改员工信息，要先把原来的员工信息显示在页面上，即这就是跳转到修改页面的方法 @RequestMapping(value=&quot;/employee/&#123;id&#125;&quot;,method = RequestMethod.GET) public String toUpdate(@PathVariable(&quot;id&quot;) Integer id,Model model)&#123; //根据id查询员工信息 Employee employee = employeeDao.get(id); //将员工信息共享到请求域中 model.addAttribute(&quot;employee&quot;,employee); //跳转到employee_update.html return &quot;employee_update.html&quot;; &#125; //这个是修改员工信息，然后重新跳转到列表功能 @RequestMapping(value=&quot;/employee&quot;,method=RequestMethod.PUT) //通过实体类获取浏览器传输的数据,添加了一个类型Employee参数，要求属性名和参数名一致 public String updateEmployee(Employee employee)&#123; //修改员工信息 employeeDao.save(employee); //重定向到列表功能，就相当于是在浏览器框中输入/employee（默认get请求），相当于重新调用第一个那个方法 return &quot;redirect:/employee&quot;; &#125;&#125; 修改员工的页面 employee_update.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;employlist&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form th:action=&quot;@&#123;/employee&#125;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; th:value=&quot;$&#123;employee.id&#125;&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;th colspan=&quot;2&quot;&gt;update employee&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;lastName&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; name=&quot;lastName&quot; th:value=&quot;$&#123;employee.lastName&#125;&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;email&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot; th:value=&quot;$&#123;employee.email&#125;&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;gender&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; th:field=&quot;$&#123;employee.gender&#125;&quot;&gt;male &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; th:field=&quot;$&#123;employee.gender&#125;&quot;&gt;female &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;update&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 删除功能SpringMVC处理ajax请求创建一个新的工程 web.xml 前面的一个集合版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 前面的一个综合版 springmvc.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!--扫描控制层组件--&gt; &lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;&lt;/context:component-scan&gt; &lt;!-- 配置Thymeleaf视图解析器 --&gt; &lt;bean id=&quot;viewResolver&quot; class=&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;property name=&quot;templateEngine&quot;&gt; &lt;bean class=&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;&gt; &lt;property name=&quot;templateResolver&quot;&gt; &lt;bean class=&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;&gt; &lt;!-- 视图前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/templates/&quot;/&gt; &lt;!-- 视图后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.html&quot;/&gt; &lt;property name=&quot;templateMode&quot; value=&quot;HTML5&quot;/&gt; &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--配置视图控制器--&gt;&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;index&quot;&gt;&lt;/mvc:view-controller&gt; &lt;!--开启mvc注解驱动--&gt; &lt;mvc:annotation-driven/&gt; &lt;!--配置默认的servlet处理静态资源--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;mvc:view-controller path=&quot;/to/add&quot; view-name=&quot;employee_add&quot;&gt;&lt;/mvc:view-controller&gt;&lt;/beans&gt; pom.xml前面集合版 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;spring_mvc_ajax&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- SpringMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- ServletAPI --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring5和Thymeleaf整合包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;version&gt;3.0.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--jackson的包--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; axios就是发送ajax请求的库，是封装的ajax axios回顾1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;index.html&lt;/h1&gt; &lt;input type=&quot;button&quot; value=&quot;测试SpringMVC处理ajax请求&quot; @click=&quot;testAjax&quot;&gt;&lt;/div&gt;首页&lt;!--引入vue和axios的库--&gt;&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/js/vue.js&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/js/axios.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var vue=new Vue(&#123; el:&#x27;#app&#x27;, methods:&#123; testAjax:function()&#123; /* axios(&#123; url:&quot;&quot;, method:&quot;&quot;, //以name=value&amp;name=value的方式发送的请求参数，不管使用的请求方式是get还是post，请求参数都会被拼接到请求地址后 //这个可以通过request.getParameter()获取 params:&#123;&#125;, //以json格式发送请求参数，请求参数会被保存到请求报文的请求体传输到服务器，所以这个必须用post //这个要通过别的方式获取 data:&#123;&#125; &#125;).then(function(value)&#123; console.log(value.data); &#125;)*/ /* axios.get和axios.post后面常用属性也是都由url和congfig，post有data，get没有 发送params参数，可以直接在url后面加，发送json形式的参数就用post的data 同时写axios内容的时候顺序不能打乱 get是先url再config post是先url再data再config*/ &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 正片用之前的方法获取ajax请求的参数 客户端 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;index.html&lt;/h1&gt; &lt;input type=&quot;button&quot; value=&quot;测试SpringMVC处理ajax请求&quot; @click=&quot;testAjax&quot;&gt;&lt;/div&gt;首页&lt;!--引入vue和axios的库--&gt;&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/vue.js&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/axios.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var vue=new Vue(&#123; el:&#x27;#app&#x27;, methods:&#123; testAjax:function()&#123; axios.post( //这个地方的顺序不能乱，对于post来说先是url，然后是data，然后是config //不用params直接拼接在url后面 &quot;/SpringMVC/test/ajax?id=1001&quot;, &#123;username:&quot;admin&quot;,password:&quot;123456&quot;&#125; ).then(function (value) &#123; console.log(value.data); &#125;) &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 服务器端 12345678910111213141516171819202122package com.atguigu.controller;import com.sun.deploy.net.HttpResponse;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@Controllerpublic class TestAjaxController &#123;@RequestMapping(&quot;/test/ajax&quot;)//Integer id获取请求参数//Ajax请求是局部更新，服务器端不能够转发页面，所以这里的返回值不能是视图，得是void//现在使用的是之前学过的获取请求参数的方式，还不是SpringMVC专门获取ajax请求参数的方式 public void testAjax(Integer id, HttpServletResponse response) throws IOException &#123;System.out.println(&quot;id:&quot;+id);response.getWriter().write(&quot;hello,axios&quot;);&#125;&#125; json字符串和json对象JSON对象 有时候在做项目的时候时常将这两个概念弄混淆，尤其是在使用springmvc的时候，后台@RequestBody接受的是一个json格式的字符串，一定是一个字符串。 先介绍一下json对象，首先说到对象的概念，对象的属性是可以用：对象.属性进行调用的。例如： 123var person=&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;age&quot;:&quot;24&quot;&#125;//json对象alert(person.name);//zhangsanalert(typeof person);//object person就是json对象。可以用perosn.name这种方式进行属性的调用。第三行代码就是看person的类型，为object类型。 JSON字符串 字符串，我们常说的JavaScript中的字符串是单引号或者双引号引起来的。 123var person=&#x27;&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;age&quot;:&quot;24&quot;&#125;&#x27;;//json字符串alert(person);//&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;age&quot;:&quot;24&quot;&#125;alert(typeof person);//string person就是一个json字符串，之所以叫json字符串，因为字符串的格式符合json的格式，第三行代码也匹配其中的类型为string。 JSON字符串和JOSN对象的转换 json字符串转json对象,调用parse方法： 123var person=&#x27;&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;age&quot;:&quot;24&quot;&#125;&#x27;;//json字符串var personObject = JSON.parse(person);alert(personObject.name);//zhangsan json对象转为json字符串，调用stringify方法： 123var person=&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;age&quot;:&quot;24&quot;&#125;;//json对象var personString = JSON.stringify(person);alert(personString); SpringMVC接受json字符串类型。 在SpringMVC中基于REST开发时，前端传入后台的应该是一个json格式的字符串，而不是一个json对象 12345678910111213141516171819&lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; var saveDataAry=[]; var data1=&#123;&quot;userName&quot;:&quot;zhangsan&quot;,&quot;address&quot;:&quot;bj&quot;&#125;; var data2=&#123;&quot;userName&quot;:&quot;lisi&quot;,&quot;address&quot;:&quot;nj&quot;&#125;; saveDataAry.push(data1); saveDataAry.push(data2); $.ajax(&#123; type:&quot;POST&quot;, url:&quot;user/saveUser&quot;, dataType:&quot;json&quot;, contentType:&quot;application/json&quot;, data:JSON.stringify(saveData), success:function(data)&#123; &#125; &#125;); &#125;); &lt;/script&gt; 上面代码，首先push方法将其封装到数组中，其表现格式： 1234[ &#123;&quot;userName&quot;:&quot;zhangsan&quot;,&quot;address&quot;:&quot;bj&quot;&#125;, &#123;&quot;userName&quot;:&quot;lisi&quot;,&quot;address&quot;:&quot;nj&quot;&#125;] JSON.stringify(saveData)将其转换为json字符串：同时ajax请求的时候也要指定dataType: “json”,contentType:”application&#x2F;json” 这样就可以轻易的将一个对象或者List传到Java端。 java后台 123456@Controller@RequestMapping(value = &quot;saveUser&quot;, method=RequestMethod.POST ) @ResponseBody public void saveUser(@RequestBody List&lt;User&gt; users) &#123; userService.batchSave(users); &#125; 后台用@RequestBody将其封装到List&lt;User&gt;中。然后进入Service层。 Springboot中 后台如果直接返回一个java对象，则就是以json对象的格式返回的 返回list中都是java对象的话，就是以json对象数组格式返回 返回map中都是java兑现的话，就是以大json对象格式返回，具体看@ResponseBody的图 Springmvc中要加上@ResponseBody注解，才有这样的效果 @RequestBody用来获取以json数据格式发送参数的请求的json数据格式参数(data中的)，也可以获取post传参的参数，因为在请求体中 1.获取正常post请求体中的参数 2.获取axios的post请求中的data 获得json格式数据的时候不能够直接用@RequestBody接受json对象中的某一个属性，要用java对象实体类或者map来接受，或者像第一个例子那样，用String requestBody来接受 服务器端 12345678910111213141516171819202122232425262728293031package com.atguigu.controller;import com.sun.deploy.net.HttpResponse;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/*@RequestBody：将请求体中的内容和控制器方的形参进行绑定 */@Controllerpublic class TestAjaxController &#123;@RequestMapping(&quot;/test/ajax&quot;)//之前方法的参数是用来获取普通形式的参数，现在是要获取json形式的参数（data中的），要在参数前加一个@RequestBody public void testAjax(Integer id,@RequestBody String requestBody, HttpServletResponse response) throws IOException &#123; //requestBody:&#123;&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;123456&quot;&#125; System.out.println(&quot;requestBody:&quot;+requestBody); System.out.println(&quot;id:&quot;+id); response.getWriter().write(&quot;hello,axios&quot;); &#125;&#125; 客户端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;index.html&lt;/h1&gt; &lt;input type=&quot;button&quot; value=&quot;测试SpringMVC处理ajax请求&quot; @click=&quot;testAjax&quot;&gt;&lt;br/&gt; &lt;input type=&quot;button&quot; value=&quot;使用@RequestBody注解处理json格式的请求&quot; @click=&quot;testRequestBody&quot;&gt;&lt;br/&gt;&lt;/div&gt;首页&lt;!--引入vue和axios的库--&gt;&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/vue.js&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/axios.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var vue=new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; username:&quot;123456&quot;, password:&quot;12345&quot; &#125;, methods:&#123; testAjax:function()&#123; axios.post( //这个地方的顺序不能乱，对于post来说先是url，然后是data，然后是config //不用params直接拼接在url后面 &quot;/SpringMVC/test/ajax?id=1001&quot;, //这个是json格式的数据 &#123;username:&quot;admin&quot;,password:&quot;123456&quot;&#125; ).then(function (value) &#123; console.log(value.data); console.log(vue.username); console.log(this.username); &#125;) &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.将请求得到的json字符串转换为对象或者map集合 使用@RequestBody获取json格式的请求参数的条件：(这里的意思是从json字符串中得到每一个参数‘ 1、导入jackson的依赖 12345 &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt;&lt;/dependency&gt; 2.SpringMVC的配置文件中设置开启mvc的注解驱动 12&lt;!--开启mvc的注解驱动--&gt;&lt;mvc:annotation-driven /&gt; 3、在控制器方法的形参位置，设置json格式的请求参数要转换成的java类型（实体类或map）的参 数，并使用@RequestBody注解标识 服务器端 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.atguigu.controller;import com.atguigu.pojo.User;import com.sun.deploy.net.HttpResponse;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Map;/*@RequestBody：将请求体中的内容和控制器方的形参进行绑定2.@RequestBody注解将json格式的请求参数转换为java对象 三个条件：1.导入jackson的jar包 2.在SpringMVC的配置文件中配置&lt;mvc:annotation-driven/&gt; 3.在处理请求的控制器方法（testRequestBody方法）的形参位置，直接设置json格式的请求参数要转换的java类型的形参（某个实体类，或者map），使用@RequestBody注解 */@Controllerpublic class TestAjaxController &#123; //将获取的json字符串转换为map，设置@RequestBody Map&lt;String,Object&gt; map @RequestMapping(&quot;/test/RequestBody/json&quot;) public void testRequestBody(@RequestBody Map&lt;String,Object&gt; map, HttpServletResponse response) throws IOException &#123; response.getWriter().write(&quot;hellp,RequestBody&quot;); //这个user也是和以前很多一样，都是set方法才是关键的请求参数是age只要有set方法setAge就可以给属性赋值，不管属性叫什么名字 //&#123;username=admin, password=123456, age=32, gender=男&#125; System.out.println(map); &#125; //将获取的json字符串转换为实体类，设置@RequestBody User user//@RequestMapping(&quot;/test/RequestBody/json&quot;)public void testRequestBody(@RequestBody User user, HttpServletResponse response) throws IOException &#123; response.getWriter().write(&quot;hellp,RequestBody&quot;); //这个user也是和以前很多一样，都是set方法才是关键的请求参数是age只要有set方法setAge就可以给属性赋值，不管属性叫什么名字 //User&#123;id=null, username=&#x27;admin&#x27;, password=&#x27;123456&#x27;, age=32, gender=&#x27;男&#x27;&#125; toString方法的结果 System.out.println(user);&#125;&#125; 客户端 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;index.html&lt;/h1&gt; &lt;input type=&quot;button&quot; value=&quot;测试SpringMVC处理ajax请求&quot; @click=&quot;testAjax&quot;&gt;&lt;br/&gt; &lt;input type=&quot;button&quot; value=&quot;使用@RequestBody注解处理json格式的请求&quot; @click=&quot;testRequestBody&quot;&gt;&lt;br/&gt;&lt;/div&gt;首页&lt;!--引入vue和axios的库--&gt;&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/vue.js&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/axios.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var vue=new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; username:&quot;123456&quot;, password:&quot;12345&quot; &#125;, methods: &#123; testRequestBody: function () &#123; axios.post( &quot;/SpringMVC/test/RequestBody/json&quot;, &#123;username: &quot;admin&quot;, password: &quot;123456&quot;, age: 32, gender: &quot;男&quot;&#125; ).then(function (value) &#123; console.log(value.data); &#125;) &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; @ResponseBody1.@ResponseBody响应常规数据 @ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到 浏览器 2.利用@ResponseBody响应json格式的数据 1、导入jackson的依赖 12345 &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt;&lt;/dependency&gt; 2.SpringMVC的配置文件中设置开启mvc的注解驱动 12&lt;!--开启mvc的注解驱动--&gt;&lt;mvc:annotation-driven /&gt; 3.将需要转换为json字符串的java对象直接作为控制器方法的返回值，使用ResponseBody注解标识控制器方法 就可以将java对象转换为json字符串响应到浏览器 user对象转换为json对象的字符串格式 {id: 1001, username: ‘admin’, password: ‘123456’, age: 20, gender: ‘男’}map集合转换为json对象的字符串格式 list集合转换为json数组的字符串格式 服务器端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.atguigu.controller;import com.atguigu.pojo.User;import com.sun.deploy.net.HttpResponse;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.*;@Controllerpublic class TestAjaxController &#123; @RequestMapping(&quot;/test/ResponseBody&quot;) @ResponseBody public String testResponseBody() &#123; //这里是把success字符串当作响应，相应的页面上 return &quot;success&quot;; &#125; /* 常用的java对象转换为json的结果 实体类--&gt;json对象的字符串 map--&gt;json对象的字符串 list集合--&gt;json数组的字符串 */ //把java对象以json数据的格式返回 @RequestMapping(&quot;/test/ResponseBody/json&quot;) @ResponseBody public List&lt;User&gt; testResponseBodyJson() &#123; User user0 = new User(1001, &quot;admin&quot;, &quot;123456&quot;, 20, &quot;男&quot;); User user1 = new User(1001, &quot;admin&quot;, &quot;123456&quot;, 20, &quot;男&quot;); User user2 = new User(1001, &quot;admin&quot;, &quot;123456&quot;, 20, &quot;男&quot;); User user3 = new User(1001, &quot;admin&quot;, &quot;123456&quot;, 20, &quot;男&quot;); List&lt;User&gt; list=new ArrayList&lt;&gt;(); list.add( user0); list.add( user1); list.add( user2); list.add( user3); return list; &#125; /*public Map&lt;String, Object&gt; testResponseBodyJson() &#123; User user0 = new User(1001, &quot;admin&quot;, &quot;123456&quot;, 20, &quot;男&quot;); User user1 = new User(1001, &quot;admin&quot;, &quot;123456&quot;, 20, &quot;男&quot;); User user2 = new User(1001, &quot;admin&quot;, &quot;123456&quot;, 20, &quot;男&quot;); User user3 = new User(1001, &quot;admin&quot;, &quot;123456&quot;, 20, &quot;男&quot;); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;0&quot;, user0); map.put(&quot;1&quot;, user1); map.put(&quot;2&quot;, user2); map.put(&quot;3&quot;, user3); return map;*/ /* public User testResponseBodyJson()&#123; User user=new User(1001,&quot;admin&quot;,&quot;123456&quot;,20,&quot;男&quot;); return user; &#125;*/ &#125; 客户端 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;index.html&lt;/h1&gt; &lt;input type=&quot;button&quot; value=&quot;使用@RequestBody注解响应json格式的数据&quot; @click=&quot;testResponseBody&quot;&gt;&lt;/div&gt;首页&lt;!--引入vue和axios的库--&gt;&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/vue.js&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/axios.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var vue=new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; username:&quot;123456&quot;, password:&quot;12345&quot; &#125;, methods: &#123; testResponseBody:function () &#123; axios.post(&quot;/SpringMVC/test/ResponseBody/json&quot;).then(function (value) &#123; //user对象转换为json对象的字符串格式 &#123;id: 1001, username: &#x27;admin&#x27;, password: &#x27;123456&#x27;, age: 20, gender: &#x27;男&#x27;&#125; //map集合转换为json对象的字符串格式 console.log(value.data); &#125;) &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; @RestController注解@RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了 @Controller注解，并且为其中的每个方法添加了@ResponseBody注解 SpringMVC的文件功能SpringMVC实现下载功能文件上传是把文件从浏览器上传到服务器 文件下载是把文件从服务器输出到浏览器 文件下载服务器端，以后设置文件下载可以直接拷贝这段代码，改改里面的文件路径就可以了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.atguigu.controller;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.util.MultiValueMap;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.ServletContext;import javax.servlet.http.HttpSession;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;/*ResponseEntity:可以作为控制器方法的返回值，表示响应到浏览器的完整的响应报文下面这个文件下载的代码都是固定的，之后下载不同的文件，你需要改变的只是文件的路径 */@Controllerpublic class FileUpAndDownController &#123; @RequestMapping(&quot;/test/down&quot;) public ResponseEntity&lt;byte[]&gt; testResponseEntity(HttpSession session) throws IOException &#123;//获取ServletContext对象 ServletContext servletContext = session.getServletContext(); String realPath = servletContext.getRealPath(&quot;/img/1.jpg&quot;);//创建输入流 InputStream is = new FileInputStream(realPath);//创建字节数组,is.avaiolable()获取输入流对应文件的字节数 byte[] bytes = new byte[is.available()];//将流读到字节数组中 is.read(bytes);//创建HttpHeaders对象设置响应头信息 MultiValueMap&lt;String, String&gt; headers = new HttpHeaders();//设置要下载方式（Content-Disposition）以及下载文件的默认的名字，这个名字是自己起的，就是filename后面的内容就是默认名字 //这个名字是用户接收到后的名字 headers.add(&quot;Content-Disposition&quot;, &quot;attachment;filename=1.jpg&quot;);//设置响应状态码 HttpStatus statusCode = HttpStatus.OK;//创建ResponseEntity对象 ResponseEntity&lt;byte[]&gt; responseEntity = new ResponseEntity&lt;&gt;(bytes, headers, statusCode);//关闭输入流 is.close(); return responseEntity; &#125;&#125; 客户端 1&lt;a th:href=&quot;@&#123;/test/down&#125;&quot;&gt;下载图片&lt;/a&gt; SpringMVC实现文件上传功能文件上传要springmvc，瑞吉外卖和springboot中三个一起看 文件上传要求form表单的请求方式必须为post，并且添加属性enctype&#x3D;”multipart&#x2F;form-data” SpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息 要先引入依赖，配置springMVC配置文件，来让上传的文件自动封装为MultipartFile类型的对象 上传步骤： ①添加依赖： 12345&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; ②在SpringMVC的配置文件中添加配置： 这里class没错，但是如果只有class不行，因为SpringMVC获取bean是通过id，而不是class，所以要设置id值为multipartResolver，且固定就是这个值 1234&lt;!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--&gt;&lt;bean id=&quot;multipartResolver&quot;class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;&lt;/bean&gt; 解析： 1234//获取ServletContext对象 ServletContext servletContext = httpSession.getServletContext(); //获取当前服务器下photo目录的真实的路径 String photoPath=servletContext.getRealPath(&quot;photo&quot;); 这里的getRealPath默认是指spring_mvc_ajax-1.0-SNAPSHOT下的内容， &#x2F;其实也是被解析为映射这下面的内容，这个是有了maven之后才有的 在没有maven的时候,&#x2F;就是被解析为，映射war包下的内容，getRealPath也就是默认这下面的内容 **其识web工程中这些文件都是打包在war包中，都是在tomcat服务器中，所以在文件分隔符的问题上用的都是&#x2F;,而不是windows的\\ ** 服务器端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.atguigu.controller;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.util.MultiValueMap;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.multipart.MultipartFile;import javax.servlet.ServletContext;import javax.servlet.http.HttpSession;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.util.UUID;@Controllerpublic class FileUpAndDownController &#123; @RequestMapping(&quot;/test/up&quot;) //MultipartFile类型的参数的参数名要和上传的文件的name属性相同 public String testUp(MultipartFile photo,HttpSession httpSession) throws IOException &#123; //获取上传的文件的文件名 String fileName=photo.getOriginalFilename(); //获取ServletContext对象 ServletContext servletContext = httpSession.getServletContext(); //获取当前服务器下photo目录的真实的路径 //photoPath就是war包下photo文件夹的路径（可能不存在photo文件夹） String photoPath=servletContext.getRealPath(&quot;photo&quot;); //处理文件重名问题 //就是将文件名设置为永远不重复的内容 //hzName是保留了文件名的后缀，然后用uuid来替换文件名 String hzName = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); fileName = UUID.randomUUID().toString() + hzName; //创建photoPath所对应的File对象，因为photo路径不一定存在 File file=new File(photoPath); //判断file所对应目录是否存在 //不存在直接创建出来 if(!file.exists())&#123; //没分开file.mkdirs和file.mkdir反正用mkdirs就可以了 //他俩都是创建文件夹的，不能创建文件 file.mkdirs(); &#125; //File.separator是文件的分隔符 String finalPath=photoPath+File.separator+fileName; //上传文件 photo.transferTo(new File(finalPath)); return &quot;success&quot;; &#125;&#125; 客户端 12345678&lt;!--文件上传的表单必须用post--&gt;&lt;!--enctype=multipart/form-data也是必须的，是把当前表单中数据以二进制方式提交到服务器中--&gt;&lt;form th:action=&quot;@&#123;/test/up&#125;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;!--设置文件域--&gt; 头像： &lt;input type=&quot;file&quot; name=&quot;photo&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;&lt;/form&gt; 上传文件成功后 可以在tomcat的war包中找到上传完成的文件 SpringMVC的拦截器SpringMVC中的拦截器用于拦截控制器方法的执行 SpringMVC中的拦截器需要实现HandlerInterceptor SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置： 第一种配置 123&lt;mvc:interceptors&gt; &lt;bean class=&quot;com.atguigu.interceptor.FirstInterceptor&quot;/&gt;&lt;/mvc:interceptors&gt; 第二种配置 用firstIntegerceptor作为bean的值是因为，spring默认bean的id就是类名驼峰式 所以通过注解扫描到的FirstInterceptor类的bean的id就是firstInterceptor 1234 &lt;!--基于注解管理bean--&gt; &lt;mvc:interceptors&gt;&lt;ref bean=&quot;firstInterceptor&quot;/&gt; &lt;/mvc:interceptors&gt; 扫描的时候扫到拦截器组件 12&lt;!--扫描所有组件--&gt;&lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;&lt;/context:component-scan&gt; 给拦截器的类加上注解 12@Componentpublic class FirstInterceptor implements HandlerInterceptor &#123; 上面两种方式配置的拦截器默认对DispatcherServlet处理的所有请求进行拦截，其实首页的访问也是通过一个控制器方法配置的，也可以使用视图控制器，所以如果preHandle方法返回false首页返回空白 第三种配置方式、 这种配置方式可以给具体的请求配置拦截器，而且这个也需要把FirstInterceptor这个类交给springioc管理，也就是扫描组件的时候可以扫描到 12345678910111213141516&lt;!--基于注解管理bean--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--对哪些请求进行拦截--&gt; &lt;!--/*指的是上下文目录后只有一层目录的请求--&gt; &lt;!--/**指的是所有的请求--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;!--从上面的请求中排除这个不进行拦截--&gt; &lt;mvc:exclude-mapping path=&quot;/abc&quot;/&gt; &lt;!--用哪一个拦截器--&gt; &lt;!--spring默认bean的id就是类名驼峰式--&gt; &lt;ref bean=&quot;firstInterceptor&quot;&gt;&lt;/ref&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; SpringMVC中的拦截器有三个抽象方法： preHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法 (即不给放行) postHandle：控制器方法执行之后执行postHandle() afterCompletion：处理完视图和模型数据，渲染视图完毕之后执行afterCompletion() 注意：无论访问的资源是否存在，无论对应的控制器方法是否存在，这三个方法都会执行的，但如果preHandle方法返回flase，就不会执行后面两个 FirstInterceptor类是表示拦截器类 1234567891011121314151617181920212223242526272829303132333435363738394041package com.atguigu.interceptor;import org.springframework.stereotype.Component;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import sun.font.TrueTypeFont;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@Componentpublic class FirstInterceptor implements HandlerInterceptor &#123; /* 在当前控制器方法之前，执行这个方法 返回false，控制器方法不执行 返回true，控制器方法执行 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;FirstInterceptor---&gt;preHandle&quot;); return true; &#125; /* 在控制器方法执行之后执行 */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;FirstInterceptor---&gt;postHandle&quot;); &#125; /* 渲染完视图之后执行的 */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;FirstInterceptor---&gt;afterCompletion&quot;); &#125;&#125; index.html 测试 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;首页&lt;/h1&gt;&lt;a th:href=&quot;@&#123;/test/hello&#125;&quot;&gt;测试拦截器&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; SpringMVC多个拦截器的执行顺序①若每个拦截器的preHandle()都返回true 此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关： preHandle()会按照配置的顺序执行，而postHandle()和afterCompletion()会按照配置的反序执行 ②若某个拦截器的preHandle()返回了false preHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false 的拦截器之前的拦截器的afterCompletion()会执行 SpringMVC异常处理器基于xml配置的异常处理器SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver HandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和 SimpleMappingExceptionResolver HandlerExceptionResolver这个接口只提供一个方法，且返回值是ModelAndView，所以异常处理器有两个功能一是能往域中保存数据，二是能返回视图，实现页面跳转 1234567891011121314151617&lt;!--配置一个异常处理器--&gt;&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;!--name是指设置的异常处理器类的属性的名字--&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;!--这个props是专门用来给properties属性赋值的标签--&gt; &lt;!--key设置的是出现的异常，value设置出现该异常时要跳转的页面所对应的逻辑视图--&gt; &lt;props&gt; &lt;prop key=&quot;ArithmeticException&quot;&gt;error&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!--property是属性的意思，这里是给exceptionAttribute属性赋值--&gt; &lt;!--value就是保存在请求域中的异常信息的属性名,可以在error.html的页面上通过获取ex显示错误信息--&gt; &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;&gt; &lt;/property&gt;&lt;/bean&gt; error.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;错误&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;error.html&lt;/h1&gt; &lt;!--获取错误信息--&gt;&lt;p th:text=&quot;$&#123;ex&#125;&quot;&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; index.html测试 同时记住给&#x2F;test&#x2F;hello所对应的控制器方法加上一个int i&#x3D;12&#x2F;0，有数学报错才能异常处理 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;首页&lt;/h1&gt;&lt;a th:href=&quot;@&#123;/test/hello&#125;&quot;&gt;测试拦截器&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 使用注解来实现异常处理在controller包下创建一个类ExceptionController，专门用来做异常处理 1234567891011121314151617181920212223package com.atguigu.controller;import org.springframework.aop.ThrowsAdvice;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.servlet.ModelAndView;//将当前类标识为异常处理的组件@ControllerAdvicepublic class ExceptionController &#123; //@ExceptionHandler标识当前方法为异常处理方法，这个地方是一个Throwable异常及其子类的class类型的数组，所以可以写多个异常,有多个异常要用&#123;&#125;包起来 // @ExceptionHandler(&#123;ArithmeticException.class, Throwable.class&#125;) @ExceptionHandler(ArithmeticException.class) //Model model用model向请求域中添加参数 public String handleException(Throwable ex,Model model)&#123; //把当前的异常信息放到请求域中去存储 model.addAttribute(&quot;ex&quot;,ex); return &quot;error&quot;; &#125;&#125; error.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;错误&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;error.html&lt;/h1&gt; &lt;!--获取错误信息--&gt;&lt;p th:text=&quot;$&#123;ex&#125;&quot;&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; index.html测试 同时记住给&#x2F;test&#x2F;hello所对应的控制器方法加上一个int i&#x3D;12&#x2F;0，有数学报错才能异常处理 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;首页&lt;/h1&gt;&lt;a th:href=&quot;@&#123;/test/hello&#125;&quot;&gt;测试拦截器&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 注解配置SpringMVC使用配置类和注解代替web.xml和SpringMVC配置文件的功能 创建初始化类，代替web.xml 代理web.xml 创建WebInit类继承AbstractAnnotationConfigDispatcherServletInitializer类 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.atguigu.config;import org.springframework.web.filter.CharacterEncodingFilter;import org.springframework.web.filter.HiddenHttpMethodFilter;import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;import javax.servlet.Filter;//这个类是用来代替SpringMVCpublic class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer &#123; @Override //设置一个配置类代理Spring的配置文件 protected Class&lt;?&gt;[] getRootConfigClasses() &#123; //直接把代替Spring配置的类的class实例当作参数传入，可以传多个因为是数组 return new Class[]&#123;SpringConfig.class&#125;; &#125; @Override //设置一个配置类代理SpringMVC的配置文件 protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class[]&#123;WebConfig.class&#125;; &#125; //设置SpringMVC的前端控制器DispatcherServlet的url-pattern @Override protected String[] getServletMappings() &#123; return new String[]&#123;&quot;/&quot;&#125;; &#125; //配置过滤器 @Override protected Filter[] getServletFilters() &#123; //创建编码过滤器 CharacterEncodingFilter characterEncodingFilter=new CharacterEncodingFilter(); characterEncodingFilter.setEncoding(&quot;UTF-8&quot;); characterEncodingFilter.setForceEncoding(true); //创建处理请求方式的过滤器 HiddenHttpMethodFilter hiddenHttpMethodFilter=new HiddenHttpMethodFilter(); return new Filter[]&#123;characterEncodingFilter,hiddenHttpMethodFilter&#125;; &#125;&#125; WebConfig 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130package com.atguigu.config;import com.atguigu.interceptor.FirstInterceptor;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.web.context.ContextLoader;import org.springframework.web.context.WebApplicationContext;import org.springframework.web.multipart.commons.CommonsMultipartResolver;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.ViewResolver;import org.springframework.web.servlet.config.annotation.*;import org.springframework.web.servlet.handler.SimpleMappingExceptionResolver;import org.thymeleaf.spring5.SpringTemplateEngine;import org.thymeleaf.spring5.view.ThymeleafViewResolver;import org.thymeleaf.templatemode.TemplateMode;import org.thymeleaf.templateresolver.ITemplateResolver;import org.thymeleaf.templateresolver.ServletContextTemplateResolver;import java.util.List;import java.util.Properties;//代替SpringMVC的配置/*在SpringMVC中都配置过的内容1.扫描组件2.视图解析器3.默认servlet处理静态资源4.mvc的注解驱动5.视图控制器，文件上传解析器6.拦截器7.异常解析器 *///将类标识为配置类@Configuration//设置扫描组件的注解，value值是范围@ComponentScan(&quot;com.atguigu.controller&quot;)//开启mvc的注解驱动@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer &#123; /* 默认servlet处理静态资源的设置 */ @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125; /* 视图控制器的设置 */ @Override public void addViewControllers(ViewControllerRegistry registry) &#123; //第一个里面是路径，第二个里面是视图 registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;); &#125; /* 拦截器的配置 */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; FirstInterceptor firstInterceptor =new FirstInterceptor(); //addPathPatterns中是拦截的路径,excludePathPatterns是从前面的路径中排除一些路径 registry.addInterceptor(firstInterceptor).addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/abc&quot;); &#125; /* 配置异常解析器 */ @Override public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123; SimpleMappingExceptionResolver exceptionResolver=new SimpleMappingExceptionResolver(); Properties prop=new Properties(); prop.setProperty(&quot;java.lang.ArithmeticException&quot;,&quot;error&quot;); //这里和xml配置文件中的类似，给properties类型属性赋值 exceptionResolver.setExceptionMappings(prop); //这个ex保存在请求域中的异常信息的属性名,可以在error.html的页面上通过获取ex显示错误信息 exceptionResolver.setExceptionAttribute(&quot;ex&quot;); resolvers.add(exceptionResolver); &#125;//下面是用来配置视图解析器的 //配置生成模板解析器 @Bean public ITemplateResolver templateResolver() &#123; WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext();// ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得 ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver( webApplicationContext.getServletContext()); templateResolver.setPrefix(&quot;/WEB-INF/templates/&quot;); templateResolver.setSuffix(&quot;.html&quot;); templateResolver.setCharacterEncoding(&quot;UTF-8&quot;); templateResolver.setTemplateMode(TemplateMode.HTML); return templateResolver; &#125; //生成模板引擎并为模板引擎注入模板解析器 //上一个方法的返回值，作为这个方法的参数，因为@Bean注解管理bean的时候，就是通过这样的方法来使用bean的，bean的id和方法的名字相同 @Bean public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver) &#123; SpringTemplateEngine templateEngine = new SpringTemplateEngine(); templateEngine.setTemplateResolver(templateResolver); return templateEngine; &#125; //生成视图解析器并未解析器注入模板引擎 //上一个方法的返回值，作为这个方法的参数，因为@Bean注解管理bean的时候，就是通过这样的方法来使用bean的，bean的id和方法的名字相同,其实在使用xml配置的时候，也会使用前面配置好的bean的id来配置后面的bean的属性 @Bean public ViewResolver viewResolver(SpringTemplateEngine templateEngine) &#123; ThymeleafViewResolver viewResolver = new ThymeleafViewResolver(); viewResolver.setCharacterEncoding(&quot;UTF-8&quot;); viewResolver.setTemplateEngine(templateEngine); return viewResolver; &#125;&#125; 先不加这个文件上传解析器，因为这个jar包引入不进来 12345678910/*文件上传解析器 */@Bean//@Bean注解可以将表示方法的的返回值作为bean进行管理，配置文件上传解析器在xml配置文件中本来就是配置一个bean//bean的id是当前这个方法的方法名//如果给@Bean注解的value赋值，那么这个bean对象的id就是这个value的值public CommonsMultipartResolver multipartResolver()&#123; return new CommonsMultipartResolver();&#125; SpringMVC的执行流程SpringMVC的常用组件Handler其实就是控制器方法 DispatcherServlet初始化的过程pdf文件 DispatcherServlet调用组件处理请求url：是资源在网络上的路径有协议端口号路径等等 uri：则是资源在服务器中的路径，只有路径，没有协议端口号什么的 加上了默认servlet之后，所有请求都会被默认servlet处理，必须要加上mvc注解驱动才能让请求先让DispatcherServlet处理，处理不了再给默认Servlet 用户向服务器发起请求，使用DispatcherServlet捕获，对其进行解析，如果没有对应的映射，就找看看有没有默认Servlet，如果没有就是404，如果有默认的Servlet处理不了，页面还是404 如果有请求映射，就用HandlerMapping去匹配当前的控制器方法（控制器方法和拦截器也就是Handler配置的所有相关对象）（Handler和Handler所对应的拦截器），再用HandlerAdaptor调用执行控制器方法，在调用控制器方法之前，会按照SpringMVC配置拦截器的顺序去执行拦截器的preHandle方法，然后调用控制器方法，然后在调用拦截器的postHandle方法，然后控制器方法执行完成后，就会返回一个ModleAndView（model是存储域中信息，View是视图）来渲染视图，渲染视图之后就要执行拦截器的afterCompletion方法，再将结果返回到页面 SSM整合Spring和SpringMVC本就是同源的，可以整合可以不整合，不整合就是两个用一个ioc容器，一个配置文件，整合就是分别一个ioc容器，各自管理各自的组件，两个配置文件 Spring管控service层组件，SpringMVC管控controller层组件，SpringMVC的controller层用到service层实体类（自动装配）可能会依赖于Spring的service层 SpringMVC的ioc创建是在DispatcherServlet初始化的时候，所以Spring的ioc创建应该在它之前，所以可以把Springioc的创建放在过滤器初始化方法（不能用，这样会忽略过滤器本来功能）或者监听器的初始化方法，所以用监听器 用监听器原因： 1.监听器初始化的方法只执行一次，因为不是每次用到ioc容器都要重新创建 2.监听器的初始化方法是web服务器启动第一个执行的方法，比DispatcherServlet初始化要早 ContextLoaderListenerSpring提供了监听器ContextLoaderListener，实现ServletContextListener接口，可监听 ServletContext的状态，在web服务器的启动，读取Spring的配置文件，创建Spring的IOC容器。web 应用中必须在web.xml中配置 这个就是为了在web服务器启动的时候，加载spring配置文件，创建springioc容器，等到SpringMVCioc容器获取的时候，完成controller中service的自动装配 使用： web.xml中加上listener的配置 12345678910111213141516171819 &lt;listener&gt; &lt;!--配置Spring的监听器，在服务器启动时加载Spring的配置文件Spring配置文件默认位置和名称：/WEB-INF/applicationContext.xml可通过上下文参数自定义Spring配置文件的位置和名称--&gt; &lt;!--在服务器启动时加载spring的配置文件--&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--自定义Spring配置文件的位置和名称,不用默认的--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt; &lt;/context-param&gt; HelloServiceImpl 1234567891011121314package com.atguigu.service.impl;import com.atguigu.service.HelloService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class HelloServiceImpl implements HelloService &#123; //Service的bean是提前放在spring的ioc容器中的 @Autowired private HelloService helloService;&#125; SpringMVC的容器是子容器，Spring的容器是父容器，当前子容器能访问到父容器中的bean，父容器中的bean不能够访问到子容器中的bean SSM整合的准备工作pom.xml 导入依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.ssm&lt;/groupId&gt; &lt;artifactId&gt;ssm&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;!--打包方式--&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;!--spring的版本号，就是一个属性，在下面的时候可以使用--&gt; &lt;properties&gt; &lt;spring.version&gt;5.3.1&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--导入spring依赖的jar包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--管理beans的jar包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--springmvc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--导入jdbc，是因为事务管理器在这个里面--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;!--spring管理切面的--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring整合junit--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Mybatis核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis和spring的整合包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log4j日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!--分页插件--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志 --&gt; &lt;!--与Themyleaf有关--&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- ServletAPI --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--在springMVC中实现json数据格式的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--文件上传的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring5和Thymeleaf整合包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;version&gt;3.0.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建表 配置web.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--配置Spring的编码过率器--&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--配置处理请求方式的过滤器，有这个才能发putpost请求--&gt; &lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--配置SpringMVC的前端控制器DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--设置SpringMVC配置文件自定义的位置和名称--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--将DispatcherServlet的初始化事件提前到服务器启动时--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--配置Spring的监听器，在服务器启动时加载Spring的配置文件--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--配置Spring配置文件自定义的位置和名称--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt; &lt;/context-param&gt;&lt;/web-app&gt; 配置Springmvc.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!--扫描控制层组件--&gt; &lt;context:component-scan base-package=&quot;com.atguigu.ssm.controller&quot;&gt;&lt;/context:component-scan&gt; &lt;!--配置视图解析器--&gt; &lt;!-- 配置Thymeleaf视图解析器 --&gt; &lt;bean id=&quot;viewResolver&quot; class=&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;property name=&quot;templateEngine&quot;&gt; &lt;bean class=&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;&gt; &lt;property name=&quot;templateResolver&quot;&gt; &lt;bean class=&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;&gt; &lt;!-- 视图前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/templates/&quot;/&gt; &lt;!-- 视图后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.html&quot;/&gt; &lt;property name=&quot;templateMode&quot; value=&quot;HTML5&quot;/&gt; &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--配置默认的Servlet处理静态资源--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--开启mvc的注解驱动--&gt; &lt;mvc:annotation-driven/&gt; &lt;!--配置视图控制器--&gt; &lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;index&quot;&gt;&lt;/mvc:view-controller&gt; &lt;!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;/bean&gt; &lt;!--下面两个都是有需要就配置--&gt; &lt;!--拦截器--&gt; &lt;!--异常处理器--&gt;&lt;/beans&gt; 配置Spring.xml1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!--扫描组件（除控制层）--&gt;&lt;context:component-scan base-package=&quot;com.atguigu.ssm&quot;&gt; &lt;!--排除对控制层组件的扫描--&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt; &lt;!--引入jdbc.properties文件引入--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;&gt;&lt;/context:property-placeholder&gt; &lt;!--数据源交给spring--&gt; &lt;!--配置数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 整合Mybatis1.创建jdbc.properties 在resource下 1234jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=UTCjdbc.username=rootjdbc.password=root 2.在resource下创建mybatis-config.xml 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- mybatis中的核心配置文件中的标签必须要按照指定的顺序配置 properties?,settings?,typeAliases?,typeHandlers?, objectFactory?,objectWrapperFactory?,reflectorFactory?, plugins?,environments?,databaseIdProvider?,mappers? --&gt; &lt;settings&gt; &lt;!--将下划线映射为驼峰--&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; &lt;plugins&gt; &lt;!--配置分页插件--&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;&lt;/plugin&gt; &lt;/plugins&gt;&lt;/configuration&gt; 3.与mybatis整合的Spring配置文件 Spring.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;&lt;!--扫描组件（除控制层）--&gt;&lt;context:component-scan base-package=&quot;com.atguigu.ssm&quot;&gt; &lt;!--排除对控制层组件的扫描--&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt; &lt;!--引入jdbc.properties文件引入--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;&gt;&lt;/context:property-placeholder&gt; &lt;!--数据源交给spring--&gt; &lt;!--配置数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置事务管理器--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--开启事务的注解驱动 将使用注解@Transactional表示的方法或类中所有的方法进行事务管理 --&gt; &lt;!--这里的注解驱动使用 tx结尾的那个链接的--&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; &lt;!--配置sqlSessionFactoryBean，可以直接在speing的ioc中获取sqlSessionFactory--&gt; &lt;!--可以直接获取这个工厂所提供的对象--&gt;&lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!--设置Mybatis的核心配置文件的路径（可以不用）--&gt; &lt;!--如果用这个的话，可以把数据源等等都在mybatis配置文件中配置，下面的都可以不用--&gt; &lt;!--原生创建sqlSessionFactory也需要配置文件流--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;&lt;/property&gt; &lt;!--可以根本不用mybatis配置文件中，直接用在spring中配置的数据源，别名等等所有myabatis-config配置的--&gt; &lt;!--如果有些配置不全，可以两个一起配置mybatis，都留着--&gt; &lt;!--数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;!--设置类型别名--&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.atguigu.ssm.pojo&quot;&gt;&lt;/property&gt; &lt;!--设置映射文件的路径--&gt; &lt;!--只有映射文件的包和mapper接口的包不一致时需要设置--&gt; &lt;!--&lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mappers/*.xml&quot;&gt;--&gt;&lt;/bean&gt; &lt;!--如果没有这个，那么上面那个mapperLocations属性一定要设置，反之可以不设置，如果有这个但mapper接口包和映射文件包名字不一致时也需要设置mapperLocations--&gt; &lt;!--配置mapper接口的扫描，可以将指定包下的所有的mapper接口，通过SqlSession创建代理实现类对象，并将这些对象交给ioc容器管理--&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.atguigu.ssm.mapper&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;/beans&gt; 4.引入log4j日志文件 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt;&lt;log4j:configuration xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt; &lt;param name=&quot;Encoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt; &lt;param name=&quot;ConversionPattern&quot; value=&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125;%m (%F:%L) \\n&quot; /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;logger name=&quot;java.sql&quot;&gt; &lt;level value=&quot;debug&quot; /&gt; &lt;/logger&gt; &lt;logger name=&quot;org.apache.ibatis&quot;&gt; &lt;level value=&quot;info&quot; /&gt; &lt;/logger&gt; &lt;root&gt; &lt;level value=&quot;debug&quot; /&gt; &lt;appender-ref ref=&quot;STDOUT&quot; /&gt; &lt;/root&gt;&lt;/log4j:configuration&gt; 5.mapper 12345678910111213package com.atguigu.ssm.mapper;import com.atguigu.ssm.pojo.Employee;import java.util.List;public interface EmployeeMapper &#123; /* 查询所有员工信息 */ List&lt;Employee&gt; getAllEmployee();&#125; 6.mapper.xml 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.atguigu.ssm.mapper.EmployeeMapper&quot;&gt; &lt;!-- List&lt;Employee&gt; getAllEmployee();--&gt; &lt;select id=&quot;getAllEmployee&quot; resultType=&quot;Employee&quot;&gt; select *from t_emp &lt;/select&gt;&lt;/mapper&gt; 7.分页功能的测试 Controller层 EmployeeController 1234567891011121314151617181920212223242526272829303132333435package com.atguigu.ssm.controller;import com.atguigu.ssm.pojo.Employee;import com.atguigu.ssm.service.EmployeeService;import com.github.pagehelper.PageInfo;import org.apache.ibatis.session.SqlSessionFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.test.context.jdbc.Sql;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import java.util.List;@Controllerpublic class EmployeeController &#123; @Autowired private EmployeeService employeeService; //这是分页的时候查询某一页的信息 @RequestMapping(value = &quot;/employee/page/&#123;pageNum&#125;&quot;,method = RequestMethod.GET) public String getEmployeePage(@PathVariable(&quot;pageNum&quot;) Integer pageNum,Model model) &#123; //获取员工的分页信息 PageInfo&lt;Employee&gt; page = employeeService.getEmployeePage(pageNum); //共享当请求域中 model.addAttribute(&quot;page&quot;,page); //跳转到employee_list.html return &quot;employee_list&quot;; &#125; &#125; pojo层 Employee类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.atguigu.ssm.pojo;import org.springframework.stereotype.Component;public class Employee&#123; private Integer empId; public Integer getEmpId() &#123; return empId; &#125; public void setEmpId(Integer empId) &#123; this.empId = empId; &#125; @Override public String toString() &#123; return &quot;Employee&#123;&quot; + &quot;empId=&quot; + empId + &quot;, empName=&#x27;&quot; + empName + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; + &quot;, email=&#x27;&quot; + email + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public String getEmpName() &#123; return empName; &#125; public Employee() &#123; &#125; public void setEmpName(String empName) &#123; this.empName = empName; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Employee(Integer empId, String empName, Integer age, String gender, String email) &#123; this.empId = empId; this.empName = empName; this.age = age; this.gender = gender; this.email = email; &#125; private String empName; private Integer age; private String gender; private String email;&#125; service层 EmployeeService interface 1234567891011121314package com.atguigu.ssm.service;import com.atguigu.ssm.pojo.Employee;import com.github.pagehelper.PageInfo;import java.util.List;public interface EmployeeService &#123; /* 获取员工的分页信息 */ PageInfo&lt;Employee&gt; getEmployeePage(Integer pageNum);&#125; EmployeeServiceImpl 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.atguigu.ssm.service.impl;import com.atguigu.ssm.mapper.EmployeeMapper;import com.atguigu.ssm.pojo.Employee;import com.atguigu.ssm.service.EmployeeService;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import java.util.List;/*查询所有员工信息---&gt;/employee--&gt;get这个1就是页码查询员工的分页信息---&gt;/employee/page/1--&gt;get根据id查询员工信息--&gt;/employee/1---&gt;get跳转到添加页面 ---&gt;/to/add---&gt;get添加员工信息 --&gt;/employee--&gt;post修改员工信息 ---&gt;/employee--&gt;put删除员工信息 --&gt;employee/1--&gt;delete */@Transactional@Servicepublic class EmployeeServiceImpl implements EmployeeService &#123; /*这个是Mapper的代理实现类对象，可以通过自动装配来设置，因为&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.atguigu.ssm.mapper&quot;&gt;&lt;/property&gt; */@Autowiredprivate EmployeeMapper employeeMapper; /* 获取员工的分页信息 */ @Override public PageInfo&lt;Employee&gt; getEmployeePage(Integer pageNum) &#123; //在查询所有员工信息之前，开启分页功能 //第一个参数是第几页，第二个参数是一页的数据数目 PageHelper.startPage(pageNum,4); //上面的分页功能，相当于给这个查询加上limit，只查询那一页的数据 List&lt;Employee&gt; list = employeeMapper.getAllEmployee(); //获取分页的相关的数据 //第一个参数使查询员工信息的集合，第二个是导航页码的个数 PageInfo&lt;Employee&gt; page = new PageInfo&lt;&gt;(list, 5); return page; &#125;&#125; employee_list.html 显示员工信息的页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http:www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;员工列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt; &lt;tr&gt; &lt;th colspan=&quot;6&quot;&gt;员工列表&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;流水号&lt;/th&gt; &lt;th&gt;员工姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;邮箱&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;!-- status是当前循环的状态对象 status中有很多属性，可以记载一些信息第几次循环之类的 --&gt; &lt;tr th:each=&quot;employee:$&#123;page.list&#125;&quot;&gt; &lt;!--count是指流水号从1开始--&gt; &lt;td th:text=&quot;$&#123;employee.empId&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.empName&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.age&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.gender&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.email&#125;&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;&quot;&gt;删除&lt;/a&gt; &lt;a href=&quot;&quot;&gt;修改&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;div style=&quot;text-align: center;&quot;&gt; &lt;a th:if=&quot;$&#123;page.hasPreviousPage&#125;&quot; th:href=&quot;@&#123;/employee/page/1&#125;&quot;&gt;首页&lt;/a&gt; &lt;!--在路径中引入变量的时候需要把前面的路经加上&#x27; &#x27; --&gt; &lt;a th:if=&quot;$&#123;page.hasPreviousPage&#125;&quot; th:href=&quot;@&#123;&#x27;/employee/page/&#x27;+$&#123;page.prePage&#125;&#125;&quot;&gt;上一页&lt;/a&gt; &lt;span th:each=&quot;num:$&#123;page.navigatepageNums&#125;&quot;&gt; &lt;!--th:text中使用变量的时候，要把其他的字符用&#x27; &#x27;拼接起来--&gt; &lt;!--如果当前页是循环展示的这个页码就标红--&gt; &lt;a th:if=&quot;$&#123;page.pageNum==num&#125;&quot; style=&quot;color: red;&quot; th:href=&quot;@&#123;&#x27;/employee/page/&#x27;+$&#123;num&#125;&#125;&quot; th:text=&quot;&#x27;[&#x27;+$&#123;num&#125;+&#x27;]&#x27;&quot;&gt;&lt;/a&gt; &lt;a th:if=&quot;$&#123;page.pageNum!=num&#125;&quot; th:href=&quot;@&#123;&#x27;/employee/page/&#x27;+$&#123;num&#125;&#125;&quot; th:text=&quot;&#x27;[&#x27;+$&#123;num&#125;+&#x27;]&#x27;&quot;&gt;&lt;/a&gt; &lt;/span&gt; &lt;a th:if=&quot;$&#123;page.hasNextPage&#125;&quot; th:href=&quot;@&#123;&#x27;/employee/page/&#x27;+$&#123;page.nextPage&#125;&#125;&quot;&gt;下一页&lt;/a&gt; &lt;a th:if=&quot;$&#123;page.hasNextPage&#125;&quot; th:href=&quot;@&#123;&#x27;/employee/page/&#x27;+$&#123;page.pages&#125;&#125;&quot;&gt;末页&lt;/a&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; index.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;index&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;index.html&lt;/h1&gt;&lt;!--默认查询第一页--&gt;&lt;a th:href=&quot;@&#123;/employee/page/1&#125;&quot;&gt;查询员工的分页信息&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 分页信息pageInfo的各个属性 1234567891011121314151617181920212223242526 /* pageInfo信息 */ //PageInfo&#123; // pageNum=2, pageSize=4, size=4, // startRow=5, endRow=8, total=30, // pages=8, list=Page&#123;count=true, pageNum=2, pageSize=4, startRow=4, endRow=8, total=30, pages=8, reasonable=false, pageSizeZero=false&#125;[Emp&#123;empId=5, empName=&#x27;a&#x27;, age=null, gender=&#x27;null&#x27;, deptId=null&#125;, Emp&#123;empId=6, empName=&#x27;aa&#x27;, age=null, gender=&#x27;null&#x27;, deptId=null&#125;, Emp&#123;empId=7, empName=&#x27;a&#x27;, age=null, gender=&#x27;null&#x27;, deptId=null&#125;, Emp&#123;empId=8, empName=&#x27;a&#x27;, age=null, gender=&#x27;null&#x27;, deptId=null&#125;], // prePage=1, nextPage=3, isFirstPage=false, // isLastPage=false, hasPreviousPage=true, // hasNextPage=true, navigatePages=5, // navigateFirstPage=1, navigateLastPage=5, navigatepageNums=[1, 2, 3, 4, 5]&#125;/*pageNum：当前页的页码pageSize：每页显示的条数size：当前页显示的真实条数total：总记录数pages：总页数prePage：上一页的页码nextPage：下一页的页码isFirstPage/isLastPage：是否为第一页/最后一页hasPreviousPage/hasNextPage：是否存在上一页/下一页navigatePages：导航分页的页码数navigatepageNums：导航分页的页码，[1,2,3,4,5] */ 修改员工信息 先跳转到修改信息的页面，再进行信息修改然后返回显示列表 employee_list.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http:www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;员工列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt; &lt;tr&gt; &lt;th colspan=&quot;6&quot;&gt;员工列表&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;流水号&lt;/th&gt; &lt;th&gt;员工姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;邮箱&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;!-- status是当前循环的状态对象 status中有很多属性，可以记载一些信息第几次循环之类的 --&gt; &lt;tr th:each=&quot;employee:$&#123;page.list&#125;&quot;&gt; &lt;!--count是指流水号从1开始--&gt; &lt;td th:text=&quot;$&#123;employee.empId&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.empName&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.age&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.gender&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.email&#125;&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;&quot;&gt;删除&lt;/a&gt; &lt;a th:href=&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.empId&#125;&#125;&quot;&gt;修改&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;div style=&quot;text-align: center;&quot;&gt; &lt;a th:if=&quot;$&#123;page.hasPreviousPage&#125;&quot; th:href=&quot;@&#123;/employee/page/1&#125;&quot;&gt;首页&lt;/a&gt; &lt;!--在路径中引入变量的时候需要把前面的路经加上&#x27; &#x27; --&gt; &lt;a th:if=&quot;$&#123;page.hasPreviousPage&#125;&quot; th:href=&quot;@&#123;&#x27;/employee/page/&#x27;+$&#123;page.prePage&#125;&#125;&quot;&gt;上一页&lt;/a&gt; &lt;span th:each=&quot;num:$&#123;page.navigatepageNums&#125;&quot;&gt; &lt;!--th:text中使用变量的时候，要把其他的字符用&#x27; &#x27;拼接起来--&gt; &lt;!--如果当前页是循环展示的这个页码就标红--&gt; &lt;a th:if=&quot;$&#123;page.pageNum==num&#125;&quot; style=&quot;color: red;&quot; th:href=&quot;@&#123;&#x27;/employee/page/&#x27;+$&#123;num&#125;&#125;&quot; th:text=&quot;&#x27;[&#x27;+$&#123;num&#125;+&#x27;]&#x27;&quot;&gt;&lt;/a&gt; &lt;a th:if=&quot;$&#123;page.pageNum!=num&#125;&quot; th:href=&quot;@&#123;&#x27;/employee/page/&#x27;+$&#123;num&#125;&#125;&quot; th:text=&quot;&#x27;[&#x27;+$&#123;num&#125;+&#x27;]&#x27;&quot;&gt;&lt;/a&gt; &lt;/span&gt; &lt;a th:if=&quot;$&#123;page.hasNextPage&#125;&quot; th:href=&quot;@&#123;&#x27;/employee/page/&#x27;+$&#123;page.nextPage&#125;&#125;&quot;&gt;下一页&lt;/a&gt; &lt;a th:if=&quot;$&#123;page.hasNextPage&#125;&quot; th:href=&quot;@&#123;&#x27;/employee/page/&#x27;+$&#123;page.pages&#125;&#125;&quot;&gt;末页&lt;/a&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Controller 第一次的 123456789//修改一条员工信息@RequestMapping(&quot;/employee/&#123;empId&#125;&quot;)public String updateEmployee(@PathVariable(&quot;empId&quot;) int id,Model model)&#123; Employee employee = employeeService.getEmployeeById(id); System.out.println(employee); model.addAttribute(&quot;employee&quot;,employee); return &quot;employee_update&quot;;&#125; employee_update.html 参数的name要和实体类中的属性名一致 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http:www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;employee_update&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=&quot;post&quot; th:action=&quot;@&#123;/employee&#125;&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot;/&gt; &lt;input type=&quot;hidden&quot; name=&quot;empId&quot; th:value=&quot;$&#123;employee.empId&#125;&quot;/&gt; &lt;table&gt; &lt;tr colspan=&quot;2&quot;&gt; updateEmployee &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;&lt;input type=&quot;text&quot; name=&quot;empName&quot; th:value=&quot;$&#123;employee.empName&#125;&quot;/&gt;&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;&lt;input type=&quot;text&quot; name=&quot;age&quot; th:value=&quot;$&#123;employee.age&#125;&quot;/&gt;&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;邮箱&lt;/th&gt; &lt;th&gt;&lt;input type=&quot;text&quot; name=&quot;email&quot; th:value=&quot;$&#123;employee.email&#125;&quot;/&gt;&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; th:field=&quot;$&#123;employee.gender&#125;&quot;&gt;male &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; th:field=&quot;$&#123;employee.gender&#125;&quot;&gt;female &lt;/th&gt; &lt;/tr&gt; &lt;/table&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; Controller 第二次的 123456@RequestMapping(value = &quot;/employee&quot;,method = RequestMethod.PUT)public String updateEmployee1(Employee employee)&#123; System.out.println(employee); employeeService.updateEmployee(employee); return &quot;redirect:/employee/page/1&quot;;&#125; EmployeeMapper.xml 123456789&lt;!-- Employee getEmployeeById();--&gt;&lt;select id=&quot;getEmployeeById&quot; resultType=&quot;Employee&quot;&gt; select *from t_emp where emp_id=#&#123;id&#125;&lt;/select&gt;&lt;!--void updateEmployee(Employee employee);--&gt;&lt;update id=&quot;updateEmployee&quot;&gt; update t_emp set emp_name=#&#123;empName&#125;,email=#&#123;email&#125;,gender=#&#123;gender&#125;,age=#&#123;age&#125; where emp_id=#&#123;empId&#125;&lt;/update&gt; EmployeeMapper 123456789/*根据id查询用户的信息 */Employee getEmployeeById(int id);/*修改用户信息 */void updateEmployee(Employee employee); EmployeeServiceImpl 1234567/*通过id更新员工信息 */@Overridepublic void updateEmployee(Employee employee) &#123; employeeMapper.updateEmployee(employee);&#125; EmployeeService 123456789/*根据id查询员工信息 */Employee getEmployeeById(int id);/*更新员工信息 */void updateEmployee(Employee employee); Employee 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.atguigu.ssm.pojo;import org.springframework.stereotype.Component;public class Employee&#123; private Integer empId; public Integer getEmpId() &#123; return empId; &#125; public void setEmpId(Integer empId) &#123; this.empId = empId; &#125; @Override public String toString() &#123; return &quot;Employee&#123;&quot; + &quot;empId=&quot; + empId + &quot;, empName=&#x27;&quot; + empName + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; + &quot;, email=&#x27;&quot; + email + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public String getEmpName() &#123; return empName; &#125; public Employee() &#123; &#125; public void setEmpName(String empName) &#123; this.empName = empName; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Employee(Integer empId, String empName, Integer age, String gender, String email) &#123; this.empId = empId; this.empName = empName; this.age = age; this.gender = gender; this.email = email; &#125; private String empName; private Integer age; private String gender; private String email;&#125; 添加员工信息 EmployeeMapper 1234&lt;!-- void addEmployee(Employee employee);--&gt;&lt;insert id=&quot;addEmployee&quot;&gt; insert into t_emp values(null,#&#123;empName&#125;,#&#123;age&#125;,#&#123;gender&#125;,#&#123;email&#125;)&lt;/insert&gt; 1234/*添加用户信息 */void addEmployee(Employee employee); employee_list.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http:www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;员工列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt; &lt;tr&gt; &lt;th colspan=&quot;6&quot;&gt;员工列表&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;流水号&lt;/th&gt; &lt;th&gt;员工姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;邮箱&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;!-- status是当前循环的状态对象 status中有很多属性，可以记载一些信息第几次循环之类的 --&gt; &lt;tr th:each=&quot;employee:$&#123;page.list&#125;&quot;&gt; &lt;!--count是指流水号从1开始--&gt; &lt;td th:text=&quot;$&#123;employee.empId&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.empName&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.age&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.gender&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.email&#125;&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;&quot;&gt;删除&lt;/a&gt; &lt;a th:href=&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.empId&#125;&#125;&quot;&gt;修改&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;div&gt; &lt;a th:href=&quot;@&#123;/to/add&#125;&quot;&gt;增添员工信息&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt; &lt;a th:if=&quot;$&#123;page.hasPreviousPage&#125;&quot; th:href=&quot;@&#123;/employee/page/1&#125;&quot;&gt;首页&lt;/a&gt; &lt;!--在路径中引入变量的时候需要把前面的路经加上&#x27; &#x27; --&gt; &lt;a th:if=&quot;$&#123;page.hasPreviousPage&#125;&quot; th:href=&quot;@&#123;&#x27;/employee/page/&#x27;+$&#123;page.prePage&#125;&#125;&quot;&gt;上一页&lt;/a&gt; &lt;span th:each=&quot;num:$&#123;page.navigatepageNums&#125;&quot;&gt; &lt;!--th:text中使用变量的时候，要把其他的字符用&#x27; &#x27;拼接起来--&gt; &lt;!--如果当前页是循环展示的这个页码就标红--&gt; &lt;a th:if=&quot;$&#123;page.pageNum==num&#125;&quot; style=&quot;color: red;&quot; th:href=&quot;@&#123;&#x27;/employee/page/&#x27;+$&#123;num&#125;&#125;&quot; th:text=&quot;&#x27;[&#x27;+$&#123;num&#125;+&#x27;]&#x27;&quot;&gt;&lt;/a&gt; &lt;a th:if=&quot;$&#123;page.pageNum!=num&#125;&quot; th:href=&quot;@&#123;&#x27;/employee/page/&#x27;+$&#123;num&#125;&#125;&quot; th:text=&quot;&#x27;[&#x27;+$&#123;num&#125;+&#x27;]&#x27;&quot;&gt;&lt;/a&gt; &lt;/span&gt; &lt;a th:if=&quot;$&#123;page.hasNextPage&#125;&quot; th:href=&quot;@&#123;&#x27;/employee/page/&#x27;+$&#123;page.nextPage&#125;&#125;&quot;&gt;下一页&lt;/a&gt; &lt;a th:if=&quot;$&#123;page.hasNextPage&#125;&quot; th:href=&quot;@&#123;&#x27;/employee/page/&#x27;+$&#123;page.pages&#125;&#125;&quot;&gt;末页&lt;/a&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Controller 123456//添加员工信息@RequestMapping(value = &quot;/employee&quot;,method = RequestMethod.POST)public String addEmployee(Employee employee)&#123; employeeService.addEmployee(employee); return &quot;redirect:/employee/page/1&quot;;&#125; ServiceImpl 12345678/*添加员工信息 */@Overridepublic void addEmployee(Employee employee) &#123; employeeMapper.addEmployee(employee);&#125; Service 1234/*添加员工信息 */void addEmployee(Employee employee);","categories":[],"tags":[]},{"title":"vue2","slug":"vue2","date":"2022-09-29T15:31:35.000Z","updated":"2023-04-10T13:19:46.333Z","comments":true,"path":"2022/09/29/vue2/","link":"","permalink":"http://example.com/2022/09/29/vue2/","excerpt":"","text":"三. Vue 21. Vue 基础1) 环境准备安装脚手架1npm install -g @vue/cli -g 参数表示全局安装，这样在任意目录都可以使用 vue 脚本创建项目 创建项目1vue ui 使用图形向导来创建 vue 项目，如下图，输入项目名 选择手动配置项目 添加 vue router 和 vuex 选择版本，创建项目 安装 devtools devtools 插件网址：https://devtools.vuejs.org/guide/installation.html 运行项目进入项目目录(client目录)，执行 1npm run serve 修改端口前端服务器默认占用了 8080 端口，需要修改一下 文档地址：DevServer | webpack 打开 vue.config.js (view工程client目录下的文件)添加 12345678910const &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)module.exports = defineConfig(&#123; // ... devServer: &#123; port: 7070 &#125; &#125;) 添加代理为了避免前后端服务器联调时， fetch、xhr 请求产生跨域问题，需要配置代理 文档地址同上 打开 vue.config.js 添加 这个设置就是让所有&#x2F;api开头的请求都走代理走target那个路径，比如正常&#x2F;api&#x2F;a1应该是localhost:7070&#x2F;api&#x2F;a1,但现在实际上上localhost:8080&#x2F;api&#x2F;a1 用代理的话服务器端就不用加那个CrossOrigin注解了 12345678910111213141516const &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)module.exports = defineConfig(&#123; // ... devServer: &#123; port: 7070, proxy: &#123; &#x27;/api&#x27;: &#123; target: &#x27;http://localhost:8080&#x27;, changeOrigin: true &#125; &#125; &#125; &#125;) Vue 项目结构1234567PS D:\\2022.js\\代码\\第3章\\client&gt; tree srcD:\\2022.JS\\代码\\第3章\\CLIENT\\SRC├─assets├─components├─router├─store└─views assets - 静态资源 components - 可重用组件 router - 路由 store - 数据共享 views - 视图组件 以后还会添加 api - 跟后台交互，发送 fetch、xhr 请求，接收响应 plugins - 插件 2) Vue 组件Vue 的组件文件以 .vue 结尾，每个组件由三部分组成 12345&lt;template&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; template 模板部分，由它生成 html 代码 script 代码部分，控制模板的数据来源和行为 style 样式部分，一般不咋关心 入口组件是 App.vue 先删除原有代码，来个 Hello, World 例子 1234567891011121314&lt;template&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&lt;/template&gt;&lt;script&gt;const options=&#123; data: function()&#123; return &#123;msg: &#x27;你好!&#x27;&#125;; &#125;&#125;;export default options;&lt;/script&gt; 解释 export default 导出组件对象，供 main.js 导入使用 这个对象有一个 data 方法，返回一个对象，给 template 提供数据 &#123;&#123;&#125;&#125; 在 Vue 里称之为插值表达式，用来绑定 data 方法返回的对象属性，绑定的含义是数据发生变化时，页面显示会同步变化 文本插值1234567891011121314&lt;template&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123; name &#125;&#125;&lt;/h1&gt; &lt;h1&gt;&#123;&#123; age &gt; 60 ? &#x27;老年&#x27; : &#x27;青年&#x27; &#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const options = &#123; data: function () &#123; return &#123; name: &#x27;张三&#x27;, age: 70 &#125;; &#125;&#125;;export default options;&lt;/script&gt; &#123;&#123;&#125;&#125; 里只能绑定一个属性，绑定多个属性需要用多个 &#123;&#123;&#125;&#125; 分别绑定 template 内只能有一个根元素，所以不能直接写两个h1，得是在div中写两个h1 插值( &#123;&#123; &#125;&#125; )内可以进行简单的表达式计算 属性绑定123456789101112131415&lt;template&gt; &lt;div&gt; &lt;div&gt;&lt;input type=&quot;text&quot; v-bind:value=&quot;name&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=&quot;date&quot; v-bind:value=&quot;birthday&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=&quot;text&quot; :value=&quot;age&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const options = &#123; data: function () &#123; return &#123; name: &#x27;王五&#x27;, birthday: &#x27;1995-05-01&#x27;, age: 20 &#125;; &#125;&#125;;export default options;&lt;/script&gt; 简写方式：可以省略 v-bind 只保留冒号 事件绑定v-on:click&#x3D;”m1” 是指单击事件 1234567891011121314151617181920212223242526&lt;!-- 事件绑定 --&gt;&lt;template&gt; &lt;div&gt; &lt;div&gt;&lt;input type=&quot;button&quot; value=&quot;点我执行m1&quot; v-on:click=&quot;m1&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=&quot;button&quot; value=&quot;点我执行m2&quot; @click=&quot;m2&quot;&gt;&lt;/div&gt; &lt;div&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const options = &#123; data: function () &#123; return &#123; count: 0 &#125;; &#125;, methods: &#123; m1() &#123; this.count ++; console.log(&quot;m1&quot;) &#125;, m2() &#123; this.count --; console.log(&quot;m2&quot;) &#125; &#125;&#125;;export default options;&lt;/script&gt; 简写方式：可以把 v-on: 替换为 @ 在 methods 方法中的 this 代表的是 data 函数返回的数据对象，也就是整个return后面的{ }这个对象 双向绑定单选框和多选框正常绑定的属性的值如果和标签value一致，则这个选框会被选中 同时用户改变选择的选框，这个属性的值也会被改变 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;label for=&quot;&quot;&gt;请输入姓名&lt;/label&gt; &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;&quot;&gt;请输入年龄&lt;/label&gt; &lt;input type=&quot;text&quot; v-model=&quot;age&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;&quot;&gt;请选择性别&lt;/label&gt; 男 &lt;input type=&quot;radio&quot; value=&quot;男&quot; v-model=&quot;sex&quot;&gt; 女 &lt;input type=&quot;radio&quot; value=&quot;女&quot; v-model=&quot;sex&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;&quot;&gt;请选择爱好&lt;/label&gt; 游泳 &lt;input type=&quot;checkbox&quot; value=&quot;游泳&quot; v-model=&quot;fav&quot;&gt; 打球 &lt;input type=&quot;checkbox&quot; value=&quot;打球&quot; v-model=&quot;fav&quot;&gt; 健身 &lt;input type=&quot;checkbox&quot; value=&quot;健身&quot; v-model=&quot;fav&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const options = &#123; data: function () &#123; return &#123; name: &#x27;&#x27;, age: null, sex:&#x27;男&#x27; , fav:[&#x27;打球&#x27;]&#125;; &#125;, methods: &#123; &#125;&#125;;export default options;&lt;/script&gt; 用 v-model 实现双向绑定，即 javascript 数据可以同步到表单标签 反过来用户在表单标签输入的新值也会同步到 javascript 这边 双向绑定只适用于表单这种带【输入】功能的标签，其它标签的数据绑定，单向就足够了 复选框这种标签，双向绑定的 javascript 数据类型一般用数组 计算属性12345678910111213141516171819202122232425262728&lt;!-- 计算属性 --&gt;&lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123;fullName&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;fullName&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;fullName&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const options = &#123; data: function () &#123; return &#123; firstName: &#x27;三&#x27;, lastName: &#x27;张&#x27; &#125;; &#125;, /* methods: &#123; fullName() &#123; console.log(&#x27;进入了 fullName&#x27;) return this.lastName + this.firstName; &#125; &#125;,*/ computed: &#123; fullName() &#123; console.log(&#x27;进入了 fullName&#x27;) return this.lastName + this.firstName; &#125; &#125;&#125;;export default options; &lt;/script&gt; 普通方法调用必须加 ()，没有缓存功能 计算属性使用时就把它当属性来用，不加 ()，有缓存功能： 一次计算后，会将结果缓存，下次再计算时，只要数据没有变化，不会重新计算，直接返回缓存结果 axiosaxios 它的底层是用了 XMLHttpRequest（xhr）方式发送请求和接收响应，xhr 相对于之前讲过的 fetch api 来说，功能更强大，但由于是比较老的 api，不支持 Promise，axios 对 xhr 进行了封装，使之支持 Promise，并提供了对请求、响应的统一拦截功能 安装 以管理员身份运行cmd，然后在client（vue项目）目录下用这个命令 1npm install axios -S 导入 1import axios from &#x27;axios&#x27; axios 默认导出一个对象，这里的 import 导入的就是它默认导出的对象 方法 请求 备注 axios.get(url[, config]) :star: axios.delete(url[, config]) axios.head(url[, config]) axios.options(url[, config]) axios.post(url[, data[, config]]) :star: axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) config - 选项对象、例如查询参数、请求头… data - 请求体数据、最常见的是 json 格式数据 get、head 请求无法携带请求体，这应当是浏览器的限制所致（xhr、fetch api 均有限制） options、delete 请求可以通过 config 中的 data 携带请求体 例子 这段代码中演示的都是同步的请求，因为有这个async和await，要等待请求返回才能接着执行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;template&gt; &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;获取远程数据&quot; @click=&quot;sendReq()&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from &#x27;axios&#x27;const options = &#123; methods: &#123; async sendReq() &#123; // 1. 演示 get, post // const resp = await axios.post(&#x27;/api/a2&#x27;); // 2. 发送请求头 //data没有可以给一个空对象&#123;&#125; // const resp = await axios.post(&#x27;/api/a3&#x27;,&#123;&#125;,&#123; // headers:&#123; // Authorization:&#x27;abc&#x27; // &#125; // &#125;); // 3. 发送请求时携带查询参数 ?name=xxx&amp;age=xxx //如果name是&amp;&amp;&amp;的话，&amp;它是属于特殊字符的，所以要进行一个编码 // const name = encodeURIComponent(&#x27;&amp;&amp;&amp;&#x27;); // const age = 18; // const resp = await axios.post(`/api/a4?name=$&#123;name&#125;&amp;age=$&#123;age&#125;`); // 不想自己拼串、处理特殊字符、就用下面的办法 // const resp = await axios.post(&#x27;/api/a4&#x27;, &#123;&#125;, &#123; // params: &#123; // name:&#x27;&amp;&amp;&amp;&amp;&#x27;, // age: 20 // &#125; // &#125;); // 4. 用请求体发数据，格式为 urlencoded //服务器端不需要@RequestBody来接受 // const params = new URLSearchParams(); // params.append(&quot;name&quot;, &quot;张三&quot;); // params.append(&quot;age&quot;, 24) // const resp = await axios.post(&#x27;/api/a4&#x27;, params); // 5. 用请求体发数据，格式为 multipart //服务器端不需要@RequestBody来接受 // const params = new FormData(); // params.append(&quot;name&quot;, &quot;李四&quot;); // params.append(&quot;age&quot;, 30); // const resp = await axios.post(&#x27;/api/a5&#x27;, params); // 6. 用请求体发数据，格式为 json //服务器端需要@RequestBody来接受 const resp = await axios.post(&#x27;/api/a5json&#x27;, &#123; name: &#x27;王五&#x27;, age: 50 &#125;); console.log(resp); &#125; &#125;&#125;;export default options;&lt;/script&gt; 创建实例 1const _axios = axios.create(config); axios 对象可以直接使用，但使用的是默认的设置 用 axios.create 创建的对象，可以覆盖默认设置，config 见下面说明 常见的 config 项有 名称 含义 baseURL 将自动加在 url 前面 headers 请求头，类型为简单对象 params 跟在 URL 后的请求参数，类型为简单对象或 URLSearchParams data 请求体，类型有简单对象、FormData、URLSearchParams、File 等 withCredentials 跨域时是否携带 Cookie 等凭证，默认为 false responseType 响应类型，默认为 json 例 123456const _axios = axios.create(&#123; baseURL: &#x27;http://localhost:8080&#x27;, withCredentials: true&#125;);await _axios.post(&#x27;/api/a6set&#x27;)await _axios.post(&#x27;/api/a6get&#x27;) 生产环境希望 xhr 请求不走代理，可以用 baseURL 统一修改 希望跨域请求携带 cookie，需要配置 withCredentials: true，服务器也要配置 allowCredentials &#x3D; true，否则浏览器获取跨域返回的 cookie 时会报错 响应格式 名称 含义 data 响应体数据 :star: status 状态码 :star: headers 响应头 200 表示响应成功 400 请求数据不正确 age&#x3D;abc 401 身份验证没通过 403 没有权限 404 资源不存在 405 不支持请求方式 post 500 服务器内部错误 请求拦截器 12345678910111213_axios.interceptors.request.use( function(config) &#123; // 比如在这里添加统一的 headers //在请求里面加上指定的请求头 config.headers=&#123; Authorization: &#x27;aaa.bbb.ccc&#x27; &#125; return config; &#125;, function(error) &#123; return Promise.reject(error); &#125;); 响应拦截器 12345678910111213141516171819202122232425262728293031_axios.interceptors.response.use( function(response) &#123; // 2xx 范围内走这里 return response; &#125;, //响应出现异常会走这个函数 function(error) &#123; //可以用来处理报错 //error中有response响应对象有一个属性叫status if(error.response.status===400)&#123; console.log(&#x27;请求参数不正确&#x27;); //这个类似于异常捕捉之后处理了，里面参数可以随便传一个 return Promise.resolve(400); &#125; else if(error.response.status===401)&#123; console.log(&#x27;跳转至登录页面&#x27;); //这个类似于异常捕捉之后处理了，里面参数可以随便传一个 return Promise.resolve(401); &#125; else if(error.response.status===404)&#123; console.log(&#x27;资源未找到&#x27;); //这个类似于异常捕捉之后处理了，里面参数可以随便传一个 return Promise.resolve(404); &#125; // 超出 2xx, 比如 4xx, 5xx 走这里 //这里就是抛出异常，异常还是会在控制台显示 // return Promise.reject(error); &#125;); 将有关axios的创建，以及种种配置单独放在一个js文件中，然后在其他的.vue文件中引入 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import axios from &#x27;axios&#x27;const _axios = axios.create(&#123; // baseURL: &#x27;http://localhost:8080&#x27;, withCredentials: true&#125;);// 9. 拦截器_axios.interceptors.request.use( function (config) &#123; // 比如在这里添加统一的 headers config.headers = &#123; Authorization: &#x27;aaa.bbb.ccc&#x27; &#125; return config; &#125;, function (error) &#123; return Promise.reject(error); &#125;);_axios.interceptors.response.use( function (response) &#123; // 2xx 范围内走这里 return response; &#125;, function (error) &#123; if (error.response?.status === 400) &#123; console.log(&#x27;请求参数不正确&#x27;); return Promise.resolve(400); &#125; else if (error.response?.status === 401) &#123; console.log(&#x27;跳转至登录页面&#x27;); return Promise.resolve(401); &#125; else if (error.response?.status === 404) &#123; console.log(&#x27;资源未找到&#x27;); return Promise.resolve(404); &#125; // 超出 2xx, 比如 4xx, 5xx 走这里 return Promise.reject(error); &#125;);export default _axios; 条件渲染 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;template&gt; &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;获取远程数据&quot; @click=&quot;sendReq()&quot;&gt; &lt;div class=&quot;title&quot;&gt;学生列表&lt;/div&gt; &lt;div class=&quot;thead&quot;&gt; &lt;div class=&quot;row bold&quot;&gt; &lt;div class=&quot;col&quot;&gt;编号&lt;/div&gt; &lt;div class=&quot;col&quot;&gt;姓名&lt;/div&gt; &lt;div class=&quot;col&quot;&gt;性别&lt;/div&gt; &lt;div class=&quot;col&quot;&gt;年龄&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;tbody&quot;&gt; &lt;!--如果students数组的长度大于零就显示学生书据，否则就是暂无学生数据--&gt; &lt;div class=&quot;row&quot; v-if=&quot;students.length &gt; 0&quot;&gt;显示学生数据&lt;/div&gt; &lt;div class=&quot;row&quot; v-else&gt;暂无学生数据&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from &#x27;../util/myaxios&#x27;const options = &#123; data: function() &#123; return &#123; students: [] &#125;; &#125;, methods : &#123; async sendReq() &#123; const resp = await axios.get(&quot;/api/students&quot;); //resp.data是那个R对象（R对象既有code，也有data，message属性），resp.data.data才是真正的要返回的java对象 console.log(resp.data.data) //this是data返回的那个&#123;&#125;对象 this.students = resp.data.data; &#125; &#125;&#125;;export default options;&lt;/script&gt;&lt;style scoped&gt; div &#123; font-family: 华文行楷; font-size: 20px; &#125; .title &#123; margin-bottom: 10px; font-size: 30px; color: #333; text-align: center; &#125; .row &#123; background-color: #fff; display: flex; justify-content: center; &#125; .col &#123; border: 1px solid #f0f0f0; width: 15%; height: 35px; text-align: center; line-height: 35px; &#125; .bold .col &#123; background-color: #f1f1f1; &#125;&lt;/style&gt; 列表渲染12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;template&gt; &lt;div&gt; &lt;!-- &lt;input type=&quot;button&quot; value=&quot;获取远程数据&quot; @click=&quot;sendReq()&quot;&gt; --&gt; &lt;div class=&quot;title&quot;&gt;学生列表&lt;/div&gt; &lt;div class=&quot;thead&quot;&gt; &lt;div class=&quot;row bold&quot;&gt; &lt;div class=&quot;col&quot;&gt;编号&lt;/div&gt; &lt;div class=&quot;col&quot;&gt;姓名&lt;/div&gt; &lt;div class=&quot;col&quot;&gt;性别&lt;/div&gt; &lt;div class=&quot;col&quot;&gt;年龄&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;tbody&quot;&gt; &lt;div v-if=&quot;students.length &gt; 0&quot;&gt; &lt;!--循环，s是students数组中的每 一个元素--&gt; &lt;!--key属性要和一个元素唯一标识的属性进行绑定--&gt; &lt;div class=&quot;row&quot; v-for=&quot;s of students&quot; :key=&quot;s.id&quot;&gt; &lt;div class=&quot;col&quot;&gt;&#123;&#123;s.id&#125;&#125;&lt;/div&gt; &lt;div class=&quot;col&quot;&gt;&#123;&#123;s.name&#125;&#125;&lt;/div&gt; &lt;div class=&quot;col&quot;&gt;&#123;&#123;s.sex&#125;&#125;&lt;/div&gt; &lt;div class=&quot;col&quot;&gt;&#123;&#123;s.age&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot; v-else&gt;暂无学生数据&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from &#x27;../util/myaxios&#x27;const options = &#123; //mounted方法在组件加载完成(准备就绪)之后就会自动调用 //组件也就是导入的js文件等等 mounted: function()&#123; //在一个方法中调用另外一个方法，要用this.方法 this.sendReq() &#125;, data: function() &#123; return &#123; students: [] &#125;; &#125;, methods : &#123; async sendReq() &#123; const resp = await axios.get(&quot;/api/students&quot;); console.log(resp.data.data) this.students = resp.data.data; &#125; &#125;&#125;;export default options;&lt;/script&gt;&lt;style scoped&gt; div &#123; font-family: 华文行楷; font-size: 20px; &#125; .title &#123; margin-bottom: 10px; font-size: 30px; color: #333; text-align: center; &#125; .row &#123; background-color: #fff; display: flex; justify-content: center; &#125; .col &#123; border: 1px solid #f0f0f0; width: 15%; height: 35px; text-align: center; line-height: 35px; &#125; .bold .col &#123; background-color: #f1f1f1; &#125;&lt;/style&gt; v-if 和 v-for 不能用于同一个标签 v-for 需要配合特殊的标签属性 key 一起使用，并且 key 属性要绑定到一个能起到唯一标识作用的数据上，本例绑定到了学生编号上 options 的 mounted 属性对应一个函数，此函数会在组件挂载后（准备就绪）被调用，可以在它内部发起请求，去获取学生数据 重用组件按钮组件 1234567891011&lt;template&gt; &lt;div class=&quot;button&quot; :class=&quot;[type,size]&quot;&gt; a&lt;slot&gt;&lt;/slot&gt;b &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const options = &#123; props: [&quot;type&quot;, &quot;size&quot;]&#125;;export default options;&lt;/script&gt; 注意，省略了样式部分 使用组件 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;h1&gt;父组件&lt;/h1&gt; &lt;my-button type=&quot;primary&quot; size=&quot;small&quot;&gt;1&lt;/my-button&gt; &lt;my-button type=&quot;danger&quot; size=&quot;middle&quot;&gt;2&lt;/my-button&gt; &lt;my-button type=&quot;success&quot; size=&quot;large&quot;&gt;3&lt;/my-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import MyButton from &#x27;../components/MyButton.vue&#x27;const options = &#123; components: &#123; MyButton &#125;&#125;;export default options;&lt;/script&gt; 2. Vue 进阶1) ElementUI安装 1npm install element-ui -S 引入组件 1234import Element from &#x27;element-ui&#x27;import &#x27;element-ui/lib/theme-chalk/index.css&#x27;Vue.use(Element) 测试，在自己的组件中使用 ElementUI 的组件 1&lt;el-button&gt;按钮&lt;/el-button&gt; 表格组件1234567891011121314151617181920212223242526&lt;template&gt; &lt;div&gt; &lt;el-table :data=&quot;students&quot;&gt; &lt;el-table-column label=&quot;编号&quot; prop=&quot;id&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column label=&quot;姓名&quot; prop=&quot;name&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column label=&quot;性别&quot; prop=&quot;sex&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column label=&quot;年龄&quot; prop=&quot;age&quot;&gt;&lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from &#x27;../util/myaxios&#x27;const options = &#123; //async和await保证了这个方法是同步的，等待axios.get请求返回后才能向下执行 async mounted() &#123; const resp = await axios.get(&#x27;/api/students&#x27;); this.students = resp.data.data &#125;, data() &#123; return &#123; students: [] &#125; &#125;&#125;export default options;&lt;/script&gt; 分页组件加了:的属性其实就是v-bind: 的简写，也就是绑定了javascript中的变量，没加冒号这些等号右边的这些就是它的结果，不会到javascript当中找啦，但是加了:这些就会区javascript中的变量去找 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;template&gt; &lt;div&gt; &lt;el-table v-bind:data=&quot;students&quot;&gt; &lt;!--prop中填的是学生对象的属性名称--&gt; &lt;el-table-column label=&quot;编号&quot; prop=&quot;id&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column label=&quot;姓名&quot; prop=&quot;name&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column label=&quot;性别&quot; prop=&quot;sex&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column label=&quot;年龄&quot; prop=&quot;age&quot;&gt;&lt;/el-table-column&gt; &lt;/el-table&gt; &lt;!--total是指总记录数是多少--&gt; &lt;!--page-size是指每页有多少条记录--&gt; &lt;!--current-page是指当前页是哪一页--&gt; &lt;!--控制哪些分页小组件(比如pager是页码)显示哪些--&gt; &lt;!--page-sizes是可以给你一个单选框让你选择一页多少条记录--&gt; &lt;!--total ,current-page这些前面带:都是先在javascript中找对应属性，找不到的话就把这个值当成表达式解析--&gt; &lt;!--就是去看total是什么类型，total是number类型，就会把50转换成数字50--&gt; &lt;!--page-sizes是number[]类型 所以会把等号后面那个看作number[]--&gt; &lt;!--@current-change和@size-change就是改变当前页的事件和改变一页有多少条记录的事件，可以在element-ui官网查到--&gt; &lt;el-pagination :total=&quot;total&quot; :page-size=&quot;queryDto.size&quot; :current-page=&quot;queryDto.page&quot; layout=&quot;prev,pager,next,sizes,-&gt;,total&quot; :page-sizes=&quot;[5,10,15,20]&quot; @current-change=&quot;currentChange&quot; @size-change=&quot;sizeChange&quot; &gt;&lt;/el-pagination&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from &#x27;../util/myaxios&#x27;const options = &#123; mounted() &#123; this.query(); &#125;, methods: &#123; //正常js中变量中page和size变化会引起页面上page和size变化就是:page-size和:current-size的变化 //但是当用户在浏览器页面上切换页的时候，可能不会引起js变量改变，从而页面的显示内容不会改变 //这个方法和下面那个方法就是让用户切换页面或者改变一页有多少数据的时候可以生效 //page参数能捕捉到当前页的值 currentChange(page) &#123; this.queryDto.page = page; this.query(); &#125;, //size参数能捕捉到当前一页有多少条记录 sizeChange(size)&#123; this.queryDto.size = size; this.query(); &#125;, async query() &#123; const resp = await axios.get(&#x27;/api/students/q&#x27;, &#123; //params会把参数拼接在url后面，整个&#123;&#125;是一个config对象 //this.queryDto就是有page和size属性，所以可以用this.queryDto给params属性赋值 params: this.queryDto &#125;); //resp.data其实是R类也就是一个Dto，resp.data.data才是最主要返回对象，这里是一个map，map里有list和total this.students = resp.data.data.list; this.total = resp.data.data.total; &#125; &#125;, data() &#123; return &#123; students: [], total: 0, queryDto: &#123; page: 1, size: 5 &#125; &#125; &#125;&#125;export default options;&lt;/script&gt; 三种情况都应该触发查询 mounted 组件挂载完成后 页号变化时 页大小变化时 查询传参应该根据后台需求，灵活采用不同方式 本例中因为是 get 请求，无法采用请求体，只能用 params 方式传参 返回响应的格式也许会很复杂，需要掌握【根据返回的响应结构，获取数据】的能力 分页搜索这些组件都是可以在element-ui上找到的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!-- ElementUI 表格+分页+条件查询 --&gt;&lt;template&gt; &lt;div&gt; &lt;!--size=&quot;mini&quot;目的是为了让输入框变小，placeholder是输入框中的提示内容--&gt; &lt;!--v-model就是用来双向绑定哪个属性--&gt; &lt;el-input placeholder=&quot;请输入姓名&quot; size=&quot;mini&quot; v-model=&quot;queryDto.name&quot;&gt;&lt;/el-input&gt; &lt;!--下拉列表--&gt; &lt;!--option是给下拉列表提供一些选项，placeholder是框中的提示内容--&gt; &lt;el-select placeholder=&quot;请选择性别&quot; size=&quot;mini&quot; v-model=&quot;queryDto.sex&quot; clearable&gt; &lt;el-option value=&quot;男&quot;&gt;&lt;/el-option&gt; &lt;el-option value=&quot;女&quot;&gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;el-select placeholder=&quot;请选择年龄&quot; size=&quot;mini&quot; v-model=&quot;queryDto.age&quot; clearable&gt; &lt;!--value会作为最终结果传给后台，label就是给用户看的--&gt; &lt;el-option value=&quot;0,20&quot; label=&quot;0到20岁&quot;&gt;&lt;/el-option&gt; &lt;el-option value=&quot;21,30&quot; label=&quot;21到30岁&quot;&gt;&lt;/el-option&gt; &lt;el-option value=&quot;31,40&quot; label=&quot;31到40岁&quot;&gt;&lt;/el-option&gt; &lt;el-option value=&quot;41,120&quot; label=&quot;41到120岁&quot;&gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;!--搜索按钮，type=&quot;primary&quot;是那个蓝颜色的按钮--&gt; &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; @click=&quot;search()&quot;&gt;搜索&lt;/el-button&gt; &lt;el-divider&gt;&lt;/el-divider&gt; &lt;el-table v-bind:data=&quot;students&quot;&gt; &lt;el-table-column label=&quot;编号&quot; prop=&quot;id&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column label=&quot;姓名&quot; prop=&quot;name&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column label=&quot;性别&quot; prop=&quot;sex&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column label=&quot;年龄&quot; prop=&quot;age&quot;&gt;&lt;/el-table-column&gt; &lt;/el-table&gt; &lt;el-pagination :total=&quot;total&quot; :page-size=&quot;queryDto.size&quot; :current-page=&quot;queryDto.page&quot; layout=&quot;prev,pager,next,sizes,-&gt;,total&quot; :page-sizes=&quot;[5, 10, 15, 20]&quot; @current-change=&quot;currentChange&quot; @size-change=&quot;sizeChange&quot;&gt;&lt;/el-pagination&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from &#x27;../util/myaxios&#x27;const options = &#123; mounted() &#123; this.query(); &#125;, methods: &#123; currentChange(page) &#123; this.queryDto.page = page; this.query(); &#125;, sizeChange(size) &#123; this.queryDto.size = size; this.query(); &#125;, async query() &#123; const resp = await axios.get(&#x27;/api/students/q&#x27;, &#123; params: this.queryDto &#125;); this.students = resp.data.data.list; this.total = resp.data.data.total; &#125;, search() &#123; this.query(); &#125; &#125;, data() &#123; return &#123; students: [], total: 0, queryDto: &#123; //把name和sex以及age和分页的page和size属性都加到queryDto当中，然后传递给后端 name: &#x27;&#x27;, sex: &#x27;&#x27;, age: null, page: 1, size: 5 &#125; &#125; &#125;&#125;export default options;&lt;/script&gt;&lt;!--下面这个是为了让输入框变小--&gt;&lt;style scoped&gt;.el-input--mini,.el-select--mini &#123; width: 193px; margin: 10px 10px 0 0;&#125;&lt;/style&gt; sex 与 age 均用 &#39;&#39; 表示用户没有选择的情况 age 取值 0,20 会被 spring 转换为 new int[]&#123;0, 20&#125; age 取值 &#39;&#39; 会被 spring 转换为 new int[0] 级联选择级联选择器中选项的数据结构为 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- cascader --&gt;&lt;template&gt; &lt;!--级联选择器的标签--&gt; &lt;el-cascader :options=&quot;ops&quot;&gt;&lt;/el-cascader&gt;&lt;/template&gt;&lt;script&gt;const options = &#123; data()&#123; return &#123; //级联选择器中的各选项，属性children是子项也就是下一级的内容 ops:[ &#123;value:100, label:&#x27;主页&#x27;,children:[ &#123;value:101, label:&#x27;菜单1&#x27;, children:[ &#123;value:105, label:&#x27;子项1&#x27;&#125;, &#123;value:106, label:&#x27;子项2&#x27;&#125; ]&#125;, &#123;value:102, label:&#x27;菜单2&#x27;, children:[ &#123;value:107, label:&#x27;子项3&#x27;&#125;, &#123;value:108, label:&#x27;子项4&#x27;&#125;, &#123;value:109, label:&#x27;子项5&#x27;&#125; ]&#125;, &#123;value:103, label:&#x27;菜单3&#x27;, children:[ &#123;value:110, label:&#x27;子项6&#x27;&#125;, &#123;value:111, label:&#x27;子项7&#x27;&#125; ]&#125;, &#123;value:104, label:&#x27;菜单4&#x27;&#125; ]&#125; ] &#125; &#125;&#125;;export default options;&lt;/script&gt;&lt;style scoped&gt;.el-cascader &#123; margin: 10px 0 0 10px;&#125;&lt;/style&gt; 下面的例子是将后端返回的一维数组【树化】 上面是用的常量的例子，下面这个是后端返回的数据然后级联方式显示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!-- cascader --&gt;&lt;template&gt; &lt;el-cascader :options=&quot;ops&quot;&gt;&lt;/el-cascader&gt;&lt;/template&gt;&lt;script&gt;import axios from &#x27;../util/myaxios&#x27;const options = &#123; async mounted() &#123; //发送请求获取数据 const resp = await axios.get(&#x27;/api/menu&#x27;) console.log(resp.data.data) const array = resp.data.data; const map = new Map(); // get set // 1. 将所有数据存入 map 集合(为了接下来查找效率) for(const &#123;id,name,pid&#125; of array) &#123; //以id为key，后面为value，pid是指这条数据它父亲的id，也就是它上一级标签的id map.set(id, &#123;value:id, label:name, pid:pid&#125;) &#125; // console.log(map); // 2. 建立父子关系 // 3. 找到顶层对象 const top = []; for(const obj of map.values()) &#123; // console.log(obj); //根据pid找到这个标签的父亲 const parent = map.get(obj.pid); //如果有父亲，不是顶层对象 if(parent !== undefined) &#123; // if(parent.children === undefined) &#123; // parent.children = [] // &#125; //parent.children如果为null，就赋值一个空数组 parent.children ??= []; //往children集合中增加儿子，也就是obj对象 parent.children.push(obj); //如果没有父亲，就是顶层对象 &#125; else &#123; top.push(obj) &#125; &#125; //把顶层对象给到ops就可以了，可以通过顶层对象找到children来显示所有的对象 this.ops = top; &#125;, data()&#123; return &#123; ops: [] /* ops:[ &#123;value:100, label:&#x27;主页&#x27;,children:[ &#123;value:101, label:&#x27;菜单1&#x27;, children:[ &#123;value:105, label:&#x27;子项1&#x27;&#125;, &#123;value:106, label:&#x27;子项2&#x27;&#125; ]&#125;, &#123;value:102, label:&#x27;菜单2&#x27;, children:[ &#123;value:107, label:&#x27;子项3&#x27;&#125;, &#123;value:108, label:&#x27;子项4&#x27;&#125;, &#123;value:109, label:&#x27;子项5&#x27;&#125; ]&#125;, &#123;value:103, label:&#x27;菜单3&#x27;, children:[ &#123;value:110, label:&#x27;子项6&#x27;&#125;, &#123;value:111, label:&#x27;子项7&#x27;&#125; ]&#125;, &#123;value:104, label:&#x27;菜单4&#x27;&#125; ]&#125; ] */ &#125; &#125;&#125;;export default options;&lt;/script&gt;&lt;style scoped&gt;.el-cascader &#123; margin: 10px 0 0 10px;&#125;&lt;/style&gt; 2) Vue-Routervue 属于单页面应用，所谓的路由，就是根据浏览器路径不同，用不同的视图组件替换这个页面内容展示,但还是一个html页面 配置路由新建一个路由 js 文件，例如 src&#x2F;router&#x2F;example14.js，内容如下 1234567891011121314151617181920212223242526272829import Vue from &#x27;vue&#x27;import VueRouter from &#x27;vue-router&#x27;//把组件引入，@是src的别名import ContainerView from &#x27;@/views/example14/ContainerView.vue&#x27;import LoginView from &#x27;@/views/example14/LoginView.vue&#x27;import NotFoundView from &#x27;@/views/example14/NotFoundView.vue&#x27;Vue.use(VueRouter)const routes = [ &#123; path:&#x27;/&#x27;, component: ContainerView &#125;, &#123; path:&#x27;/login&#x27;, component: LoginView &#125;, &#123; path:&#x27;/404&#x27;, component: NotFoundView &#125;]const router = new VueRouter(&#123; routes&#125;)export default router 最重要的就是建立了【路径】与【视图组件】之间的映射关系 本例中映射了 3 个路径与对应的视图组件 在 main.js 中采用我们的路由 js 12345678910111213141516import Vue from &#x27;vue&#x27;import e14 from &#x27;./views/Example14View.vue&#x27;//之前是&#x27;./router&#x27;默认找的是router文件夹下的index.jsimport router from &#x27;./router/example14&#x27; // 修改这里import store from &#x27;./store&#x27;import Element from &#x27;element-ui&#x27;import &#x27;element-ui/lib/theme-chalk/index.css&#x27;Vue.config.productionTip = falseVue.use(Element)new Vue(&#123; router, store, render: h =&gt; h(e14)&#125;).$mount(&#x27;#app&#x27;) 根组件是 Example14View.vue，内容为： 1234567891011121314&lt;template&gt; &lt;div class=&quot;all&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.all &#123; height: 100%; background-color: darksalmon; background-image: url(&quot;data:image/svg+xml,%3Csvg xmlns=&#x27;http://www.w3.org/2000/svg&#x27;%3E%3Ctext x=&#x27;22&#x27; y=&#x27;10&#x27; font-size=&#x27;14&#x27; font-family=&#x27;system-ui, sans-serif&#x27; text-anchor=&#x27;middle&#x27; dominant-baseline=&#x27;middle&#x27;%3E最外层%3C/text%3E%3C/svg%3E&quot;); padding: 20px; box-sizing: border-box;&#125;&lt;/style&gt; 样式略 其中 &lt;router-view&gt; 起到占位作用，改变路径后，这个路径对应的视图组件就会占据 &lt;router-view&gt; 的位置，替换掉它之前的内容 动态导入src&#x2F;router&#x2F;example14.js 12345678910111213141516171819202122232425import Vue from &#x27;vue&#x27;import VueRouter from &#x27;vue-router&#x27;Vue.use(VueRouter)const routes = [ &#123; path:&#x27;/&#x27;, component: () =&gt; import(&#x27;@/views/example14/ContainerView.vue&#x27;) &#125;, &#123; path:&#x27;/login&#x27;, component: () =&gt; import(&#x27;@/views/example14/LoginView.vue&#x27;) &#125;, &#123; path:&#x27;/404&#x27;, component: () =&gt; import(&#x27;@/views/example14/NotFoundView.vue&#x27;) &#125;]const router = new VueRouter(&#123; routes&#125;)export default router 静态导入是将所有组件的 js 代码打包到一起，如果组件非常多，打包后的 js 文件会很大，影响页面加载速度 动态导入是将组件的 js 代码放入独立的文件，用到时才加载 嵌套路由src&#x2F;router&#x2F;example14.js 组件内再要切换内容，就需要用到嵌套路由（子路由），下面的例子是在【ContainerView 组件】内定义了 3 个子路由 一个父组件不变，组件中某一块内容要切换，要配置children children中子路由的路径要和父路由的路径拼接在一起才是他最后的路径 1234567891011121314151617181920212223242526272829303132333435const routes = [ &#123; path:&#x27;/&#x27;, component: () =&gt; import(&#x27;@/views/example14/ContainerView.vue&#x27;), //redirect就是从定向的意思，刚开始访问/ 接下来跳转会转到/c/p1 redirect: &#x27;/c/p1&#x27;, children: [ &#123; path:&#x27;c/p1&#x27;, component: () =&gt; import(&#x27;@/views/example14/container/P1View.vue&#x27;) &#125;, &#123; path:&#x27;c/p2&#x27;, component: () =&gt; import(&#x27;@/views/example14/container/P2View.vue&#x27;) &#125;, &#123; path:&#x27;c/p3&#x27;, component: () =&gt; import(&#x27;@/views/example14/container/P3View.vue&#x27;) &#125; ] &#125;, &#123; path:&#x27;/login&#x27;, component: () =&gt; import(&#x27;@/views/example14/LoginView.vue&#x27;) &#125;, &#123; path:&#x27;/404&#x27;, component: () =&gt; import(&#x27;@/views/example14/NotFoundView.vue&#x27;) &#125;, //如果上面这些路径都匹配不上,*可以匹配任意路径，然后重定向到/404 &#123; path:&#x27;*&#x27;, redirect: &#x27;/404&#x27; &#125;] 子路由变化，切换的是【ContainerView 组件】中 &lt;router-view&gt;&lt;/router-view&gt; 部分的内容 12345&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; redirect 可以用来重定向（跳转）到一个新的地址 path 的取值为 * 表示匹配不到其它 path 时，就会匹配它 ElementUI 布局通常主页要做布局，下面的代码是 ElementUI 提供的【上-【左-右】】布局 12345678910111213141516171819&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;el-container&gt; &lt;el-header&gt;&lt;/el-header&gt; &lt;el-container&gt; &lt;!--el-aside是设置左边的内容--&gt; &lt;el-aside width=&quot;200px&quot;&gt; &lt;!--router-link是类似超链接的标签，to的内容是链接，标签中间内容是标签名字--&gt; &lt;router-link to=&quot;/c/p1&quot;&gt;P1&lt;/router-link&gt; &lt;router-link to=&quot;/c/p2&quot;&gt;P2&lt;/router-link&gt; &lt;router-link to=&quot;/c/p3&quot;&gt;P3&lt;/router-link&gt; &lt;/el-aside&gt; &lt;el-main&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt; &lt;/div&gt;&lt;/template&gt; 路由跳转标签式12345&lt;el-aside width=&quot;200px&quot;&gt; &lt;router-link to=&quot;/c1/p1&quot;&gt;P1&lt;/router-link&gt; &lt;router-link to=&quot;/c1/p2&quot;&gt;P2&lt;/router-link&gt; &lt;router-link to=&quot;/c1/p3&quot;&gt;P3&lt;/router-link&gt;&lt;/el-aside&gt; 编程式编程式跳转，type是指这个按钮的样式，el-button是elementui的组件，size属性是让这个按钮小一点 12345678&lt;el-header&gt; &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-edit&quot; circle size=&quot;mini&quot; @click=&quot;jump(&#x27;/c1/p1&#x27;)&quot;&gt;&lt;/el-button&gt; &lt;el-button type=&quot;success&quot; icon=&quot;el-icon-check&quot; circle size=&quot;mini&quot; @click=&quot;jump(&#x27;/c1/p2&#x27;)&quot;&gt;&lt;/el-button&gt; &lt;el-button type=&quot;warning&quot; icon=&quot;el-icon-star-off&quot; circle size=&quot;mini&quot; @click=&quot;jump(&#x27;/c1/p3&#x27;)&quot;&gt;&lt;/el-button&gt;&lt;/el-header&gt; jump 方法 设计jump方法 1234567891011&lt;script&gt;const options = &#123; methods : &#123; jump(url) &#123; //this.$router是一个路由对象，push方法是根据url来跳转 this.$router.push(url); &#125; &#125;&#125;export default options;&lt;/script&gt; 其中 this.$router 是拿到路由对象 push 方法根据 url 进行跳转 导航菜单有子项的时候外层用标签，内层用 没有子项的时候都用平行的就可以 123456789101112131415161718192021222324252627282930&lt;!--backgroud-color和text-color以及active-text-color都是样式属性--&gt;&lt;!--router属性是开启了下面index的功能，跳转的功能--&gt;&lt;el-menu router background-color=&quot;#545c64&quot; text-color=&quot;#fff&quot; active-text-color=&quot;#ffd04b&quot;&gt; &lt;el-submenu index=&quot;/c1&quot;&gt; &lt;!--在span里面包裹文字和图标标签，span有个slot属性--&gt; &lt;!--有span是为了方便加二级标签--&gt; &lt;span slot=&quot;title&quot;&gt; &lt;!--i标签是图标标签--&gt; &lt;i class=&quot;el-icon-platform-eleme&quot;&gt;&lt;/i&gt; 菜单1 &lt;/span&gt; &lt;!--index属性决定这个标签是否能跳转，以及跳转的路径--&gt; &lt;el-menu-item index=&quot;/c1/p1&quot;&gt;子项1&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;/c1/p2&quot;&gt;子项2&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;/c1/p3&quot;&gt;子项3&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;el-menu-item index=&quot;/c2&quot;&gt; &lt;span slot=&quot;title&quot;&gt; &lt;i class=&quot;el-icon-phone&quot;&gt;&lt;/i&gt; 菜单2 &lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;/c3&quot;&gt; &lt;span slot=&quot;title&quot;&gt; &lt;i class=&quot;el-icon-star-on&quot;&gt;&lt;/i&gt; 菜单3 &lt;/span&gt; &lt;/el-menu-item&gt;&lt;/el-menu&gt; 图标和菜单项文字建议用 &lt;span slot=&#39;title&#39;&gt;&lt;/span&gt; 包裹起来 el-menu 标签上加上 router 属性，表示结合导航菜单与路由对象，此时，就可以利用菜单项的 index 属性来路由跳转 动态路由与菜单将菜单、路由信息（仅主页的）存入数据库中 123456789101112insert into menu(id, name, pid, path, component, icon) values (101, &#x27;菜单1&#x27;, 0, &#x27;/m1&#x27;, null, &#x27;el-icon-platform-eleme&#x27;), (102, &#x27;菜单2&#x27;, 0, &#x27;/m2&#x27;, null, &#x27;el-icon-delete-solid&#x27;), (103, &#x27;菜单3&#x27;, 0, &#x27;/m3&#x27;, null, &#x27;el-icon-s-tools&#x27;), (104, &#x27;菜单4&#x27;, 0, &#x27;/m4&#x27;, &#x27;M4View.vue&#x27;, &#x27;el-icon-user-solid&#x27;), (105, &#x27;子项1&#x27;, 101, &#x27;/m1/c1&#x27;, &#x27;C1View.vue&#x27;, &#x27;el-icon-s-goods&#x27;), (106, &#x27;子项2&#x27;, 101, &#x27;/m1/c2&#x27;, &#x27;C2View.vue&#x27;, &#x27;el-icon-menu&#x27;), (107, &#x27;子项3&#x27;, 102, &#x27;/m2/c3&#x27;, &#x27;C3View.vue&#x27;, &#x27;el-icon-s-marketing&#x27;), (108, &#x27;子项4&#x27;, 102, &#x27;/m2/c4&#x27;, &#x27;C4View.vue&#x27;, &#x27;el-icon-s-platform&#x27;), (109, &#x27;子项5&#x27;, 102, &#x27;/m2/c5&#x27;, &#x27;C5View.vue&#x27;, &#x27;el-icon-picture&#x27;), (110, &#x27;子项6&#x27;, 103, &#x27;/m3/c6&#x27;, &#x27;C6View.vue&#x27;, &#x27;el-icon-upload&#x27;), (111, &#x27;子项7&#x27;, 103, &#x27;/m3/c7&#x27;, &#x27;C7View.vue&#x27;, &#x27;el-icon-s-promotion&#x27;); 不同的用户查询的的菜单、路由信息是不一样的 例如：访问 /api/menu/admin 返回所有的数据 12345678910111213141516171819202122232425262728293031323334[ &#123; &quot;id&quot;: 102, &quot;name&quot;: &quot;菜单2&quot;, &quot;icon&quot;: &quot;el-icon-delete-solid&quot;, &quot;path&quot;: &quot;/m2&quot;, &quot;pid&quot;: 0, &quot;component&quot;: null &#125;, &#123; &quot;id&quot;: 107, &quot;name&quot;: &quot;子项3&quot;, &quot;icon&quot;: &quot;el-icon-s-marketing&quot;, &quot;path&quot;: &quot;/m2/c3&quot;, &quot;pid&quot;: 102, &quot;component&quot;: &quot;C3View.vue&quot; &#125;, &#123; &quot;id&quot;: 108, &quot;name&quot;: &quot;子项4&quot;, &quot;icon&quot;: &quot;el-icon-s-platform&quot;, &quot;path&quot;: &quot;/m2/c4&quot;, &quot;pid&quot;: 102, &quot;component&quot;: &quot;C4View.vue&quot; &#125;, &#123; &quot;id&quot;: 109, &quot;name&quot;: &quot;子项5&quot;, &quot;icon&quot;: &quot;el-icon-picture&quot;, &quot;path&quot;: &quot;/m2/c5&quot;, &quot;pid&quot;: 102, &quot;component&quot;: &quot;C5View.vue&quot; &#125;] 访问 /api/menu/wang 返回 1234567891011121314151617181920212223242526[ &#123; &quot;id&quot;: 103, &quot;name&quot;: &quot;菜单3&quot;, &quot;icon&quot;: &quot;el-icon-s-tools&quot;, &quot;path&quot;: &quot;/m3&quot;, &quot;pid&quot;: 0, &quot;component&quot;: null &#125;, &#123; &quot;id&quot;: 110, &quot;name&quot;: &quot;子项6&quot;, &quot;icon&quot;: &quot;el-icon-upload&quot;, &quot;path&quot;: &quot;/m3/c6&quot;, &quot;pid&quot;: 103, &quot;component&quot;: &quot;C6View.vue&quot; &#125;, &#123; &quot;id&quot;: 111, &quot;name&quot;: &quot;子项7&quot;, &quot;icon&quot;: &quot;el-icon-s-promotion&quot;, &quot;path&quot;: &quot;/m3/c7&quot;, &quot;pid&quot;: 103, &quot;component&quot;: &quot;C7View.vue&quot; &#125;] 前端根据他们身份不同，动态添加路由和显示菜单 动态路由src&#x2F;router&#x2F;example15.js 1234567891011121314export function addServerRoutes(array) &#123; for (const &#123; id, path, component &#125; of array) &#123; if (component !== null) &#123; // 动态添加路由 // 参数1：父路由名称 // 参数2：路由信息对象 router.addRoute(&#x27;c&#x27;, &#123; path: path, name: id, component: () =&gt; import(`@/views/example15/container/$&#123;component&#125;`) &#125;); &#125; &#125;&#125; js 这边只保留几个固定路由，如主页、404 和 login 以上方法执行时，将服务器返回的路由信息加入到名为 c 的父路由中去 这里要注意组件路径，前面 @&#x2F;views 是必须在 js 这边完成拼接的，否则 import 函数会失效 重置路由src&#x2F;router&#x2F;example15.js 在用户注销时应当重置路由 123export function resetRouter() &#123; router.matcher = new VueRouter(&#123; routes &#125;).matcher&#125; 页面刷新页面刷新后，会导致动态添加的路由失效，解决方法是将路由数据存入 sessionStorage 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;template&gt; &lt;div class=&quot;login&quot;&gt; &lt;el-input v-model=&quot;username&quot; placeholder=&quot;请输入用户名&quot; size=&quot;mini&quot;&gt;&lt;/el-input&gt; &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; @click=&quot;login()&quot;&gt;登录&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from &#x27;@/util/myaxios&#x27; //@是src，@/router/example15是文件从中导入两个方法重置路由和添加动态路由import &#123;resetRouter, addServerRoutes&#125; from &#x27;@/router/example15&#x27;const options = &#123; data() &#123; return &#123; username: &#x27;admin&#x27; &#125; &#125;, methods: &#123; async login() &#123; resetRouter(); // 重置路由 const resp = await axios.get(`/api/menu/$&#123;this.username&#125;`) const array = resp.data.data; // localStorage 即使浏览器关闭，存储的数据仍在 // sessionStorage 以标签页为单位，关闭标签页时，数据被清除 sessionStorage.setItem(&#x27;serverRoutes&#x27;, JSON.stringify(array)) addServerRoutes(array); this.$router.push(&#x27;/&#x27;); &#125; &#125;&#125;export default options;&lt;/script&gt;&lt;style scoped&gt;.login &#123; height: 100%; background-color: darkseagreen; /* background-image: url(&quot;data:image/svg+xml,%3Csvg xmlns=&#x27;http://www.w3.org/2000/svg&#x27;%3E%3Ctext x=&#x27;15&#x27; y=&#x27;10&#x27; font-size=&#x27;14&#x27; font-family=&#x27;system-ui, sans-serif&#x27; text-anchor=&#x27;middle&#x27; dominant-baseline=&#x27;middle&#x27;%3E登录%3C/text%3E%3C/svg%3E&quot;); */&#125;.el-input--mini &#123; width: 193px; margin: 10px 10px 0 10px;&#125;&lt;/style&gt; 页面刷新，重新创建路由对象时，从 sessionStorage 里恢复路由数据 12345678910const router = new VueRouter(&#123; routes&#125;)// 从 sessionStorage 中恢复路由数据const serverRoutes = sessionStorage.getItem(&#x27;serverRoutes&#x27;);if(serverRoutes) &#123; const array = JSON.parse(serverRoutes); addServerRoutes(array) // 动态添加路由&#125; 动态菜单代码部分 1234567891011121314151617181920212223242526272829&lt;script&gt;const options = &#123; mounted() &#123; const serverRoutes = sessionStorage.getItem(&#x27;serverRoutes&#x27;); const array = JSON.parse(serverRoutes); const map = new Map(); for(const obj of array) &#123; map.set(obj.id, obj); &#125; const top = []; for(const obj of array) &#123; const parent = map.get(obj.pid); if(parent) &#123; parent.children ??= []; parent.children.push(obj); &#125; else &#123; top.push(obj); &#125; &#125; this.top = top; &#125;, data() &#123; return &#123; top: [] &#125; &#125;&#125;export default options;&lt;/script&gt; 菜单部分 12345678910111213141516171819&lt;el-menu router background-color=&quot;#545c64&quot; text-color=&quot;#fff&quot; active-text-color=&quot;#ffd04b&quot; :unique-opened=&quot;true&quot;&gt; &lt;template v-for=&quot;m1 of top&quot;&gt;&lt;el-submenu v-if=&quot;m1.children&quot; :key=&quot;m1.id&quot; :index=&quot;m1.path&quot;&gt; &lt;span slot=&quot;title&quot;&gt; &lt;i :class=&quot;m1.icon&quot;&gt;&lt;/i&gt; &#123;&#123;m1.name&#125;&#125; &lt;/span&gt; &lt;el-menu-item v-for=&quot;m2 of m1.children&quot; :key=&quot;m2.id&quot; :index=&quot;m2.path&quot;&gt; &lt;span slot=&quot;title&quot;&gt; &lt;i :class=&quot;m2.icon&quot;&gt;&lt;/i&gt; &#123;&#123;m2.name&#125;&#125; &lt;/span&gt; &lt;/el-menu-item&gt; &lt;/el-submenu&gt;&lt;el-menu-item v-else :key=&quot;m1.id&quot; :index=&quot;m1.path&quot;&gt; &lt;span slot=&quot;title&quot;&gt; &lt;i :class=&quot;m1.icon&quot;&gt;&lt;/i&gt; &#123;&#123;m1.name&#125;&#125; &lt;/span&gt; &lt;/el-menu-item&gt; &lt;/template&gt;&lt;/el-menu&gt; 没有考虑递归菜单问题，认为菜单只有两级 3) Vuex入门vuex 可以在多个组件之间共享数据，并且共享的数据是【响应式】的，即数据的变更能及时渲染到模板 与之对比 localStorage 与 sessionStorage 也能共享数据，但缺点是数据并非【响应式】 首先需要定义 state 与 mutations 他们一个用来读取共享数据，一个用来修改共享数据 src&#x2F;store&#x2F;index.js 1234567891011121314151617181920212223242526import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)/* 读取数据，走 state, getters 修改数据，走 mutations, actions*/export default new Vuex.Store(&#123; state: &#123; name: &#x27;&#x27;, age: 18 &#125;, getters: &#123; &#125;, mutations: &#123; updateName(state, name) &#123; state.name = name; &#125; &#125;, actions: &#123; &#125;, modules: &#123; &#125;&#125;) 修改共享数据 12345678910111213141516171819202122&lt;template&gt; &lt;div class=&quot;p&quot;&gt; &lt;el-input placeholder=&quot;请修改用户姓名&quot; size=&quot;mini&quot; v-model=&quot;name&quot;&gt;&lt;/el-input&gt; &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; @click=&quot;update()&quot;&gt;修改&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const options = &#123; methods: &#123; update()&#123; this.$store.commit(&#x27;updateName&#x27;, this.name); &#125; &#125;, data () &#123; return &#123; name:&#x27;&#x27; &#125; &#125;&#125;export default options;&lt;/script&gt; mutations 方法不能直接调用，只能通过 store.commit(mutation方法名, 参数) 来间接调用 读取共享数据 123456789101112131415161718&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;el-container&gt; &lt;el-header&gt; &lt;div class=&quot;t&quot;&gt; 欢迎您：&#123;&#123; $store.state.name &#125;&#125;, &#123;&#123; $store.state.age &#125;&#125; &lt;/div&gt; &lt;/el-header&gt; &lt;el-container&gt; &lt;el-aside width=&quot;200px&quot;&gt; &lt;/el-aside&gt; &lt;el-main&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt; &lt;/div&gt;&lt;/template&gt; mapState每次去写 $store.state.name 这样的代码显得非常繁琐，可以用 vuex 帮我们生成计算属性 12345678910111213141516171819202122232425&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;el-container&gt; &lt;el-header&gt; &lt;div class=&quot;t&quot;&gt;欢迎您：&#123;&#123; name &#125;&#125;, &#123;&#123; age &#125;&#125;&lt;/div&gt; &lt;/el-header&gt; &lt;el-container&gt; &lt;el-aside width=&quot;200px&quot;&gt; &lt;/el-aside&gt; &lt;el-main&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapState &#125; from &#x27;vuex&#x27;const options = &#123; computed: &#123; ...mapState([&#x27;name&#x27;, &#x27;age&#x27;]) &#125;&#125;export default options;&lt;/script&gt; mapState 返回的是一个对象，对象内包含了 name() 和 age() 的这两个方法作为计算属性 此对象配合 ... 展开运算符，填充入 computed 即可使用 mapMutations123456789101112131415161718192021&lt;template&gt; &lt;div class=&quot;p&quot;&gt; &lt;el-input placeholder=&quot;请修改用户姓名&quot; size=&quot;mini&quot; v-model=&quot;name&quot;&gt;&lt;/el-input&gt; &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; @click=&quot;updateName(name)&quot;&gt;修改&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapMutations&#125; from &#x27;vuex&#x27;const options = &#123; methods: &#123; ...mapMutations([&#x27;updateName&#x27;]) &#125;, data () &#123; return &#123; name:&#x27;&#x27; &#125; &#125;&#125;export default options;&lt;/script&gt; 类似的，调用 mutation 修改共享数据也可以简化 mapMutations 返回的对象中包含的方法，就会调用 store.commit() 来执行 mutation 方法 注意参数传递略有不同 actionsmutations 方法内不能包括修改不能立刻生效的代码，否则会造成 Vuex 调试工具工作不准确，必须把这些代码写在 actions 方法中 12345678910111213141516171819202122232425262728293031323334353637383940414243import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)/* 读取数据，走 state, getters 修改数据，走 mutations, actions*/import axios from &#x27;@/util/myaxios&#x27;export default new Vuex.Store(&#123; state: &#123; name: &#x27;&#x27;, age: 18 &#125;, getters: &#123; &#125;, mutations: &#123; updateName(state, name) &#123; state.name = name; &#125;, // 错误的用法，如果在mutations方法中包含了异步操作，会造成开发工具不准确 /* async updateServerName(state) &#123; const resp = await axios.get(&#x27;/api/user&#x27;); const &#123;name, age&#125; = resp.data.data; state.name = name; state.age = age; &#125; */ updateServerName(state, user) &#123; const &#123; name, age &#125; = user; state.name = name; state.age = age; &#125; &#125;, actions: &#123; async updateServerName(context) &#123; const resp = await axios.get(&#x27;/api/user&#x27;); context.commit(&#x27;updateServerName&#x27;, resp.data.data) &#125; &#125;, modules: &#123; &#125;&#125;) 首先应当调用 actions 的 updateServerName 获取数据 然后再由它间接调用 mutations 的 updateServerName 更新共享数据 页面使用 actions 的方法可以这么写 123456789101112131415&lt;template&gt; &lt;div class=&quot;p&quot;&gt; &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; @click=&quot;updateServerName()&quot;&gt;从服务器获取数据,存入store&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapActions &#125; from &#x27;vuex&#x27;const options = &#123; methods: &#123; ...mapActions([&#x27;updateServerName&#x27;]) &#125;&#125;export default options;&lt;/script&gt; mapActions 会生成调用 actions 中方法的代码 调用 actions 的代码内部等价于，它返回的是 Promise 对象，可以用同步或异步方式接收结果 1this.$store.dispatch(&#x27;action名称&#x27;, 参数) 3. Vue 实战课程不准备从头开发一个 Vue 项目，这里我准备采用这样的教学方法：带着大家看一个较为典型的基于 Vue 的项目实现，分析其中几个重点流程 这里选择了 vue-element-admin 这个项目骨架，它采用的技术与我们之前学过的较为契合 vue 2 element-ui 2 vue-router 3 vuex 3 axios 安装12345678910111213git clone https://gitee.com/panjiachen/vue-element-admin.git client-actioncd client-actiongit branch -agit checkout -b i18n remotes/origin/i18ngit config --global url.&quot;https://&quot;.insteadOf git://npm installnpm run dev 需要切换分支到 i18n，否则不支持国际化（中文）功能 npm install 要多试几次，因为中间会连接 gitbub 下载一些依赖，网络不稳定会导致失败 npm run dev 运行后回自动打开浏览器，使用的端口是 9527 后端路径开发环境下执行下面命令 1npm run dev 会同时启动 mock-server 在开发环境下，后端访问路径起始路径配置在文件 .env.development 中 1VUE_APP_BASE_API = &#x27;/dev-api&#x27; 默认向后台的请求都发给 http://localhost:9527/dev-api 的 mock-server 获得的都是模拟数据 需要跟真实后台联调时，可以改动以上地址为 VUE_APP_BASE_API = &#39;http://localhost:8080/api&#39; 发送请求的 axios 工具被封装在 src&#x2F;utils&#x2F;request.js 中 12345678910111213import axios from &#x27;axios&#x27;import &#123; MessageBox, Message &#125; from &#x27;element-ui&#x27;import store from &#x27;@/store&#x27;import &#123; getToken &#125; from &#x27;@/utils/auth&#x27;// create an axios instanceconst service = axios.create(&#123; baseURL: process.env.VUE_APP_BASE_API, // url = base url + request url // withCredentials: true, // send cookies when cross-domain requests timeout: 5000 // request timeout&#125;)// ... 原有代码的 URI 路径都是这样的： 1234/vue-element-admin/user/login/vue-element-admin/user/info/vue-element-admin/user/logout... 如果觉得不爽，可以来一个全局替换 1234/user/login/user/info/user/logout... token 的请求头修改一下，在 src&#x2F;utils&#x2F;request.js 中 1234567891011121314151617181920...service.interceptors.request.use( config =&gt; &#123; // do something before request is sent if (store.getters.token) &#123; // let each request carry token // [&#x27;X-Token&#x27;] is a custom headers key // please modify it according to the actual situation config.headers[&#x27;Authorization&#x27;] = getToken() &#125; return config &#125;, error =&gt; &#123; // do something with request error console.log(error) // for debug return Promise.reject(error) &#125;)... 登录流程1. src/views/login/index.vue123456789101112131415161718192021222324252627282930&lt;script&gt;import &#123; validUsername &#125; from &#x27;@/utils/validate&#x27;import LangSelect from &#x27;@/components/LangSelect&#x27;import SocialSign from &#x27;./components/SocialSignin&#x27;export default &#123; // ... methods: &#123; handleLogin() &#123; this.$refs.loginForm.validate(valid =&gt; &#123; if (valid) &#123; this.loading = true this.$store.dispatch(&#x27;user/login&#x27;, this.loginForm) .then(() =&gt; &#123; this.$router.push(&#123; path: this.redirect || &#x27;/&#x27;, query: this.otherQuery &#125;) this.loading = false &#125;) .catch(() =&gt; &#123; this.loading = false &#125;) &#125; else &#123; console.log(&#x27;error submit!!&#x27;) return false &#125; &#125;) &#125; // ... &#125;&#125;&lt;/script&gt; 这里调用了 store 的 actions，user/login 因为是异步调用，因此只能用 actions 登录成功会优先跳转至 this.redirect 路径、否则跳转至 &#x2F; &#x2F; 查看 src/router/index.js 的路由表可知，会重定向至 &#x2F;dashboard 2. src/store/modules/user.js12345678910111213141516171819import &#123; login, logout, getInfo &#125; from &#x27;@/api/user&#x27;// ...const actions = &#123; // user login login(&#123; commit &#125;, userInfo) &#123; const &#123; username, password &#125; = userInfo return new Promise((resolve, reject) =&gt; &#123; login(&#123; username: username.trim(), password: password &#125;).then(response =&gt; &#123; const &#123; data &#125; = response commit(&#x27;SET_TOKEN&#x27;, data.token) setToken(data.token) resolve() &#125;).catch(error =&gt; &#123; reject(error) &#125;) &#125;) &#125; // ...&#125; 发请求用了 src/api/user.js，请求成功使用 commit 将 token 存入 mutations，同时往 cookie 存储了一份 这里的 response 其实是真正的 response.data，见后面的说明 评价 向 cookie 或 sessionStorage 存储 token 即可，token 无需做成响应式，不必放入 store 作者使用了 Promise API，其实可以改变为 await 方式，提高可读性 3. src/api/user.js1234567891011import request from &#x27;@/utils/request&#x27;export function login(data) &#123; return request(&#123; url: &#x27;/user/login&#x27;, method: &#x27;post&#x27;, data &#125;)&#125;// ... 其中 request 相当于我们之前封装的 myaxios 4. src/utils/request.js123456789101112131415161718192021222324252627282930import axios from &#x27;axios&#x27;import &#123; MessageBox, Message &#125; from &#x27;element-ui&#x27;import store from &#x27;@/store&#x27;import &#123; getToken &#125; from &#x27;@/utils/auth&#x27;// create an axios instanceconst service = axios.create(&#123; baseURL: process.env.VUE_APP_BASE_API, // url = base url + request url // withCredentials: true, // send cookies when cross-domain requests timeout: 5000 // request timeout&#125;)// ... service.interceptors.response.use( // ... response =&gt; &#123; const res = response.data if (res.code !== 20000) &#123; // ... &#125; else &#123; return res &#125; &#125;, error =&gt; &#123; // ... &#125;)export default service 其中响应拦截器发现响应正确，返回 resp.data 这样，其它处代码解构时少了一层 data 5. src/permission.js登录成功后，只是获得了 token，还未获取用户信息，获取用户信息是在路由跳转的 beforeEach 里做的 sequenceDiagram participant c as 登录页 participant r as Router participant s as Store participant t as Tomcat rect rgba(255,0,0,0.2) c -&gt;&gt; +s: login(username,password) s -&gt;&gt; +t: login(username,password) t --&gt;&gt; -s: token s -&gt;&gt; s: 存储 token s --&gt;&gt; -c: end rect rgba(0,255,0,0.2) c -&gt;&gt; +r: 跳转至 / r -&gt;&gt; +s: beforeEach getInfo(token) s -&gt;&gt; +t: getInfo(token) t --&gt;&gt; -s: name,avatar,roles等 s -&gt;&gt; s: 存储用户信息 s --&gt;&gt; -r: r -&gt;&gt; r: 根据roles动态生成路由 r --&gt;&gt; -c: end 关键代码 1234567891011121314151617181920import router from &#x27;./router&#x27;// ...router.beforeEach(async(to, from, next) =&gt; &#123; // ... const hasToken = getToken() if (hasToken) &#123; if (to.path === &#x27;/login&#x27;) &#123; // ... &#125; else &#123; // ... const &#123; roles &#125; = await store.dispatch(&#x27;user/getInfo&#x27;) // ... &#125; &#125; else &#123; // ... &#125;&#125;) 登录后跳转至 &#x2F; 之前进入这里的 beforeEach 方法，方法内主要做两件事 一是调用 actions 方法获取用户角色，见 6 二是根据用户角色，动态生成路由，见 7 6. src/store/modules/user.js这里用其中 getInfo 方法获取用户信息，其中角色返回给 beforeEach 1234567891011121314151617181920212223242526272829import &#123; login, logout, getInfo &#125; from &#x27;@/api/user&#x27;// ...const actions = &#123; getInfo(&#123; commit, state &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; getInfo(state.token).then(response =&gt; &#123; const &#123; data &#125; = response if (!data) &#123; reject(&#x27;Verification failed, please Login again.&#x27;) &#125; const &#123; roles, name, avatar, introduction &#125; = data if (!roles || roles.length &lt;= 0) &#123; reject(&#x27;getInfo: roles must be a non-null array!&#x27;) &#125; commit(&#x27;SET_ROLES&#x27;, roles) commit(&#x27;SET_NAME&#x27;, name) commit(&#x27;SET_AVATAR&#x27;, avatar) commit(&#x27;SET_INTRODUCTION&#x27;, introduction) resolve(data) &#125;).catch(error =&gt; &#123; reject(error) &#125;) &#125;) &#125;&#125; 7. src/router/index.js路由表中路由分成两部分，静态路由与动态路由 12345678910111213141516171819202122export const constantRoutes = [ // ... &#123; path: &#x27;/login&#x27;, component: () =&gt; import(&#x27;@/views/login/index&#x27;), hidden: true &#125;, &#123; path: &#x27;/&#x27;, component: Layout, redirect: &#x27;/dashboard&#x27;, children: [ &#123; path: &#x27;dashboard&#x27;, component: () =&gt; import(&#x27;@/views/dashboard/index&#x27;), name: &#x27;Dashboard&#x27;, meta: &#123; title: &#x27;dashboard&#x27;, icon: &#x27;dashboard&#x27;, affix: true &#125; &#125; ] &#125; // ...] 其中 hidden: true 的路由只做路由跳转，不会在左侧导航菜单展示 动态路由 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657export const asyncRoutes = [ &#123; path: &#x27;/permission&#x27;, component: Layout, redirect: &#x27;/permission/page&#x27;, alwaysShow: true, // will always show the root menu name: &#x27;Permission&#x27;, meta: &#123; title: &#x27;permission&#x27;, icon: &#x27;lock&#x27;, roles: [&#x27;admin&#x27;, &#x27;editor&#x27;] // you can set roles in root nav &#125;, children: [ &#123; path: &#x27;page&#x27;, component: () =&gt; import(&#x27;@/views/permission/page&#x27;), name: &#x27;PagePermission&#x27;, meta: &#123; title: &#x27;pagePermission&#x27;, roles: [&#x27;admin&#x27;] // or you can only set roles in sub nav &#125; &#125;, &#123; path: &#x27;directive&#x27;, component: () =&gt; import(&#x27;@/views/permission/directive&#x27;), name: &#x27;DirectivePermission&#x27;, meta: &#123; title: &#x27;directivePermission&#x27; // if do not set roles, means: this page does not require permission &#125; &#125;, &#123; path: &#x27;role&#x27;, component: () =&gt; import(&#x27;@/views/permission/role&#x27;), name: &#x27;RolePermission&#x27;, meta: &#123; title: &#x27;rolePermission&#x27;, roles: [&#x27;admin&#x27;] &#125; &#125; ] &#125;, &#123; path: &#x27;/icon&#x27;, component: Layout, children: [ &#123; path: &#x27;index&#x27;, component: () =&gt; import(&#x27;@/views/icons/index&#x27;), name: &#x27;Icons&#x27;, meta: &#123; title: &#x27;icons&#x27;, icon: &#x27;icon&#x27;, noCache: true, roles: [&#x27;admin&#x27;] &#125; &#125; ] &#125; // ...&#125; 动态路由中关联了角色信息，根据用户的角色决定那些路由可用，但这样做的缺点是把角色和路由绑定死了 8. src/layout/index.vue它对应的是我们之前介绍的 Container.vue 完成主页布局的，路由路径是 &#x2F; 其中又由多部分组成，其中固定不变的是 侧边栏 导航栏 标签栏 设置 变化的是中间的 dashboard 部分（AppMain），它由 router-view 配合子路由切换显示 进入 &#x2F; 后，就会 redirect 重定向到 &#x2F;dashboard 子路由 进入首页后，会有一个 /api/transaction/list 的后台请求报 404，作为练习，把它补充完整 第三方登录sequenceDiagram participant a7 as 前端(9527) participant a8 as 后端(8080) participant g as gitee rect rgba(0,255,0,0.2) a7 -&gt;&gt; +g: 打开新窗口, 请求 /oauth/authorize g -&gt;&gt; g: 认证通过 end rect rgba(255,0,0,0.2) g -&gt;&gt; -a8: 重定向 redirect uri end rect rgba(0,255,0,0.2) a8 -&gt;&gt; +g: 请求 /oauth/token g -&gt;&gt; -a8: 返回 access_token(gitee) end rect rgba(0,255,0,0.2) a8 -&gt;&gt; +g: 请求 /api/v5/user g --&gt;&gt; -a8: end a8 -&gt;&gt; 8: 生成 token(8080) rect rgba(0,0,255,0.2) a8 -&gt;&gt; +a7: 新窗口将 token(8080) 发送给老窗口(9527) end 9527 打开新窗口，请求 https://gitee.com/oauth/authorize?client_id=$&#123;client_id&#125;&amp;redirect_uri=$&#123;redirect_uri&#125;&amp;response_type=code gitee 认证通过，重定向至 8080，并携带 code 8080 发送请求 https://gitee.com/oauth/token 携带 client_id、client_secret、code，gitee 返回 access_token 给 8080 这时走的是 https 协议，并且不经过浏览器，能够保证数据传输的安全性 重定向到 8080 时，如果被有心人拿到了 code，也没事，因为接下来会把 client_secret 发给 gitee 验证（client_secret 应当只存在 8080），只要 client_secret 不泄露，就可以保证安全 如果改成前端拿 code 换 access_token，那就意味着 access_token 得保存在前端，所有保存在前端的都有风险 8080 可以访问 gitee 的 api 了，拿到用户信息，存入数据库，返回 8080 的 token 8080 可以通过 window.opener.postMessage 把 token 给 9527 的老窗口 这里又会涉及到跨域，不过 9527 与 8080 直接存在信任关系，设置一下就好 9527 再走之前的逻辑就可以了，在 router 的 beforeEach 方法里，用 8080 token 换用户信息 增删改查首先，在 api 里添加与后端交互的代码：src/api/student.js 12345678910111213141516171819202122232425262728293031import axios from &#x27;@/utils/request&#x27;export function all() &#123; return axios(&#123; url: &#x27;/students&#x27;, method: &#x27;get&#x27; &#125;)&#125;export function deleteById(id) &#123; return axios(&#123; url: `/students/$&#123;id&#125;`, method: &#x27;delete&#x27; &#125;)&#125;export function update(id, dto) &#123; return axios(&#123; url: `/students/$&#123;id&#125;`, method: &#x27;put&#x27;, data: dto &#125;)&#125;export function insert(dto) &#123; return axios(&#123; url: `/students`, method: &#x27;post&#x27;, data: dto &#125;)&#125; 然后，添加新的路由：src/router/index.js 123456789101112131415export const asyncRoutes = [ // ... &#123; path: &#x27;/student&#x27;, component: Layout, children: [ &#123; path: &#x27;index&#x27;, component: () =&gt; import(&#x27;@/views/student/index&#x27;), meta: &#123; title: &#x27;学生管理&#x27;, icon: &#x27;el-icon-s-help&#x27;, roles: [&#x27;admin&#x27;] &#125; &#125; ] &#125;, // ...] 注意 title 这里没有考虑国际化 最后，添加新的视图界面：src/views/student/index.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;template&gt; &lt;div&gt; &lt;el-table :data=&quot;students&quot;&gt; &lt;el-table-column label=&quot;编号&quot; prop=&quot;id&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column label=&quot;姓名&quot; prop=&quot;name&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column label=&quot;性别&quot; prop=&quot;sex&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column label=&quot;年龄&quot; prop=&quot;age&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column fixed=&quot;right&quot; label=&quot;操作&quot; width=&quot;100&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button @click=&quot;handleUpdate(scope.row)&quot; type=&quot;text&quot; size=&quot;small&quot;&gt;修改&lt;/el-button&gt; &lt;el-button @click=&quot;handleDelete(scope.row)&quot; type=&quot;text&quot; size=&quot;small&quot;&gt;删除&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;el-dialog width=&quot;22%&quot; :visible.sync=&quot;updateDialogVisible&quot;&gt; &lt;el-form :model=&quot;updateForm&quot;&gt; &lt;el-form-item label=&quot;编号&quot;&gt; &lt;el-input size=&quot;mini&quot; :readonly=&quot;true&quot; v-model=&quot;updateForm.id&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;姓名&quot;&gt; &lt;el-input size=&quot;mini&quot; v-model=&quot;updateForm.name&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;性别&quot;&gt; &lt;el-select size=&quot;mini&quot; v-model=&quot;updateForm.sex&quot;&gt; &lt;el-option value=&quot;男&quot;&gt;&lt;/el-option&gt; &lt;el-option value=&quot;女&quot;&gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;年龄&quot;&gt; &lt;el-input size=&quot;mini&quot; v-model=&quot;updateForm.age&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; @click=&quot;confirmUpdate()&quot;&gt;确定&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/el-dialog&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; all, deleteById, update, insert &#125; from &#x27;@/api/student&#x27;const options = &#123; mounted() &#123; this.all() &#125;, data() &#123; return &#123; students: [], updateDialogVisible: false, updateForm: &#123; id: 0, name: &#x27;&#x27;, sex: &#x27;男&#x27;, age: 0 &#125; &#125; &#125;, methods: &#123; async confirmUpdate() &#123; await update(this.updateForm.id, this.updateForm) this.updateDialogVisible = false this.all() &#125;, handleUpdate(row) &#123; // &#123;id, name, sex, age&#125; this.updateDialogVisible = true this.updateForm = &#123; ...row &#125; // this.updateForm = row // 错误写法，不能让他俩指向同一个对象 &#125;, async handleDelete(row) &#123; try &#123; await this.$confirm(&#x27;此操作将永久删除该学生, 是否继续?&#x27;, &#x27;提示&#x27;, &#123; confirmButtonText: &#x27;确定&#x27;, cancelButtonText: &#x27;取消&#x27;, type: &#x27;warning&#x27; &#125;) await deleteById(row.id) this.all() &#125; catch (e) &#123; console.log(&#x27;取消删除&#x27;) &#125; &#125;, async all() &#123; const &#123; data &#125; = await all() this.students = data &#125; &#125;&#125;export default options&lt;/script&gt;&lt;style scoped&gt;.el-input,.el-select &#123; width: 180px;&#125;&lt;/style&gt; 其中 handleUpdate 和 handleDelete 接收的参数，都是代表了当前行的学生对象","categories":[],"tags":[]},{"title":"数据结构与算法","slug":"数据结构与算法","date":"2022-09-29T15:31:35.000Z","updated":"2023-04-10T13:15:48.893Z","comments":true,"path":"2022/09/29/数据结构与算法/","link":"","permalink":"http://example.com/2022/09/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","excerpt":"","text":"数据结构和算法的概述数据结构：数据结构就是把数据元素按照一定的关系组织起来的集合，用来组织和存储数据 数据结构分类： 1.逻辑结构：集合结构，线性结构，树形结构，图形结构 2.物理结构：顺序存储结构，链式存储结构 顺序存储结构和链式存储结构的区别 链表存储结构的内存地址不一定是连续的，但顺序存储结构的内存地址一定是连续的； 链式存储适用于在较频繁地插入、删除、更新元素时，而顺序存储结构适用于频繁查询时使用。 顺序存储结构和链式存储结构的优缺点： 空间上顺序比链式节约空间。是因为链式结构每一个节点都有一个指针存储域。 存储操作上：顺序支持随机存取，方便操作 插入和删除上：链式的要比顺序的方便（因为插入的话顺序表也很方便，问题是顺序表的插入要执行更大的空间复杂度，包括一个从表头索引以及索引后的元素后移，而链表是索引后，插入就完成了） 例如：当你在字典中查询一个字母j的时候，你可以选择两种方式，第一，顺序查询，从第一页依次查找直到查询到j。第二，索引查询，从字典的索引中，直接查出j的页数，直接找页数，或许是比顺序查询最快的。 算法的概述根据一定的条件，得到需要的结果 标准：1.花最少的时间完成需求 ​ 2.占用最少的内存空间完成需求 比如求1到100的和 1.可以用for循环来进行叠加1到100 ​ 2.也可以用高斯公式从(n+1)*n&#x2F;2 算法分析如何花更少的时间，如何占用更少的内存去完成相同的需求 时间复杂度分析事后分析估算方法 并不是很好，浪费时间 在程序前后加上 long start &#x3D;System.currentTimeMillis();&#x2F;&#x2F;程序开始的时间 ​ long end&#x3D;System.currentTimeMillis();&#x2F;&#x2F;程序结束的时间 ​ System.out.println(start-end);&#x2F;&#x2F;程序执行的时间 程序运行在不同的电脑上会对运行时间产生一定影响 事前分析估算方法 1.算法采用的策略和方案 2.问题的输入规模（所谓的问题输入规模就是输入量的多少） 3.编译产生的代码质量 4.机器执行指令的速度 分析一个算法的运行时间，最重要的就是把核心操作的次数和输入规模关联起来 函数渐近增长 n为输入规模，fn为核心操作次数（运算）明显是橙色优于红色优于紫色 算法函数规则 1.随着输入规模的增大，算法的常数操作可以忽略不计 2.随着输入规模的增大，与最高次数相乘的常数可以忽略 3.最高次项的指数大的，随着n的增长，结果也会变得增长特别快 4.算法函数中n的最高次幂越小，算法效率越高 大o记法 定义：用大写O来体现算法时间复杂度记法，称之为大O记法，执行次数等于执行时间 算法一：运行次数为3次 算法二：运行次数为n+3次 算法三：运行次数为n*n+2次 大o记法规则：1.用常数1取代运行时间中的所有加法常数 ​ 2.在修改后的运行次数中，只保留高阶项 ​ 3.如果最高阶项存在，且常数因子不是1，则出去与这个项相乘的常数 算法1：O(1) 算法2：O(n) 算法3:O(n^2) 对数阶 int i&#x3D;1,n&#x3D;100; while(i&lt;n){ i&#x3D;i*2; } 执行次数为log(2)100 时间复杂度为O(logn) 把底数忽略掉的原因是随着n的增大底数可以忽略不计 常见的大O阶的复杂程度排序 O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3) 最坏情况 public int search(int num){ int []arr&#x3D;[11,10,8,9,7,5]; for(int i&#x3D;0;i&lt;arr.length;i++){ if(num&#x3D;&#x3D;arr[i]){ return i; } } return -1; } 在一个数组中存储了n个数查找指定一个数的下标 最好情况：查找的第一个数字就是期望数字，时间复杂度为O(1) 最坏情况：查找的最后一个数字才是期望数字，时间复杂度为O(n) 平均情况:任何数字查找的平均成本为O(n&#x2F;2) 以后做算法分析的时候：更多情况下是要看在最坏情况下的算法复杂度 经典计算时间复杂度 空间复杂度分析1.java中常见的基本数据类型的占用 byte 1字节 一字节是八位 short 2字节 int 4字节 long 8字节 float 4字节 double 8字节 boolean 1字节 char 2字节 2.计算机访问内存的方式都是一次一个字节 3.一个引用需要八个字节表示 ​ 例如：Date date &#x3D;new Date(),则这个变量需要占用8个字节来表示 4.创建一个对象new Date()，除了Date对象内部存储的数据(年月日)占用的内存，该对象本身也有内存的开销，每个对象的自身开销是16个字节，用来保存对象头信息 5.一般内存的使用，如果不够八个字节，都会被自动填充为8个字节 例子：public class A{ public int a&#x3D;1; } 通过new A()创建一个对象的内存占用如下：1.整形成员变量a占用四个字节2.对象本身占用16个字节 那么创建对象总共需要20个字节，但由于不是以8位为单位，会自动填充为24个字节 6.java中数组被限定为对象，他们一般会因为记录长度而需要额外的内存，一个原始数据类型的数字一般需要24个字节的头信息（16个自己的对象开销，四字节用于保存长度，以及四个填充字节）再加上保存至所需的内存 简单排序这些排序写的例子都是从小到大排序的 Comparable接口对实现了Comparable接口的对象进行排序 1234567891011121314151617181920212223//通过Comparable接口提供比较规则class Student implements Comparable&lt;Student&gt;&#123; private int age; private String username; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; @Override public int compareTo(Student o) &#123; return this.getAge()-o.getAge();//这种是按照年龄的从小到大对学生对象进行排序 &#125;&#125; 测试使用 1234567891011121314151617181920212223242526class Main&#123; public static void main(String []args) &#123; Student s1=new Student(); s1.setAge(10); s1.setUsername(&quot;找&quot;); Student s2=new Student(); s2.setAge(13); s2.setUsername(&quot;我&quot;); Comparable max=getMax(s1,s2); System.out.println(max); &#125; public static Comparable getMax(Comparable c1,Comparable c2) &#123; int result=c1.compareTo(c2); if(result&gt;=0) &#123; return c1; &#125; else &#123; return c2; &#125; &#125;&#125; 冒泡排序冒泡排序的API设计 1.构造方法：创建Bubble对象 2.成员方法：public static void sort(Comparable[] a):对数组内的元素进行排序 private static boolean greater(Comparable v,Comparable w):判断v是否大于w private static void (Comparable[] a,int i,int j):交换数组中，索引i和索引j处的值 12345678910111213141516171819202122232425262728class Bubble&#123; //对数组a中元素进行冒泡排序 public static void sort(Comparable[] a) &#123; for(int i=a.length-1;i&gt;0;i--) &#123; for(int j=0;j&lt;i;j++) &#123; if(greater(a[j],a[j+1])) &#123; exch(a,j,j+1); &#125; &#125; &#125; &#125; //比较v元素是否大于w元素 public static boolean greater(Comparable v,Comparable w) &#123; return v.compareTo(w)&gt;0; &#125; //数组元素i和j交换位置 private static void exch(Comparable[] a,int i,int j) &#123; Comparable temp; temp=a[i]; a[i]=a[j]; a[j]=temp; &#125;&#125; 测试 12345678910class Main&#123; public static void main(String []args) &#123;Integer []arr= &#123;4,5,6,3,2,1&#125;;//这里必须是用Integer而不是基本数据类型，因为Integer实现了Comparable类Bubble.sort(arr);System.out.println(Arrays.toString(arr));//[1, 2, 3, 4, 5, 6] &#125;&#125; 最坏情况下也就是数组里的数完全逆序 元素的比较次数：(n-1)+(n-2)+(n-3)+(n-4)+..+2+1&#x3D;n^2&#x2F;2-n&#x2F;2; 元素的交换次数：(n-1)+(n-2)+(n-3)+(n-4)+..+2+1&#x3D;n^2&#x2F;2-n&#x2F;2; 总执行次数为：n^2-n; 时间复杂度为O(n^2) 选择排序排序原理：每一次遍历过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较，如果第一个索引处的值大于a索引处的值，则交换这个a索引处的值和第一个索引处的值，这样一直遍历到最后一个元素，就会得到这些数中的最小值，同时它是放在第一个索引处的，接下来再对剩下的数进行相同的操作 选择排序的API设计 Selection 构造方法：Selection()用来创建对象 1.public static void sort(Comparable[] a):对数组内的元素排序 2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w private static void (Comparable[] a,int i,int j):交换数组中，索引i和索引j处的值 123456789101112131415161718192021222324252627class Selection&#123; //对数组a中元素进行选择排序 public static void sort(Comparable[] a) &#123; for(int i=0;i&lt;a.length-1;i++) &#123; //定义一个变量，记录最小元素所在的索引，默认为参与选择排序的第一个元素所在的位置 int minIndex=i; for(int j=i+1;j&lt;a.length;j++) &#123; //需要比较最小索引minIndex处的值和j索引处的值 if(greater(a[minIndex],a[j])) &#123; //交换最小元素所在的索引minIndex处的值和索引处的值 exch(a,minIndex,j); &#125; &#125; &#125; &#125; //比较v元素是否大于w元素 public static boolean greater(Comparable v,Comparable w) &#123; return v.compareTo(w)&gt;0; &#125; //数组元素i和j交换位置 private static void exch(Comparable[] a,int i,int j) &#123; Comparable temp; temp=a[i]; a[i]=a[j]; a[j]=temp; &#125;&#125; 测试： 12345678910class Main&#123; public static void main(String []args) &#123;Integer []arr= &#123;4,5,6,3,2,1&#125;;Selection.sort(arr);System.out.println(Arrays.toString(arr));//[1, 2, 3, 4, 5, 6] &#125;&#125; 最坏情况： 1.元素比较次数(n-1)+(n-2)+(n-3)+(n-4)+..+2+1&#x3D;n^2&#x2F;2-n&#x2F;2; 2.元素的交换次数是n-1 时间复杂度为n^2&#x2F;2+n&#x2F;2-1； 时间复杂度为O(n^2) 插入排序1.把所有的元素分为两组，已经排序的和未排序的 2.找到未排序的组中的第一个元素，向已经排序的组中进行插入 3.用排好序的最后一个元素a和未排序的第一个元素b比较，如果a&gt;b，那么他俩交换位置，然后b再和前面的比较，直到找到比他小的或相等的就不用交换了，如果a&lt;b，a和b就不用交换了 插入排序的API设计 1.public static void sort(Comparable[] a):对数组内的元素排序 2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w private static void (Comparable[] a,int i,int j):交换数组中，索引i和索引j处的值 12345678910111213141516171819202122232425262728class Insertion&#123; //对数组a中元素进行插入排序 public static void sort(Comparable[] a) &#123; for(int i=1;i&lt;a.length;i++) &#123; for(int j=i;j&gt;0;j--) &#123; //比较索引处的值和索引-1处的值，如果索引j-1处的值比索引处的值大，则交换数据，如果不大，那么就找到合适的位置了，退出循环即可 if(greater(a[j-1],a[j])) &#123; exch(a,j-1,j); &#125; else &#123; break; &#125; &#125; &#125; &#125; //比较v元素是否大于w元素 public static boolean greater(Comparable v,Comparable w) &#123; return v.compareTo(w)&gt;0; &#125; //数组元素i和j交换位置 private static void exch(Comparable[] a,int i,int j) &#123; Comparable temp; temp=a[i]; a[i]=a[j]; a[j]=temp; &#125;&#125; 测试： 1234567891011class Main&#123; public static void main(String []args) &#123;Integer []arr= &#123;4,5,6,3,2,1&#125;;Insertion.sort(arr);System.out.println(Arrays.toString(arr)); &#125;&#125;结果：[1, 2, 3, 4, 5, 6] 最坏情况： 元素的比较次数：(n-1)+(n-2)+(n-3)+(n-4)+..+2+1&#x3D;n^2&#x2F;2-n&#x2F;2; 元素的交换次数：(n-1)+(n-2)+(n-3)+(n-4)+..+2+1&#x3D;n^2&#x2F;2-n&#x2F;2; 总执行次数为：n^2-n; 时间复杂度为O(n^2) 高级排序希尔排序插入排序的高效版 1.选定一个增长量n，按照增长量n所谓数据分组的依据，对数据进行分组 2.比如n为7的时候就比较下标为0和下标为7，下标为1和下标为8，以此类推直到下标大于最大下标，然后n&#x3D;n&#x2F;2,保持n&gt;&#x3D;1即可 3.减小增长量，最小减为1，重复第二步操作 增长量h的确定，假设数组的元素个数为10 int h&#x3D;1; while(h&lt;5){ h&#x3D;2h+1;&#x2F;&#x2F;3,7 } 循环结束后就可以确定增长量的最大值 每次增长量减少之后h为h&#x2F;2,按照这个规则来减少 7变为3，3变为1 希尔排序API（Shell） 1.public static void sort(Comparable[] a):对数组内的元素排序 2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w private static void exch(Comparable[] a,int i,int j):交换数组中，索引i和索引j处的值 最早的 1234567891011121314151617181920212223242526272829303132333435363738394041class Shell&#123; //对数组a中元素进行希尔排序 public static void sort(Comparable[] a) &#123; int h=1; while(h&lt;a.length/2) &#123; h=2*h+1; &#125; while(h&gt;=1) &#123; //找到待插入的元素 for(int i=h;i&lt;a.length;i++) &#123; //把待插入的元素插入到有序数列中 for(int j=i;j&gt;=h;j-=h) &#123; //待插入的元素是a[j]，比较a[j]和a[j-h] if(greater(a[j-h],a[j])) &#123; exch(a,j-h,j); &#125; else &#123; break; &#125; &#125; &#125; //减小h的值 h=h/2; &#125; &#125; //比较v元素是否大于w元素 public static boolean greater(Comparable v,Comparable w) &#123; return v.compareTo(w)&gt;0; &#125; //数组元素i和j交换位置 private static void exch(Comparable[] a,int i,int j) &#123; Comparable temp; temp=a[i]; a[i]=a[j]; a[j]=temp; &#125;&#125; 自己又写的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package 排序算法;public class Shell &#123; public static void sort(Comparable a[]) &#123; int h=1; while(h&lt;a.length) &#123; h=2*h+1; &#125; while(h&gt;=1) &#123; for(int i=h;i&lt;a.length;i++) &#123; if(greater(a[i-h],a[i])) &#123; exch(a,i-h,i); &#125; &#125; h=h/2; &#125; &#125; //判断a是否比b大 public static boolean greater(Comparable a,Comparable b) &#123; return a.compareTo(b)&gt;0; &#125; //进行数值交换 public static void exch(Comparable[] a,int i,int j) &#123; Comparable mid=a[i]; a[i]=a[j]; a[j]=mid; &#125;​ &#125; 测试： 123456789101112class Main&#123; public static void main(String []args) &#123;Integer []arr= &#123;4,5,6,3,2,1&#125;;Shell.sort(arr);System.out.println(Arrays.toString(arr)); &#125;&#125;结果：[1, 2, 3, 4, 5, 6] 希尔排序和插入排序的时间复杂度分析 一个例子：就是一个完全倒叙的数组用两种排序进行一个时间的比较 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113import java.io.BufferedInputStream;import java.io.BufferedReader;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.util.ArrayList;import java.util.Arrays;class Insertion&#123; //对数组a中元素进行插入排序 public static void sort(Comparable[] a) &#123; for(int i=1;i&lt;a.length;i++) &#123; for(int j=i;j&gt;0;j--) &#123; //比较索引处的值和索引-1处的值，如果索引j-1处的值比索引处的值大，则交换数据，如果不大，那么就找到合适的位置了，退出循环即可 if(greater(a[j-1],a[j])) &#123; exch(a,j-1,j); &#125; else &#123; break; &#125; &#125; &#125; &#125; //比较v元素是否大于w元素 public static boolean greater(Comparable v,Comparable w) &#123; return v.compareTo(w)&gt;0; &#125; //数组元素i和j交换位置 private static void exch(Comparable[] a,int i,int j) &#123; Comparable temp; temp=a[i]; a[i]=a[j]; a[j]=temp; &#125;&#125;class Shell&#123; //对数组a中元素进行希尔排序 public static void sort(Comparable[] a) &#123; int h=1; while(h&lt;a.length/2) &#123; h=2*h+1; &#125; while(h&gt;=1) &#123; //找到待插入的元素 for(int i=h;i&lt;a.length;i++) &#123; //把待插入的元素插入到有序数列中 for(int j=i;j&gt;=h;j-=h) &#123; //待插入的元素是a[j]，比较a[j]和a[j-h] if(greater(a[j-h],a[j])) &#123; exch(a,j-h,j); &#125; else &#123; break; &#125; &#125; &#125; //减小h的值 h=h/2; &#125; &#125; //比较v元素是否大于w元素 public static boolean greater(Comparable v,Comparable w) &#123; return v.compareTo(w)&gt;0; &#125; //数组元素i和j交换位置 private static void exch(Comparable[] a,int i,int j) &#123; Comparable temp; temp=a[i]; a[i]=a[j]; a[j]=temp; &#125;&#125;class Main&#123; public static void testShell(Integer []a) &#123; //获取执行之前的时间 long start=System.currentTimeMillis(); Shell.sort(a); //获取执行之后的时间 long end=System.currentTimeMillis(); System.out.println(end-start); &#125; public static void testInsertion(Integer []a) &#123; long start=System.currentTimeMillis(); Insertion.sort(a); long end=System.currentTimeMillis(); System.out.println(end-start); &#125; public static void main(String []args) throws NumberFormatException, IOException &#123; //创建一个ArrayList集合，读取数据，并存储在ArrayList中ArrayList&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;();BufferedReader reader=new BufferedReader(new FileReader(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;));String line=null;while((line=reader.readLine())!=null) &#123; //line是字符串把line转换成Integer，存储到集合中 int i=Integer.parseInt(line); list.add(i);&#125;reader.close();//将ArrayList转换为数组Integer a[]=new Integer[list.size()];list.toArray(a);//调用调试代码完成测试//testInsertion(a);1毫秒//testShell(a);0毫秒 &#125; &#125; 归并排序定义方法时，调用方法本身称之为递归 注意事项：在递归中，不能无限制的调用自己，必须要有边界条件，能够让递归结束，因为每一次递归调用都会在栈内存开辟新的空间，重新执行方法，如果递归的层级太深，很容易造成栈内存溢出 递归地实现：求阶乘 123456789101112class Main&#123; public static void main(String []args) &#123; int result=factorial(5); System.out.println(result); &#125; public static int factorial(int n) &#123; if(n==1) &#123; return 1; &#125; return n*factorial(n-1); &#125;&#125; 归并排序的原理 如果是奇数个数比如9就分为4和5，然后再分到不能分为止 归并排序的API设计 1.public static void sort(Comparable[] a):对数组内的元素排序 2.private static boolean less(Comparable v,Comparable w):判断v是否小于w private static void (Comparable[] a,int i,int j):交换数组中，索引i和索引j处的值 4.private static void sort(Comparable[]a,int lo,int hi):对数组a中索引o到索引h之间的元素进行排序 5.private static void merge(Comparable[] a,int lo,int mid,int hi)从索引lo到mid为一个子组，从索引mid+1到索引hi为另一个子组，把数组a中的这两个子组的数据合并成一个有序的大组(从索引lo到索引hi) 成员变量：private static Comparable[] assist 完成归并操作需要的辅助数组 merge归并的原理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class Merge&#123; //归并所需要的辅助数据 private static Comparable[] assist; /* * 比较v元素是否小于w元素 */ private static boolean less(Comparable v,Comparable w) &#123; return v.compareTo(w)&lt;0; &#125; /* * 将数组中的元素交换位置 */ private static void exch(Comparable[] a,int i,int j) &#123; Comparable t=a[i]; a[i]=a[j]; a[j]=t; &#125; /* * 对数组中a中的元素从lo到hi进行排序 */ public static void sort(Comparable []a,int lo,int hi) &#123; //做一个安全性的校验 if(hi&lt;=lo) &#123; return ; &#125;//对lo到high之间的数据分为两个组 int mid=lo+(hi-lo)/2; //分别对每一组数据进行排序 sort(a,lo,mid); sort(a,mid+1,hi); //再把两个组中的数据进行归并 merge(a,lo,mid,hi); &#125; /* * 对数组中a中的元素进行排序 */ public static void sort(Comparable []a) &#123; //1.初始化辅助数组assist assist =new Comparable[a.length]; //2.定义一个lo变量，和hi变量，分别记录数组中最小的索引和最大的索引 int lo=0; //这个地方同时可以指定，你要给哪些元素排序 int hi=a.length-1; //3.调用sort重载方法完成数组a中，从索引lo到索引hi的元素排序 sort(a,lo,hi); &#125; /* * 对数组中，从lo到mid为一组，从mid+1到hi为一组，对比两组数据进行归并 */ private static void merge(Comparable[] a,int lo,int mid,int hi) &#123; //定义三个指针 int i=lo;//辅助数组的第一个数 int p1=lo;//左子组的第一个数 int p2=mid+1;//右子组的第一个数 //遍历：移动p1指针和p2至真1，比较对应索引处的值，找出小的那个，放到辅助数组的对应索引处 while(p1&lt;=mid&amp;&amp;p2&lt;=hi) &#123; if(less(a[p1],a[p2])) &#123; assist[i++]=a[p1++]; &#125; else &#123; assist[i++]=a[p2++]; &#125; &#125; //遍历，如果p2走完了p1的指针没有走完，那么顺序移动p1指针，把对应的元素放到辅助数据的对应索引处 while(p1&lt;=mid) &#123; assist[i++]=a[p1++]; &#125; //遍历，如果p1走完了p2的指针没有走完，那么顺序移动p1指针，把对应的元素放到辅助数据的对应索引处 while(p2&lt;=hi) &#123; assist[i++]=a[p2++]; &#125; //把辅助数组中的元素拷贝到原数组中 for(int m=lo;m&lt;=hi;m++) &#123; a[m]=assist[m]; &#125; &#125;&#125; 归并排序的时间复杂度分析 log2(n)为总层数 第k层的数组个数为2^k 每个数组的长度为2^(log2(n)-k) 所以这一层比较次数为2^log2(n) 总共有log2(n)层 1所以总的比较次数为log2(n)*2^log2(n)=log2(n)*n 最终归并排序的时间复杂度为O(nlogn);忽略底数 归并排序缺点：需要申请额外的数组空间，倒置空间复杂度提升，是典型的以空间换时间的操作 快速排序当进行从小到大排序的时候，你选的这个临界值默认为第一个元素在左边，所以指针找比标准值小的数的右指针要先开始找，这样右指针也是先停，然后停在一个比标准值小的值上这样第一个元素和右指针所在的元素交换位置，才能保证交换后标准值左边的值都比它小 快速排序原理： 找到数组当中的第一个数，以他为分界线，比这个数大的一组(右边)比这个数小的一组(左边)，然后再进行重复的操作，然后再将他们合并起来 快速排序的API设计 1.public static void sort(Comparable[] a):对数组内的元素排序 2.private static boolean less(Comparable v,Comparable w):判断v是否小于w 3.private static int partition(Comparable[] a,int lo,int hi):对数组a中，从索引lo到索引hi之间的元素进行分组，并返回分组界限对应的索引 4.private static void sort(Comparable[]a,int lo,int hi):对数组a中索引o到索引h之间的元素进行排序 5.private static void exch(Comparable[] a,int i,int j):交换数组中，索引i和索引j处的值 切分原理：两个指针一个从左到右一个从右到左，当右指针遇到比标准值小的数停下，左指针遇到比标准值大的数停下，然后两者交换 直到左右指针相遇将第一个数也就是标准值与相遇的那个数交换位置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Quick&#123; /* * 比较v元素是否小于w元素 */ private static boolean less(Comparable v,Comparable w) &#123; return v.compareTo(w)&lt;0; &#125; /* * 数组元素i和j交换位置 */ private static void exch(Comparable[] a,int i,int j) &#123; Comparable t=a[i]; a[i]=a[j]; a[j]=t; &#125; /* * 对数组中的元素进行排序 */ public static void sort(Comparable []a) &#123; int lo=0; int hi=a.length-1; sort(a,lo,hi); &#125; /* * 对数组a中从索引lo到索引hi之间的元素进行排序 */ public static void sort(Comparable []a,int lo,int hi) &#123; //安全性校验 if(hi&lt;=lo) &#123; return; &#125; //现需要对数组中lo索引到hi索引处的元素进行分组 左子组，右子组 int partition=partition(a,lo,hi);//返回的是分组的分界值所在的索引，分界值位置变换后的索引 //让左子组有序，让右子组有序 sort(a,lo,partition-1); sort(a,partition+1,hi); &#125; /* * 对数组a中，从索引lo到hi之间的元素进行分组，并返回分组界限所应的索引 */ public static int partition(Comparable[]a,int lo,int hi) &#123; //确定分界值 Comparable key=a[lo]; //定义两个分界值，分别指向待切分元素的最小索引处和最大索引处的下一个位置 int left=lo; int right=hi+1; //切分 while(true) &#123; //先从右往左扫描，移动right指针，找到一个比分界值小的元素，停止 while(less(key,a[--right])) &#123; if(right==lo) &#123; break; &#125; &#125; //再从左往右扫描，移动left指针，找到一个比分界值大的元素,停止 while(less(a[++left],key)) &#123; if(left==hi) &#123; break; &#125; &#125; //判断left&gt;=right,如果是则证明元素扫描完毕，结束循环，如果不是，则交换元素即可 if(left&gt;=right) &#123; break; &#125; else &#123; exch(a,left,right); &#125; &#125; exch(a,lo,right); return right; &#125;&#125; 测试： 12345678class Main&#123; public static void main(String []args) &#123; Integer[] a= &#123;1,4,3,3,6,5,7&#125;; Quick.sort(a); System.out.println(Arrays.toString(a)); &#125;&#125;结果：[1, 3, 3, 4, 5, 6, 7] 快速排序和归并排序的区别 1.归并排序是数组分成两个子数组分别排序，并将有序的子数组归并从而将整个数组排序，而快速排序的方式则是当两个数组有序时，整个数组自然就有序了。 快速排序最坏情况 每一次切分选择的基准数字是当前序列中最大数或者最小数，这使得每次切分都会有一个子组，那么总共就得切分n次，所以，最坏情况下，快速排序的时间复杂度为O(n^2) 快速排序最优，平均情况 复杂度为O(nlogn) 排序稳定性数组arr中有若干元素，其中A元素和B元素相等，并且A元素再B元素前面，如果使用某种排序算法排序后，能保证A元素依然在B元素的前面，可以说这个算法是稳定的 稳定性的意义：如果一组数据只需要一次排序，那么稳定性没有任何意义 冒泡排序：稳定的 选择排序：不稳定的 插入排序：稳定的 希尔排序：不稳定的 归并排序：稳定的 快速排序：不稳定的 数据结构线性表线性表是最基本最简单也是最常用的一种数据结构，一个线性表是n个具有相同特性的数据元素的有限序列 前驱元素： 若A元素在B元素的前面，则称A为B的前驱元素 后继元素： 若B元素在A元素的后面，则称B为A的后继元素 线性表的特征：数据元素之间具有一种“一对一”的逻辑关系。 1. 第一个数据元素没有前驱，这个数据元素被称为头结点； 最后一个数据元素没有后继，这个数据元素被称为尾结点； 除了第一个和最后一个数据元素外，其他数据元素有且仅有一个前驱和一个后继。 如果把线性表用数学语言来定义，则可以表示为(a1,…ai-1,ai,ai+1,…an)，ai-1领先于ai,ai领先于ai+1，称ai-1是ai的 前驱元素，ai+1是ai的后继元素 线性表的分类： 线性表中数据存储的方式可以是顺序存储，也可以是链式存储，按照数据的存储方式不同，可以把线性表分为顺序 表和链表。 构造方法: SequenceList(int capacity)：创建容量为capacity的SequenceList对象 成员方法：1.public void clear()：空置线性表 2.publicboolean isEmpty()：判断线性表是否为空，是返回true，否返回false 3.public int length():获取线性表中元素的个数 4.public T get(int i):读取并返回线性表中的第i个元素的值 5.public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。 6.public void insert(T t):向线性表中添加一个元素t 7.public T remove(int i):删除并返回线性表中第i个数据元素。 8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返 回-1。 成员变量：1.private T[] eles：存储元素的数组 ​ 2.private int N:当前线性表的长度 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class SequenceList&lt;T&gt;&#123;//存储元素的数组 private T[] eles; //记录当前顺序表中元素的个数 private int N; //构造方法 public SequenceList(int capacity) &#123; //初始化数据 this.eles=(T[])new Object[capacity]; this.N=0; &#125; //将一个线性表置为空表 public void clear() &#123; this.N=0; &#125; //判断当前线性表是否为空表 public boolean isEmpty() &#123; return N==0; &#125; //获取线性表的长度 public int length() &#123; return N; &#125; //获取指定位置的元素 public T get(int i) &#123; if(i&lt;0||i&gt;=N) &#123; throw new RuntimeException(&quot;当前元素不存在&quot;); &#125; return eles[i]; &#125; //向线性表中添加元素t public void insert(T t) &#123; if(N==eles.length) &#123; throw new RuntimeException(&quot;当前表已满&quot;); &#125; eles[N++]=t; &#125; //向线性表的指定位置添加元素 public void insert(int i,T t) &#123; if(N==eles.length) &#123; throw new RuntimeException(&quot;当前表已满&quot;); &#125; if(i&lt;0||i&gt;N) &#123; throw new RuntimeException(&quot;插入的位置不合法&quot;); &#125; //记录最后一位的值 T last=eles[N-1]; //先把i索引处的元素及其后面的元素依次向后移一位 for(int index=N;index&gt;i;index--) &#123; eles[index]=eles[index-1]; &#125; //再把t元素放到i索引处即可 eles[i]=t; N++; &#125; //删除指定索引处的元素，并返回该元素 public T remove(int i) &#123; //记录索引处的值 T current=eles[i]; //索引i后面元素依次向前移动一位即可 for(int m=i;m&lt;N-1;m++) &#123; eles[m]=eles[m+1]; &#125; //元素个数减一 N--; return current; &#125; public int indexOf(T t) &#123; for(int i=0;i&lt;N;i++) &#123; if(eles[i].equals(t)) &#123; return i; &#125; &#125; return -1; &#125;&#125; 测试： 12345678910111213141516171819202122232425public class Main&#123; public static void main(String []args) &#123; //创建顺序表对象 SequenceList&lt;String&gt; s1=new SequenceList&lt;&gt;(10); //测试插入 s1.insert(&quot;姚明&quot;); s1.insert(&quot;科比&quot;); s1.insert(&quot;麦迪&quot;); s1.insert(1,&quot;艾弗森&quot;); //测试获取 String getResult1=s1.get(1); System.out.println(getResult1); //测试删除 String removeResult=s1.remove(0); System.out.println(removeResult); //测试清空 s1.clear(); System.out.println(&quot;清空后的线性表中的元素个数&quot;+s1.length()); System.out.println(s1.get(1)); &#125;&#125; 这里对这个clear有个疑问 顺序表的遍历 在java中，遍历集合的方式一般都是用的是foreach循环，如果想让我们的SequenceList也能支持foreach循环，则 需要做如下操作： 1.让SequenceList实现Iterable接口，重写iterator方法； 2.在SequenceList内部提供一个内部类SIterator,实现Iterator接口，重写hasNext方法和next方法； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110import java.util.Arrays;import java.util.Iterator;class SequenceList&lt;T&gt; implements Iterable&lt;T&gt;&#123;//存储元素的数组 private T[] eles; //记录当前顺序表中元素的个数 private int N; //构造方法 public SequenceList(int capacity) &#123; //初始化数据 this.eles=(T[])new Object[capacity]; this.N=0; &#125; //将一个线性表置为空表 public void clear() &#123; this.N=0; &#125; //判断当前线性表是否为空表 public boolean isEmpty() &#123; return N==0; &#125; //获取线性表的长度 public int length() &#123; return N; &#125; //获取指定位置的元素 public T get(int i) &#123; if(i&lt;0||i&gt;=N) &#123; throw new RuntimeException(&quot;当前元素不存在&quot;); &#125; return eles[i]; &#125; //向线性表中添加元素t public void insert(T t) &#123; if(N==eles.length) &#123; throw new RuntimeException(&quot;当前表已满&quot;); &#125; eles[N++]=t; &#125; //向线性表的指定位置添加元素 public void insert(int i,T t) &#123; if(i==eles.length) &#123; throw new RuntimeException(&quot;当前表已满&quot;); &#125; if(i&lt;0||i&gt;N) &#123; throw new RuntimeException(&quot;插入的位置不合法&quot;); &#125; //记录最后一位的值 T last=eles[N-1]; //先把i索引处的元素及其后面的元素依次向后移一位 for(int index=N;index&gt;i;index--) &#123; eles[index]=eles[index-1]; &#125; //再把t元素放到i索引处即可 eles[i]=t; N++; &#125; //删除指定索引处的元素，并返回该元素 public T remove(int i) &#123; //记录索引处的值 T current=eles[i]; //索引i后面元素依次向前移动一位即可 for(int m=i;m&lt;N-1;m++) &#123; eles[m]=eles[m+1]; &#125; //元素个数减一 N--; return current; &#125; public int indexOf(T t) &#123; for(int i=0;i&lt;N;i++) &#123; if(eles[i].equals(t)) &#123; return i; &#125; &#125; return -1; &#125; @Override public Iterator&lt;T&gt; iterator() &#123; // TODO Auto-generated method stub return new SIterator(); &#125; private class SIterator implements Iterator&#123;private int cusor;public SIterator() &#123; this.cusor=0;&#125; @Override public boolean hasNext() &#123; // TODO Auto-generated method stub return cusor&lt;N; &#125; @Override public Object next() &#123; // TODO Auto-generated method stub return eles[cusor++]; &#125; &#125;​ &#125; 测试： 123456789101112131415161718192021222324public class Main&#123; public static void main(String []args) &#123; //创建顺序表对象 SequenceList&lt;String&gt; s1=new SequenceList&lt;&gt;(10); //测试插入 s1.insert(&quot;姚明&quot;); s1.insert(&quot;科比&quot;); s1.insert(&quot;麦迪&quot;); s1.insert(1,&quot;艾弗森&quot;); //测试循环 for(String s3:s1) &#123; System.out.println(s3); &#125; System.out.println(&quot;-----------------------------------------&quot;); Iterator it=s1.iterator(); while(it.hasNext()) &#123; System.out.println(it.next()); &#125; &#125;&#125; 顺序表的容量可变 添加元素时，应该检查当前数组的大小是否能容纳新的元素，如果不能容纳，则需要创建新的容量更大的数组，我 们这里创建一个是原数组两倍容量的新数组存储元素。 移除元素时，应该检查当前数组的大小是否太大，比如正在用100个容量的数组存储10个元素，这样就会造成内存 空间的浪费，应该创建一个容量更小的数组存储元素。如果我们发现数据元素的数量不足数组容量的1&#x2F;4，则创建 一个是原数组容量的1&#x2F;2的新数组存储元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124import java.util.Arrays;import java.util.Iterator;class SequenceList&lt;T&gt; implements Iterable&lt;T&gt;&#123;//存储元素的数组 private T[] eles; //记录当前顺序表中元素的个数 private int N; //构造方法 public SequenceList(int capacity) &#123; //初始化数据 this.eles=(T[])new Object[capacity]; this.N=0; &#125; //将一个线性表置为空表 public void clear() &#123; this.N=0; &#125; //判断当前线性表是否为空表 public boolean isEmpty() &#123; return N==0; &#125; //获取线性表的长度 public int length() &#123; return N; &#125; //获取指定位置的元素 public T get(int i) &#123; if(i&lt;0||i&gt;=N) &#123; throw new RuntimeException(&quot;当前元素不存在&quot;); &#125; return eles[i]; &#125; //向线性表中添加元素t public void insert(T t) &#123; if(N==eles.length) &#123; resize(2*eles.length); &#125; eles[N++]=t; &#125; //向线性表的指定位置添加元素 public void insert(int i,T t) &#123; if(N==eles.length) &#123; resize(2*eles.length); &#125; if(i&lt;0||i&gt;N) &#123; throw new RuntimeException(&quot;插入的位置不合法&quot;); &#125; //记录最后一位的值 T last=eles[N-1]; //先把i索引处的元素及其后面的元素依次向后移一位 for(int index=N;index&gt;i;index--) &#123; eles[index]=eles[index-1]; &#125; //再把t元素放到i索引处即可 eles[i]=t; N++; &#125; //删除指定索引处的元素，并返回该元素 public T remove(int i) &#123; //记录索引处的值 T current=eles[i]; //索引i后面元素依次向前移动一位即可 for(int m=i;m&lt;N-1;m++) &#123; eles[m]=eles[m+1]; &#125; //元素个数减一 N--; if(N&lt;eles.length/4) &#123; resize(eles.length/2); &#125; return current; &#125; public int indexOf(T t) &#123; for(int i=0;i&lt;N;i++) &#123; if(eles[i].equals(t)) &#123; return i; &#125; &#125; return -1; &#125; //根据参数newSize，重置eles的大小 public void resize(int newSize) &#123; //定义一个临时数组，指向原数组 T[] temp=eles; //创建新数组 eles=(T[])new Object[newSize]; //吧原数组中的内容拷贝到新数组中 for(int i=0;i&lt;N;i++) &#123; eles[i]=temp[i]; &#125; &#125; @Override public Iterator&lt;T&gt; iterator() &#123; // TODO Auto-generated method stub return new SIterator(); &#125; private class SIterator implements Iterator&#123;private int cusor;public SIterator() &#123; this.cusor=0;&#125; @Override public boolean hasNext() &#123; // TODO Auto-generated method stub return cusor&lt;N; &#125; @Override public Object next() &#123; // TODO Auto-generated method stub return eles[cusor++]; &#125; &#125;​ &#125; 测试： 12345678910public class Main&#123; public static void main(String []args) &#123; SequenceList&lt;String&gt; s1=new SequenceList&lt;String&gt;(1); s1.insert(&quot;张三&quot;); s1.insert(&quot;李四&quot;);System.out.println(s1.length()); &#125;&#125;结果为2 顺序表的时间复杂度 get(i):不难看出，不论数据元素量N有多大，只需要一次eles[i]就可以获取到对应的元素，所以时间复杂度为O(1); insert(int i,T t):每一次插入，都需要把i位置后面的元素移动一次，随着元素数量N的增大，移动的元素也越多，时 间复杂为O(n); remove(int i):每一次删除，都需要把i位置后面的元素移动一次，随着数据量N的增大,移动的元素也越多，时间复 杂度为O(n); 由于顺序表的底层由数组实现，数组的长度是固定的，所以在操作的过程中涉及到了容器扩容操作。这样会导致顺 序表在使用过程中的时间复杂度不是线性的，在某些需要扩容的结点处，耗时会突增，尤其是元素越多，这个问题 越明显 java中ArrayList的实现 java中ArrayList集合的底层也是一种顺序表，使用数组实现，同样提供了增删改查以及扩容等功能。 1.是否用数组实现； 2.有没有扩容操作； 3.有没有提供遍历方式； 链表之前，顺序表的查询很快，但是增删的效率是比较低的，每次修改伴随大量数据元素移动，这些都是因为他们元素的内存地址是连续的 链表：物理存储单元不是连续的，链表由一系列的结点组成，节点可以在运行时动态生成 插入数据就是把11和13之间的链断开，将11和22连接再将22和13连接 删除数据就是把11直接指向12 结点API设计 构造方法：Node(T t,Node next)：创建Node对象 成员变量：T item:存储数据 ​ Node next：指向下一个结点 基本链表 12345678910111213141516171819202122232425262728293031class Node&lt;T&gt;&#123; //存储元素 public T item; //指向下一个节点 public Node next; public Node(T item,Node next) &#123; this.item=item; this.next=next; &#125;&#125;class Main&#123; public static void main(String []args) &#123; //构建结点 Node&lt;Integer&gt; first=new Node&lt;Integer&gt;(11,null); Node&lt;Integer&gt; second=new Node&lt;Integer&gt;(13,null); Node&lt;Integer&gt; third=new Node&lt;Integer&gt;(12,null); Node&lt;Integer&gt; fourth=new Node&lt;Integer&gt;(8,null); Node&lt;Integer&gt; fifth=new Node&lt;Integer&gt;(9,null); //生成链表 first.next=second; second.next=third; third.next=fourth; fourth.next=fifth; &#125;&#125; 单向链表单向链表是链表的一种，它由多个结点组成，每个结点都是由一个数据域和一个指针域组成，数据域用来存储数据，指针域用来指向其后结点，链表的头节点数据与不存储数据，指针域指向第一个真正存储数据的结点 构造方法：LinkList()：创建LinkList对象 单向链表的API设计 下面这些i都是指索引的意思，就是第一个有data的结点索引是0 1.public void clear()：空置线性表 2.publicboolean isEmpty()：判断线性表是否为空，是返回true，否返回false 3.public int length():获取线性表中元素的个数 4.public T get(int i):读取并返回线性表中的第i个元素的值 5.public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。 6.public void insert(T t):向线性表中添加一个元素t 7.public T remove(int i):删除并返回线性表中第i个数据元素。 8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返 回-1。 成员内部类：private class Node 结点类 成员变量：1.private Node head 记录首结点 ​ 2.private int N 记录链表的长度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138import java.util.Iterator;class LinkList&lt;T&gt; implements Iterable&lt;T&gt;&#123; //记录头节点 private Node head; //记录链表的长度 private int N; //结点类 private class Node&lt;T&gt;&#123; //存储数据 T item; //下一个结点 Node next; public Node(T item,Node next) &#123; this.item=item; this.next=next; &#125; &#125; public LinkList() &#123; //创建头结点 this.head=new Node(null,null); //初始化元素个数 this.N=0; &#125; //清空链表 public void clear() &#123; head.next=null; this.N=0; &#125; //获取链表的长度 public int length() &#123;return N;&#125; //判断链表是否为空 public boolean isEmpty() &#123; return N==0; &#125; //获取指定位置i处的元素 public T get(int i) &#123; Node&lt;T&gt; m=head.next; for(int n=0;n&lt;i;n++) &#123; //通过循环，从头结点开始往后找，依次找i次，就可以找到对应的元素 m=m.next; &#125; return m.item; &#125; public void insert(T item) &#123; //找到当前最后一个结点 Node n=head; while(n.next!=null) &#123; n=n.next; &#125; //创建新结点，保存元素t Node&lt;T&gt; newNode=new Node&lt;&gt;(item,null); //让当前最后一个结点指向新结点 n.next=newNode; //元素的个数+1 N++; &#125; //向指定的位置i处添加新元素 public void insert(T item,int i) &#123; //找到i位置前一个结点 Node n=head; for(int index=0;index&lt;=i-1;index++) &#123; n=n.next; &#125; //找到i位置的结点 Node curr=n.next; //创建新结点，并且·新结点需要指向原来i位置的结点 Node newNode=new Node(item,curr); //原来i位置的前一个结点指向新结点即可 n.next=newNode; //元素的个数加一 N++; &#125; //删除指定位置i的元素，并返回被删除的元素 public T remove(int i) &#123;//找到i前一个位置的结点 Node&lt;T&gt; n=head; for(int index=0;index&lt;=i-1;index++) &#123; n=n.next; &#125; //找到i位置这个节点 Node curr=n.next; //找到i位置之后这个结点 Node last=curr.next; //将i位置之前的这个结点指向i位置之后这个结点 n.next=last; //元素数目-1 N--; return get(i); &#125; //查找元素t在链表中第一次出现的位置 public int indexOf(T t) &#123; Node&lt;T&gt; n=head; for(int i=0;n.next!=null;i++) &#123; if(n.next.item.equals(t)) &#123; return i; &#125; &#125; return -1; &#125; //实现遍历 private class SIterator implements Iterator&#123; private Node n; public SIterator() &#123; this.n=head; &#125; @Override public boolean hasNext() &#123; return n.next!=null; &#125; @Override public Object next() &#123; n=n.next; return n.item; &#125; &#125; @Override public Iterator&lt;T&gt; iterator() &#123; // TODO Auto-generated method stub return new SIterator();//有点不理解应该是&lt;T&gt;泛型的Iterator对象，但这个不是也行啊 &#125; &#125;//有了Itreable的实现才能用遍历for(String s:s1)这个 测试： 123456789101112131415161718192021222324public class Main&#123; public static void main(String []args) &#123; //创建顺序表对象 LinkList&lt;String&gt; s1=new LinkList&lt;String&gt;(); //测试插入 s1.insert(&quot;姚明&quot;); s1.insert(&quot;科比&quot;); s1.insert(&quot;麦迪&quot;); s1.insert(&quot;艾弗森&quot;,1); //测试获取 String getResult1=s1.get(1); System.out.println(getResult1); //测试删除 String removeResult=s1.remove(0); System.out.println(removeResult); //测试清空 s1.clear(); System.out.println(&quot;清空后的线性表中的元素个数&quot;+s1.length()); &#125;&#125; 双向链表每个结点都由一个数据域和两个指针域组成，数据域用来存放数据，其中一个指针域用来指向其后继结点，另一个指针域用来指向前驱结点。 结点API设计 构造方法：Node(T t,Node pre,Node next)：创建Node对象 成员变量：T item:存储数据 ​ Node next：指向下一个结点 ​ Node pre:指向上一个结点 双向链表API设计 成员变量：1.private Node first:记录首结点 2.private Node last:记录尾结点 3.private int N:记录链表的长度 成员内部类：private class Node 1.public void clear()：空置线性表 2.publicboolean isEmpty()：判断线性表是否为空，是返回true，否返回false 3.public int length():获取线性表中元素的个数 4.public T get(int i):读取并返回线性表中的第i个元素的值 5.public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。 6.public void insert(T t):向线性表中添加一个元素t 7.public T remove(int i):删除并返回线性表中第i个数据元素。 8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返 回-1。 9.public T getFirst():获取第一个元素 10.public T getLast():获取最后一个元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160import java.util.Iterator;class TowWayLinkList&lt;T&gt; implements Iterable&lt;T&gt; &#123; //首结点 private Node head; //最后一个结点 private Node last; //链表的长度 private int N; //结点类 private class Node&#123; public Node(T item,Node pre,Node next) &#123; this.item=item; this.pre=pre; this.next=next; &#125; //存储数据 public T item; //指向上一个结点 public Node pre; //指向下一个结点 public Node next; &#125; public TowWayLinkList() &#123; this.head=new Node(null,null,null); this.last=null;//刚开始是没有尾节点的 //初始化元素个数 this.N=0; &#125; //清空列表 public void clear() &#123; this.head.next=null; this.head.pre=null; this.N=0; &#125; //获取链表的长度 public int length() &#123; return N; &#125; //判断链表是否为空 public boolean isEmpty() &#123; return N==0; &#125; //获取第一个元素 public T getFirst() &#123; if(isEmpty()) &#123; return null; &#125; return head.next.item; &#125; //获取最后一个元素 public T getLast() &#123; if(isEmpty()) &#123; return null; &#125; return last.item; &#125; public void insert(T item) &#123; if(isEmpty()) &#123; //如果我们的链表为空 Node n=new Node(item,head,null);//因为是第一个插入的没有尾节点自己就是，所以第三个参数为null //我们需要让新结点为尾节点 last=n; //让头结点指向尾节点 head.next=last; &#125; else &#123; //如果我们的链表不为空3 Node oldlast=last; //创建新的节点 Node n=new Node(item,oldlast,null); //让老尾节点指向新结点 oldlast.next=n; //让新结点成为尾结点 last=n; &#125; //元素个数加一 N++; &#125; public void insert(int i,T t) &#123; //找到i位置前的一个结点 Node pre=head; for(int index=0;index&lt;=i-1;index++) &#123; pre=pre.next; &#125; //找到i位置的一个结点 Node curr=pre.next; //创建新结点 Node newNode=new Node(t,pre,curr); //让i位置的前一个结点的下一个结点为新结点 pre.next=newNode; //让i位置的前一个结点为新结点 curr.pre=newNode; //元素的个数加一 N++; &#125; //获取指定位置i处的元素 public T get(int i) &#123; Node n=head; for(int index=0;index&lt;=i;index++) &#123; n=n.next; &#125; return n.item; &#125; //找到元素t在链表中第一次出现的位置 public int indexOf(T t) &#123; Node n=head; for(int i=0;n.next!=null;i++) &#123; n=n.next; if(n.item.equals(t)) &#123; return i; &#125; &#125; return -1; &#125; public T remove(int i) &#123; //找到i位置的前一个结点 Node n=head; for(int index=0;index&lt;=i-1;index++) &#123; n=n.next; &#125; //找到i位置结点 Node curr=n.next; //找到i位置后一个结点 Node last=curr.next; //让i位置后一个结点的上一个结点是i位置的前一个结点 last.pre=n; //然i位置前一个结点的下一个结点是i位置的后一个结点 n.next=last; //减少一个元素 N--; return curr.item; &#125; @Override public Iterator&lt;T&gt; iterator() &#123; // TODO Auto-generated method stub return null; &#125; private class SIterator&lt;T&gt; implements Iterator&lt;T&gt;&#123; private Node n=head; @Override public boolean hasNext() &#123; // TODO Auto-generated method stub return n.next!=null; &#125; @Override public T next() &#123; n=n.next; return (T)n.item; &#125; &#125; &#125;注意点：上面添加元素时之所以只有一个方向的指向是因为在创建那个元素的时候就已经规定了另外一个方向了 测试： 123456789101112131415161718192021222324252627public class Main&#123; public static void main(String []args) &#123; //创建顺序表对象 TowWayLinkList&lt;String&gt; s1=new TowWayLinkList&lt;String&gt;(); //测试插入 s1.insert(&quot;姚明&quot;); s1.insert(&quot;科比&quot;); s1.insert(&quot;麦迪&quot;); s1.insert(1,&quot;艾弗森&quot;); //测试获取 String getResult1=s1.get(1); System.out.println(getResult1); //测试删除 String removeResult=s1.remove(0); System.out.println(removeResult); //测试方法 System.out.println(&quot;第一个元素是&quot;+s1.getFirst()); System.out.println(&quot;最后一个元素是&quot;+s1.getLast()); //测试清空 s1.clear(); System.out.println(&quot;清空后的线性表中的元素个数&quot;+s1.length()); &#125;&#125; 1.2.2.4 java中LinkedList实现 java中LinkedList集合也是使用双向链表实现，并提供了增删改查等相关方法 1.底层是否用双向链表实现； 2.结点类是否有三个域 链表的复杂度分析 最坏情况 get(int i):可能会找N次 复杂度为O(n) insert(int i,T t):要找到位置的前一个元素，所以复杂度也为O(n) remove(int i):找到i位置的结点，所以复杂度也为O(n) 相比较顺序表，链表插入和删除的时间复杂度和他一样，但链表有优势，不需要提前指定存储空间大小，并且没有涉及元素的交换 相比较顺序表，链表的查询操作性能会比较低，所以查询操作多使用顺序表，增删操作多，使用链表 链表反转单链表的反转 添加两个方法： 反转API： public void reverse()：对整个链表反转 public Node reverse(Node curr)：反转链表中的某个结点curr,并把反转后的curr结点返回 原链表： 反转之后是head指向4指向3指向2指向1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165package Main;import java.util.Iterator;class LinkList&lt;T&gt; implements Iterable&lt;T&gt;&#123; //记录头节点 private Node head; //记录链表的长度 private int N; //结点类 private class Node&lt;T&gt;&#123; //存储数据 T item; //下一个结点 Node next; public Node(T item,Node next) &#123; this.item=item; this.next=next; &#125; &#125; public LinkList() &#123; //创建头结点 this.head=new Node(null,null); //初始化元素个数 this.N=0; &#125; //清空链表 public void clear() &#123; head.next=null; this.N=0; &#125; //获取链表的长度 public int length() &#123;return N;&#125; //判断链表是否为空 public boolean isEmpty() &#123; return N==0; &#125; //获取指定位置i处的元素 public T get(int i) &#123; Node&lt;T&gt; m=head.next; for(int n=0;n&lt;i;n++) &#123; //通过循环，从头结点开始往后找，依次找i次，就可以找到对应的元素 m=m.next; &#125; return m.item; &#125; public void insert(T item) &#123; //找到当前最后一个结点 Node n=head; while(n.next!=null) &#123; n=n.next; &#125; //创建新结点，保存元素t Node&lt;T&gt; newNode=new Node&lt;&gt;(item,null); //让当前最后一个结点指向新结点 n.next=newNode; //元素的个数+1 N++; &#125; //向指定的位置i处添加新元素 public void insert(T item,int i) &#123; //找到i位置前一个结点 Node n=head; for(int index=0;index&lt;=i-1;index++) &#123; n=n.next; &#125; //找到i位置的结点 Node curr=n.next; //创建新结点，并且·新结点需要指向原来i位置的结点 Node newNode=new Node(item,curr); //原来i位置的前一个结点指向新结点即可 n.next=newNode; //元素的个数加一 N++; &#125; //删除指定位置i的元素，并返回被删除的元素 public T remove(int i) &#123;//找到i前一个位置的结点 Node&lt;T&gt; n=head; for(int index=0;index&lt;=i-1;index++) &#123; n=n.next; &#125; //找到i位置这个节点 Node curr=n.next; //找到i位置之后这个结点 Node last=curr.next; //将i位置之前的这个结点指向i位置之后这个结点 n.next=last; //元素数目-1 N--; return get(i); &#125; //查找元素t在链表中第一次出现的位置 public int indexOf(T t) &#123; Node&lt;T&gt; n=head; for(int i=0;n.next!=null;i++) &#123; if(n.next.item.equals(t)) &#123; return i; &#125; &#125; return -1; &#125; //实现遍历 private class SIterator implements Iterator&#123; private Node n; public SIterator() &#123; this.n=head; &#125; @Override public boolean hasNext() &#123; return n.next!=null; &#125; @Override public Object next() &#123; n=n.next; return n.item; &#125; &#125; @Override public Iterator&lt;T&gt; iterator() &#123; // TODO Auto-generated method stub return new SIterator();//有点不理解应该是&lt;T&gt;泛型的Iterator对象，但这个不是也行啊 &#125; //用来反转整个链表 public void reverse() &#123; //判断当前链表是否为空链表,如果是空链表，则结束运行，如果不是，则调用重载reverse方法完成反转 if(isEmpty()) &#123; return ; &#125; reverse(head.next); &#125; public Node reverse(Node curr) &#123; //一个出口，如果反转到最后一个元素就用head指向它 if(curr.next==null) &#123; head.next=curr; return curr; &#125; else &#123; //递归地去反转当前节点curr的下一个结点 Node pre=reverse(curr.next); //让返回的结点的下一个结点变为curr pre.next=curr; //把当前结点的下一个结点变为null curr.next=null; //返回值就是当前结点的下一个结点，也是反转后的上一个结点 return curr; &#125; &#125; &#125; 链表反转的代码 测试： 12345678910111213141516171819public class Main&#123; public static void main(String []args) &#123; //创建顺序表对象 LinkList&lt;String&gt; s1=new LinkList&lt;String&gt;(); //测试插入 s1.insert(&quot;姚明&quot;); s1.insert(&quot;科比&quot;); s1.insert(&quot;麦迪&quot;); s1.insert(&quot;艾弗森&quot;,1); s1.reverse();for(String s:s1) &#123;System.out.println(s);&#125;&#125; &#125;结果： 麦迪科比艾弗森姚明 快慢指针快慢指针指的是定义两个指针，这两个指针的移动速度一块一慢，以此来制造出自己想要的差值，这个差值可以然 我们找到链表上相应的结点。一般情况下，快指针的移动步长为慢指针的两倍 中间值问题：主要是那个getMid方法 &#96;&#96;&#96;&#x2F;&#x2F;测试类public class Main {public static void main(String[] args) throws Exception {Node first &#x3D; new Node(“aa”, null);Node second &#x3D; new Node(“bb”, null);Node third &#x3D; new Node(“cc”, null);Node fourth &#x3D; new Node(“dd”, null);Node fifth &#x3D; new Node(“ee”, null);Node six &#x3D; new Node(“ff”, null);Node seven &#x3D; new Node(“gg”, null);&#x2F;&#x2F;完成结点之间的指向first.next &#x3D; second;second.next &#x3D; third;third.next &#x3D; fourth;fourth.next &#x3D; fifth;fifth.next &#x3D; six;six.next &#x3D; seven;&#x2F;&#x2F;查找中间值String mid &#x3D; getMid(first);System.out.println(“中间值为：”+mid);}&#x2F;** @param first 链表的首结点 @return 链表的中间结点的值*&#x2F;public static String getMid(Node first) {&#x2F;&#x2F;定义两个指针Node fast&#x3D;first;Node slow&#x3D;first;&#x2F;&#x2F;使用两个指针遍历链表，当快指针指向的结点没有下一个结点了，就可以结束了，结束之后，慢指针指向的结点就是中间值while(fast!&#x3D;null&amp;&amp;fast.next!&#x3D;null) {&#x2F;&#x2F;变换fast值和slow的值fast&#x3D;fast.next.next;slow&#x3D;slow.next;}return slow.item;}&#x2F;&#x2F;结点类private static class Node {&#x2F;&#x2F;存储数据T item;&#x2F;&#x2F;下一个结点Node next;public Node(T item, Node next) {this.item &#x3D; item;this.next &#x3D; next;}}}123456789 **单项链表是否有环的问题**![image-20220801103447923](https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291656815.png)在有环链表中快慢指针迟早会相遇，指向同一个元素，因为快指针比慢指针走得快代码： public class Main {public static void main(String[] args) throws Exception {Node first &#x3D; new Node(“aa”, null);Node second &#x3D; new Node(“bb”, null);Node third &#x3D; new Node(“cc”, null);Node fourth &#x3D; new Node(“dd”, null);Node fifth &#x3D; new Node(“ee”, null);Node six &#x3D; new Node(“ff”, null);Node seven &#x3D; new Node(“gg”, null);&#x2F;&#x2F;完成结点之间的指向first.next &#x3D; second;second.next &#x3D; third;third.next &#x3D; fourth;fourth.next &#x3D; fifth;fifth.next &#x3D; six;six.next &#x3D; seven;seven.next&#x3D;second;&#x2F;&#x2F;判断是否为环boolean circle&#x3D;isCircle(first);System.out.println(“first链表中是否有环”+circle);} public static boolean isCircle(Node first) { &#x2F;&#x2F;定义快慢指针 Node fast&#x3D;first; Node slow&#x3D;first; &#x2F;&#x2F;遍历链表，如果快慢指针指向同一个结点，那么证明有环 while(fast!&#x3D;null&amp;&amp;fast.next!&#x3D;null) { &#x2F;&#x2F;变换fast和slow fast&#x3D;fast.next.next; slow&#x3D;slow.next; if(fast.equals(slow)) { return true; } } return false; } &#x2F;&#x2F;结点类 private static class Node { &#x2F;&#x2F;存储数据 T item; &#x2F;&#x2F;下一个结点 Node next; public Node(T item, Node next) { this.item &#x3D; item; this.next &#x3D; next; } } }结果：first链表中是否有环true 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970**检测链表中有环如何找到环的入口**当快慢指针相遇时，我们可以判断到链表中有环，这时重新设定一个新指针指向链表的起点，且步长与慢指针一样 为1，则慢指针与“新”指针相遇的地方就是环的入口。代码```javapublic class Main &#123;public static void main(String[] args) throws Exception &#123;Node&lt;String&gt; first = new Node&lt;String&gt;(&quot;aa&quot;, null);Node&lt;String&gt; second = new Node&lt;String&gt;(&quot;bb&quot;, null);Node&lt;String&gt; third = new Node&lt;String&gt;(&quot;cc&quot;, null);Node&lt;String&gt; fourth = new Node&lt;String&gt;(&quot;dd&quot;, null);Node&lt;String&gt; fifth = new Node&lt;String&gt;(&quot;ee&quot;, null);Node&lt;String&gt; six = new Node&lt;String&gt;(&quot;ff&quot;, null);Node&lt;String&gt; seven = new Node&lt;String&gt;(&quot;gg&quot;, null);//完成结点之间的指向first.next = second;second.next = third;third.next = fourth;fourth.next = fifth;fifth.next = six;six.next = seven;seven.next=third;//找到环的入口结点Node&lt;String&gt; entrance=getEntrance(first);System.out.println(&quot;first链表中环的入口结点元素为&quot;+entrance.item);&#125;public static Node getEntrance(Node&lt;String&gt; first) &#123; //定义快慢指针 Node&lt;String&gt; fast=first; Node&lt;String&gt; slow=first; Node&lt;String&gt; temp=null; //遍历链表，如果快慢指针指向同一个结点，找到换，准备一个临时指针，指向表的首结点，继续遍历，直到慢指针和临时指针相遇，那么相遇时指向的结点就是环的入口 while(fast!=null&amp;&amp;fast.next!=null) &#123; //变换fast和slow fast=fast.next.next; slow=slow.next; if(fast.equals(slow)) &#123; temp=first; continue; &#125; //让临时结点不是null的时候变换 if(temp!=null) &#123; temp=temp.next; //判断临时指针是否和慢指针相遇 if(temp.equals(slow)) &#123; break; &#125; &#125; &#125; return temp;&#125; //结点类 private static class Node&lt;T&gt; &#123; //存储数据 T item; //下一个结点 Node next; public Node(T item, Node next) &#123; this.item = item; this.next = next; &#125; &#125; &#125; 结果为：cc 循环链表循环链表，顾名思义，链表整体要形成一个圆环状。在单向链表中，最后一个节点的指针为null，不指向任何结 点，因为没有下一个元素了。要实现循环链表，我们只需要让单向链表的最后一个节点的指针指向头结点即可。 1234567891011121314151617181920212223242526272829public class Main &#123;public static void main(String[] args) &#123;//构建结点Node&lt;Integer&gt; first = new Node&lt;Integer&gt;(1, null);Node&lt;Integer&gt; second = new Node&lt;Integer&gt;(2, null);Node&lt;Integer&gt; third = new Node&lt;Integer&gt;(3, null);Node&lt;Integer&gt; fourth = new Node&lt;Integer&gt;(4, null);Node&lt;Integer&gt; fifth = new Node&lt;Integer&gt;(5, null);Node&lt;Integer&gt; six = new Node&lt;Integer&gt;(6, null);Node&lt;Integer&gt; seven = new Node&lt;Integer&gt;(7, null);//构建单链表first.next = second;second.next = third;third.next = fourth;fourth.next = fifth;fifth.next = six;six.next = seven;//构建循环链表,让最后一个结点指向第一个结点seven.next = first;&#125;private static class Node&lt;T&gt; &#123; public T i; public Node next; public Node(T i,Node next) &#123; this.i=i; this.next=next; &#125;&#125;&#125; 报错但不知道为什么，报错的原因是内部类要在main函数中使用必须是static 约瑟夫问题41个人坐一圈，第一个人编号为1，第二个人编号为2，第n个人编号为n。 1.编号为1的人开始从1报数，依次向后，报数为3的那个人退出圈； 2.自退出那个人开始的下一个人再次从1开始报数，以此类推； 3.求出最后退出的那个人的编号。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Main &#123; private static class Node&lt;T&gt; &#123; public T item; public Node next; public Node(T item,Node next) &#123; this.item=item; this.next=next; &#125; &#125;public static void main(String[] args) &#123;//构建循环链表具有41个结点。分别存储1-41之间的值 Node&lt;Integer&gt; first=null;//记录首结点 Node&lt;Integer&gt; pre=null;//记录前一个结点 for(int i=1;i&lt;=41;i++) &#123; //1.如果是第一个结点 if(i==1) &#123; first=new Node&lt;&gt;(i,null);//下一个节点暂时不知道 pre=first; continue; &#125; //如果不是第一个结点 Node newNode=new Node&lt;&gt;(i,null); pre.next=newNode; pre=newNode; //如果是最后一个结点，让下一个结点为first if(i==41) &#123; pre.next=first; &#125; &#125;//1.需要count计数器，模拟报数int count =0; //遍历循环链表//记录每次遍历拿到的结点，默认从首节点开始Node&lt;Integer&gt; n=first;//记录当前节点的上一个节点Node&lt;Integer&gt; before=null;while(n!=n.next) &#123;//模拟报数 count++; //判断当前报数是不是3 if(count==3) &#123; //如果是3，则把当前结点删除调用，打印当前结点，重置count为0，让我当前节点n后移 before.next=n.next; System.out.print(n.item+&quot;,&quot;); count=0; n=n.next; &#125; else &#123; //如果不是3，让before变为当前结点，让当前结点后移 before=n; n=n.next; &#125; &#125;//打印最后一个元素System.out.print(&quot;\\n&quot;);System.out.println(n.item);&#125;&#125; 栈栈是一种基于先进后出(FILO)的数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出 的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一 个数据被第一个读出来）。 称数据进入到栈的动作为压栈，数据从栈中出去的动作为弹栈。 栈的API设计 构造方法：Stack()创建Stack对象 成员方法:1.public boolean isEmpty()：判断栈是否为空，是返回true，否返回false ​ 2.public int size():获取栈中元素的个数 ​ 3.public T pop():弹出栈顶元素 ​ 4.public void push(T t)：向栈中压入元素t 成员变量:1.private Node head:记录首结点 ​ 2.private int N:当前栈的元素个数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980```import java.util.Iterator;class Stack&lt;T&gt; implements Iterable&lt;T&gt;&#123; //记录首节点 private Node head; //栈中元素个数 private int N; private class Node&#123; public T item; public Node next; public Node(T item,Node next) &#123; this.item=item; this.next=next; &#125; &#125; public Stack() &#123; //初始化首节点 this.head=new Node(null,null); //初始化栈元素个数 this.N=0; &#125; //判断当前栈中的元素个数是否为零 public boolean isEmpty() &#123; return N==0; &#125; //获取栈中元素的个数 public int size() &#123; return N; &#125; //将t元素压入栈 public void push(T t) &#123; //创建一个新结点，将新结点插入到首节点和下一个结点之间 Node newNode=new Node(t,head.next); head.next=newNode; N++; &#125; //弹栈 public T pop() &#123; //找到首节点指向第一个结点 Node old=head.next; //如果栈中没有元素 if(old==null) &#123; return null; &#125; //让首节点直接连要删除结点后面一个节点 head.next=head.next.next; //元素个数减一 N--; //返回那个被弹出的结点 return old.item; &#125; @Override public Iterator&lt;T&gt; iterator() &#123; return new SIterator(); &#125; private class SIterator implements Iterator&#123; private Node n; public SIterator() &#123; this.n=head; &#125; @Override public boolean hasNext() &#123; return n.next!=null; &#125;``` @Override public Object next() &#123; n=n.next; return n.item; &#125; &#125; &#125; 测试： 123456789101112131415public class Main&#123; public static void main(String []args) &#123; Stack&lt;String&gt; stack=new Stack&lt;&gt;(); stack.push(&quot;a&quot;); stack.push(&quot;b&quot;); stack.push(&quot;c&quot;); stack.push(&quot;d&quot;); for(String a:stack) &#123; System.out.println(a); &#125; String result=stack.pop(); System.out.println(result); System.out.println(&quot;剩余元素个数&quot;+stack.size()); &#125; &#125; 括号匹配问题给定一个字符串，里边可能包含”()”小括号和其他字符，请编写程序检查该字符串的中的小括号是否成对出现。 例如: “(上海)(长安)”：正确匹配 ​ “上海((长安))”：正确匹配 ​ “上海(长安(北京)(深圳)南京)”:正确匹配 ​ “上海(长安))”：错误匹配 ​ “((上海)长安”：错误匹配 下面主要是isMatch方法的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113import java.util.Iterator;class Stack&lt;T&gt; implements Iterable&lt;T&gt;&#123; //记录首节点 private Node head; //栈中元素个数 private int N; private class Node&#123; public T item; public Node next; public Node(T item,Node next) &#123; this.item=item; this.next=next; &#125; &#125; public Stack() &#123; //初始化首节点 this.head=new Node(null,null); //初始化栈元素个数 this.N=0; &#125; //判断当前栈中的元素个数是否为零 public boolean isEmpty() &#123; return N==0; &#125; //获取栈中元素的个数 public int size() &#123; return N; &#125; //将t元素压入栈 public void push(T t) &#123; //创建一个新结点，将新结点插入到首节点和下一个结点之间 Node newNode=new Node(t,head.next); head.next=newNode; N++; &#125; //弹栈 public T pop() &#123; //找到首节点指向第一个结点 Node old=head.next; //如果栈中没有元素 if(old==null) &#123; return null; &#125; //让首节点直接连要删除结点后面一个节点 head.next=head.next.next; //元素个数减一 N--; //返回那个被弹出的结点 return old.item; &#125; @Override public Iterator&lt;T&gt; iterator() &#123; return new SIterator(); &#125; private class SIterator implements Iterator&#123; private Node n; public SIterator() &#123; this.n=head; &#125; @Override public boolean hasNext() &#123; return n.next!=null; &#125; @Override public Object next() &#123; n=n.next; return n.item; &#125; &#125; &#125; public class Main &#123; public static void main(String[] args) &#123; String str = &quot;(上海(长安)())&quot;; boolean match = isMatch(str); System.out.println(str+&quot;中的括号是否匹配：&quot;+match); &#125; public static boolean isMatch(String str)&#123; //创建栈对象用来存储左阔 Stack&lt;String&gt; stack=new Stack&lt;String&gt;(); //从左往右遍历字符串 for(int i=0;i&lt;str.length();i++) &#123; String currchar=str.charAt(i)+&quot;&quot;; //判断当前字符是否为左括号，如果是，则压入栈中 if(currchar.equals(&quot;(&quot;)) &#123; stack.push(currchar); &#125; else if(currchar.equals(&quot;)&quot;)) &#123; //继续判断当前字符是否是右括号，如果是，则弹出一个左括号，并判断弹出结果是否为null，是null则证明没有匹配的左括号，不是null则证明右匹配的左括号 String pop=stack.pop(); if(pop==null) &#123; return false; &#125; &#125; &#125; //判断是否有剩余的左括号 if(stack.size()!=0) &#123; return false; &#125; return true; &#125; &#125; 逆波兰表达式求值问题逆波兰表达式简介： 也就是后缀表达式，运算符总是放在跟他相关的操作数之后 中缀表达式简介： 二元运算符总是置于两个操作数之间 代码： 主要是caculate方法的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142import java.util.Iterator;class Stack&lt;T&gt; implements Iterable&lt;T&gt;&#123; //记录首节点 private Node head; //栈中元素个数 private int N; private class Node&#123; public T item; public Node next; public Node(T item,Node next) &#123; this.item=item; this.next=next; &#125; &#125; public Stack() &#123; //初始化首节点 this.head=new Node(null,null); //初始化栈元素个数 this.N=0; &#125; //判断当前栈中的元素个数是否为零 public boolean isEmpty() &#123; return N==0; &#125; //获取栈中元素的个数 public int size() &#123; return N; &#125; //将t元素压入栈 public void push(T t) &#123; //创建一个新结点，将新结点插入到首节点和下一个结点之间 Node newNode=new Node(t,head.next); head.next=newNode; N++; &#125; //弹栈 public T pop() &#123; //找到首节点指向第一个结点 Node old=head.next; //如果栈中没有元素 if(old==null) &#123; return null; &#125; //让首节点直接连要删除结点后面一个节点 head.next=head.next.next; //元素个数减一 N--; //返回那个被弹出的结点 return old.item; &#125; @Override public Iterator&lt;T&gt; iterator() &#123; return new SIterator(); &#125; private class SIterator implements Iterator&#123; private Node n; public SIterator() &#123; this.n=head; &#125; @Override public boolean hasNext() &#123; return n.next!=null; &#125; @Override public Object next() &#123; n=n.next; return n.item; &#125; &#125; &#125;public class Main &#123;public static void main(String[] args) &#123;//中缀表达式3*（17-15）+18/6的逆波兰表达式如下String[] notation = &#123;&quot;3&quot;, &quot;17&quot;, &quot;15&quot;, &quot;-&quot;, &quot;*&quot;,&quot;18&quot;, &quot;6&quot;,&quot;/&quot;,&quot;+&quot;&#125;;int result = caculate(notation);System.out.println(&quot;逆波兰表达式的结果为：&quot;+result);&#125;public static int caculate(String[] notaion)&#123;//定义一个栈，用来存储操作数Stack&lt;Integer&gt; stack=new Stack&lt;&gt;();//从左往右遍历逆波兰表达式，得到每一个元素 for(int i=0;i&lt;notaion.length;i++) &#123; String curr=notaion[i]; //3.判断该字符串是不是运算符，如果不是，把该该操作数压入oprands栈中 Integer o1; Integer o2; Integer result; switch (curr) &#123; case &quot;+&quot;: //4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2 o1 =stack.pop(); o2 = stack.pop(); //5.使用该运算符计算o1和o2，得到结果result result = o2 + o1; //6.把该结果压入oprands栈中 stack.push(result); break; case &quot;-&quot;: //4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2 o1 = stack.pop(); o2 = stack.pop(); //5.使用该运算符计算o1和o2，得到结果result result = o2 - o1; //6.把该结果压入oprands栈中 stack.push(result); break; case &quot;*&quot;: //4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2 o1 = stack.pop(); o2 = stack.pop(); //5.使用该运算符计算o1和o2，得到结果result result = o2 * o1; //6.把该结果压入oprands栈中 stack.push(result); break; case &quot;/&quot;: //4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2 o1 = stack.pop(); o2 = stack.pop(); //5.使用该运算符计算o1和o2，得到结果result result = o2 / o1; //6.把该结果压入oprands栈中 stack.push(result); break; default: //如果是操作数，直接压入栈中就可以 stack.push(Integer.parseInt(curr)); break; &#125;&#125; //得到栈中最后一个元素就是逆波兰表达式的结果 int result=stack.pop(); return result;&#125;&#125; 队列队列是一种基于先进先出(FIFO)的数据结构，是一种只能在一端进行插入,在另一端进行删除操作的特殊线性表，它 按照先进先出的原则存储数据，先进入的数据，在读取数据时先读被读出来。 构造方法 ：Queue()：创建Queue对象 成员变量：1.private Node head:记录首结点 ​ 2.private int N:当前栈的元素个数 ​ 3.private Node last:记录最后一个结点 成员方法：1.public boolean isEmpty()：判断队列是否为空，是返回true，否返回false ​ 2.public int size():获取队列中元素的个数 ​ 3.public T dequeue():从队列中拿出一个元素 ​ 4.public void enqueue(T t)：往队列中插入一个元素 成员内部类：private class Node 队列的API 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import java.util.Iterator;class Queue&lt;T&gt; implements Iterable&lt;T&gt;&#123; //记录首节点 private Node head; //记录最后一个结点 private Node last; //记录队列中元素的个数 private int N; private class Node&#123; public T item; public Node next; public Node(T item,Node next) &#123; this.item=item; this.next=next; &#125; &#125; public Queue() &#123; this.head=new Node(null,null); this.last=null; this.N=0; &#125; //判断当前队列是否为空 public boolean isEmpty() &#123; return N==0; &#125; //返回队列中元素的个数 public int size() &#123; return N; &#125; //像队列中插入元素t public void enqueue(T t) &#123; //当前尾节点为null if(last==null) &#123; last=new Node(t,null); head.next=last; &#125; else &#123; //当前尾节点不为null //创建新结点 Node oldlast=last; Node newNode =new Node(t,null); //将新结点设置为尾节点 last=newNode; //将原本的尾节点指向新结点 oldlast.next=last; &#125; //元素个数加一 N++; &#125; //从队列中拿出一个元素 public T dequeue() &#123; if(isEmpty()) &#123; return null; &#125; //保留原本第一个 Node oldfirst=head.next; //头节点直接指向原本第二个 head.next=oldfirst.next; N--; //如果队列中的元素删除完了，需要重置last=null if(isEmpty()) &#123; last=null; &#125; //返回原本第一个 return oldfirst.item; &#125; @Override public Iterator&lt;T&gt; iterator() &#123; return new SIterator(); &#125; private class SIterator implements Iterator&#123; private Node n; public SIterator() &#123; this.n=head; &#125; @Override public boolean hasNext() &#123; return n.next!=null; &#125; @Override public Object next() &#123; n=n.next; return n.item; &#125; &#125; &#125; 测试： 123456789101112131415161718192021public class Main&#123;public static void main(String []args) &#123; //创建队列对象 Queue&lt;String&gt; queue=new Queue&lt;String&gt;(); //测试队列中的enqueue方法 queue.enqueue(&quot;a&quot;); queue.enqueue(&quot;b&quot;); queue.enqueue(&quot;c&quot;); queue.enqueue(&quot;d&quot;); for(String s:queue) &#123; System.out.println(s); &#125; System.out.println(&quot;--------------------------------------------------&quot;); //调试队列的dequeue方法 String result=queue.dequeue(); System.out.println(result); System.out.println(queue.size());&#125;&#125;​ 符号表符号表最主要的目的就是将一个键和一个值联系起来，符号表能够存储的数据元素是一个键和一个值共同组成的键值对数据，我们可以根据键来查找对应的值 符号表中，键要有唯一性 符号表的API设计 结点类： 构造方法 Node(Key key,Value value,Node next)：创建Node对象 成员变量 1.public Key key:存储键 ​ 2.public Value value:存储值 ​ 3.public Node next:存储下一个结点 符号表的API SymbolTable() 构造方法 SymbolTable()：创建SymbolTable对象 成员方法 1.public Value get(Key key)：根据键key，找对应的值 ​ 2.public void put(Key key,Value val):向符号表中插入一个键值对 ​ 3.public void delete(Key key):删除键为key的键值对 ​ 4.public int size()：获取符号表的大小 成员变量 1.private Node head:记录首结点 2.private int N:记录符号表中键值对的个数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879 class Symboltable&lt;Key,Value&gt;&#123; //记录首结点 private Node head; //记录符号表中元素的个数 private int N; private class Node&#123; //键 public Key key; //值 public Value value; //下一个结点 public Node next; public Node(Key key,Value value,Node next) &#123; this.key=key; this.value=value; this.next=next; &#125; &#125; public Symboltable() &#123; //初始化 this.head=new Node(null,null,null); this.N=0; &#125; //获取符号表中键值对的个数 public int size() &#123; return N; &#125; //往符号表中插入键值对 public void put(Key key,Value value) &#123; //符号表中已经存在键为key的键值对，那么只需要找到该结点，替换值value Node n=head; while(n.next!=null) &#123; n=n.next; if(n.key.equals(key)) &#123; n.value=value; return; &#125; &#125; //如果符号表中不存在键为key的键值对，只需要创建新的结点，保存要插入的键值对，把新结点插入到链表的头部 head.next=新结点即可 Node newNode=new Node(key,value,null); Node oldfirst=head.next; newNode.next=oldfirst; head.next=newNode; //数据元素加一 N++; &#125; //删除符号表中键为key的键值对 public void delete(Key key) &#123; Node n=head; while(n.next!=null) &#123; //判断一下n的下一个结点的key是否符合,这样可以更好的获得符合条件的结点的上一个结点 if(n.next.key.equals(key)) &#123; n.next=n.next.next; N--; return; &#125; n=n.next; &#125; &#125; public Value get(Key key) &#123; Node n=head; //找到符合条件的结点返回它的value值 while(n.next!=null) &#123; n=n.next; if(n.key.equals(key)) &#123; return n.value; &#125; &#125; return null; &#125;&#125; 测试： 12345678910111213141516171819202122class Main&#123; public static void main(String[] args) &#123; //创建符号表对象 Symboltable&lt;Integer,String&gt; symboltable=new Symboltable&lt;Integer,String&gt;(); //测试put方法（插入，替换） symboltable.put(1, &quot;乔峰&quot;); symboltable.put(2, &quot;虚竹&quot;); symboltable.put(3, &quot;段餐&quot;); System.out.println(&quot;插入完毕以后，元素的个数为&quot;+symboltable.size()); symboltable.put(2, &quot;慕容夫&quot;); System.out.println(&quot;替换之后元素个数&quot;+symboltable.size()); //测试get方法 System.out.println(symboltable.get(2)); //测试删除方法 symboltable.delete(2); System.out.println(&quot;删除完毕之后元素个数&quot;+symboltable.size()); &#125; &#125; 有序符号表主要是put方法的改变 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 class OrderSymboltable&lt;Key extends Comparable&lt;Key&gt;,Value&gt;&#123; //记录首结点 private Node head; //记录符号表中元素的个数 private int N; private class Node&#123; //键 public Key key; //值 public Value value; //下一个结点 public Node next; public Node(Key key,Value value,Node next) &#123; this.key=key; this.value=value; this.next=next; &#125; &#125; public OrderSymboltable() &#123; //初始化 this.head=new Node(null,null,null); this.N=0; &#125; //获取符号表中键值对的个数 public int size() &#123; return N; &#125; //往符号表中插入键值对,并根据key排序 public void put(Key key,Value value) &#123;//定义两个Node变量，分别记录当前结点和当前结点的上一个结点 Node curr=head.next; Node pre=head; //如果节点不为空且要插入key大于当前结点的key就往后走 while(curr!=null&amp;&amp;key.compareTo(curr.key)&gt;=0) &#123; //都向后移一位，方便之后插入的时候连接 pre=curr; curr=curr.next; &#125; //如果当前结点curr的键和要插入的Key一样，替换 if(curr!=null&amp;&amp;key.compareTo(curr.key)==0) &#123; curr.value=value; return ; &#125; //如果当前结点curr键和要插入的key不一样，把新的结点插入到curr之前 Node newNode=new Node(key,value,curr); pre.next=newNode; //元素的个数加一 N++; &#125; //删除符号表中键为key的键值对 public void delete(Key key) &#123; Node n=head; while(n.next!=null) &#123; //判断一下n的下一个结点的key是否符合,这样可以更好的获得符合条件的结点的上一个结点 if(n.next.key.equals(key)) &#123; n.next=n.next.next; N--; return; &#125; n=n.next; &#125; &#125; public Value get(Key key) &#123; Node n=head; //找到符合条件的结点返回它的value值 while(n.next!=null) &#123; n=n.next; if(n.key.equals(key)) &#123; return n.value; &#125; &#125; return null; &#125;&#125; 测试： 123456789101112131415class Main&#123; public static void main(String[] args) &#123; //创建符号表对象 OrderSymboltable&lt;Integer,String&gt; table=new OrderSymboltable&lt;Integer,String&gt;(); //测试put方法（插入，替换） table.put(1, &quot;张三&quot;); table.put(2, &quot;李四&quot;); table.put(4, &quot;赵六&quot;); table.put(7, &quot;七&quot;); table.put(3,&quot;王五&quot;); &#125; &#125; 树之前我们实现的符号表中，不难看出，符号表的增删查操作，随着元素个数N的增多，其耗时也是线性增多的，时 间复杂度都是O(n),为了提高运算效率，接下来我们学习树这种数据结构。 树由有限结点组成的具有层次关系的集合 用数组来实现树天生查询快，可以改善增删慢 用链表来实现树天生增删快，可以改善查询慢 树具有以下特点： 1.每个结点有零个或多个子结点； ​ 2.没有父结点的结点为根结点； ​ 3.每一个非根结点只有一个父结点； ​ 4.每个结点及其后代结点整体上可以看做是一棵树，称为当前结点的父结点的一个子树；（一个结点也可以称之为子树，就是E有两个子树两个度） 结点的度： 一个结点含有的子树的个数称为该结点的度； 叶结点： 度为0的结点称为叶结点，也可以叫做终端结点 分支结点： 度不为0的结点称为分支结点，也可以叫做非终端结点 结点的层次： 从根结点开始，根结点的层次为1，根的直接后继层次为2，以此类推 结点的层序编号：将树中的结点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数 树的度： 树中所有结点的度的最大值 **树的高度(深度)**： 树中结点的最大层次 森林： m（m&gt;&#x3D;0）个互不相交的树的集合，将一颗非空树的根结点删去，树就变成一个森林；给森林增加一个统一的根 结点，森林就变成一棵树 孩子结点： 一个结点的直接后继结点称为该结点的孩子结点 **双亲结点(父结点)**： 一个结点的直接前驱称为该结点的双亲结点 兄弟结点： 同一双亲结点的孩子结点间互称兄弟结点 二叉树二叉树就是度不超过2的树(每个结点最多有两个子结点) 满二叉树 一个二叉树，如果每一个层的结点树都达到最大值，则这个二叉树就是满二叉树。 完全二叉树： 叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树 完全二叉树就是先把该层从左到右都放满才会放下一层 二叉查找树的创建用链表设计一个二叉查找树 二叉查找树是左子节点大于根节点小于右子节点 结点类：类名Node&lt;Key,Value&gt; 构造方法 Node(Key key, Value value, Node left, Node right)：创建Node对象 成员变量：1.public Node left:记录左子结点 ​ 2.public Node right:记录右子结点 （因为度最大为二所以只有左右子节点即可） ​ 3.public Key key:存储键 ​ 4.public Value value:存储值 二叉查找树的API设计 类名:BinaryTree&lt;Key extends Comparable,Value value&gt; key继承Comparable是为了排序 构造方法 BinaryTree()：创建BinaryTree对象 成员变量 1.private Node root:记录根结点 ​ 2.private int N:记录树中元素的个数 成员方法 1.public void put(Key key,Value value):向树中插入一个键值对 2.private Node put(Node x, Key key, Value val)：给指定树x上，添加键一个键值对，并返回添 加后的新树 3.public Value get(Key key):根据key，从树中找出对应的值 4.private Value get(Node x, Key key):从指定的树x中，找出key对应的值 5.public void delete(Key key):根据key，删除树中对应的键值对 6.private Node delete(Node x, Key key):删除指定树x上的键为key的键值对，并返回删除后的 新树 7.public int size():获取树中元素的个数 插入方法put实现思想： 1.如果当前树中没有任何一个结点，则直接把新结点当做根结点使用 2.如果当前树不为空，则从根结点开始： 2.1如果新结点的key小于当前结点的key，则继续找当前结点的左子结点； 2.2如果新结点的key大于当前结点的key，则继续找当前结点的右子结点； 2.3如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。 查询方法的get实现思想： 从根节点开始： 1.如果要查询的key小于当前结点的key，则继续找当前结点的左子结点； ​ 2.如果要查询的key大于当前结点的key，则继续找当前结点的右子结点； ​ 3.如果要查询的key等于当前结点的key，则树中返回当前结点的value。 删除方法delete的实现思想 1.找到被删除结点； 2.找到被删除结点右子树中的最小结点minNode （右子树中最左最下的） 3.删除右子树中的最小结点 4.让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子树 5.让被删除结点的父节点指向最小结点minNode 代码API实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144public class BinaryTree&lt;Key extends Comparable&lt;Key&gt;,Value&gt; &#123;//记录根结点private Node root;//记录树中元素个数private int N;private class Node&#123; //存储键 public Key key; //存储值 public Value value; //记录左子节点 public Node left; //记录右子节点 public Node right; public Node(Key key,Value value,Node left,Node right) &#123; this.key=key; this.value=value; this.right=right; this.left=left; &#125;&#125;//获取树中元素的个数public int size() &#123; return N;&#125;//向树中添加元素key-valuepublic void put(Key key,Value value) &#123; root=put(root,key,value);&#125;//向指定的树中添加key-value，并返回添加元素后的新树public Node put(Node x,Key key,Value value) &#123; //x子树为空 if(x==null) &#123; N++; return new Node(key,value,null,null); &#125; //如果x子树不为空 //比较x结点的键和key的大小 int cmp=key.compareTo(x.key); if(cmp&gt;0) &#123; //如果key大于x结点的键，则继续找x结点右子树 x.right=put(x.right,key,value); &#125; else if(cmp&lt;0) &#123; //如果key小于x节点的键，则继续找x结点的左子树 x.left=put(x.left,key,value); &#125; else &#123; //如果key等于x结点的键，则替换value x.value=value; &#125; return x;&#125;//查询树中指定key对应的valuepublic Value get(Key key) &#123; return get(root,key);&#125;//从指定的树x中，查找key对应的值public Value get(Node x,Key key) &#123; //x树为null if(x==null) &#123; return null; &#125; //x树不为null //比较key和x结点键的大小 int cmp=key.compareTo(x.key); if(cmp&gt;0) &#123; //如果key大于x结点的键，则继续找x结点右子树 return get(x.right,key); &#125; else if(cmp&lt;0) &#123; //如果key小于x节点的键，则继续找x结点的左子树 return get(x.left,key); &#125; else &#123; //如果key等于x结点的键，就找到了key的结点，只需要返回x结点的值即可 return x.value; &#125;&#125;//删除树中key对应的value值public void delete(Key key) &#123; delete(root,key);&#125;//删除指定树x中的key所对应的value，并返回删除后的新树public Node delete(Node x,Key key) &#123; //x树为null if(x==null) &#123; return null; &#125; //x树不为null //比较key和x结点键的大小 int cmp=key.compareTo(x.key); if(cmp&gt;0) &#123; //如果key大于x结点的键，则继续找x结点右子树 x.right=delete(x.right,key); &#125; else if(cmp&lt;0) &#123; //如果key小于x节点的键，则继续找x结点的左子树 x.left=delete(x.left,key); &#125; else &#123; //得找到x结点右子树中最小的结点 if(x.right==null) &#123; return x.left;//因为是递归所以这个返回值之后在上面会自动给那个被删除结点的父节点 &#125; if(x.left==null) &#123; return x.right;//因为是递归所以这个返回值之后在上面会自动给那个被删除结点的父节点 &#125; Node minNode=x.right; while(minNode.left!=null) &#123; minNode=minNode.left; &#125; //删除右子树中的最小结点 Node n=x.right; while(n.left!=null) &#123; //如果n结点的下一个的下一个是空，就将n结点的下一个设为null if(n.left.left==null) &#123; n.left=null; &#125; else &#123; //变换n结点即可 n=n.left; &#125; &#125; //让最小结点为被删结点左右结点的父结点 minNode.right=x.right; minNode.left=x.left; //被删结点的父结点为minNode的父节点 x=minNode; //让元素个数减一 N--; &#125; return x;//因为是递归所以这个返回值为x也就是minNode之后在上面会自动给那个被删除结点的父节点，到最后返回的就是删除后的新树&#125;&#125; 测试： 12345678910111213141516171819public class testTree &#123; public static void main(String[] args) &#123; //创建二叉查找对象 BinaryTree&lt;Integer,String&gt; tree=new BinaryTree&lt;&gt;(); //测试插入 tree.put(1,&quot;张三&quot;); tree.put(2, &quot;李四&quot;); tree.put(3, &quot;王五&quot;); System.out.println(&quot;插入完毕后元素个数&quot;+tree.size()); //测试获取 System.out.println(&quot;键对应的元素是&quot;+tree.get(2)); //测试删除 tree.delete(3); System.out.println(&quot;删除后元素的个数&quot;+tree.size()); System.out.println(&quot;删除后键3对应的元素&quot;+tree.get(3)); &#125;&#125; 查找二叉树中的最小键和最大键 重点是两个min()方法和两个max()方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173public class BinaryTree&lt;Key extends Comparable&lt;Key&gt;,Value&gt; &#123;//记录根结点private Node root;//记录树中元素个数private int N;private class Node&#123; //存储键 public Key key; //存储值 public Value value; //记录左子节点 public Node left; //记录右子节点 public Node right; public Node(Key key,Value value,Node left,Node right) &#123; this.key=key; this.value=value; this.right=right; &#125;&#125;//获取树中元素的个数public int size() &#123; return N;&#125;//向树中添加元素key-valuepublic void put(Key key,Value value) &#123; root=put(root,key,value);&#125;//向指定的树中添加key-value，并返回添加元素后的新树public Node put(Node x,Key key,Value value) &#123; //x子树为空 if(x==null) &#123; N++; return new Node(key,value,null,null); &#125; //如果x子树不为空 //比较x结点的键和key的大小 int cmp=key.compareTo(x.key); if(cmp&gt;0) &#123; //如果key大于x结点的键，则继续找x结点右子树 x.right=put(x.right,key,value); &#125; else if(cmp&lt;0) &#123; //如果key小于x节点的键，则继续找x结点的左子树 x.left=put(x.left,key,value); &#125; else &#123; //如果key等于x结点的键，则替换value x.value=value; &#125; return x;&#125;//查询树中指定key对应的valuepublic Value get(Key key) &#123; return get(root,key);&#125;//从指定的树x中，查找key对应的值public Value get(Node x,Key key) &#123; //x树为null if(x==null) &#123; return null; &#125; //x树不为null //比较key和x结点键的大小 int cmp=key.compareTo(x.key); if(cmp&gt;0) &#123; //如果key大于x结点的键，则继续找x结点右子树 return get(x.right,key); &#125; else if(cmp&lt;0) &#123; //如果key小于x节点的键，则继续找x结点的左子树 return get(x.left,key); &#125; else &#123; //如果key等于x结点的键，就找到了key的结点，只需要返回x结点的值即可 return x.value; &#125;&#125;//删除树中key对应的value值public void delete(Key key) &#123; delete(root,key);&#125;//删除指定树x中的key所对应的value，并返回删除后的新树public Node delete(Node x,Key key) &#123; //x树为null if(x==null) &#123; return null; &#125; //x树不为null //比较key和x结点键的大小 int cmp=key.compareTo(x.key); if(cmp&gt;0) &#123; //如果key大于x结点的键，则继续找x结点右子树 x.right=delete(x.right,key); &#125; else if(cmp&lt;0) &#123; //如果key小于x节点的键，则继续找x结点的左子树 x.left=delete(x.left,key); &#125; else &#123; //让元素个数减一 N--; //得找到x结点右子树中最小的结点 if(x.right==null) &#123; return x.left;//因为是递归所以这个返回值之后在上面会自动给那个被删除结点的父节点 &#125; if(x.left==null) &#123; return x.right;//因为是递归所以这个返回值之后在上面会自动给那个被删除结点的父节点 &#125; Node minNode=x.right; while(minNode.left!=null) &#123; minNode=minNode.left; &#125; //删除右子树中的最小结点 Node n=x.right; while(n.left!=null) &#123; //如果n结点的下一个的下一个是空，就将n结点的下一个设为null if(n.left.left==null) &#123; n.left=null; &#125; else &#123; //变换n结点即可 n=n.left; &#125; &#125; //让最小结点为被删结点左右结点的父结点 minNode.right=x.right; minNode.left=x.left; //被删结点的父结点为minNode的父节点 x=minNode; &#125; return x;//因为是递归所以这个返回值为x也就是minNode之后在上面会自动给那个被删除结点的父节点，到最后返回的就是删除后的新树&#125;//找出整个树中找出最小的键public Key min() &#123; return min(root).key;&#125;//查找指定树x中找出最小键所在的结点public Node min(Node x) &#123; if(x.left!=null) &#123; return min(x.left); &#125; else &#123; return x; &#125;&#125;//找出整个树中最大的键public Key max() &#123; return max(root).key;&#125;//查找指定树中的最大键public Node max(Node x) &#123; if(x.right!=null) &#123; return min(x.right); &#125; else &#123; return x; &#125;&#125;&#125; 测试： 12345678910111213141516public class testTree &#123; public static void main(String[] args) &#123; //创建二叉查找对象 BinaryTree&lt;Integer,String&gt; tree=new BinaryTree&lt;&gt;(); //测试插入 tree.put(1,&quot;张三&quot;); tree.put(2, &quot;李四&quot;); tree.put(3, &quot;王五&quot;);System.out.println(tree.min());System.out.println(tree.max()); &#125;&#125;结果：1，2 不知道为什么最大值弄不出来 二叉树的基础遍历 1.前序遍历； 先访问根结点，然后再访问左子树，最后访问右子树 前序遍历 public Queue preErgodic()：使用前序遍历，获取整个树中的所有键 private void preErgodic(Node x,Queue keys)：使用前序遍历，把指定树x中的所有键放入到keys队列中 实现过程中，我们通过前序遍历，把,把每个结点的键取出，放入到队列中返回即可。 12345678910111213141516171819202122//获取整个树中的所有键public Queue&lt;Key&gt; preErgodic()&#123; Queue&lt;Key&gt; keys=new Queue&lt;Key&gt;(); preErgodic(root,keys); return keys;&#125;//获取指定树所有的键放到keysprivate void preErgodic(Node x,Queue&lt;Key&gt; keys) &#123; if(x==null) &#123; return; &#125; //把x结点的key放入到keys中 keys.enqueue(x.key); //递归遍历x结点的左子树 if(x.left!=null) &#123; preErgodic(x.left,keys); &#125; //递归遍历x结点的右子树 if(x.right!=null) &#123; preErgodic(x.right,keys); &#125;&#125; 2.中序遍历； 先访问左子树，中间访问根节点，最后访问右子树 中序遍历 123456789101112131415161718192021public Queue&lt;Key&gt; midErgodic()&#123; Queue&lt;Key&gt; keys=new Queue&lt;Key&gt;(); midErgodic(root,keys); return keys;&#125;private void midErgodic(Node x,Queue&lt;Key&gt; keys) &#123; if(x==null) &#123; return; &#125; //递归遍历x结点的左子树 if(x.left!=null) &#123; midErgodic(x.left,keys); &#125; //把x结点的key放入到keys中 keys.enqueue(x.key); //递归遍历x结点的右子树 if(x.right!=null) &#123; midErgodic(x.right,keys); &#125;&#125; 3.后序遍历； 先访问左子树，再访问右子树，最后访问根节点 12345678910111213141516private void lastErgodic(Node x,Queue&lt;Key&gt; keys) &#123; if(x==null) &#123; return; &#125; //递归遍历x结点的左子树 if(x.left!=null) &#123; lastErgodic(x.left,keys); &#125; //递归遍历x结点的右子树 if(x.right!=null) &#123; lastErgodic(x.right,keys); &#125; //把x结点的key放入到keys中 keys.enqueue(x.key); &#125; 二叉树的层序遍历 所谓的层序遍历，就是从根节点开始依次向下，获取每一层所有结点的值（从左到右） 弹出一个的时候要判断弹出的这个结点有没有左子节点和右子节点按照先左后右的顺序去判断 代码： 12345678910111213141516171819202122232425//层序遍历public Queue&lt;Key&gt; layerErgodic()&#123; //定义两个队列，分别存储树中的键和树中的结点 Queue&lt;Key&gt; keys=new Queue&lt;&gt;(); Queue&lt;Node&gt; nodes=new Queue&lt;&gt;(); //默认往结点队列中放入根节点 nodes.enqueue(root); while(!nodes.isEmpty()) &#123; //从队列中弹出一个结点 Node n=nodes.dequeue(); keys.enqueue(n.key); //判断当前结点有没有左子节点，有则放入nodes中 if(n.left!=null) &#123; nodes.enqueue(n.left); &#125; //判断当前结点有没有右子节点，有则放入nodes中 if(n.right!=null) &#123; nodes.enqueue(n.right); &#125; &#125; return keys;&#125; 包含全部遍历的API 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274public class BinaryTree&lt;Key extends Comparable&lt;Key&gt;,Value&gt; &#123;//记录根结点private Node root;//记录树中元素个数private int N;private class Node&#123; //存储键 public Key key; //存储值 public Value value; //记录左子节点 public Node left; //记录右子节点 public Node right; public Node(Key key,Value value,Node left,Node right) &#123; this.key=key; this.value=value; this.right=right; &#125;&#125;//获取树中元素的个数public int size() &#123; return N;&#125;//向树中添加元素key-valuepublic void put(Key key,Value value) &#123; root=put(root,key,value);&#125;//向指定的树中添加key-value，并返回添加元素后的新树public Node put(Node x,Key key,Value value) &#123; //x子树为空 if(x==null) &#123; N++; return new Node(key,value,null,null); &#125; //如果x子树不为空 //比较x结点的键和key的大小 int cmp=key.compareTo(x.key); if(cmp&gt;0) &#123; //如果key大于x结点的键，则继续找x结点右子树 x.right=put(x.right,key,value); &#125; else if(cmp&lt;0) &#123; //如果key小于x节点的键，则继续找x结点的左子树 x.left=put(x.left,key,value); &#125; else &#123; //如果key等于x结点的键，则替换value x.value=value; &#125; return x;&#125;//查询树中指定key对应的valuepublic Value get(Key key) &#123; return get(root,key);&#125;//从指定的树x中，查找key对应的值public Value get(Node x,Key key) &#123; //x树为null if(x==null) &#123; return null; &#125; //x树不为null //比较key和x结点键的大小 int cmp=key.compareTo(x.key); if(cmp&gt;0) &#123; //如果key大于x结点的键，则继续找x结点右子树 return get(x.right,key); &#125; else if(cmp&lt;0) &#123; //如果key小于x节点的键，则继续找x结点的左子树 return get(x.left,key); &#125; else &#123; //如果key等于x结点的键，就找到了key的结点，只需要返回x结点的值即可 return x.value; &#125;&#125;//删除树中key对应的value值public void delete(Key key) &#123; delete(root,key);&#125;//删除指定树x中的key所对应的value，并返回删除后的新树public Node delete(Node x,Key key) &#123; //x树为null if(x==null) &#123; return null; &#125; //x树不为null //比较key和x结点键的大小 int cmp=key.compareTo(x.key); if(cmp&gt;0) &#123; //如果key大于x结点的键，则继续找x结点右子树 x.right=delete(x.right,key); &#125; else if(cmp&lt;0) &#123; //如果key小于x节点的键，则继续找x结点的左子树 x.left=delete(x.left,key); &#125; else &#123; //让元素个数减一 N--; //得找到x结点右子树中最小的结点 if(x.right==null) &#123; return x.left;//因为是递归所以这个返回值之后在上面会自动给那个被删除结点的父节点 &#125; if(x.left==null) &#123; return x.right;//因为是递归所以这个返回值之后在上面会自动给那个被删除结点的父节点 &#125; Node minNode=x.right; while(minNode.left!=null) &#123; minNode=minNode.left; &#125; //删除右子树中的最小结点 Node n=x.right; while(n.left!=null) &#123; //如果n结点的下一个的下一个是空，就将n结点的下一个设为null if(n.left.left==null) &#123; n.left=null; &#125; else &#123; //变换n结点即可 n=n.left; &#125; &#125; //让最小结点为被删结点左右结点的父结点 minNode.right=x.right; minNode.left=x.left; //被删结点的父结点为minNode的父节点 x=minNode; &#125; return x;//因为是递归所以这个返回值为x也就是minNode之后在上面会自动给那个被删除结点的父节点，到最后返回的就是删除后的新树&#125;//找出整个树中找出最小的键public Key min() &#123; return min(root).key;&#125;//查找指定树x中找出最小键所在的结点public Node min(Node x) &#123; if(x.left!=null) &#123; return min(x.left); &#125; else &#123; return x; &#125;&#125;//找出整个树中最大的键public Key max() &#123; return max(root).key;&#125;//查找指定树中的最大键public Node max(Node x) &#123; if(x.right!=null) &#123; return min(x.right); &#125; else &#123; return x; &#125;&#125;//前序遍历//获取整个树中的所有键public Queue&lt;Key&gt; preErgodic()&#123; Queue&lt;Key&gt; keys=new Queue&lt;Key&gt;(); preErgodic(root,keys); return keys;&#125;//获取指定树所有的键放到keysprivate void preErgodic(Node x,Queue&lt;Key&gt; keys) &#123; if(x==null) &#123; return; &#125; //把x结点的key放入到keys中 keys.enqueue(x.key); //递归遍历x结点的左子树 if(x.left!=null) &#123; preErgodic(x.left,keys); &#125; //递归遍历x结点的右子树 if(x.right!=null) &#123; preErgodic(x.right,keys); &#125;&#125; public Queue&lt;Key&gt; midErgodic()&#123; Queue&lt;Key&gt; keys=new Queue&lt;Key&gt;(); midErgodic(root,keys); return keys;&#125;//中序遍历private void midErgodic(Node x,Queue&lt;Key&gt; keys) &#123; if(x==null) &#123; return; &#125; //递归遍历x结点的左子树 if(x.left!=null) &#123; midErgodic(x.left,keys); &#125; //把x结点的key放入到keys中 keys.enqueue(x.key); //递归遍历x结点的右子树 if(x.right!=null) &#123; midErgodic(x.right,keys); &#125;&#125;//后序遍历public Queue&lt;Key&gt; lastErgodic()&#123; Queue&lt;Key&gt; keys=new Queue&lt;Key&gt;(); lastErgodic(root,keys); return keys;&#125;private void lastErgodic(Node x,Queue&lt;Key&gt; keys) &#123; if(x==null) &#123; return; &#125; //递归遍历x结点的左子树 if(x.left!=null) &#123; lastErgodic(x.left,keys); &#125; //递归遍历x结点的右子树 if(x.right!=null) &#123; lastErgodic(x.right,keys); &#125; //把x结点的key放入到keys中 keys.enqueue(x.key); &#125;//层序遍历public Queue&lt;Key&gt; layerErgodic()&#123; //定义两个队列，分别存储树中的键和树中的结点 Queue&lt;Key&gt; keys=new Queue&lt;&gt;(); Queue&lt;Node&gt; nodes=new Queue&lt;&gt;(); //默认往结点队列中放入根节点 nodes.enqueue(root); while(!nodes.isEmpty()) &#123; //从队列中弹出一个结点 Node n=nodes.dequeue(); keys.enqueue(n.key); //判断当前结点有没有左子节点，有则放入nodes中 if(n.left!=null) &#123; nodes.enqueue(n.left); &#125; //判断当前结点有没有右子节点，有则放入nodes中 if(n.right!=null) &#123; nodes.enqueue(n.right); &#125; &#125; return keys;&#125;&#125; 测试： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class testTree &#123; public static void main(String[] args) &#123; //创建二叉查找对象 BinaryTree&lt;String,String&gt; tree=new BinaryTree&lt;&gt;(); tree.put(&quot;E&quot;, &quot;5&quot;); tree.put(&quot;B&quot;, &quot;2&quot;); tree.put(&quot;G&quot;, &quot;7&quot;); tree.put(&quot;A&quot;, &quot;1&quot;); tree.put(&quot;D&quot;, &quot;4&quot;); tree.put(&quot;F&quot;, &quot;6&quot;); tree.put(&quot;H&quot;, &quot;8&quot;); tree.put(&quot;C&quot;, &quot;3&quot;); //前序遍历 Queue&lt;String&gt; keys=tree.preErgodic(); for(String key:keys) &#123; String value=tree.get(key); System.out.println(key+&quot;----&quot;+value); &#125; System.out.println(&quot;-----------------------------------&quot;); //中序遍历 Queue&lt;String&gt; key1s=tree.midErgodic(); for(String key:key1s) &#123; String value=tree.get(key); System.out.println(key+&quot;----&quot;+value); &#125; System.out.println(&quot;-----------------------------------&quot;); //后序遍历 Queue&lt;String&gt; key2s=tree.lastErgodic(); for(String key:key2s) &#123; String value=tree.get(key); System.out.println(key+&quot;----&quot;+value); &#125; System.out.println(&quot;-----------------------------------&quot;); //层序遍历 Queue&lt;String&gt; key3s=tree.layerErgodic(); for(String key:key3s) &#123; String value=tree.get(key); System.out.println(key+&quot;----&quot;+value); &#125; &#125;&#125; 二叉树的最大深度问题分别计算左右子树的最大深度然后再加一就是整个子树的最大深度 代码API 123456789101112131415161718192021222324252627282930//计算整个树的最大深度public int maxDepth() &#123; return maxDepth(root);&#125;//获取指定树x的最大深度public int maxDepth(Node x) &#123; if(x==null) &#123; return 0; &#125; int max=0;//这是x的最大深度 int maxl=0;//这是x的左子树的最大深度 int maxR=0;//这是x的右子树的最大深度 //计算x结点左子树的最大深度 if(x.left!=null) &#123; maxl=maxDepth(x.left); &#125; //计算x结点右子树最大深度 if(x.right!=null) &#123; maxR=maxDepth(x.right); &#125; //比较左子树最大深度和右子树最大深度，取较大值+1即可 max=maxl&gt;maxR?maxl+1:maxR+1; return max;&#125; 测试： 1234567891011121314151617public class testTree &#123; public static void main(String[] args) &#123; //创建二叉查找对象 BinaryTree&lt;String,String&gt; tree=new BinaryTree&lt;&gt;(); tree.put(&quot;E&quot;, &quot;5&quot;); tree.put(&quot;B&quot;, &quot;2&quot;); tree.put(&quot;G&quot;, &quot;7&quot;); tree.put(&quot;A&quot;, &quot;1&quot;); tree.put(&quot;D&quot;, &quot;4&quot;); tree.put(&quot;F&quot;, &quot;6&quot;); tree.put(&quot;H&quot;, &quot;8&quot;); tree.put(&quot;C&quot;, &quot;3&quot;);System.out.println(tree.maxDepth());&#125;&#125; 总的API 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302public class BinaryTree&lt;Key extends Comparable&lt;Key&gt;,Value&gt; &#123;//记录根结点private Node root;//记录树中元素个数private int N;private class Node&#123; //存储键 public Key key; //存储值 public Value value; //记录左子节点 public Node left; //记录右子节点 public Node right; public Node(Key key,Value value,Node left,Node right) &#123; this.key=key; this.value=value; this.right=right; &#125;&#125;//获取树中元素的个数public int size() &#123; return N;&#125;//向树中添加元素key-valuepublic void put(Key key,Value value) &#123; root=put(root,key,value);&#125;//向指定的树中添加key-value，并返回添加元素后的新树public Node put(Node x,Key key,Value value) &#123; //x子树为空 if(x==null) &#123; N++; return new Node(key,value,null,null); &#125; //如果x子树不为空 //比较x结点的键和key的大小 int cmp=key.compareTo(x.key); if(cmp&gt;0) &#123; //如果key大于x结点的键，则继续找x结点右子树 x.right=put(x.right,key,value); &#125; else if(cmp&lt;0) &#123; //如果key小于x节点的键，则继续找x结点的左子树 x.left=put(x.left,key,value); &#125; else &#123; //如果key等于x结点的键，则替换value x.value=value; &#125; return x;&#125;//查询树中指定key对应的valuepublic Value get(Key key) &#123; return get(root,key);&#125;//从指定的树x中，查找key对应的值public Value get(Node x,Key key) &#123; //x树为null if(x==null) &#123; return null; &#125; //x树不为null //比较key和x结点键的大小 int cmp=key.compareTo(x.key); if(cmp&gt;0) &#123; //如果key大于x结点的键，则继续找x结点右子树 return get(x.right,key); &#125; else if(cmp&lt;0) &#123; //如果key小于x节点的键，则继续找x结点的左子树 return get(x.left,key); &#125; else &#123; //如果key等于x结点的键，就找到了key的结点，只需要返回x结点的值即可 return x.value; &#125;&#125;//删除树中key对应的value值public void delete(Key key) &#123; delete(root,key);&#125;//删除指定树x中的key所对应的value，并返回删除后的新树public Node delete(Node x,Key key) &#123; //x树为null if(x==null) &#123; return null; &#125; //x树不为null //比较key和x结点键的大小 int cmp=key.compareTo(x.key); if(cmp&gt;0) &#123; //如果key大于x结点的键，则继续找x结点右子树 x.right=delete(x.right,key); &#125; else if(cmp&lt;0) &#123; //如果key小于x节点的键，则继续找x结点的左子树 x.left=delete(x.left,key); &#125; else &#123; //让元素个数减一 N--; //得找到x结点右子树中最小的结点 if(x.right==null) &#123; return x.left;//因为是递归所以这个返回值之后在上面会自动给那个被删除结点的父节点 &#125; if(x.left==null) &#123; return x.right;//因为是递归所以这个返回值之后在上面会自动给那个被删除结点的父节点 &#125; Node minNode=x.right; while(minNode.left!=null) &#123; minNode=minNode.left; &#125; //删除右子树中的最小结点 Node n=x.right; while(n.left!=null) &#123; //如果n结点的下一个的下一个是空，就将n结点的下一个设为null if(n.left.left==null) &#123; n.left=null; &#125; else &#123; //变换n结点即可 n=n.left; &#125; &#125; //让最小结点为被删结点左右结点的父结点 minNode.right=x.right; minNode.left=x.left; //被删结点的父结点为minNode的父节点 x=minNode; &#125; return x;//因为是递归所以这个返回值为x也就是minNode之后在上面会自动给那个被删除结点的父节点，到最后返回的就是删除后的新树&#125;//找出整个树中找出最小的键public Key min() &#123; return min(root).key;&#125;//查找指定树x中找出最小键所在的结点public Node min(Node x) &#123; if(x.left!=null) &#123; return min(x.left); &#125; else &#123; return x; &#125;&#125;//找出整个树中最大的键public Key max() &#123; return max(root).key;&#125;//查找指定树中的最大键public Node max(Node x) &#123; if(x.right!=null) &#123; return min(x.right); &#125; else &#123; return x; &#125;&#125;//前序遍历//获取整个树中的所有键public Queue&lt;Key&gt; preErgodic()&#123; Queue&lt;Key&gt; keys=new Queue&lt;Key&gt;(); preErgodic(root,keys); return keys;&#125;//获取指定树所有的键放到keysprivate void preErgodic(Node x,Queue&lt;Key&gt; keys) &#123; if(x==null) &#123; return; &#125; //把x结点的key放入到keys中 keys.enqueue(x.key); //递归遍历x结点的左子树 if(x.left!=null) &#123; preErgodic(x.left,keys); &#125; //递归遍历x结点的右子树 if(x.right!=null) &#123; preErgodic(x.right,keys); &#125;&#125; public Queue&lt;Key&gt; midErgodic()&#123; Queue&lt;Key&gt; keys=new Queue&lt;Key&gt;(); midErgodic(root,keys); return keys;&#125;//中序遍历private void midErgodic(Node x,Queue&lt;Key&gt; keys) &#123; if(x==null) &#123; return; &#125; //递归遍历x结点的左子树 if(x.left!=null) &#123; midErgodic(x.left,keys); &#125; //把x结点的key放入到keys中 keys.enqueue(x.key); //递归遍历x结点的右子树 if(x.right!=null) &#123; midErgodic(x.right,keys); &#125;&#125;//后序遍历public Queue&lt;Key&gt; lastErgodic()&#123; Queue&lt;Key&gt; keys=new Queue&lt;Key&gt;(); lastErgodic(root,keys); return keys;&#125;private void lastErgodic(Node x,Queue&lt;Key&gt; keys) &#123; if(x==null) &#123; return; &#125; //递归遍历x结点的左子树 if(x.left!=null) &#123; lastErgodic(x.left,keys); &#125; //递归遍历x结点的右子树 if(x.right!=null) &#123; lastErgodic(x.right,keys); &#125; //把x结点的key放入到keys中 keys.enqueue(x.key); &#125;//层序遍历public Queue&lt;Key&gt; layerErgodic()&#123; //定义两个队列，分别存储树中的键和树中的结点 Queue&lt;Key&gt; keys=new Queue&lt;&gt;(); Queue&lt;Node&gt; nodes=new Queue&lt;&gt;(); //默认往结点队列中放入根节点 nodes.enqueue(root); while(!nodes.isEmpty()) &#123; //从队列中弹出一个结点 Node n=nodes.dequeue(); keys.enqueue(n.key); //判断当前结点有没有左子节点，有则放入nodes中 if(n.left!=null) &#123; nodes.enqueue(n.left); &#125; //判断当前结点有没有右子节点，有则放入nodes中 if(n.right!=null) &#123; nodes.enqueue(n.right); &#125; &#125; return keys;&#125;//计算整个树的最大深度public int maxDepth() &#123; return maxDepth(root);&#125;//获取指定树x的最大深度public int maxDepth(Node x) &#123; if(x==null) &#123; return 0; &#125; int max=0;//这是x的最大深度 int maxl=0;//这是x的左子树的最大深度 int maxR=0;//这是x的右子树的最大深度 //计算x结点左子树的最大深度 if(x.left!=null) &#123; maxl=maxDepth(x.left); &#125; //计算x结点右子树最大深度 if(x.right!=null) &#123; maxR=maxDepth(x.right); &#125; //比较左子树最大深度和右子树最大深度，取较大值+1即可 max=maxl&gt;maxR?maxl+1:maxR+1; return max;&#125;&#125; 二叉树的折纸问题堆1，堆是完全二叉树 2.堆通常是通过数组来实现 如果一个结点的位置为k，则它的父结点的位置为[k&#x2F;2],而它的两个子结点的位置则分别为2k和2k+1。这样，在不 使用指针的情况下，我们也可以通过计算数组的索引在树中上下移动：从a[k]向上一层，就令k等于k&#x2F;2,向下一层就 令k等于2k或2k+1。 3.每个结点都大于等于它的两个子结点。这里要注意堆中仅仅规定了每个结点大于等于它的两个子结点，但这两个 子结点的顺序并没有做规定，跟我们之前学习的二叉查找树是有区别的。 堆的API设计类名：Heap&lt;T extends Comparable&gt; 构造方法 Heap(int capacity)：创建容量为capacity的Heap对象 成员方法: 1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素 2.private void exch(int i,int j):交换堆中i索引和j索引处的值 3.public T delMax():删除堆中最大的元素,并返回这个最大元素 4.public void insert(T t)：往堆中插入一个元素 5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置 6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置 成员变量： 1.private T[] imtes : 用来存储元素的数组 2.private int N：记录堆中元素的个数 堆的API设计 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class Heap&lt;T extends Comparable&lt;T&gt;&gt; &#123; //存放堆中的元素 private T[] item; //堆中元素的个数 private int N; //构造方法，生成元素个数为capacity的堆 public Heap(int capacity) &#123; item=(T[])new Comparable[capacity+1];//不能直接定义一个泛型数组，要用这钟强转形式,同时T类继承Comparable所以应该这样，而且0被弃用，所以要capacity+1 this.N=0; &#125; //判断堆中索引i处的元素是否小于索引j处的值 private boolean less(int i,int j) &#123; return item[i].compareTo(item[j])&lt;0; &#125; //交换堆中i索引和j索引的值 private void exch(int i,int j) &#123; T a; a=item[i]; item[i]=item[j]; item[j]=a; &#125; //往堆中插入一个元素 public void insert(T t) &#123; item[++N]=t; swim(N);//因为新加进去之后在最后所以一定是上浮 &#125; //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置 private void swim(int k) &#123; //通过循环不断比较当前结点和其父结点的值，如果发现父结点比当前结点的值小就交换 while(k&gt;1) &#123; //比较当前结点和其父节点 if(less(k/2,k)) &#123; exch(k/2,k); &#125; k=k/2; &#125; &#125; //删除堆中最大的元素，并返回这个最大的元素 public T delMax() &#123; T max =item[1];//记录被删除的最大值 //让根节点和最大索引处的结点y交换位置 exch(1,N); //让现在的最大索引处指向null item[N]=null; //元素个数-1 N--; //通过下沉算法，让堆重新有序 sink(1); return max; &#125; //使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置 private void sink(int k) &#123; //通过循环不断对比当前k结点和其左子节点2k和右子节点2k+1处的元素大小，如果当前结点小，则需要交换位置 while(2*k&lt;=N) &#123; //获取当前子节点中的较大值 int max=0;//记录较大子结点所在的索引 if(2*k+1&lt;=N) &#123; if(less(2*k,2*k+1)) &#123; max=2*k+1; &#125; else &#123; max=2*k; &#125; &#125; else &#123; max=2*k; &#125; //比较当前结点和较大子节点的值,因为k是从最底下弄上来的，所以不存在它比一个子节点大比另一个子节点小的情况 if(less(max,k)) &#123; break; &#125; //交换k索引处的键和max索引处的位置 exch(k,max); //变换k的值 k=max; &#125; &#125;&#125; 测试： 123456789101112131415161718192021222324public class Heaptest &#123; public static void main(String[] args) &#123; //创建堆对象 Heap&lt;String&gt; heap=new&lt;String&gt; Heap(10); //往堆中存入字符串数据 heap.insert(&quot;a&quot;); heap.insert(&quot;b&quot;); heap.insert(&quot;c&quot;); heap.insert(&quot;d&quot;); heap.insert(&quot;e&quot;); heap.insert(&quot;f&quot;); heap.insert(&quot;g&quot;); heap.insert(&quot;h&quot;); heap.insert(&quot;i&quot;); //通过循环从堆中删除数据 String result=null; while((result=heap.delMax())!=null) &#123; System.out.println(result); &#125;&#125;&#125; 堆的排序给定一个数组： String[] arr &#x3D; {“S”,”O”,”R”,”T”,”E”,”X”,”A”,”M”,”P”,”L”,”E”} 请对数组中的字符按从小到大排序。 类名：HeapSort&lt;T extends Comparable&gt; 成员方法：1.public static void sort(Comparable[] source)：对source数组中的数据从小到大排序 2.private static void createHeap(Comparable[] source, Comparable[] heap):根据原数组 source，构造出堆heap 3.private static boolean less(Comparable[] heap, int i, int j)：判断heap堆中索引i处的元素是否 小于索引j处的元素 4.private static void exch(Comparable[] heap, int i, int j):交换heap堆中i索引和j索引处的值 5.private static void sink(Comparable[] heap, int target, int range):在heap堆中，对target处的 元素做下沉，范围是0~range。 createHeap方法 用排列好的从小到大的数组，得到堆数组，就是对不是叶子结点的元素进行下沉所以 非叶子结点的个数是总的个数除以二 sort方法是拿堆中最大的元素和未排序的最后一个交换，然后再对现在的那个根节点进行下沉，并且下沉范围不包括已经排好序的 API代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class HeapSort &#123;//判断heap堆中索引i处的元素是否小于索引j处的元素 private static boolean less(Comparable[] heap,int i,int j) &#123; return heap[i].compareTo(heap[j])&lt;0; &#125; //交换heap堆中i索引和j索引处的值 private static void exch(Comparable[] heap,int i,int j) &#123; Comparable temp=heap[i]; heap[i]=heap[j]; heap[j]=temp; &#125; //根据原数组source，构成出堆heap private static void createHeap(Comparable[] source,Comparable[] heap) &#123; //把source中的元素拷贝到heap中，heap中的元素就形成一个无序的堆 System.arraycopy(source,0, heap, 1, source.length); //对堆中的元素做下沉调整（从长度的一半处开始往索引1出扫描） for(int i=source.length/2;i&gt;0;i--) &#123; sink(heap,i,heap.length-1); &#125; &#125; //对source数组中的数据从小到大排序 public static void sort(Comparable[] source) &#123; //拿堆中最大的元素和未排序的最后一个交换 //构建堆 Comparable []heap=new Comparable[source.length+1];//0索引废弃掉 createHeap(source,heap); //定义一个变量，记录未排序的元素中最大索引 int N=heap.length-1; //通过循环交换1索引和未排序的元素中最大索引处的元素交换 while(N!=1) &#123; exch(heap,1,N); //排除交换后最大元素所在的索引让他不要参与堆的下沉调整 N--; //对索引1处的元素进行下沉调整 sink(heap,1,N); &#125; //把heap中的数据复制到原数组中 System.arraycopy(heap,1,source,0,source.length); &#125; //在heap堆中，对target处的元素做下沉，范围是0-range private static void sink(Comparable[] heap,int target,int range) &#123; while(2*target&lt;=range) &#123; //如果这个没有左子结点连while循环都进不来，所以下面没有 没有子节点的情况 //1.找出当前结点的较大的子结点 int max; if(2*target+1&lt;=range) &#123; if(less(heap,2*target,2*target+1)) &#123; max=2*target+1; &#125; else &#123; max=2*target; &#125; &#125;else &#123; max=2*target; &#125; //2.比较当前结点的值和较大子结点的值 if(less(heap,max,target)) &#123; break; &#125; exch(heap,target,max); target=max; &#125; &#125;&#125; 测试： 1234567891011public class HeapSortTest &#123; public static void main(String[] args) &#123; //待排序的数组 String[] arr = &#123;&quot;S&quot;,&quot;O&quot;,&quot;R&quot;,&quot;T&quot;,&quot;E&quot;,&quot;X&quot;,&quot;A&quot;,&quot;M&quot;,&quot;P&quot;,&quot;L&quot;,&quot;E&quot;&#125;; HeapSort.sort(arr); //打印排序后数组中元素 System.out.println(Arrays.toString(arr)); &#125;&#125; 优先队列就是想要特定的元素从队列中先出来 优先队列按照其作用不同，可以分为以下两种： 最大优先队列： 可以获取并删除队列中最大的值 最小优先队列： 可以获取并删除队列中最小的值 最大优先队列最大优先队列的API设计 类名：MaxPriorityQueue&lt;T extends Comparable&gt; 构造方法 MaxPriorityQueue(int capacity)：创建容量为capacity的MaxPriorityQueue对象 1.private T[] imtes : 用来存储元素的数组 2.private int N：记录堆中元素的个数 成员方法：1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素 2.private void exch(int i,int j):交换堆中i索引和j索引处的值 3.public T delMax():删除队列中最大的元素,并返回这个最大元素 4.public void insert(T t)：往队列中插入一个元素 5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置 6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置 7.public int size():获取队列中元素的个数 8.public boolean isEmpty():判断队列是否为空 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class MaxPriorityQueue&lt;T extends Comparable&lt;T&gt;&gt; &#123; //存储堆中的元素 private T[] items; //记录堆中元素的个数 private int N; public MaxPriorityQueue(int Capacity) &#123; this.items=(T[])new Comparable[Capacity+1]; this.N=0; &#125; //获取队列中元素个数 public int size() &#123; return N; &#125; //判断队列是否为空 public boolean isEmpty() &#123; return N==0; &#125; //判断堆中索引i处的元素是否小于索引j处的元素 private boolean less(int i,int j) &#123; return items[i].compareTo(items[j])&lt;0; &#125; //交换堆中i索引和j索引处的值 private void exch(int i,int j) &#123; T a=items[i]; items[i]=items[j]; items[j]=a; &#125; //往堆中插入一个元素 public void insert(T t) &#123; items[++N]=t; swim(N); &#125; //删除堆中最大的元素，并返回这个最大的值 public T delMax() &#123; T max=items[1]; exch(1,N); items[N]=null; N--; sink(1); return max; &#125; //使用上浮算法，使索引k处的元素都在堆中处于一个正确的位置 private void swim(int k) &#123; while(k&gt;1) &#123; if(less(k/2,k)) &#123; exch(k/2,k); &#125; k=k/2; &#125; &#125; //使用下沉算法，使索引k处的元素在堆中处于一个正确的位置 private void sink(int k) &#123; while(2*k&lt;=N) &#123; int max; if(2*k+1&lt;=N) &#123; if(less(2*k,2*k+1)) &#123; max=2*k+1; &#125; else &#123; max=2*k; &#125; &#125; else &#123; max=2*k; &#125; if(!less(k,max)) &#123; break; &#125; exch(k,max); k=max; &#125; &#125; &#125; 测试： 123456789101112131415161718192021public class MaxPriorityQueueTest &#123; public static void main(String[] args) &#123; //创建优先队列 MaxPriorityQueue&lt;String&gt; queue=new MaxPriorityQueue&lt;&gt;(10); //往队列中存储元素 queue.insert(&quot;a&quot;); queue.insert(&quot;b&quot;); queue.insert(&quot;c&quot;); queue.insert(&quot;d&quot;); queue.insert(&quot;e&quot;); queue.insert(&quot;f&quot;); queue.insert(&quot;g&quot;); //通过循环从队列中获取最大的元素 while(!queue.isEmpty()) &#123; String max=queue.delMax(); System.out.println(max); &#125; &#125;&#125; 最小优先队列最小优先队列的实现也是通过堆来完成最小优先队列 我们前面学习堆的时候，堆中存放数据元素的数组要满足都满足如下特性： 1.最大的元素放在数组的索引1处。 2.每个结点的数据总是大于等于它的两个子结点的数据。 我们可以用相反的思想实现最小堆，让堆中存放数据元素的数组满足 如下特性： 1.最小的元素放在数组的索引1处。 2.每个结点的数据总是小于等于它的两个子结点的数据。 API设计 类名：MinPriorityQueue&lt;T extends Comparable&gt; 构造方法 MinPriorityQueue(int capacity)：创建容量为capacity的MinPriorityQueue对象 成员变量：1.private T[] imtes : 用来存储元素的数组 ​ 2.private int N：记录堆中元素的个数 成员方法： ​ 1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素 2.private void exch(int i,int j):交换堆中i索引和j索引处的值 3.public T delMin():删除队列中最小的元,并返回这个最小元素 4.public void insert(T t)：往队列中插入一个元素 5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置 6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置 7.public int size():获取队列中元素的个数 8.public boolean isEmpty():判断队列是否为空 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class MinPriorityQueue&lt;T extends Comparable&lt;T&gt;&gt;&#123; //存储堆中的元素 private T[] items; //记录堆中元素的个数 private int N; public MinPriorityQueue (int capacity) &#123; this.items=(T[]) new Comparable[capacity+1]; &#125; //获取队列中元素个数 public int size() &#123; return N; &#125; //判断队列是否为空 public boolean isEmpty() &#123; return N==0; &#125; //判断堆中索引i处的元素是否小于索引j处的元素 private boolean less(int i,int j) &#123; return items[i].compareTo(items[j])&lt;0; &#125; //交换堆中索引i的值和索引j的值 private void exch(int i,int j) &#123; T a=items[i]; items[i]=items[j]; items[j]=a; &#125; //往堆中添加一个元素 public void insert(T t) &#123; items[++N]=t; swim(N); &#125; //删除堆中最小的元素，并返回这个最小元素 public T delMin() &#123; T min=items[1]; exch(1,N); items[N]=null; N--; sink(1); return min; &#125; //使用上浮算法，使索引为k的元素在堆中处于一个正确的位置 public void swim(int k) &#123; //通过循环比较当前结点和其父节点的大小 while(k&gt;1) &#123; if(less(k,k/2)) &#123; exch(k,k/2); &#125; k=k/2; &#125; &#125; //使用下沉算法，使索引为k的元素在堆中处于一个正确的位置 public void sink(int k) &#123; //通过循环比较当前结点和子结点中的较小值 while(2*k&lt;=N) &#123; //找到子结点中的较小值 int min; if(2*k+1&lt;=N) &#123; if(less(2*k,2*k+1)) &#123; min=2*k; &#125; else &#123; min=2*k+1; &#125; &#125; else &#123; min=2*k; &#125; //判断当前结点和较小值的大小 if(less(k,min)) &#123; break; &#125; exch(k,min); k=min; &#125;​ &#125;&#125; 测试： 1234567891011121314151617public class MinPriorityQueueTest &#123; public static void main(String[] args) &#123; MinPriorityQueue&lt;String&gt; mpqt=new MinPriorityQueue&lt;&gt;(10); mpqt.insert(&quot;f&quot;); mpqt.insert(&quot;e&quot;); mpqt.insert(&quot;d&quot;); mpqt.insert(&quot;c&quot;); mpqt.insert(&quot;b&quot;); mpqt.insert(&quot;a&quot;); while(!mpqt.isEmpty()) &#123; String min=mpqt.delMin(); System.out.println(min+&quot; &quot;); &#125; &#125;&#125; ### 索引最小优先队列 第一个数组是储存不符合堆排序的元素的，索引与元素有一一对应关系 为了调整顺序但索引对应关系不变有了第二个辅助数组，是满足堆调整的 第三个是当修改（不是交换）某个元素的值时更容易找到那个值所对应的索引 qp就是把pq数组的索引当值，值当索引 索引最小优先队列的API设计 类名：IndexMinPriorityQueue&lt;T extends Comparable&gt; 构造方法 IndexMinPriorityQueue(int capacity)：创建容量为capacity的IndexMinPriorityQueue对象 成员变量：1.private T[] imtes : 用来存储元素的数组 ​ 2.private int[] pq:保存每个元素在items数组中的索引，pq数组需要堆有序 ​ 3.private int [] qp:保存qp的逆序，pq的值作为索引，pq的索引作为值 ​ 4.private int N：记录堆中元素的个数 成员方法：1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素 ​ 2.private void exch(int i,int j):交换堆中i索引和j索引处的值 ​ 3.public int delMin():删除队列中最小的元素,并返回该元素关联的索引 ​ 4.public void insert(int i,T t)：往队列中插入一个元素,并关联索引i ​ 5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置 ​ 6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置 ​ 7.public int size():获取队列中元素的个数 ​ 8.public boolean isEmpty():判断队列是否为空 ​ 9.public boolean contains(int k):判断k对应的元素是否存在 ​ 10.public void changeItem(int i, T t):把与索引i关联的元素修改为为t ​ 11.public int minIndex():最小元素关联的索引 12.public void delete(int i):删除索引i关联的元素 ​ API 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159public class IndexMinPriorityQueue&lt;T extends Comparable&lt;T&gt;&gt; &#123;//存储堆中的元素 private T[] items; //保存每个元素在items数组中的索引，pq数组需要堆有序 private int[] pq; //保存pq的逆序，pq的值是索引，pq的索引是值 private int[] qp; //记录堆中元素个数 private int N; public IndexMinPriorityQueue (int capacity) &#123; this.items=(T[])new Comparable[capacity+1]; this.pq=new int[capacity+1]; this.qp=new int[capacity+1]; this.N=0; //默认情况下，队列中没有任何数据，qp中元素都为-1 for(int i=0;i&lt;qp.length;i++) &#123; qp[i]=-1; &#125; &#125; //获取队列中的元素个数 public int size() &#123; return N; &#125; //判断队列是否为空 public boolean isEmpty() &#123; return N==0; &#125; //判断堆中索引i处的元素是否小于索引j处的元素 public boolean less(int i,int j) &#123; return items[pq[i]].compareTo(items[pq[j]])&lt;0; &#125; //交换堆中索引i和索引j的位置 private void exch(int i,int j) &#123; //交换pq中的数据 int tmp=pq[i]; pq[i]=pq[j]; pq[j]=tmp; //更新qp中的数据 qp[pq[i]]=i; qp[pq[j]]=j; &#125; //判断k对应的元素是否存在 public boolean contains(int k) &#123; return qp[k]!=-1; &#125; //最小元素关联的索引 public int minIndex() &#123; return pq[1]; &#125; //往队列中插入一个元素，并关联索引i public void insert(int i,T t) &#123; //判断i是否已经被关联,如果已经被关联则不让插入 if(contains(i)) &#123; return ; &#125; //元素个数加一 N++; //把数据存储到items对应的i位置处 items[i]=t; //把i存储到pq中 pq[N]=i; //通过qp来记录pq中的i qp[i]=N; //通过堆的上浮来完成堆序列 swim(N); &#125; public int delMin() &#123; //获取最小元素关联的索引 int minIndex=pq[1]; //交换pq中索引1处和最大索引处的元素 exch(1,N); //删除qp中对应的内容 qp[pq[N]]=-1; //删除pq中最大索引处的内容 pq[N]=-1; //删除items中对应的内容 items[minIndex]=null; //元素个数-1 N--; //下沉调整 sink(1); return minIndex; &#125; //删除索引i关联的元素 public void delete(int i) &#123; //找到i在pq中的索引 int k=qp[i]; //交换pq中的索引k处的值和索引N处的值 exch(k,N); //删除qp中的对应内容 qp[pq[N]]=-1; //删除pq中的内容 pq[N]=-1; //删除items中的内容 items[k]=null; //堆的调整 sink(k); swim(k); &#125; //修改索引i关联的元素修改为t public void changeItem (int i,T t) &#123; //修改items数组中i位置的元素为t items[i]=t; //找到i在pq中出现的位置 int k=qp[i]; //堆调整 sink(k); swim(k); &#125; //堆上浮算法，使索引k处的元素在堆中处于一个正确的位置 private void swim(int k) &#123; while(k&gt;1) &#123; if(less(k,k/2)) &#123; exch(k,k/2); &#125; k=k/2; &#125; &#125; //使用下沉算法，使索引k处的元素在堆中处于一个正确的位置 private void sink(int k) &#123; while(2*k&lt;=N) &#123; int min; if(2*k+1&lt;=N) &#123; if(less(2*k,2*k+1)) &#123; min=2*k; &#125; else &#123; min=2*k+1; &#125; &#125; else &#123; min=2*k; &#125; //比较当前结点和较小值 if(less(k,min)) &#123; break; &#125; exch(k,min); k=min; &#125; &#125; &#125; 测试： 1234567891011121314151617public class IndexMinPriorityQueueTest &#123; public static void main(String[] args) &#123; IndexMinPriorityQueue&lt;String&gt; queue=new IndexMinPriorityQueue&lt;&gt;(10); queue.insert(0, &quot;A&quot;); queue.insert(1, &quot;C&quot;); queue.insert(2, &quot;F&quot;); queue.changeItem(2,&quot;B&quot;); while(!queue.isEmpty()) &#123; int index=queue.delMin(); System.out.println(index); &#125; &#125;&#125; 树的进阶如果是二叉查找树会出现 可能会出现这样的情况，查找1的效率会很低 我们有一种方法，能够不受插入数据的影响，让生成的树都像完全二叉树那样，那么即使在最坏情 况下，查找的效率依旧会很好。 平衡树这块笔记不详细，可以去看它的原版笔记 2-3查找树的定义 一棵2-3查找树要么为空，要么满足满足下面两个要求： 2-结点： 含有一个键(及其对应的值)和两条链，左链接指向2-3树中的键都小于该结点，右链接指向的2-3树中的键都大 于该结点。 3-结点： 含有两个键(及其对应的值)和三条链，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都 位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。 查找 在这个数中找H，先和第一个比较M比较，H比M小所以找M的左联结，然后将H和EJ比较发先H在E J的中间，所以查找E J 的中连接，然后找到H 插入向2-结点中插入新键应该让它变成3-结点，同时3-结点中小的在左边 向只含有一个3-结点的树中插入新键 向一个父节点为2-结点的3-结点中插入新键 向一个父节点为3-结点的3-结点中插入新键 分解根节点 当插入结点到根节点的路径上全部都是3-结点，最终我们的根节点会拆分为两个2-结点，树高度加一 2-3树的性质举例上面这个最近的图，有四个叶子结点，八个空链接 ​ 任意空链接到根结点的路径长度都是相等的。 ​ 4-结点变换为3-结点时，树的高度不会发生变化，只有当根结点是临时的4-结点，分解根结点时，树高+1。 ​ 2-3树与普通二叉查找树最大的区别在于，普通的二叉查找树是自顶向下生长，而2-3树是自底向上生长。 红黑树红黑树主要是对2-3树进行编码，红黑树背后的基本思想是用标准的二叉查找树(完全由2-结点构成)和一些额外的信 息(替换3-结点)来表示2-3树。我们将树中的链接分为两种类型： 红链接：将两个2-结点连接起来构成一个3-结点； 黑链接：则是2-3树中的普通链接。 准确来说红链接连接的两个2-节点其实就组成了3-结点 定义基于二叉查找树，满足以下条件 红链接均为左链接； 没有任何一个结点同时和两条红链接相连； 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同； 红黑树结点API 类名 Node 构造方法 Node(Key key, Value value, Node left, Node right，boolean color)：创建Node对象 成员变量 1.public Node left:记录左子结点 ​ 2.public Node right:记录右子结点 ​ 3.public Key key:存储键 ​ 4.public Value value:存储值 ​ 5.public boolean color:由其父结点指向它的链接的颜色 红黑树平衡化对红黑树进行增删改查操作之后，容易破坏红黑树的定义，所以我们需要对这些情况通过旋转进行修复 左旋 当某个结点的左子结点为黑色，右子结点为红色，此时需要左旋。 左旋过程： 1.让x的左子结点变为h的右子结点：h.right&#x3D;x.left; ​ 2.让h成为x的左子结点：x.left&#x3D;h; ​ 3.让h的color属性变为x的color属性值：x.color&#x3D;h.color; ​ 4.让h的color属性变为RED：h.color&#x3D;true 右旋 当某个结点的左子结点是红色，且左子结点的左子结点也是红色，需要右旋 右旋过程： 1. 让x的右子结点成为h的左子结点：h.left &#x3D; x.right; ​ 2.让h成为x的右子结点：x.right&#x3D;h; ​ 3.让x的color变为h的color属性值：x.color &#x3D; h.color; ​ 4. 让h的color为RED； 红黑树插入红黑树插入键的时候其实就是插入红色的，因为每一个都可以被看作2-结点 向单个2-结点中插入新建 如果新键小于当前结点的键，我们只需要新增一个红色结点即可，新的红黑树和单个3-结点完全等价 新键大于当前结点的键，那么新增的红色结点将会产生一条红色的右链接，此时我们需要通过左旋，把 红色右链接变成左链接，插入操作才算完成 向底部的2-结点插入新键 颜色反转 当一个结点的左子结点和右子结点的color都为RED时，也就是出现了临时的4-结点，此时只需要把左子结点和右子 结点的颜色变为BLACK，同时让当前结点的颜色变为RED即可。 向一颗双键树（即一个3-结点）中插入新建 1.新键大于原树中的两个键 新键小于原树中的两个键 .新键介于原数中两个键之间 根节点的颜色总是黑色的，因为指向它的是空的，每次插入操作后都要把根节点的颜色设置为黑色 向树底部的3-结点插入新建 详细见资料 红黑树的API设计类名：RedBlackTree&lt;Key extends Comparable,Value&gt; 构造方法 RedBlackTree()：创建RedBlackTree对象 成员方法 1.private boolean isRed(Node x)：判断当前结点的父指向链接是否为红色 2.private Node rotateLeft(Node h):左旋调整 3.private Node rotateRight(Node h):右旋调整 4.private void flipColors(Node h)：颜色反转,相当于完成拆分4-结点 5.public void put(Key key, Value val):在整个树上完成插入操作 6.private Node put(Node h, Key key, Value val):在指定树中，完成插入操作,并返回添加元素后 新的树 7.public Value get(Key key):根据key，从树中找出对应的值 8.private Value get(Node x, Key key):从指定的树x中，找出key对应的值 9.public int size():获取树中元素的个数 成员变量 1.private Node root : 记录根结点 2.private int N:记录树中元素的个数 3.private static final boolean RED：红色链接标识 4.private static final boolean BLACK:黑色链接标识 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157public class RedBlackTree &lt;Key extends Comparable&lt;Key&gt;,Value&gt; &#123;//根节点 private Node root; //记录树中元素的个数 private int N; //红色链接 private static final boolean RED=true; //黑色链接 private static final boolean BLACK=false; //结点类 private class Node&#123; //存储键 public Key key; //存储值 public Value value; //记录左子节点 public Node left; //记录右子结点 public Node right; //由其父节点指向它的链接的颜色 public boolean color; public Node(Key key,Value value,Node left,Node right,boolean color) &#123; this.key=key; this.value=value; this.left=left; this.right=right; this.color=color; &#125; &#125; //获取树中元素的个数 public int size() &#123; return N; &#125; //判断当前结点的父节点指向链接是否为红色 private boolean isRed(Node x) &#123; if(x==null) &#123; return false; &#125; return x.color==RED; &#125; //左旋 private Node rotateleft(Node h) &#123; //获取h结点的右子节点，表示为x Node x=h.right; //让x结点的左子节点称为h节点的右子结点 h.right=x.left; //让h称为x的左子节点 x.left=h; //让x节点的color属性等于h结点的color属性 x.color=h.color; //让h结点的color属性变为红色 h.color=RED; return x; &#125; //右旋 private Node rotateright(Node h) &#123; //获取h结点的左子结点，表示为x Node x=h.left; //让x节点的右子节点为h的左子节点 h.left=x.right; //让h节点成为x节点的右子结点 x.right=h; //让x结点的color属性等于h节点的color属性 x.color=h.color; //让h节点的color属性为红色 h.color=RED; return x; &#125; //颜色反转，左右子结点是黑色，当前节点是红色 private void flipColor(Node n) &#123; n.left.color=BLACK; n.right.color=BLACK; n.color=RED; &#125; public void put(Key key,Value value) &#123; root=put(root,key,value); //根节点的颜色总是黑色的 root.color=BLACK; &#125; /* * 在指定树中完成插入操作，并返回添加元素后新的树 */ private Node put(Node h,Key key,Value val) &#123; //判断h是否为空 if(h==null) &#123; //数量加一 N++; return new Node(key,val,null,null,RED); &#125; //不为空就得去比较h节点的键和key的大小 int cmp=key.compareTo(h.key); if(cmp&lt;0) &#123; //小于零，继续往左 h.left=put(h.left,key,val); &#125; else if(cmp&gt;0) &#123; //大于零继续往右 h.right=put(h.right,key,val); &#125; else &#123; //等于零,进行替换 h.value=val; &#125; //进行左旋，当当前结点h的左子节点为黑色，右子结点为红色，需要左旋 if(isRed(h.right)&amp;&amp;!isRed(h.left)) &#123; h=rotateleft(h); &#125; //进行右旋，当当前结点h的左子节点，和左子节点的左子节点都为红色需要右旋 if(isRed(h.left)&amp;&amp;isRed(h.left.left)) &#123; h=rotateright(h); &#125; //颜色反转当前结点的左右子结点都为红色 if(isRed(h.left)&amp;&amp;isRed(h.right)) &#123; flipColor(h); &#125; return h; &#125; //这个查找方法和二叉查找树一摸一样 //查询树中指定key对应的value public Value get(Key key) &#123; return get(root,key); &#125; //从指定的树x中，查找key对应的值 public Value get(Node x,Key key) &#123; //x树为null if(x==null) &#123; return null; &#125; //x树不为null //比较key和x结点键的大小 int cmp=key.compareTo(x.key); if(cmp&gt;0) &#123; //如果key大于x结点的键，则继续找x结点右子树 return get(x.right,key); &#125; else if(cmp&lt;0) &#123; //如果key小于x节点的键，则继续找x结点的左子树 return get(x.left,key); &#125; else &#123; //如果key等于x结点的键，就找到了key的结点，只需要返回x结点的值即可 return x.value; &#125; &#125; &#125; 测试： 1234567891011121314151617public class RedBlackTreeTest &#123; public static void main(String[] args) &#123; RedBlackTree&lt;String ,String&gt; tree=new RedBlackTree&lt;String ,String&gt;(); tree.put(&quot;1&quot;, &quot;张三&quot;); tree.put(&quot;2&quot;, &quot;李四&quot;); tree.put(&quot;3&quot;, &quot;王五&quot;); String r1=tree.get(&quot;1&quot;); System.out.println(r1); String r2=tree.get(&quot;2&quot;); System.out.println(r2); String r3=tree.get(&quot;3&quot;); System.out.println(r3); &#125;&#125; B树定义B树中允许一个结点中包含多个key，可以是3个、4个、5个甚至更多，并不确定，需要看具体的实现。现在我们选 择一个参数M，来构造一个B树，我们可以把它称作是M阶的B树，那么该树会具有如下特点： 每个结点最多有M-1个key，并且以升序排列； 每个结点最多能有M个子结点； 根结点至少有两个子结点； 所以，即使存储大量的数据，B树的高度仍然比较小，这 样在某些应用场景下，就可以体现出它的优势。 B树存储数据详情见资料 B树在磁盘文件中的应用B+树B+数的所有元素都会出现在叶子结点中 黄色区域是一页，b树叶子节点中也存储值，导致一页中存储的key减少，就导致指针减少，就会不断增高层级，但是b+树除了叶子结点都不存储值，就存储的key，一页中存储的key就多，树的层级就少，效率就高 上面这段话中的值是指比如二级索引节点中会存储对应的主键也就是聚合索引的值，聚合索引节点中会存储对应的行信息，也就是这些信息b树存储在所有节点上，而b+树存储在叶子节点上 key是对应索引的字段 并查集并查集是一种树型的数据结构 ，并查集可以高效地进行如下操作： 查询元素p和元素q是否属于同一组 合并元素p和元素q所在的组 并查集也是一种树型结构 每个元素都唯一的对应一个结点； 每一组数据中的多个元素都在同一颗树中； 一个组中的数据对应的树和另外一个组中的数据对应的树之间没有任何联系 元素在树中并没有子父级关系的硬性要求； 并查集的API设计类名：UF 构造方法 UF(int N)：初始化并查集，以整数标识(0,N-1)个结点 成员方法 1.public int count()：获取当前并查集中的数据有多少个分组 2.public boolean connected(int p,int q):判断并查集中元素p和元素q是否在同一分组中 3.public int find(int p):元素p所在分组的标识符 4.public void union(int p,int q)：把p元素所在分组和q元素所在分组合并 成员变量 1.private int[] eleAndGroup: 记录结点元素和该元素所在分组的标识 ​ 2.private int count：记录并查集中数据的分组个数 构造方法的实现 初始情况下，每个元素都在一个独立的分组中，所以，初始情况下，并查集中的数据默认分为N个组； 初始化数组eleAndGroup； 把eleAndGroup数组的索引看做是每个结点存储的元素，把eleAndGroup数组每个索引处的值看做是该结点 所在的分组，那么初始化情况下，i索引处存储的值就是i union方法的实现 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class UF &#123; //记录结点元素和该元素所在分组的标识private int[] eleAndGroup;//记录并查集中数据的分组个数private int count;//初始化并查集public UF(int N) &#123; //初始化分组的数量，默认情况下有N个分组 this.count=N; //初始化end数组 this.eleAndGroup=new int [N]; //初始化eleAndGroup中的元素极其所在的组的标识符,让eleAndGroup数组的索引作为并查集的每个节点的元素，并且让每个索引处的值(该元素所在组的标识符)就是该索引 for(int i=0;i&lt;eleAndGroup.length;i++) &#123; eleAndGroup[i]=i; &#125;&#125;//获取当前并查集中的数据有多少个分组public int count() &#123; return this.count; &#125;//查询p所在分组的标识符public int find(int p) &#123; return eleAndGroup[p];&#125;//判断并查集中元素p和元素q是否在同一个分组中public boolean connected(int p,int q) &#123; return find(p)==find(q);&#125;//合并p元素和q元素所在的分组public void union(int p,int q) &#123; //判断元素p和q是否已经在同一分组中，如果已经在同一分组中，则结束方法就可以了 if(connected(p,q)) &#123; return ; &#125; //找到p所在分组的标识符 int pgroup=find(p); //找到q所在分组的标识符 int qgroup=find(q); //合并组，让p所在组的所有元素的组标识符变为q所在分组的标识符 for(int i=0;i&lt;eleAndGroup.length;i++) &#123; if(eleAndGroup[i]==pgroup) &#123; eleAndGroup[i]=qgroup; &#125; &#125; //组数减一 this.count--;&#125;&#125; 测试： 1234567891011121314151617181920212223public class UFTest &#123; public static void main(String[] args) &#123; UF uf=new UF(5); System.out.println(&quot;默认情况分组个数&quot;+uf.count()); Scanner in=new Scanner(System.in); while(true) &#123; System.out.println(&quot;请输入第一个要合并的元素&quot;); int p=in.nextInt(); System.out.println(&quot;请输入第二个要合并的元素&quot;); int q=in.nextInt(); if(uf.connected(p,q)) &#123; System.out.println(p+&quot;元素和&quot;+q+&quot;已经在同一个组中了&quot;); continue; &#125; uf.union(p, q); System.out.println(&quot;当前并查集中还有：&quot;+uf.count()+&quot;个分组&quot;); &#125; &#125;&#125; 上面这种并查集的效率很低 UF-Tree算法优化为了提升union算法的性能，我们需要重新设计find方法和union方法的实现，此时我们先需要对我们的之前数据结 构中的eleAndGourp数组的含义进行重新设定： 1.我们仍然让eleAndGroup数组的索引作为某个结点的元素； 2.eleAndGroup[i]的值不再是当前结点所在的分组标识，而是该结点的父结点； find(int p)查询方法实现 1.判断当前元素p的父结点eleAndGroup[p]是不是自己，如果是自己则证明已经是根结点了； 2.如果当前元素p的父结点不是自己，则让p&#x3D;eleAndGroup[p]，继续找父结点的父结点,直到找到根结点为止； 这个元素的标识符就是元素的根节点 union方法 1.3.5.3 union(int p,int q)合并方法实现 找到p元素所在树的根结点 找到q元素所在树的根结点 . 如果p和q已经在同一个树中，则无需合并； 如果p和q不在同一个分组，则只需要将p元素所在树根结点的父结点设置为q元素的根结点即可； 分组数量-1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class UFTREE &#123; //记录结点元素和该元素所在分组的标识 private int[] eleAndGroup; //记录并查集中数据的分组个数 private int count; //初始化并查集 public UFTREE(int N) &#123; //初始化分组的数量，默认情况下有N个分组 this.count=N; //初始化end数组 this.eleAndGroup=new int [N]; //初始化eleAndGroup中的元素极其所在的组的标识符,让eleAndGroup数组的索引作为并查集的每个节点的元素，并且让每个索引处的值(该元素所在组的标识符)就是该索引 for(int i=0;i&lt;eleAndGroup.length;i++) &#123; eleAndGroup[i]=i; &#125; &#125; //获取当前并查集中的数据有多少个分组 public int count() &#123; return this.count; &#125; //查询p所在分组的标识符 public int find(int p) &#123; while(true) &#123; if(p==eleAndGroup[p]) &#123; return p; &#125; p=eleAndGroup[p]; &#125; &#125; //判断并查集中元素p和元素q是否在同一个分组中 public boolean connected(int p,int q) &#123; return find(p)==find(q); &#125; //合并p元素和q元素所在的分组 public void union(int p,int q) &#123; //找到p所在分组的对应的根节点 int pRoot=find(p); //找到q所在分组的根节点 int qRoot=find(q);//如果p和q已经在一个分组就不用合并了 if(pRoot==qRoot) &#123; return ; &#125; //让p所在树的根节点的父节点为q所在树的根节点即可 eleAndGroup[pRoot]=qRoot; //组数减一 this.count--; &#125; &#125; 测试： 12345678910111213141516171819202122public class UFTREETEST &#123; public static void main(String[] args) &#123; UFTREE uf=new UFTREE(5); System.out.println(&quot;默认情况分组个数&quot;+uf.count()); Scanner in=new Scanner(System.in); while(true) &#123; System.out.println(&quot;请输入第一个要合并的元素&quot;); int p=in.nextInt(); System.out.println(&quot;请输入第二个要合并的元素&quot;); int q=in.nextInt(); if(uf.connected(p,q)) &#123; System.out.println(p+&quot;元素和&quot;+q+&quot;已经在同一个组中了&quot;); continue; &#125; uf.union(p, q); System.out.println(&quot;当前并查集中还有：&quot;+uf.count()+&quot;个分组&quot;); &#125; &#125;&#125; 优化之后这个union方法的时间复杂度从O(N^2)便成了O(N) find方法从时间复杂度为O(1)变为现在最坏的情况下为O(N) 路径压缩如果 我们把并查集中每一棵树的大小记录下来，然后在每次合并树的时候，把较小的树连接到较大的树上，就可以减小 树的深度。 只要我们保证每次合并，都能把小树合并到大树上，就能够压缩合并后新树的路径，这样就能提高find方法的效率 为了完成这个需求，我们需要另外一个数组来记录存储每个根结点对应的树中元素的个数，并且需要一些代码 调整数组中的值。 改进之后的API 主要是union方法的改动 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class UF_TREE_WEIGHTED &#123; //记录结点元素和该元素所在分组的标识 private int[] eleAndGroup; //记录并查集中数据的分组个数 private int count; //用来存储每一个根节点对应树中保存的结点个数 private int[] sz; //初始化并查集 public UF_TREE_WEIGHTED(int N) &#123; //初始化分组的数量，默认情况下有N个分组 this.count=N; //初始化end数组 this.eleAndGroup=new int [N]; //初始化eleAndGroup中的元素极其所在的组的标识符,让eleAndGroup数组的索引作为并查集的每个节点的元素，并且让每个索引处的值(该元素所在组的标识符)就是该索引 for(int i=0;i&lt;eleAndGroup.length;i++) &#123; eleAndGroup[i]=i; &#125; this.sz=new int[N]; //默认情况下，sz中每个索引处的值都是1 for(int i=0;i&lt;sz.length;i++) &#123; sz[i]=1; &#125; &#125; //获取当前并查集中的数据有多少个分组 public int count() &#123; return this.count; &#125; //查询p所在分组的标识符 public int find(int p) &#123; while(true) &#123; if(p==eleAndGroup[p]) &#123; return p; &#125; p=eleAndGroup[p]; &#125; &#125; //判断并查集中元素p和元素q是否在同一个分组中 public boolean connected(int p,int q) &#123; return find(p)==find(q); &#125; //合并p元素和q元素所在的分组 public void union(int p,int q) &#123; //找到p所在分组的对应的根节点 int pRoot=find(p); //找到q所在分组的根节点 int qRoot=find(q);//如果p和q已经在一个分组就不用合并了 if(pRoot==qRoot) &#123; return ; &#125; //判断是pRoot对应的树大还是qRoot对应的树大 if(sz[pRoot]&lt;sz[qRoot]) &#123; eleAndGroup[pRoot]=qRoot; sz[qRoot]+=sz[pRoot]; &#125; else &#123; eleAndGroup[qRoot]=pRoot; sz[pRoot]=sz[qRoot]; &#125; //组数减一 this.count--; &#125; &#125; 测试： 12345678910111213141516171819202122public class UFWEIGHTEDTEST &#123; public static void main(String []args) &#123; UF_TREE_WEIGHTED uf=new UF_TREE_WEIGHTED(5); System.out.println(&quot;默认情况分组个数&quot;+uf.count()); Scanner in=new Scanner(System.in); while(true) &#123; System.out.println(&quot;请输入第一个要合并的元素&quot;); int p=in.nextInt(); System.out.println(&quot;请输入第二个要合并的元素&quot;); int q=in.nextInt(); if(uf.connected(p,q)) &#123; System.out.println(p+&quot;元素和&quot;+q+&quot;已经在同一个组中了&quot;); continue; &#125; uf.union(p, q); System.out.println(&quot;当前并查集中还有：&quot;+uf.count()+&quot;个分组&quot;); &#125; &#125;&#125; 畅通工程某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目 标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。 总共有20个城市，目前已经修改好了7条道路，问还需要修建多少条道路，才能让这20个城市之间全部相通？ 解题思路： 1.创建一个并查集UF_Tree_Weighted(20); 2.分别调用union(0,1),union(6,9),union(3,8),union(5,11),union(2,12),union(6,10),union(4,8)，表示已经修建好的 道路把对应的城市连接起来； 3.如果城市全部连接起来，那么并查集中剩余的分组数目为1，所有的城市都在一个树中，所以，只需要获取当前 并查集中剩余的数目，减去1，就是还需要修建的道路数目； 20个城市就是20个元素，修路就是两个变成一个组，然后7条路再看剩下还有多少组，得到剩下的组数之后，减去1就是要修的路的数量，如此组数便可为零 123456789101112131415161718192021222324252627282930import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;public class Traffic_Project_Test &#123; public static void main(String[] args) throws NumberFormatException, IOException &#123; BufferedReader br=new BufferedReader(new FileReader(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;)); //城市数量 int number=Integer.parseInt(br.readLine()); UF_TREE_WEIGHTED uf=new UF_TREE_WEIGHTED(number); //路的数量 int roadNumber=Integer.parseInt(br.readLine()); //循环读取已经修建好的道路，并调用union方法 for(int i=0;i&lt;roadNumber;i++) &#123; String line = br.readLine(); int p = Integer.parseInt(line.split(&quot; &quot;)[0]); int q = Integer.parseInt(line.split(&quot; &quot;)[1]); uf.union(p,q); &#125; //获取剩余的分组数量 int groupNumber = uf.count(); //计算出还需要修建的道路 System.out.println(&quot;还需要修建&quot;+(groupNumber-1)+&quot;道路，城市才能相通&quot;); &#125;&#125; 无向图定义：图是由一组顶点和一组能够将两个顶点相连的边组成的 特殊的图： 自环：即一条连接一个顶点和其自身的边； 平行边：连接同一对顶点的两条边； 图的分类： 按照连接两个顶点的边的不同，可以把图分为以下两种： 无向图：边仅仅连接两个顶点，没有其他含义； 有向图：边不仅连接两个顶点，并且具有方向； 相关术语 相邻顶点： 当两个顶点通过一条边相连时，我们称这两个顶点是相邻的，并且称这条边依附于这两个顶点。 度： 某个顶点的度就是依附于该顶点的边的个数 子图： 是一幅图的所有边的子集(包含这些边依附的顶点)组成的图； 路径： 是由边顺序连接的一系列的顶点组成 环： 是一条至少含有一条边且终点和起点相同的路径 连通图： 如果图中任意一个顶点都存在一条路径到达另外一个顶点，那么这幅图就称之为连通图 连通子图： 一个非连通图由若干连通的部分组成，每一个连通的部分都可以称为该图的连通子图 图的存储结构 1.图中所有的顶点； 所有连接顶点的边； 常见的图的存储结构有两种：邻接矩阵和邻接表 图的API设计类名：Graph 构造方法 Graph(int V)：创建一个包含V个顶点但不包含边的图 成员方法： 1.public int V():获取图中顶点的数量 2.public int E():获取图中边的数量 3.public void addEdge(int v,int w):向图中添加一条边 v-w 4.public Queue adj(int v)：获取和顶点v相邻的所有顶点 成员变量： 1.private final int V: 记录顶点数量 2.private int E: 记录边数量 3.private Queue[] adj: 邻接表 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Graph &#123; //顶点数目private final int V;//边的数目private int E;//邻接表private Queue&lt;Integer&gt;[] adj;public Graph(int v) &#123; //初始化顶点数量 this.V=v; //初始化边的数量 this.E=0; //初始化邻接表 this.adj=new Queue[v]; for(int i=0;i&lt;adj.length;i++) &#123; adj[i]=new Queue&lt;Integer&gt;(); &#125;&#125;///获取顶点的数目public int V() &#123; return V;&#125;//获取边的数目public int E() &#123; return E;&#125;//如图中添加一条边v-wpublic void addEdge(int v,int w) &#123; //在无向图中，边是没有方向的，该边既可以说是从v到w也可以说是从w到v得边，让w出现在v邻接表中，让v出现在w邻接表中 adj[v].enqueue(w); adj[w].enqueue(v); //边的数量加一 E++;&#125;//获取和顶点v相邻的所有顶点public Queue&lt;Integer&gt; adj(int v)&#123; return adj[v];&#125;&#125; 图的搜索找出图中与指定的顶点相连的所有顶点，或者判定某个顶点与指定顶点是否相通，是非常常见的需求。 有关图的搜索，最经典的算法有深度优先搜索和广度优先搜索，接下来我们分别讲解这两种搜索算法。 深度优先搜索所谓的深度优先搜索，指的是在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找子结点，然后找 兄弟结点。 红色的线是查询的顺序，已经被重复过搜索的顶点，要避免被搜索，直到你要搜索的都被搜索过了，然后去往回返找你的兄弟结点 看兄弟结点有没有被搜索过 API设计 类名 DepthFirstSearch 构造方法：DepthFirstSearch(Graph G,int s)：构造深度优先搜索对象，使用深度优先搜索找出G图中s顶点 的所有相通顶点 成员方法：1.private void dfs(Graph G, int v)：使用深度优先搜索找出G图中v顶点的所有相通顶点 ​ 2.public boolean marked(int w):判断w顶点与s顶点是否相通 ​ 3.public int count():获取与顶点s相通的所有顶点的总数 成员变量： ​ 1.private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索 ​ 2.private int count：记录有多少个顶点与s顶点相通 1234567891011121314151617181920212223242526272829303132333435363738public class DepthFirstSearch &#123; //索引代表顶点，值表示当前顶点是否已经被搜索 private boolean[] marked; //记录有多少个顶点与s顶点相通 private int count; //构造深度优先搜索对象，使用深度优先搜索找出G图中s顶点 的所有相通顶点 public DepthFirstSearch(Graph G,int s) &#123; //初始化marked数组 this.marked=new boolean[G.V()]; //初始化和顶点s相通的顶点的数量 this.count=0; dfs(G,s); &#125; //使用深度优先搜索找出G图中v顶点的所有相通顶点 private void dfs(Graph G,int v ) &#123; //把v顶点标识为已搜索 marked[v]=true; //没被搜索，遍历当前v顶点的邻接表 for(Integer w:G.adj(v)) &#123; //判断这些元素有没有被搜索过，如果没有搜索过，则递归调用dfs方法进行深度搜索 if(!marked[w]) &#123; dfs(G,w); &#125; &#125; count++; &#125; //判断顶点w与s顶点是否相通 public boolean marked(int w) &#123; return marked[w]; &#125; //获取与顶点s相通的所有顶点的总数 public int count() &#123; return count; &#125;&#125; 测试： 12345678910111213141516171819202122232425262728public class DepthFirstSearchTest &#123; public static void main(String[] args) &#123; //准备Graph对象 Graph graph=new Graph(13); graph.addEdge(0,5); graph.addEdge(0,6); graph.addEdge(0,1); graph.addEdge(0,2); graph.addEdge(5,3); graph.addEdge(5,4); graph.addEdge(3,4); graph.addEdge(4,6); graph.addEdge(7,8); graph.addEdge(9,11); graph.addEdge(9,10); graph.addEdge(9,12); graph.addEdge(11,12); //准备深度优先搜索对象 DepthFirstSearch dfs=new DepthFirstSearch(graph,0); //测试与某个顶点相通的顶点数量 System.out.println(dfs.count());//与0顶点相通的顶点数量 //测试某个0点与5点是否相通 boolean marked1=dfs.marked(5); System.out.println(marked1); &#125;&#125; 广度优先搜索如果遇到一个结点既有子结点，又有兄弟结点，那么先找兄弟结点，然后 找子结点。 红色代表查找的顺序 类名：BreadFirstSearch 构造方法：BreadthFirstSearch(Graph G,int s)：构造广度优先搜索对象，使用广度优先搜索找出G图中s顶点的所有相邻顶点 成员方法：1.private void bfs(Graph G, int v)：使用广度优先搜索找出G图中v顶点的所有相邻顶点 ​ 2.public boolean marked(int w):判断w顶点与s顶点是否相通 ​ 3.public int count():获取与顶点s相通的所有顶点的总数 成员变量： ​ 1.private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索 ​ 2.private int count：记录有多少个顶点与s顶点相通 ​ 3.private Queue waitSearch: 用来存储待搜索邻接表的点 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class BreadFirstSearch &#123; //索引代表顶点，值表示当前顶点是否已经被搜索 private boolean[] marked; //记录有多少个顶点与s顶点相通 private int count; //用来存储待搜索邻接表的点 private Queue&lt;Integer&gt; waitSearch; //构造广度优先搜索对象，使用广度优先搜索找出G图中s顶点的所有相邻顶点 public BreadFirstSearch(Graph G,int s) &#123; this.marked=new boolean[G.V()]; this.count=0; this.waitSearch=new Queue&lt;Integer&gt;(); bfs(G,s); &#125; private void bfs(Graph G,int v) &#123; //将当前v标识为已搜索 marked[v]=true; //还要让v进入队列待搜索 waitSearch.enqueue(v); //通过循环，如果队列不为空，则从队列中弹出一个待搜索的顶点进行搜索 while(!waitSearch.isEmpty()) &#123; //弹出一个待搜索的顶点 Integer wait=waitSearch.dequeue(); //遍历wait顶点的邻接表 for(Integer w: G.adj(wait)) &#123; //判断当前结点是否被搜索 if(!marked[w]) &#123; bfs(G,w); &#125; &#125; &#125; //让相通的顶点+1 count++; &#125; //判断w顶点是否与s顶点相通 public boolean marked(int w) &#123; return marked[w]; &#125; //获取与顶点s相通的所有顶点的总数 public int count() &#123; return count; &#125;&#125; 测试： 1234567891011121314151617181920212223242526public class BreadFirstSearchTest &#123; public static void main(String[] args) &#123; //准备Graph对象 Graph graph=new Graph(13); graph.addEdge(0,5); graph.addEdge(0,6); graph.addEdge(0,1); graph.addEdge(0,2); graph.addEdge(5,3); graph.addEdge(5,4); graph.addEdge(3,4); graph.addEdge(4,6); graph.addEdge(7,8); graph.addEdge(9,11); graph.addEdge(9,10); graph.addEdge(9,12); graph.addEdge(11,12); //准备深度优先搜索对象 BreadFirstSearch dfs=new BreadFirstSearch(graph,0); //测试与某个顶点相通的顶点数量 System.out.println(dfs.count());//与0顶点相通的顶点数量 //测试某个0点与5点是否相通 boolean marked1=dfs.marked(5); System.out.println(marked1); &#125;&#125; 畅通工程的续集总共有20个城市，目前已经修改好了7条道路，问9号城市和10号城市是否相通？9号城市和8号城市是否相通？ 解题思路： 1.创建一个图Graph对象，表示城市； ​ 2.分别调用 addEdge(0,1),addEdge(6,9),addEdge(3,8),addEdge(5,11),addEdge(2,12),addEdge(6,10),addEdge(4,8)，表示已 经修建好的道路把对应的城市连接起来； ​ 3.通过Graph对象和顶点9，构建DepthFirstSearch对象或BreadthFirstSearch对象； ​ 4.调用搜索对象的marked(10)方法和marked(8)方法，即可得到9和城市与10号城市以及9号城市与8号城市是否相 通。 123456789101112131415161718192021222324import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;public class Traffic_Project_test2 &#123; public static void main(String[] args) throws NumberFormatException, IOException &#123; BufferedReader br=new BufferedReader(new FileReader(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;)); int citynumber=Integer.parseInt(br.readLine()); Graph group=new Graph(citynumber); int roadnumber=Integer.parseInt(br.readLine()); for(int i=0;i&lt;roadnumber;i++) &#123; String line=br.readLine(); int p=Integer.parseInt(line.split(&quot; &quot;)[0]); int q=Integer.parseInt(line.split(&quot; &quot;)[1]); group.addEdge(p,q); &#125; DepthFirstSearch search=new DepthFirstSearch(group,9); //判断第九个城市和第八个第十个是否相通 System.out.println(search.marked(10)); System.out.println(search.marked(8)); &#125;&#125; 路径查找 类名 DepthFirstPaths 构造方法 DepthFirstPaths(Graph G,int s)：构造深度优先搜索对象，使用深度优先搜索找出G图中起点为 s的所有路径 成员方法 1.private void dfs(Graph G, int v)：使用深度优先搜索找出G图中v顶点的所有相通顶点 ​ 2.public boolean hasPathTo(int v):判断v顶点与s顶点是否存在路径 ​ 3.public Stack pathTo(int v):找出从起点s到顶点v的路径(就是该路径经过的顶点) 成员变量 1.private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索 ​ 2.private int s:起点 ​ 3.private int[] edgeTo:索引代表顶点，值代表从起点s到当前顶点路径上的最后一个顶点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class DepthFirstPaths &#123;//索引代表顶点，值表示当前顶点是否已经被搜索 private boolean[] marked; //起点 private int s; //索引代表顶点，值代表从起点s到当前顶点路径上的最后一个顶点 private int[] edgeTo; // public DepthFirstPaths(Graph G,int s) &#123; //初始化marked数组 this.marked=new boolean[G.V()]; //初始化s起点 this.s=s; //初始化edgeTo数组 this.edgeTo=new int[G.V()]; dfs(G,s); &#125; //使用深度优先搜索找出G图中v顶点的所有相通顶点 private void dfs(Graph G,int v) &#123; //把v标识为已搜索 marked[v]=true; //通过顶点v的邻接表，拿到每一个相邻的顶点，继续进行搜索 for(Integer w:G.adj(v)) &#123; //如果w没有被搜索则继续递归搜索 if(!marked[w]) &#123; edgeTo[w]=v;//到达顶点w路径上的最后一个顶点是v,通过v找到w的 dfs(G,w); &#125; &#125; &#125; //判断v顶点与s顶点是否存在路径 private boolean hasPathTo(int v) &#123; return marked[v]; &#125; //找出从起点s到顶点v的路径(就是该路径经过的顶点) public Stack&lt;Integer&gt; pathTo(int v)&#123; if(!hasPathTo(v)) &#123; return null; &#125; //创键栈对象，保存路径中的所有顶点 Stack&lt;Integer&gt; path=new Stack&lt;&gt;(); //通过循环，从顶点v开始，一直往前找找到起点为止 for(int x=v;x!=s;x=edgeTo[x]) &#123; path.push(x); &#125; //把起点s放到栈中 path.push(s); return path; &#125;&#125; 测试： 这个测试的例子就是上面右方那个图 1234567891011121314151617181920212223242526272829import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;public class DepthFirstSearchPathsTest &#123; public static void main(String[] args) throws IOException &#123; BufferedReader br=new BufferedReader(new FileReader(&quot;D:\\\\放乱七八糟\\\\b.txt&quot;)); int pointnumber=Integer.parseInt(br.readLine()); Graph g=new Graph(pointnumber); int edgenumber=Integer.parseInt(br.readLine()); for(int i=0;i&lt;edgenumber;i++) &#123; String line=br.readLine(); int p=Integer.parseInt(line.split(&quot; &quot;)[0]); int q=Integer.parseInt(line.split(&quot; &quot;)[1]); g.addEdge(p, q); &#125; DepthFirstPaths paths=new DepthFirstPaths(g,0); Stack&lt;Integer&gt; path=paths.pathTo(4); StringBuilder sb=new StringBuilder(); for(Integer v:path) &#123; sb.append(v+&quot;-&quot;); &#125; sb.deleteCharAt(sb.length()-1); System.out.println(sb); &#125;&#125; 有向图有向图是一副具有方向性的图，是由一组顶点和一组有方向的边组成的，每条方向的边都连着一对有序的顶点。 出度： 由某个顶点指出的边的个数称为该顶点的出度。 入度： 指向某个顶点的边的个数称为该顶点的入度。 有向路径： 由一系列顶点组成，对于其中的每个顶点都存在一条有向边，从它指向序列中的下一个顶点。 有向环： 一条至少含有一条边，且起点和终点相同的有向路径。 一副有向图中两个顶点v和w可能存在以下四种关系： 没有边相连； 存在从v到w的边v—&gt;w; 存在从w到v的边w—&gt;v 既存在w到v的边，也存在v到w的边，即双向连接； 有向图的API设计类名 Digraph 构造方法 Digraph(int V)：创建一个包含V个顶点但不包含边的有向图 成员方法 1.public int V():获取图中顶点的数量 2.public int E():获取图中边的数量 3.public void addEdge(int v,int w):向有向图中添加一条边 v-&gt;w 4.public Queue adj(int v)：获取由v指出的边所连接的所有顶点 5.private Digraph reverse():该图的反向图 成员变量 1.private final int V: 记录顶点数量 2.private int E: 记录边数量 3.private Queue[] adj: 邻接表 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Digraph &#123;//顶点数目 private final int V; //边的数目 private int E; //邻接表 private Queue&lt;Integer&gt;[] adj; public Digraph(int V) &#123; //初始化顶点数量 this.V=V; //初始化边的数量 this.E=0; //初始化邻接表 this.adj=new Queue[V]; for(int i=0;i&lt;adj.length;i++) &#123; adj[i]=new Queue&lt;Integer&gt;(); &#125; &#125; //获取顶点的数目 public int V() &#123; return V; &#125; //获取边的数目 public int E() &#123; return E; &#125; //往有向图中添加一条边 v-&gt;w public void addEdge(int v,int w) &#123; //让顶点w出现在顶点v的邻接表中，因为边是有方向的，最终，顶点v的邻接表中存储的相邻顶点的含义是v到其他顶点 adj[v].enqueue(w); E++; &#125; //获取由v指出的边所链接的顶点 public Queue&lt;Integer&gt; adj(int v)&#123; return adj[v]; &#125; //获取该图的反向图 private Digraph reverse() &#123; //创建有向图对象 Digraph r=new Digraph(V); for(int v=0;v&lt;V;v++) &#123; //获取由该顶点指出的所有边 for(Integer w:adj[v]) &#123;//原图中表示的是由v-&gt;w得边 r.addEdge(w, v);//将两个点反向添加，就可以让边都反向 &#125; &#125; return r; &#125;&#125; 拓扑排序给定一副有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素，此时就可以明 确的表示出每个顶点的优先级。下列是一副拓扑排序后的示意图： 如果有向图中有了环就无法对它进行拓扑排序了 检测有向图中的环类名 DirectedCircle 构造方法 DirectedCycle(Digraph G)：创建一个检测环对象，检测图G中是否有环 成员方法 1.private void dfs(Digraph G,int v)：基于深度优先搜索，检测图G中是否有环 2.public boolean hasCycle():判断图中是否有环 成员变量 1.private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索 2.private boolean hasCycle: 记录图中是否有环 3.private boolean[] onStack:索引代表顶点，使用栈的思想，记录当前顶点有没有已经处于正在 搜索的有向路径上 检测的一个步骤 API 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class DirectedCircle &#123; //索引代表顶点，值表示当前顶点是否已经被搜索 private boolean[] marked; //记录图中是否有环 private boolean hasCycle; //索引代表顶点，使用栈的思想，记录当前顶点有没有已经处于正在 搜索的有向路径上 private boolean[] onStack; //创建一个检测环对象，检测图G中是否有环 public DirectedCircle(Digraph G) &#123; //初始化marked数组 this.marked=new boolean[G.V()]; //初始化hasCycle this.hasCycle=false; //初始化onStack this.onStack=new boolean[G.V()]; //找到图中每一个顶点，让每一个顶点作为入口，调用一次dfs进行搜索 for(int v=0;v&lt;G.V();v++) &#123; //判断如果当前顶点还没有搜索过，则调用dfs进行搜索 if(!marked[v]) &#123; dfs(G,v); &#125; &#125;​ ​ &#125; //基于深度优先搜索，检测图G中是否有环 private void dfs(Digraph G,int v) &#123; //把顶点v标识为已搜索 marked[v]=true; //把当前顶点进栈 onStack[v]=true; //进行深度搜索 for(Integer w:G.adj(v)) &#123; //如果当前结点w没有被搜索过则继续递归调用dfs方法 if(!marked[w]) &#123; dfs(G,w); &#125; //判断当前顶点w是否已经在栈中，如果已经在栈中，证明当前顶点之前处于正在搜索的状态，那么现在又要搜索一次，就证明检测到环了 if(onStack[w]) &#123; hasCycle=true; return ; &#125; &#125; //让当前节点出栈 onStack[v]=false; &#125; //判断图中是否有环 public boolean hasCycle() &#123; return hasCycle; &#125;&#125; 顶点排序类名：DepthFirstOrder 构造方法 DepthFirstOrder(Digraph G)：创建一个顶点排序对象，生成顶点线性序列； 成员方法：1.private void dfs(Digraph G,int v)：基于深度优先搜索，生成顶点线性序列 ​ 2.public Stack reversePost():获取顶点线性序列 成员变量：1.private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索 ​ 2.private Stack reversePost: 使用栈，存储顶点序列 顶点排序的具体定义去看资料 1234567891011121314151617181920212223242526272829303132333435363738public class DepthFirstOrder &#123; //索引代表顶点，值表示当前顶点是否已经被搜索 private boolean[] marked; //使用栈，存储顶点序列 private Stack reversePost; //创建一个检测环对象，检测图G中是否有环 public DepthFirstOrder(Digraph G) &#123; //初始化marked数组 this.marked=new boolean[G.V()]; //初始化reversePost栈 this.reversePost=new Stack&lt;Integer&gt;(); //让图中的每一个顶点作为一次入口完成深度搜索 for(int v=0;v&lt;G.V();v++) &#123; if(!marked[v]) &#123; dfs(G,v); &#125; &#125; &#125; //基于深度优先搜索，生成顶点线性序列 private void dfs(Digraph G,int v) &#123; marked[v]=true; for(Integer w:G.adj(v)) &#123; if(!marked[w]) &#123; dfs(G,w); &#125; &#125; //让顶点v进栈 reversePost.push(v); &#125; //获取顶点线性序列 public Stack reversePost() &#123; return reversePost; &#125;&#125; 拓扑排序的实现那么拓扑排序就很简单了，基于一幅图，先检测有没有环，如果没有环， 则调用顶点排序即可 类名 TopoLogical 构造方法 TopoLogical(Digraph G)：构造拓扑排序对象 成员方法 1.public boolean isCycle()：判断图G是否有环 ​ 2.public Stack order():获取拓扑排序的所有顶点 成员变量 1.private Stack order: 顶点的拓扑排序 API 123456789101112131415161718192021public class TopoLogical &#123; //顶点的拓扑排序 private Stack order; public TopoLogical(Digraph G) &#123; //先检测图中有没有环 DirectedCircle circle=new DirectedCircle(G); //判断G图中有没有环，如果没有环，则进行顶点排序，创建一个顶点排序对象 if(!circle.hasCycle()) &#123; DepthFirstOrder depthFirstOrder=new DepthFirstOrder(G); order=depthFirstOrder.reversePost(); &#125; &#125; //判断图G是否有环 public boolean isCycle() &#123; return order==null; &#125; //获取拓扑排序的所有顶点 public Stack order() &#123; return order; &#125;&#125; 测试： 123456789101112131415161718192021public class TopLogicalTest &#123; public static void main(String[] args) &#123; //准备有向图 Digraph digraph=new Digraph(6); digraph.addEdge(0, 2); digraph.addEdge(0, 3); digraph.addEdge(2, 4); digraph.addEdge(3, 4); digraph.addEdge(4, 5); digraph.addEdge(1,3); //通过TopoLogical对象对有向图中的顶点进行排序 TopoLogical topological=new TopoLogical(digraph); //获取顶点的线性序列，进行打印就可以了 Stack&lt;Integer&gt; order=topological.order(); for(Integer s:order) &#123; System.out.println(s); &#125; &#125;&#125; 例子就是这个 加权无向图每一条边都有一个权值 两个顶点之间可以有多条路径，可以通过权值来判断最好的路径 加权无向图的表示加权无向图的边是用对象来表示的 加权无向图中的边我们就不能简单的使用v-w两个顶点表示了，而必须要给边关联一个权重值，因此我们可以使用 对象来描述一条边。 边的API 类名 Edge implements Comparable 构造方法 Edge(int v,int w,double weight)：通过顶点v和w，以及权重weight值构造一个边对象 成员方法 1.public double weight():获取边的权重值 ​ 2.public int either():获取边上的一个点 ​ 3.public int other(int vertex)):获取边上除了顶点vertex外的另外一个顶点 ​ 4.public int compareTo(Edge that)：比较当前边和参数that边的权重，如果当前边权重大，返回 1，如果一样大，返回0，如果当前权重小，返回-1 成员变量 1.private final int v：顶点一 2.private final int w：顶点二 3.private final double weight：当前边的权重 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Edge implements Comparable&lt;Edge&gt;&#123;private final int v;//顶点一private final int w;//顶点二private final double weight;//权重值//通过顶点v和w，以及权重weight值构成一个边对象public Edge(int v,int w,double weight) &#123; this.v=v; this.w=w; this.weight=weight;&#125;//获取边的权重值public double weight() &#123; return weight;&#125;//获取边上的一个点public int either() &#123; return v;&#125;//获取边上除了顶点vertex外的另外一个顶点public int other(int vertex) &#123; if(vertex==v) &#123; return w; &#125; else &#123; return v; &#125;&#125;//比较当前边和参数that边的权重，如果当前边权重大，返回 1，如果一样大，返回0，如果当前权重小，返回-1 public int compareTo(Edge that) &#123; int cmp=0; if(this.weight()&gt;that.weight()) &#123; cmp=1; &#125; else if(this.weight()&lt;that.weight()) &#123; cmp=-1; &#125; else &#123; cmp=0; &#125; return cmp; &#125;&#125; 加权无向图的API类名：EdgeWeightedGraph 构造方法 EdgeWeightedGraph(int V)：创建一个含有V个顶点的空加权无向图 成员方法： 1.public int V():获取图中顶点的数量 2.public int E():获取图中边的数量 3.public void addEdge(Edge e):向加权无向图中添加一条边e 4.public Queue adj(int v)：获取和顶点v关联的所有 5.public Queue edges()：获取加权无向图的所有边 成员变量 1.private final int V: 记录顶点数量 2.private int E: 记录边数量 3.private Queue[] adj: 邻接表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class EdgeWeightedGraph &#123; //记录顶点数量 private final int V; //记录边数量 private int E; //邻接表 private Queue&lt;Edge&gt;[] adj; //创建一个含有V个顶点的空加权无向图 public EdgeWeightedGraph(int V) &#123; //初始化顶点的数量 this.V=V; //初始化边的数量 this.E=0; //初始化邻接表 this.adj=new Queue[V]; for(int i=0;i&lt;adj.length;i++) &#123; adj[i]=new Queue&lt;Edge&gt;(); &#125; &#125; //获取图中顶点的数量 public int V() &#123; return V; &#125; //获取图中边的数量 public int E() &#123; return E; &#125; //往无向图中添加一条边e public void addEdge(Edge e) &#123; //获取这条边的两个顶点 int v=e.either(); int w=e.other(v); adj[v].enqueue(e); adj[w].enqueue(e); //边的数量加一 E++; &#125; //获取顶点v所关联的所有边 public Queue&lt;Edge&gt; adj(int v)&#123; return adj[v]; &#125; //获取加权无向图的所有边 public Queue&lt;Edge&gt; edges() &#123; //创建一个队列对象存储所有边 Queue&lt;Edge&gt; alledges=new Queue&lt;&gt;(); //遍历图中的每一个顶点，找到该顶点的邻接表，邻接表中存储了该顶点关联的每一条边 //因为这是无向图，所以同一条边同时出现在了它关联的两个点的邻接表中，如果按照上述方法会一条边出现两次，需要让一条边只记录一次 //解决方法就是如果当前结点小于另一个结点的时候才会添加，这样就砍去了一半的情况 for(int i=0;i&lt;V;i++) &#123; for(Edge w:adj[i]) &#123; if(w.other(i)&lt;i) &#123; alledges.enqueue(w); &#125; &#125; &#125; return alledges; &#125;&#125; 最小生成树图的生成树是它的一棵含有其所有顶点的无环连通子图，一副加权无向图的最小生成树它的一棵权值(树中所有边的权重之和)最小的生成树 最小生成树原理树的性质 切分定理 详情见资料 贪心算法 详情见资料 Prim算法 Prim算法的切分规则： 把最小生成树中的顶点看做是一个集合，把不在最小生成树中的顶点看做是另外一个集合。 把红线连着的点看成一个集合，把剩下的点看成一个集合然后用切分算法去找到最小横切边然后标红 prem算法的API设计 类名：PrimMST 构造方法 PrimMST(EdgeWeightedGraph G)：根据一副加权无向图，创建最小生成树计算对象； 成员方法 1.private void visit(EdgeWeightedGraph G, int v)：将顶点v添加到最小生成树中，并且更新数 据 2.public Queue edges():获取最小生成树的所有边 成员变量： 1.private Edge[] edgeTo: 索引代表顶点，值表示当前顶点和最小生成树之间的最短边 2.private double[] distTo: 索引代表顶点，值表示当前顶点和最小生成树之间的最短边的权重 3.private boolean[] marked:索引代表顶点，如果当前顶点已经在树中，则值为true，否则为 false 4.private IndexMinPriorityQueue pq:存放树中顶点与非树中顶点之间的有效横切边 Prim算法的实现原理 详情见资料 最小生成树中的点是一个集合，其他的是一个集合，要往最小生成树中加点，就是找连接两个集合的边的权值最小的那个，把这个边中不属于最小生成树中的顶点加进去 Prim算法的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import 优先队列.IndexMinPriorityQueue;public class PrimMST &#123; //索引代表顶点，值表示当前顶点和最小生成树之间的最短边 private Edge[] edgeTo; //索引代表顶点，值表示当前顶点和最小生成树之间的最短边的权重 private double[] distTo; //索引代表顶点，如果当前顶点已经在树中，则值为true，否则为 false private boolean[] marked; //存放树中顶点与非树中顶点之间的有效横切边 private IndexMinPriorityQueue pq; //根据一副加权无向图，创建最小生成树计算对象； public PrimMST(EdgeWeightedGraph G) &#123; this.edgeTo=new Edge[G.V()]; this.distTo=new double[G.V()]; for(int i=0;i&lt;distTo.length;i++) &#123; distTo[i]=Double.POSITIVE_INFINITY; &#125; this.marked=new boolean[G.V()]; pq=new IndexMinPriorityQueue&lt;Double&gt;(G.V()); //默认让顶点0进入到树中，但是树中只有一个顶点0，因此零顶点默认没有与其他顶点相连，所以让distTo对应位置的值存储0.0 distTo[0]=0.0; pq.insert(0, 0.0); //遍历索引最小优先队列，拿到最小的横切边对应的顶点，把该顶点加入到最小生成树中 while(!pq.isEmpty()) &#123; visit(G,pq.delMin()); &#125; &#125; //将顶点v添加到最小生成树中，并且更新数 据 private void visit(EdgeWeightedGraph G, int v) &#123; //把顶点v添加到最小生成树中 marked[v]=true; //更新数据 for(Edge e:G.adj(v)) &#123; //获取e边的另外一个顶点 int w=e.other(v); //判断另外一个顶点是不是已经在树中，如果在树中不做处理，不在树中，更新数据 if(marked[w]) &#123; continue; &#125; //判断边e的权重是否小于从w顶点到树中已经存在最小边的权重 if(e.weight()&lt;distTo[w]) &#123; //更新数据 edgeTo[w]=e; distTo[w]=e.weight(); if(pq.contains(w)) &#123; pq.changeItem(w,e.weight()); &#125; else &#123; pq.insert(w, e.weight()); &#125; &#125; &#125; &#125; //获取最小生成树的所有边 public Queue edges() &#123; Queue&lt;Edge&gt; alledges=new Queue&lt;&gt;(); for(int i=0;i&lt;edgeTo.length;i++) &#123; if(edgeTo[i]!=null) &#123; alledges.enqueue(edgeTo[i]); &#125; &#125; return alledges; &#125;&#125; 测试： 1234567891011121314151617181920212223242526272829303132333435363738import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;public class PrimMSTTest &#123;public static void main(String []args) throws NumberFormatException, IOException &#123; //先创建一个加权无向图 BufferedReader br=new BufferedReader(new FileReader(&quot;D:\\\\放乱七八糟\\\\c.txt&quot;)); int pointnumbers=Integer.parseInt(br.readLine()); EdgeWeightedGraph G=new EdgeWeightedGraph(pointnumbers); int edgenumbers=Integer.parseInt(br.readLine()); for(int i=0;i&lt;edgenumbers;i++) &#123; String []line=br.readLine().split(&quot; &quot;); int v=Integer.parseInt(line[0]); int w=Integer.parseInt(line[1]); double weight=Double.parseDouble(line[2]); //构建加权无向边 Edge edge=new Edge(v,w,weight); G.addEdge(edge); &#125; //创建一个PrimMST对象，计算加权无向图中的最小生成树 PrimMST primMST=new PrimMST(G); //获取最小生成树中的所有边 Queue&lt;Edge&gt; edges=primMST.edges(); //遍历打印所有的边 for(Edge e:edges) &#123; int v=e.either(); int w=e.other(v); double weight=e.weight(); System.out.println(v+&quot;-&quot;+w+&quot;::&quot;+weight); &#125;&#125;&#125; kruskal算法 kruskal算法API设计 类名 KruskalMST 构造方法 KruskalMST(EdgeWeightedGraph G)：根据一副加权无向图，创建最小生成树计算对象； 成员方法 1.public Queue edges():获取最小生成树的所有边 成员变量 1.private Queue mst：保存最小生成树的所有边 ​ 2.private UF_Tree_Weighted uf: 索引代表顶点，使用uf.connect(v,w)可以判断顶点v和顶点w是否在 同一颗树中，使用uf.union(v,w)可以把顶点v所在的树和顶点w所在的树合并 ​ 3.private MinPriorityQueue pq: 存储图中所有的边，使用最小优先队列，对边按照权重进行排序 原理：通过pq对所有边的权重进行排序，然后找到最小的边加入到一个树中，然后再找第二小的边，看这个边的两个点是否在同一个树中，不在则把两个点所在的树连接起来，在就不做处理 每一个顶点在最开始的时候都是一个树，然后用并查集对它进行分组 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import 优先队列.MinPriorityQueue;import 树.UF_TREE_WEIGHTED;public class kruskalMST &#123; //保存最小生成树的所有边 private Queue mst; //索引代表顶点，使用uf.connect(v,w)可以判断顶点v和顶点w是否在 同一颗树中，使用uf.union(v,w)可以把顶点v所在的树和顶点w所在的树合并 private UF_TREE_WEIGHTED uf ; //存储图中所有的边，使用最小优先队列，对边按照权重进行排序 private MinPriorityQueue&lt;Edge&gt; pq; //根据一副加权无向图，创建最小生成树计算对象； public kruskalMST(EdgeWeightedGraph G) &#123; //初始化mst mst=new Queue&lt;Edge&gt;(); //初始化uf uf=new UF_TREE_WEIGHTED(G.V()); //初始化pq pq=new MinPriorityQueue&lt;&gt;(G.E()+1); //把图中所有的边存储到pq中 for(Edge e:G.edges()) &#123; pq.insert(e); &#125; //遍历pq队列，拿到最小权重的边进行处理 while(!pq.isEmpty()&amp;&amp;mst.size()&lt;G.V()-1) &#123; //找到权重最小的边 Edge e=pq.delMin(); //找到该边的两个顶点 int v=e.either(); int w=e.other(v); //判断这两个顶点是否已经在同一颗树中，如果在同一颗树中，不对该边做处理，不在一棵树中，则让这两个顶点属于的两棵树合并成一颗树 if(uf.connected(v,w)) &#123; continue; &#125; uf.union(v, w); //让边e进入到mst队列中 mst.enqueue(e); &#125; &#125; //获取最小生成树的所有边 public Queue edges() &#123; return mst; &#125;&#125; 加权有向图加权有向图边的表示 类名 DirectedEdge 构造方法 DirectedEdge(int v,int w,double weight)：通过顶点v和w，以及权重weight值构造一个边对象 成员方法 1.public double weight():获取边的权重值 ​ 2.public int from():获取有向边的起点 ​ 3.public int to():获取有向边的终点 成员变量 1.private final int v：起点 ​ 2.private final int w：终点 ​ 3.private final double weight：当前边的权重 1234567891011121314151617181920212223242526public class DirectedEdge &#123;private final int v;//起点private final int w;//终点private final double weight;//当前边的权重//通过顶点v和w，以及权重weight值构造一个边对象public DirectedEdge(int v,int w,double weight) &#123; this.v=v; this.w=w; this.weight=weight;&#125;//获取边的权重值public double weight() &#123; return weight;&#125;//获取有向边的起点public int from() &#123; return v;&#125; //获取有向边的终点public int to() &#123; return w;&#125;&#125; 加权有向图的API类名 EdgeWeightedDigraph 构造方法 EdgeWeightedDigraph(int V)：创建一个含有V个顶点的空加权有向图 成员方法 1.public int V():获取图中顶点的数量 2.public int E():获取图中边的数量 3.public void addEdge(DirectedEdge e):向加权有向图中添加一条边e 4.public Queue adj(int v)：获取由顶点v指出的所有的边 5.public Queue edges()：获取加权有向图的所有边 成员变量 1.private final int V: 记录顶点数量 2.private int E: 记录边数量 3.private Queue[] adj: 邻接表 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class EdgeWeightedDigraph &#123; //记录顶点数量 private final int V; //记录边数量 private int E; //邻接表 private Queue&lt;DirectedEdge&gt;[] adj; //创建一个含有V个顶点的空加权有向图 public EdgeWeightedDigraph(int V)&#123; //初始化顶点数量 this.V=V; //初始化边的数量 this.E=0; //初始化邻接表 this.adj=new Queue[V]; for(int i=0;i&lt;adj.length;i++) &#123; adj[i]=new Queue&lt;DirectedEdge&gt;(); &#125; &#125; //获取图中顶点的数量 public int V() &#123; return V; &#125; //获取图中边的数量 public int E() &#123; return E;&#125;//向加权有向图中添加一条边e public void addEdge(DirectedEdge e) &#123; //边e是有方向的，只需要让e出现在起点的邻接表中即可 int v=e.from(); adj[v].enqueue(e); E++;&#125;//获取由顶点v指出的所有的边 public Queue adj(int v) &#123; return adj[v];&#125;//获取加权有向图的所有边public Queue edges() &#123;//遍历图中的每一个顶点然后得到该顶点的邻接表，遍历得到每一条边添加到队列中Queue&lt;DirectedEdge&gt; edges=new Queue&lt;DirectedEdge&gt;();for(int v=0;v&lt;V;v++) &#123; for(DirectedEdge edge:adj[v]) &#123; edges.enqueue(edge); &#125;&#125;return edges;&#125;&#125; 最短路径在一副加权有向图中，从顶点s到顶点t的最短路径是所有从顶点s到顶点t的路径中总权重最小的那条路径。 性质： 1.路径具有方向性； ​ 2 .权重不一定等价于距离。权重可以是距离、时间、花费等内容，权重最小指的是成本最低 ​ 3.只考虑连通图。一副图中并不是所有的顶点都是可达的，如果s和t不可达，那么它们之间也就不存在最短路径， 为了简化问题，这里只考虑连通图。 ​ 4.最短路径不一定是唯一的。从一个顶点到达另外一个顶点的权重最小的路径可能会有很多条，这里只需要找出一 条即可 最短路径树： 给定一副加权有向图和一个顶点s，以s为起点的一棵最短路径树是图的一副子图，它包含顶点s以及从s可达的所有顶点。这棵有向树的根结点为s，树的每条路径都是有向图中的一条最短路径。 说白了就是这个树里s顶点到每一个顶点的权重都是最小的 最短路径API设计 类名 DijkstraSP 构造方法 public DijkstraSP(EdgeWeightedDigraph G, int s)：根据一副加权有向图G和顶点s，创建一个计 算顶点为s的最短路径树对象 成员方法 1.private void relax(EdgeWeightedDigraph G, int v)：松弛图G中的顶点v ​ 2.public double distTo(int v):获取从顶点s到顶点v的最短路径的总权重 ​ 3.public boolean hasPathTo(int v):判断从顶点s到顶点v是否可达 ​ 4.public Queue pathTo(int v):查询从起点s到顶点v的最短路径中所有的边 成员变量 1.private DirectedEdge[] edgeTo: 索引代表顶点，值表示从顶点s到当前顶点的最短路径上的最 后一条边 ​ 2.private double[] distTo: 索引代表顶点，值从顶点s到当前顶点的最短路径的总权重 ​ 3.private IndexMinPriorityQueue pq:存放树中顶点与非树中顶点之间的有效横切边 松弛技术 就是比较w点到s点的距离是经过v点更远，还是不经过v直接到s更远 详情见资料 Dijstra算法实现最短路径12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class DijkstraSP &#123; //索引代表顶点，值表示从顶点s到当前顶点的最短路径上的最后一条边 private DirectedEdge[] edgeTo; //索引代表顶点，值从顶点s到当前顶点的最短路径的总权重 private double[] distTo; //存放树中顶点与非树中顶点之间的有效横切边 private IndexMinPriorityQueue pq; //根据一副加权有向图G和顶点s，创建一个计 算顶点为s的最短路径树对象 public DijkstraSP(EdgeWeightedDigraph G, int s) &#123; //初始化edgeTo this.edgeTo=new DirectedEdge[G.V()]; //初始化distTo this.distTo=new double[G.V()]; for(int i=0;i&lt;distTo.length;i++) &#123; distTo[i]=Double.POSITIVE_INFINITY; &#125; //初始化pq this.pq=new IndexMinPriorityQueue&lt;&gt;(G.V()); //找到图G中以顶点s为起点的最短路径 //默认让顶点s进入到最短路径树中 distTo[s]=0.0; pq.insert(s, 0.0); //遍历pq while(!pq.isEmpty()) &#123; relax(G,pq.delMin()); &#125; &#125; //松弛图G中的顶点v private void relax(EdgeWeightedDigraph G, int v) &#123; for(DirectedEdge edge:G.adj(v)) &#123; //获取到该边中的终点w int w=edge.to(); //通过松弛技术，判断从起点s到顶点w的最短路径是否需要从顶点s到顶点v，然后再由顶点v到顶点w if(distTo(v)+edge.weight()&lt;distTo(w)) &#123; distTo[w]=distTo(v)+edge.weight(); edgeTo[w]=edge;//更新数据 //判断pq中是否已经存在顶点w，如果存在则更新权重，如果不存在则直接添加 if(pq.contains(w)) &#123; pq.changeItem(w, distTo(w)); &#125; else &#123; pq.insert(w, distTo(w)); &#125; &#125; &#125; &#125; //获取从顶点s到顶点v的最短路径的总权重 public double distTo(int v)&#123; return distTo[v]; &#125; //判断从顶点s到顶点v是否可达 public boolean hasPathTo(int v) &#123; return distTo[v]&lt;Double.POSITIVE_INFINITY; &#125;//查询从起点s到顶点v的最短路径中所有的边 public Queue&lt;DirectedEdge&gt; pathTo(int v) &#123; //从顶点s到顶点v是否可达，如果不可达，直接返回null if(!hasPathTo(v)) &#123; return null; &#125; Queue&lt;DirectedEdge&gt; allEdges=new Queue&lt;&gt;(); while(true) &#123; DirectedEdge e=edgeTo[v]; if(e==null) &#123; break; &#125; allEdges.enqueue(e); v=e.from(); &#125; &#125;&#125; 测试 最小生成树的测试差不多 蓝桥杯准备提交题目不能有包名，且类必须要Main类，而且用到别的包的时候要导入 一个可以看数据结构的网站 https://programmercarl.com/ java基础 跳出两层循环,在两层循环外加上OUT：然后代码处用的是break OUT; 跳出多层循环可以类推 123456789101112OUT: for(int i=0;i&lt;number-1;i++)&#123; for(int j=i+1;j&lt;number;j++)&#123; if(a[i]+a[j]==sum)&#123; min=i; max=j; break OUT; &#125; &#125; &#125; 泛型数组对象 泛型的实例化对象不能直接创建 //初始化 public SequenceList(int capacity) &#123; //获取泛型对象的数组 eles=(T[])new Object[capacity]; N=0; &#125; 按照key或者value对map排序的方法 Map会根据key的大小来自动排序 因为LinekedHashMap是按照顺序添加的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.*;class compare1 implements Comparator&lt;Map.Entry&gt;&#123; @Override public int compare(Map.Entry o1,Map.Entry o2) &#123; return (int)(o2.getValue())-(int)(o1.getValue());//注意这个地方的()缺一不可 &#125;&#125;class Main&#123; public static void main(String []args)&#123; Scanner in=new Scanner(System.in); String a=in.nextLine(); String b[]=a.split(&quot; &quot;); Hashtable&lt;String,Integer&gt; c=new Hashtable&lt;String,Integer&gt;(); int count =0; for(int i=0;i&lt;b.length;i++) &#123; if(c.containsKey(b[i])) &#123; c.put(b[i],c.get(b[i])+1); &#125; else &#123; c.put(b[i],1); &#125; &#125; List list=new LinkedList(c.entrySet()); compare1 q=new compare1(); Collections.sort(list,q); Map sortedMap=new LinkedHashMap();//这个地方必须使用LinkedHashMap for(Iterator it=list.iterator();it.hasNext();) &#123; Map.Entry entry=(Map.Entry)it.next();//这里的迭代器如果加泛型&lt;Iterator&gt;,就不用强制转换了 sortedMap.put(entry.getKey(), entry.getValue());&#125; Set h=sortedMap.keySet(); Iterator&lt;String&gt; r=h.iterator(); while(r.hasNext()) &#123; String i=r.next(); System.out.println(i+&quot;:&quot;+ sortedMap.get(i)); &#125; &#125;&#125; 用函数法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.*;import java.util.Map.Entry;class Compare implements Comparator&lt;Map.Entry&gt;&#123; @Override public int compare(Map.Entry o1,Map.Entry o2) &#123; return (int)(o2.getValue())-(int)(o1.getValue()); &#125;&#125;class Main&#123; public static Map getMap(Map unsortedMap) &#123; List a=new ArrayList(unsortedMap.entrySet()); Compare b=new Compare(); Collections.sort(a,b); Map sortedMap=new LinkedHashMap();//这里必须是LinkedHashMap for(Iterator it=a.iterator();it.hasNext();) &#123; Map.Entry entry=(Map.Entry)it.next(); sortedMap.put(entry.getKey(), entry.getValue()); &#125; return sortedMap; &#125; public static void main(String []args) &#123; Scanner in=new Scanner(System.in); String a=in.nextLine(); String b[]=a.split(&quot; &quot;); Hashtable&lt;String,Integer&gt; c=new Hashtable&lt;String,Integer&gt;(); int count =0; for(int i=0;i&lt;b.length;i++) &#123; if(c.containsKey(b[i])) &#123; c.put(b[i],c.get(b[i])+1); &#125; else &#123; c.put(b[i],1); &#125; &#125; Map n=getMap(c); Set i=n.keySet(); Iterator&lt;String&gt; e=i.iterator(); while(e.hasNext()) &#123; String t=e.next(); System.out.println(t+&quot;:&quot;+n.get(t)); &#125; &#125;&#125;就是java是向下兼容的，如果函数返回类型是Map其实是返回的只要是Map的子类的实例化对象都可以 如果函数的参数类型是Map类型，其实这个参数只要是Map子类的实例化对象都可以 ​ 当集合或者Iterator没有泛型的时候，就是很多类似的如果没有泛型获取里面集合里面对象之后，是不能直接调用集合中对象特有的方法的 hashmap.getOrDefault(key,0); 这个意思就是如果map中没有key，就返回0，hashmap.get(key)如果没有key会报错 while(scanner.hasNext()){ &#x2F;&#x2F;用来进行持续的输入 } 用BufferedReader方式实现快读，防止考试中有题目是大量输入 line.split(“ +”)如果有多个空格要分开就用这个+号，是正则表达式 有些题目，就是求总和的地方最好是用long类型的因为有的时候测试的数据量会比较大 判断一个数是否是完全平方数 12345678public static boolean isQurt(int a) &#123; //它是Math.sqrt的返回值是浮点数 int b=(int)Math.sqrt(a);if(b*b==a) &#123; return true;&#125; return false;&#125; 日期模拟 本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。 19491949 年的国庆节（ 1010 月 11 日）是星期六。 今年（20122012）的国庆节是星期一。 那么，从建国到现在，有几次国庆节正好是星期日呢？ 不要求写出具体是哪些年，只要一个数 这是利用w数组模仿一个月有多少天，根据是否闰年判断二月的天数 用w，y，m，d来模拟日历 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import java.util.Scanner;//1:无需package//2: 类名必须Main, 不可修改public class Main &#123;static int w[]=&#123;0,31,30,31,30,31,30,31,31,30,31,30,31&#125;;static int y=1949;static int m=10;static int d=1;static int sum=0;static int day=6； public static void main(String[] args) &#123; while(y!=2012||m!=10||d!=1)&#123; if(y%400==0||(y%4==0&amp;&amp;y%100!=0))&#123; w[2]=29; &#125; else w[2]=28; if(m==10&amp;&amp;d==1&amp;&amp;day==7)&#123; sum++; &#125; d++; day++; if(day&gt;7)&#123; day=1; &#125; if(d&gt;w[m])&#123; d=1; m++; &#125; if(m&gt;12)&#123; m=1; y++; &#125; &#125; System.out.println(sum); &#125;&#125; 16.基础语法巩固实战一 得到了1，3，5三个数字想要得到135步骤是 120*10+1=11*10+3=13,然后13*10+5 题目：输入一个数，然后对其进行翻转 12345678910111213141516171819public class Main&#123; public static void main(String []args) &#123; Scanner scanner=new Scanner(System.in); //输入要反转的整数 int number=scanner.nextInt(); int sum=0; while(number&gt;0) &#123; sum=sum*10+number%10; number=number/10; &#125; System.out.println(sum); &#125;&#125; 123456789101112131415public class Main&#123; public static void main(String []args) &#123; Scanner scanner=new Scanner(System.in); //输入要反转的整数 int number=scanner.nextInt(); //利用字符串反转的方法 String reversenumber=new StringBuffer(String.valueOf(number)).reverse().toString(); System.out.println(reversenumber); &#125;&#125; 二.交换值不用变量省掉一个空间 第一种方法 正常交换a和b ：int temp&#x3D;a; int a&#x3D;b; int b&#x3D;temp; 省掉空间：a&#x3D;a+b; b&#x3D;a-b; a&#x3D;a-b 第二种方法 a&#x3D;a^b ,b&#x3D;a^b ,a&#x3D;a^b 三，获取三个数当中的最大值 第一种方法 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Main&#123; public static void main(String []args) &#123; Scanner scanner=new Scanner(System.in); int a=scanner.nextInt(); int b=scanner.nextInt(); int c=scanner.nextInt(); int max=get3Max(a,b,c); System.out.println(max); &#125; public static int get3Max(int a,int b,int c) &#123; if(a&gt;b) &#123; if(a&gt;c) &#123; return a; &#125; else &#123; return c; &#125; &#125; else &#123; if(b&gt;c) &#123; return b; &#125; else &#123; return c; &#125; &#125; &#125;&#125; 第二种方法我就比较熟悉了 就是设立一个最大值max一开始第一个数或者等于0然后把这个max和参与比较的数轮流比较，找到比max大的就赋值给max，最后max就是这些数中的最大值 第三种方法 Math.max(Math.max(a,b),c)来获得三个数的最大值 18.优雅的型号图按画实心圆和空心圆 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package 排序算法;import 基础结构.BinaryTree;import 基础结构.Queue;import java.util.ArrayList;import java.util.Scanner;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.List;public class Main&#123; public static void main(String []args) &#123; circle(16); circle2(16); &#125; public static void circle(int r) &#123; for(int y=-r;y&lt;=r;y+=2) &#123; for(int x=-r;x&lt;=r;x++) &#123; if(x*x+y*y&lt;=r*r) &#123; System.out.print(&quot;*&quot;); &#125; else &#123; System.out.print(&quot; &quot;); &#125; &#125; System.out.println(); &#125; &#125; public static void circle2(int r) &#123; for(int y=-r;y&lt;=r;y+=2) &#123; int x=(int)Math.sqrt(r*r-y*y); for(int i=0;i&lt;r-x;i++) &#123; System.out.print(&quot; &quot;); &#125; System.out.print(&quot;*&quot;); for(int i=0;i&lt;2*x;i++) &#123; System.out.print(&quot; &quot;); &#125; System.out.print(&quot;*&quot;); System.out.println(); &#125; &#125;&#125; 爱心的公式 public static void love() { 1234567891011121314 for(double y=2;y&gt;=-3;y-=0.1) &#123; for(double x=-4;x&lt;=4;x+=0.05) &#123; if(Math.pow(x*x+y*y-1,3)-x*x*y*y*y&lt;=0) &#123; System.out.print(&quot;*&quot;); &#125; else &#123; System.out.print(&quot; &quot;); &#125; &#125; System.out.println(); &#125; &#125; 取值没看出来特别的，就是x和y的开头和结尾必须一正一负才行 191.判断一个数的二进制形式有多少个1 Integer类的函数用法 ​ int a&#x3D;Integer.bitCount(number) ; 返回number这个long或者int类型数字的二进制数中1的个数 ​ int b&#x3D;Integer.toString(a,2) 这是把a这个Integer转换为它二进制数对应得字符串,第二个参数是进制 ​ String c&#x3D; Integer.parseInt(a); 把ca转换为String类型的 求一个数的二进制数中有多少个1 这些数和1&amp;，不管这个数二进制有多少位和1&amp;除了最后一位其他肯定全是0，最后一位如果是1那么&amp;结果就是1，如果是0那么&amp;结果就是0 12345678910111213141516171819202122232425public class Main&#123; public static void main(String []args) &#123; Scanner scan=new Scanner(System.in); int count=scan.nextInt(); int number=0; while(count&gt;0) &#123; //这个括号必须有 if((count&amp;1)==1) &#123; number++; &#125; count&gt;&gt;=1; &#125; System.out.println(number); scan.close(); &#125;&#125; 判断一个数是否为2的幂 输出一下这些2的幂的数的二进制的形式，可以发现规律，2的幂的二进制数只有一个1 这个例子是没把1当作2的幂 12345678910111213141516171819202122232425262728293031323334353637public class Main &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int number=scan.nextInt(); if(number==1)&#123; System.out.println(&quot;NO&quot;); return ; &#125; int count=Integer.bitCount(number); if(count==1)&#123; System.out.println(&quot;YES&quot;); &#125; else &#123; System.out.println(&quot;NO&quot;); &#125; scan.close(); &#125;&#125; 视频二十进位模拟与数位拆分求a和b两个数最后两位的和，获得两位就是a%100,获得最后三位就是a%1000,获得最后一位就是a%10 求a和b两个数相加进位多少次 这个if(a&#x3D;&#x3D;0&amp;&amp;b&#x3D;&#x3D;0) break; 不能写在for循环里面，否则会漏掉进位，还有for循环那个次数，如果不够用，可以设置的再大一点 视频二十一最大公约数和最小公倍数求两个数的最大公约数 这个是辗转相除法，24 和15的最大公约数是 与15和24%15的最大公约数相同，一直到小的那个值等于0，另一个值就是最大公约数 所以一定要保证a大于b 求两个数的最小公倍数 1234567891011121314151617181920212223242526272829303132333435public class Main &#123; public static void main(String[] args) &#123; Scanner scan=new Scanner(System.in); int a=scan.nextInt(); int b=scan.nextInt(); int index=gcd(a,b); System.out.println(lcm(a,b,index)); &#125; //求最大公约数的方法二 public static int gcd(int a,int b) &#123; return b==0?a:gcd(b,a%b); &#125; //这个是算最小公倍数的方法，a，b分别是那两个数，index是他俩的最大公约数 public static int lcm(int a,int b,int index) &#123; //返回的是两个数相乘再除以他俩的最大公约数 return a*b/index; &#125; //求最大公约数的方法 public static int gcd1(int a,int b) &#123; while(b&gt;0) &#123; int temp=a%b; a=b; b=temp; &#125; return a; &#125;&#125; 视频二十二进制理论篇 圈3和圈4是提供了16进制专二进制，和8转2进制的方法 D是十进制，H是十六进制，B是二进制，O是八进制 第二个会报错 视频二十三进制实践篇判断一个数的12进制，16进制，10进制是否相等 把数组a当作集合打印a集合的所有子集 for循环的次数根据集合元素个数来定，有 视频二十四位运算理论篇x^x&#x3D;0 x^0&#x3D;x a^b^c&#x3D;a^c^b&#x3D;b^c^a; &lt;&lt;是左移，&gt;&gt;是右移 负数右移，在左边高位补1 负数左移右边低位补0 负数移动的都是补码，移动完事之后得到的也是对应数的补码 正数左移右移都是补零 -7&gt;&gt;&gt;3 无符号右移 是指把-7补码右移三位之后，左侧高位用零补，得到的是对应数的源码或者补码都可以（因为得到的一定是正数） 视频二十五位运算实践篇输入一个数如果是2的次方，输出yes，否则输出no 一个数如果是2的次方，它的二进制形式大概就是100(4)，1000(8), 这个数如果是2的次方，那么这个数减一的二进制形式大概是011(3),0111(7),所以只要这个数和这个数减一取&amp;为零，这个数就是二的次方 12345678910public class Main &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); while(scan.hasNext()) &#123; int a=scan.nextInt(); System.out.println((a&amp;(a-1))==0?&quot;yes&quot;:&quot;no&quot;); &#125; &#125;&#125; 输入一个数，输出它二进制数中1的个数 12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); while(scan.hasNext()) &#123; int a=scan.nextInt(); int count=0; while(a&gt;0) &#123; a=a&amp;(a-1);//做一次就把a最右边的1置为0 count++; &#125; System.out.println(count); &#125; &#125;&#125; 输入n，然后再输入2*n-1个数 0^n&#x3D;n,n^n&#x3D;0，所以就一直^就能得到输入这些数中不重复的那个数 视频26大整数乘法模拟a，b是两个字符串，是大数要进行乘法运算 判断一个数是否是质数1和0都不是质数 第一种方法 1234567891011public static boolean check(int a) &#123; for(int i=2;i&lt;=a/i;i++) &#123; if(a%i==0) &#123; return false; &#125; &#125; return true; &#125; 第二种方法 视频三十埃氏筛法判断一个数n，从1到n有多少个素数 就是i是素数，就把2i，3i，4i都当做是素数 判断一个数是否是回文数把这个数的每一位都放进数组中，然后把最后一位和第一位作比较，倒数第二位和第二位作比较，以此类推，中间如果出现不相等，直接跳出循环，说明不是回文数 蓝桥杯的填空题直接输出答案就可以了，如果把程序也交上去可能会超时 视频四十字符’0’的ASCII码是48，字符’1’的ASCII码是49，字符’9’的ASCII码是57 ‘9’&#x3D;&#x3D;57是可以判断成功的，两个字符相减，数字减字符或者字符减数字都是ascii码值相减但是最后得到的结果是ascii码值的差值，还是ascii码值的差值对应的字符，取决于你想得到哪个 输入一个英文句子，判断英文句子中有多少个不重复的单词，英文句子中的每个单词中间有一个或者多个空格 12345678910111213141516 public static void main(String[] args) &#123; Scanner scan=new Scanner(System.in); String juzi=scan.nextLine(); juzi.trim();//去除句子的首尾空格 //按照空格分开，+可以防止两个单词之间有多个空格 String[]danci=juzi.split(&quot; +&quot;); //用set保证单词不重复 Set&lt;String&gt; set=new HashSet&lt;String&gt;(); for(int i=0;i&lt;danci.length;i++) &#123; set.add(danci[i]); &#125; System.out.println(set.size()); &#125; 123456789101112131415public class Main &#123; public static void main(String[] args) &#123; String ip =&quot;192.168.0.1&quot;; //.在正则表达式中有自己的语义所以要用/.来表示单纯的. // 斜杠\\在java字符串中有别的语义所以一个斜杠\\要用两个斜杠\\\\来表示 //所以split中的内容应该是//. String [] ips=ip.split(&quot;\\\\.&quot;); for(int i=0;i&lt;ips.length;i++) &#123; System.out.println(ips[i]); &#125; &#125;&#125; 求阶乘 一个数N的阶乘后面有多少零，决定他2和5因数的个数，这个个数可以通过N&#x2F;K+N&#x2F;K的平方+N&#x2F;K的三次方。。。。（K为2或者5）以此类推，直到一项为零停止， 显然这个个数一定是5的小，所以有多少个零取决于这个数有多少个5的因数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package 排序算法;import java.util.Scanner;// 1:无需package// 2: 类名必须Main, 不可修改public class Main &#123; public static void main(String[] args) &#123; Scanner scan=new Scanner(System.in); long k=scan.nextLong(); long l=0L ; //9e18是9乘以十的十八次方 long r=(long)9e18; //二分法，因为要找check==k的，所以check&gt;=k条件下要r=mid，而另一个是l=mid+1 while(l&lt;r) &#123; long mid=l+r&gt;&gt;1; if(check(mid)&gt;=k) &#123; r=mid; &#125; else &#123; l=mid+1; &#125; &#125; if(check(l)==k) &#123; System.out.println(l); &#125; else &#123; System.out.println(&quot;-1&quot;); &#125; scan.close(); &#125; public static long check(long x) &#123; long res=0; while(x&gt;0) &#123; res+=x/5; x=x/5; &#125; return res; &#125; &#125; 最少刷题数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.Scanner;// 1:无需package// 2: 类名必须Main, 不可修改public class Main &#123; public static void main(String[] args) &#123; Scanner scan=new Scanner(System.in); //输入有多少个学生 int count=scan.nextInt(); //用来存储每个学生对应的刷题数 int a[]=new int[count+1]; //用来存储从1到100000刷题数分别有多少学生完成 int cnt[]=new int[100001]; int max=0; for(int i=1;i&lt;=count;i++) &#123; //完成a数组 a[i]=scan.nextInt(); //完成cnt数组 cnt[a[i]]++; //找出最多的刷题数目为max max=Math.max(max, a[i]); &#125; //这就是一个前缀码思想，这样操作得到的cnt数组，cnt[i-1]是刷题小于i的人数，cnt[i]是刷题小于等于i的人数 //n-cnt[i]是刷题大于i的人数 for(int i=1;i&lt;=max;i++) &#123; cnt[i]=cnt[i-1]+cnt[i]; &#125; //pos是增加某同学刷题数之前的中间值，就是满足刷题数大于i的人小于等于刷题数小于i的人的i的最小值 int pos=-1; //pos1是增加某同学刷题数之后的中间值 int pos1=-1; for(int i=1;i&lt;=max;i++) &#123; if(cnt[i-1]&gt;=count-cnt[i]) &#123; if(pos==-1) &#123; pos=i; &#125; &#125; //这里求pos1 用cnt[i-1]减1是因为，某同学增加了一些刷题数之后从小于pos变成了pos1，所以小于中间值的人数要减1 if(cnt[i-1]-1&gt;=count-cnt[i]) &#123; if(pos1==-1) &#123; pos1=i; break; &#125; &#125; &#125; for(int i=1;i&lt;=count;i++) &#123; //如果这个刷题数大于等于pos就不需要再刷题了 if(a[i]&gt;=pos) &#123; System.out.print(&quot;0 &quot;); &#125; //如果刷题数小于pos，就要再刷pos1-a[i]道题，让刷题数变为pos1 else &#123; System.out.print(pos1-a[i]+&quot; &quot;); &#125; &#125; &#125;&#125; 直线 选用kx+b截距式来表示直线，最方便，能够最好的判断两条直线是否是同一条直线 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package 排序算法;import java.util.ArrayList;import java.util.HashSet;import java.util.Scanner;//1:无需package//2: 类名必须Main, 不可修改import java.util.Set;public class Main &#123; public static void main(String[] args) &#123; //用set来存储点，保持了这个不重复性 Set&lt;Integer&gt; set=new HashSet&lt;Integer&gt;(); //用ans这个set类型集合存储直线保证了这个不重复性 Set&lt;String&gt; ans=new HashSet&lt;String&gt;(); for(int i=0;i&lt;20;i++) &#123; for(int m=0;m&lt;21;m++) &#123; //往set中存储点，用100*i+m是因为，如果直接存储i+m可能会有重复,并且用100*i+m存储方便取出x和y，i对应为x，m对应为y set.add(100*i+m); &#125; &#125; //这个list用来存储点，它可以很方便把点取出来 ArrayList&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;(set); //这里两个for循环遍历，就是把点两两不重复的组合，先取第一个点和后面所有点组合，再取第二个点和后面所有点组合，以此类推 for(int i=0;i&lt;list.size();i++) &#123; //取出一个点 int a=list.get(i); for(int j=i+1;j&lt;list.size();j++) &#123; //取出第二个点 int d=list.get(j); //算出x1，x2，y1，y2，因为存储时用100*x+y存储的，所以要这样取出 int x1=a/100;int x2=d/100; int y1=a%100;int y2=d%100; //斜率k的分子 int up=y1-y2; //斜率k的分母 int down=x1-x2; //如果down为零这种直线，就用特殊的方式存储(保证不重复存储同一条线)，因为它的k不存在 //用x=x1是因为这个里面这个for循环中x1是固定的，都是其他点和x1的点组合，如果x1和两个点组合的直线分别都是down为0的，那这两条直线相同，存储一次即可，所以存储x=x1保证不重复存储同一条直线 if(down==0) &#123; ans.add(&quot;x =&quot;+x1); continue; &#125; //算up和down的最大公约数 int gcd=gcd(up,down); //因为k可能除不尽，所以用这种形式表示k，分子分母中间加空格是因为，分母为13分子为1和分子为11分母3这两种情况如果中间没有空格就都是113不符合要求 //分子分母除以最大公约数约分，保证ans中不会存储相同直线 String k=up/gcd+&quot; &quot;+down/gcd; int ky=y1*down-up*x1; int kx=down; int gcd2=gcd(ky,kx); //求b，b也是分子+分母这种形式，加空格原因和上面一样，分子分母约分原因也是一样 String b=ky/gcd2+&quot; &quot;+kx/gcd2; ans.add(k+&quot; &quot;+b); &#125; &#125; //输出ans中直线数量 System.out.println(ans.size());&#125; public static int gcd(int a,int b) &#123; return b==0?a:gcd(b,a%b); &#125;&#125; 卡片 123456789101112131415161718192021222324252627282930313233343536373839404142434445package 排序算法;import java.util.ArrayList;import java.util.HashSet;import java.util.Scanner;//1:无需package//2: 类名必须Main, 不可修改import java.util.Set;public class Main &#123; //用数组存储0~9卡片的个数，0号位存储0卡片个数，1号位存储1卡片个数，一直存储到9卡片 static int a[]= &#123;2021,2021,2021,2021,2021,2021,2021,2021,2021,2021&#125;; public static void main(String[] args) &#123;//不断用卡片组成1，2，3，4，以此类推，直到check返回0的时候说明这个i这个数无法组成，所以输出i-1 for(int i=1;;i++) &#123; if(check(i)==0) &#123; System.out.println(i-1); break; &#125; &#125; &#125; public static int check(int c) &#123; //一直取c的最低位，取到之后从数组中扣除对应的卡片，直到有一个卡片槽为零，返回0，如果所有卡片槽一直大于零，就返回1 while(c&gt;0) &#123; int b=c%10; if(a[b]&gt;0) &#123; a[b]--; &#125; else &#123; return 0; &#125; c=c/10; &#125; return 1; &#125;&#125; 货物摆放 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package 排序算法;import java.util.ArrayList;import java.util.HashSet;import java.util.Scanner;//1:无需package//2: 类名必须Main, 不可修改import java.util.Set;public class Main &#123; public static void main(String args[]) &#123; int maxn=1000; //a数组保存b(输入)的因数,大概是不到1000个因数，所以建立数组大小是1000 long a[]=new long[maxn]; int len=0; //输入的数 long b=2021041820210418L; //获取b的因数，如果i是因数，只要b%i!=i,b%i也就是b的因数，所以只需要检查i&lt;根号b的i for(long i=1;i*i&lt;b;i++) &#123; if(b%i==0) &#123; a[len++]=i; if(b/i!=i) &#123; a[len++]=b/i; &#125; &#125; &#125; //三个for循环一次取三个因数组合测试看相乘是不是等于b int count=0; for(int i=0;i&lt;len;i++) &#123; for(int j=0;j&lt;len;j++) &#123; //如果前两个数相乘就大于b了，直接进入下次循环就可以了，不用再乘第三个数了 if(a[i]*a[j]&gt;b) &#123; continue; &#125; for(int m=0;m&lt;len;m++) &#123; //如果三个因数相乘为b，count++; if(a[i]*a[j]*a[m]==b) &#123; count++; &#125; &#125; &#125; &#125; //最后输出count System.out.println(count); &#125;&#125; 时间显示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.ArrayList;import java.util.HashSet;import java.util.Scanner;//1:无需package//2: 类名必须Main, 不可修改import java.util.Set;public class Main &#123; public static void main(String args[]) &#123; //输入毫秒数 Scanner scan=new Scanner(System.in); long data=scan.nextLong(); //将毫秒数转换为秒数 long data2=data/1000; //n是除去能凑成一天的秒数之后剩下的秒数 long n=data2%(24*60*60); //输出小时 System.out.printf(&quot;%02d:&quot;,n/3600); //输出分钟，n/60是为了看这些秒数总共能有多少分钟然后在对60取模就是除去那些能凑成小时的分钟最后得到的就是对应的分钟 System.out.printf(&quot;%02d:&quot;, n/60%60); //输出秒数 //%02d是占位符，占两位，不够两位用0补 //%2d也是占位符，占两位，不够的话会留出空位 System.out.printf(&quot;%02d&quot;, n%60); &#125;&#125; 最少砝码 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.ArrayList;import java.util.HashSet;import java.util.Scanner;//1:无需package//2: 类名必须Main, 不可修改import java.util.Set;public class Main &#123; public static void main(String args[]) &#123; Scanner scan=new Scanner(System.in); //输入一个数 long data=scan.nextLong(); int sum=0; int curr=0; //直到sum大于data停止循环，sum就是3的零次方加3的1次方加3的2次方以此类推 while(sum&lt;data) &#123; sum+=Math.pow(3,curr); curr++; &#125; System.out.println(curr); &#125;&#125; 寻找2020 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.io.FileNotFoundException;import java.io.FileReader;import java.util.ArrayList;import java.util.HashSet;import java.util.Scanner;//1:无需package//2: 类名必须Main, 不可修改import java.util.Set;public class Main &#123; public static void main(String args[]) &#123; //记事本中能看到行数是300 String []str=new String[300]; int n=0; try &#123; //读取2020.txt Scanner scan=new Scanner(new FileReader(&quot;C:\\\\Users\\\\#赵梓皓&amp;\\\\Desktop\\\\2020.txt&quot;)); //判断是否有下一行，读取下一行 while(scan.hasNextLine()) &#123; //也可以通过这个n来判断有多少行 str[n++]=scan.nextLine(); &#125; &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; int ans=0; //遍历行 for(int i=0;i&lt;300;i++) &#123; //遍历列 for(int j=0;j&lt;str[i].length();j++) &#123; //如果这个数是2满足条件接着判断 if(str[i].charAt(j)==&#x27;2&#x27;) &#123; //这个是判断当前遍历那个数所在那一列的四个能否满足2020 if(j+3&lt;str[i].length()&amp;&amp;str[i].charAt(j+1)==&#x27;0&#x27;&amp;&amp;str[i].charAt(j+2)==&#x27;2&#x27;&amp;&amp;str[i].charAt(j+3)==&#x27;0&#x27;) &#123; ans++; &#125; //这个是判断当前遍历那个数所在那一行的四个能否满足2020 if(i+3&lt;300&amp;&amp;str[i+1].charAt(j)==&#x27;0&#x27;&amp;&amp;str[i+2].charAt(j)==&#x27;2&#x27;&amp;&amp;str[i+3].charAt(j)==&#x27;0&#x27;) &#123; ans++; &#125; //这个是判断当前遍历那个数所在那一45度斜线的四个能否满足2020 if(i+3&lt;300&amp;&amp;j+3&lt;str[i].length()&amp;&amp;str[i+1].charAt(j+1)==&#x27;0&#x27;&amp;&amp;str[i+2].charAt(j+2)==&#x27;2&#x27;&amp;&amp;str[i+3].charAt(j+3)==&#x27;0&#x27;) &#123; ans++; &#125; &#125; &#125; &#125; //最后输出满足条件的个数 System.out.println(ans);&#125;&#125; 蛇形填数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package 排序算法;import java.io.FileNotFoundException;import java.io.FileReader;import java.util.ArrayList;import java.util.HashSet;import java.util.Scanner;//1:无需package//2: 类名必须Main, 不可修改import java.util.Set;public class Main &#123; public static void main(String args[]) &#123; //ans是模拟的数字，每次循环加1，一开始为1是因为当r=20，c=20的时候没有加1 //r是行号，c是列号int r=1; int c=1; int ans=1;//当行和列同时为20的时候停止循环while(r!=20 || c!=20) &#123; //第一行时奇数列会直接向右移动一个，偶数列向左下移动 if(r==1) &#123; if(c%2==1) &#123; c++; &#125; else &#123; r++;c--; &#125; &#125; //第一列时，奇数行向右上移动，偶数行向下移动 else if(c==1) &#123; if(r%2==0) &#123; r++; &#125; else &#123; r--; c++; &#125; &#125; //既不是第一列也不是第一行的当行列号加起来时偶数向右上移动，当行列号加起来是奇数向坐下移动 else &#123; if((r+c)%2==0) &#123; r--; c++; &#125; else &#123; r++; c--; &#125; &#125; //每次循环加1模拟我们要得到的数字 ans++;&#125;System.out.println(ans);&#125;&#125; 成绩分析 123456789101112131415161718192021222324252627282930313233import java.util.Scanner;// 1:无需package// 2: 类名必须Main, 不可修改public class Main &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int count=scan.nextInt(); int max=0; int min=100; int sum=0; for(int i=0;i&lt;count;i++)&#123; int a=scan.nextInt(); if(a&gt;max)&#123; max=a; &#125; if(a&lt;min)&#123; min=a; &#125; sum+=a; &#125; System.out.println(max); System.out.println(min);//保留两位小数，把1.0*sum是把后面这个数转换为double形式，才能以%.2f输出 System.out.printf(&quot;%.2f&quot;,(1.0*sum)/count); scan.close(); &#125;&#125; 不同子串 1234567891011121314151617181920212223242526272829303132333435package 排序算法;import java.util.HashSet;import java.util.Scanner;import java.util.TreeSet;//1:无需package//2: 类名必须Main, 不可修改public class Main &#123; public static void main(String[] args) &#123; //用set来存储子串，保证不重复 TreeSet&lt;String&gt; set=new TreeSet&lt;String&gt;(); String s=&quot;0100110001010001&quot;; //两个for循环遍历s的所有子串 //i表示子串起点 for(int i=0;i&lt;s.length();i++) &#123; //j表示子串终点 for(int j=i;j&lt;s.length();j++) &#123; StringBuilder t=new StringBuilder(); //得到对应的子串 for(int k=i;k&lt;=j;k++) &#123; t.append(s.charAt(k)); &#125; //将子串加入到set中 set.add(t.toString()); &#125; &#125; //输出set中元素的个数 System.out.println(set.size());&#125;&#125; 数字三角形 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.util.Scanner;// 1:无需package// 2: 类名必须Main, 不可修改public class Main &#123; public static void main(String[] args) &#123;​ Scanner scan = new Scanner(System.in);​ //在此输入您的代码...​ int n=scan.nextInt();//输入行数n​ int[][] arr = new int[n+1][n+1];//存储数字三角形的二维数组，n+1行n+1列​ for(int i=1;i&lt;=n;i++)&#123;//因为是从数组下标为1开始存储，表示第一行，1到n有n个数字，一共存储n行​ for(int j=1;j&lt;=i;j++)&#123;//每列小于等于当前列的行数，例如第二行有两列，第三行有三列​ arr[i][j]=scan.nextInt();​ &#125;​ &#125;​ //求到每个数字路径的最大值，然后赋值给到这个数字​ for(int i=1;i&lt;=n;i++)&#123;​ for(int j=1;j&lt;=i;j++)&#123;​ //按照题目的说法：路径上的每一步只能从一个数走到下一层和它最近的左边的那个数或者右边的那个数。​ //那求最大值则是当前数字加上它上一层的左边的数字或右边的数字，就看哪边的数字大​ //用数组描述上一层左边的数字就是当前数字的上一层前一列，上一层右边数字的话就是当前数字的上一层当前列。​ arr[i][j]=arr[i][j]+Math.max(arr[i-1][j-1], arr[i-1][j]);​ &#125;​ &#125;​ if(n%2 == 0)&#123;​ //因为定义的数组是n+1行n+1列,所以行数n直接就是最后一行了​ //因为题目中说到向左下走的次数与向右下走的次数相差不能超过1。​ //意思就是无论如何我们最后到达的数字都是最后一行的中间数。​ //偶数行则必是最后一行中间两个数，看一下谁大谁小进行输出​ System.out.println(Math.max(arr[n][n/2],arr[n][n/2 + 1]));​ &#125;else&#123;​ //奇数行中间数就是n/2 + 1 ​ System.out.println(arr[n][n/2 + 1]);​ &#125;​ scan.close(); &#125; &#125; 空间 求和 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import java.util.Scanner;public class Main&#123; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); //定义一个数组 Long [] arr = new Long[n]; Long sum = 0l; //对数组赋值 for( int i = 0 ; i &lt; arr.length ; i++ )&#123; arr[i] = sc.nextLong(); sum += arr[i]; //对数组求和 &#125; //结果 Long res = 0l; for( int i = 0 ; i &lt; arr.length - 1 ; i++ )&#123; //依次减去当前索引所指的数 sum -= arr[i]; //累加求和 res += sum * arr[i]; &#125; System.out.println(res); &#125;&#125;//考察了数学知识，重点是将数学语言转换成编程语言//假如有5个数：a0,a1,a2,a3,a4//求解：// sum0 = a0 + a1 + a2 + a3 + a4// 用乘法分配律进行分组求和// sum1 = ( a1 + a2 + a3 + a4 ) * a0 = (sum0 - a0 ) * a0// sum2 = ( a2 + a3 + a4 ) * a1 = (sum0 - a0 - a1 ) * a1// sum3 = ( a3 + a4 ) * a2 = (sum0 - a0 - a1 - a2 ) * a2// sum4 = ( a4 ) * a3 = (sum0 - a0 - a1 - a2 - a3 ) * a3// res = sum1 + sum2 + sum3 + sum4//可以看到非常的有规律//我们求出数组的和(sum)后，在遍历求和时，依次减去当前索引所指的数，再与这个被减的数相乘//用常规方法，双重for循环遍历数组，时间复杂度为 O(n2)。显然，只能拿30％的分//如果运用些数学知识，只用一个for循环即可完成求解，时间复杂度为 O(n)","categories":[],"tags":[]},{"title":"瑞吉外卖项目","slug":"瑞吉外卖项目","date":"2022-09-29T15:31:35.000Z","updated":"2023-04-10T13:01:13.407Z","comments":true,"path":"2022/09/29/瑞吉外卖项目/","link":"","permalink":"http://example.com/2022/09/29/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"DAY1f12之后那个网络是当前页面发起的请求 你可以点击那个小删除号，删除页面上那些静态资源请求，然后点击一个按钮，这时候出现的请求就是这个按钮对应的请求，但如果按了之后跳转了页面(也就是刷新了页面)，则这个请求可能会很快消失，显示的会是跳转过去后那个页面的请求 瑞吉外卖项目springBoot +ssm企业级项目 前置知识：Java基础知识 ​ javaweb ​ MySql ​ SpringBoot ​ SSM（Spring，SpringMVC，Mybatis） ​ Maven 软件开发整体介绍 需求分析–》设计–》编码–》测试–》上线运维 角色分工 软件环境： 开发环境：开发人员在开发阶段使用的环境（本地或者专门一台服务器），一般外部用户无法访问 测试环境：专门给测试人员使用的环境，用于测试项目，一班外部用户无法访问 项目整体介绍 技术选型 功能开发 这个是角色需求 数据库环境搭建mysql默认编码是utf-8 创建数据库 ，设置字符集为 utf8mb4这个是utf8的一个超集兼容utf-8 character前面还可以加一个default create database reggle character set utf8mb4; 资料中提供了sql语句，可以点开navicat，右键数据库，点击运行sql文件，然后导入所有的表 数据库中的用户密码要转换为md5加密格式 创建maven工程创建工程后，配置maven环境 pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.5&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;reggie_take_out&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--springboot--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt;&lt;!--测试场境的包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;!--web场景的包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt;&lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--pojo快速开发包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.20&lt;/version&gt; &lt;/dependency&gt; &lt;!--将对象转json的包--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.76&lt;/version&gt; &lt;/dependency&gt; &lt;!--通用语言包--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt; &lt;!---mysql驱动包--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--druid数据源包--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.23&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--打包成jar包的包--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.4.5&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml 12345678910111213141516171819202122#tomacat端口号server: port: 8080spring: #应用的名称，不必须 application: name: reggie_take_out #配置数据源为druid datasource: druid: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/reggle?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true username: root password: rootmybatis-plus: configuration: #在映射实体或者属性时，将数据库中表名和字段名中的下划线去掉，按照驼峰命名法映射 map-underscore-to-camel-case: true log-impl: org.apache.ibatis.logging.stdout.StdOutImpl global-config: db-config: id-type: ASSIGN_ID 下面截图是项目的文件架构，以及创建的springboot主程序类 进行静态资源的配置 在config包下创建WebMvcConfig配置类（也可以用yml文件） 用了这个配置类（继承WebMvcConfigurationSupport）之后，springboot对springmvc相关的自动配置都不会实现了，视图解析器，静态资源路径之类的 Spring Boot中只能有一个WebMvcConfigurationSupport配置类是真正起作用的，对于这个问题，其实可以通过implements WebMvcConfigurer来解决，多个不同的类实现这个接口后的配置都可以正常运行。 12345678910111213141516171819package com.itheima.reggie.config;import lombok.extern.slf4j.Slf4j;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;@Slf4j@Configurationpublic class WebMvcConfig extends WebMvcConfigurationSupport &#123; @Override protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123; log.info(&quot;开始进行静态资源映射&quot;); //这个的意思是 /backend/**请求对应到 类路径下的backend文件夹下的资源 registry.addResourceHandler(&quot;/backend/**&quot;).addResourceLocations(&quot;classpath:backend/&quot;); registry.addResourceHandler(&quot;/front/**&quot;).addResourceLocations(&quot;classpath:front/&quot;); &#125;&#125; 也可以用类来继承WebMvcConfigurer 123456789101112131415161718192021222324252627282930package com.itheima.reggie.config;import lombok.extern.slf4j.Slf4j;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Slf4j@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; //配置拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginInterceptor()) .addPathPatterns(&quot;/**&quot;) //所有请求都被拦截包括静态资源 .excludePathPatterns(&quot;/employee/login&quot;,&quot;/employee/logout&quot;,&quot;/backend/**&quot;,&quot;/front/**&quot;); //放行的请求 &#125; //配置静态资源的映射 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; log.info(&quot;开始进行静态资源映射&quot;); //这个的意思是 /backend/**请求对应到 类路径下的backend文件夹下的资源 registry.addResourceHandler(&quot;/backend/**&quot;).addResourceLocations(&quot;classpath:backend/&quot;); registry.addResourceHandler(&quot;/front/**&quot;).addResourceLocations(&quot;classpath:front/&quot;); &#125;&#125; 后台登陆功能开发需求分析 代码开发 功能测试 Employee类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.itheima.reggie.entity;import com.baomidou.mybatisplus.annotation.FieldFill;import com.baomidou.mybatisplus.annotation.TableField;import lombok.Data;import java.io.Serializable;import java.time.LocalDateTime;/*员工实体类 */@Datapublic class Employee implements Serializable &#123; private static final long serialVersionUID = 1L; private Long id; private String username; private String name; private String password; private String phone; private String sex; private String idNumber; private Integer status; //驼峰命名法和数据库表中的字段名相对应 private LocalDateTime createTime; private LocalDateTime updateTime; @TableField(fill = FieldFill.INSERT) private Long createUser; @TableField(fill = FieldFill.INSERT_UPDATE) private Long updateUser;&#125; R这是一个公共类，专门作为返回值的，用户后端往前端返回数据的时候用的 springboot中，后端往前端返回java对象默认就是返回json对象 1234567891011121314151617181920212223242526272829303132333435363738394041package com.itheima.reggie.common;import lombok.Data;import java.util.HashMap;import java.util.Map;@Datapublic class R&lt;T&gt; &#123; private Integer code; //编码：1成功，0和其它数字为失败 private String msg; //错误信息 private T data; //数据，就是查询到的实体类 private Map map = new HashMap(); //动态数据 //静态方法，当登陆成功可以调用来获得R对象，将查询得到的实体类作为方法参数 //R调用这个方法就可以获得R对象 public static &lt;T&gt; R&lt;T&gt; success(T object) &#123; R&lt;T&gt; r = new R&lt;T&gt;(); r.data = object; r.code = 1; return r; &#125; //静态方法，当登陆失败可以调用来获得R对象，将错误信息作为方法参数 //R调用这个方法就可以获得R对象 public static &lt;T&gt; R&lt;T&gt; error(String msg) &#123; R r = new R(); r.msg = msg; r.code = 0; return r; &#125; public R&lt;T&gt; add(String key, Object value) &#123; this.map.put(key, value); return this; &#125;&#125; 使用R的原因： 返回的实体类中要有data属性，msg属性，code属性，所以直接给他集中到R类里 123456789101112131415161718192021222324 methods: &#123; //当点击登录键的时候会调用这个handleLogin方法，校验后会发起请求 async handleLogin() &#123; this.$refs.loginForm.validate(async (valid) =&gt; &#123; //校验 if (valid) &#123; this.loading = true //发送请求，res就是请求的返回值 //通过res.code,res.data,res.msg来获取值 let res = await loginApi(this.loginForm) if (String(res.code) === &#x27;1&#x27;) &#123; //可以把员工的信息，员工实体放到data，前端页面把他转为json，存储到浏览器当中 localStorage.setItem(&#x27;userInfo&#x27;,JSON.stringify(res.data)) window.location.href= &#x27;/backend/index.html&#x27; &#125; else &#123; //这个msg是错误信息 this.$message.error(res.msg) this.loading = false &#125; &#125; &#125;) &#125; &#125;&#125;) 这个是全部文件的形式 点击登录之后，出现的请i求url的路径，决定了那个controller中的路径规定 这个是根据前端发起的是ajax请求，用的是data所以是以json字符串格式返回数据决定了后台接收参数时要用@RequestBody Controller中登录方法的开发流程 EmployeeController 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package com.itheima.reggie.controller;import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;import com.itheima.reggie.common.R;import com.itheima.reggie.entity.Employee;import com.itheima.reggie.service.EmployeeService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.util.DigestUtils;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;@Slf4j@RestController@RequestMapping(&quot;/employee&quot;)public class EmployeeController &#123; @Autowired private EmployeeService employeeService; /* 登录功能 */ //加上外面类的实际就是/employee/login //这个是根据点击登陆后url得到的 @PostMapping(&quot;/login&quot;) //这里使用@RequestBody是因为前端用ajax请求以json字符串格式发送数据 public R&lt;Employee&gt; login(HttpServletRequest request, @RequestBody Employee employee) &#123; // 1.将页面提交的密码password进行md5加密处理 String password = employee.getPassword(); password= DigestUtils.md5DigestAsHex(password.getBytes()); // 2.根据页面提交的用户名username查询数据库 LambdaQueryWrapper&lt;Employee&gt; lambdaQueryWrapper=new LambdaQueryWrapper&lt;&gt;(); //eq方法是判断这个有没有username是等于第二个参数的 lambdaQueryWrapper.eq(Employee::getUsername,employee.getUsername()); //数据库中设置username的时候，设置的是unique，所以最多只有一条，所以可以用getOne()方法 Employee one = employeeService.getOne(lambdaQueryWrapper); //3.如果没有查询到则返回登陆失败结果 //这个R.error就可以创建一个R对象，详情见R类那 if(one==null)&#123; return R.error(&quot;用户名不存在&quot;); &#125; // 4.密码比对，如果不一致则返回登陆失败结果 if(!one.getPassword().equals(password))&#123; return R.error(&quot;密码错误&quot;); &#125; // 5.查看员工状态，如果为已禁用状态，则返回员工已禁用结果 if(one.getStatus()==0)&#123; return R.error(&quot;员工已被禁用&quot;); &#125; // 6.登陆成功，将员工id存入Session并返回登陆成功结果 //这里存的一定是数据库中查找出来的那个对象的id request.getSession().setAttribute(&quot;employee&quot;,one.getId()); return R.success(one); &#125; /* 登出功能 */@PostMapping(&quot;/logout&quot;) public R&lt;String&gt; logout(HttpServletRequest request)&#123; //1.清理Session中的用户id HttpSession session = request.getSession(); session.removeAttribute(&quot;employee&quot;); //2.返回结果 return R.success(&quot;退出成功&quot;);&#125;/*新增员工 *///路径是/employee所以不用加@PostMapping//@RequestBody接受json数据格式 public void saveEmployee(@RequestBody Employee employee)&#123; log.info(&quot;员工信息:&#123;&#125;&quot;,employee.toString());&#125;&#125; EmployeeService 123456789package com.itheima.reggie.service;import com.baomidou.mybatisplus.extension.service.IService;import com.itheima.reggie.entity.Employee;public interface EmployeeService extends IService&lt;Employee&gt; &#123;&#125; EmployeeServiceImpl 123456789101112package com.itheima.reggie.service.impl;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.itheima.reggie.entity.Employee;import com.itheima.reggie.mapper.EmployeeMapper;import com.itheima.reggie.service.EmployeeService;import org.springframework.stereotype.Service;@Servicepublic class EmployeeServiceImpl extends ServiceImpl&lt;EmployeeMapper, Employee&gt; implements EmployeeService &#123;&#125; EmployeeMapper 123456789package com.itheima.reggie.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.itheima.reggie.entity.Employee;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface EmployeeMapper extends BaseMapper&lt;Employee&gt; &#123;&#125; request.js中，把超时时间设置大一点，设置断点调试就不会超时了 123456789(function (win) &#123; axios.defaults.headers[&#x27;Content-Type&#x27;] = &#x27;application/json;charset=utf-8&#x27; // 创建axios实例 const service = axios.create(&#123; // axios中请求配置有baseURL选项，表示请求URL公共部分 baseURL: &#x27;/&#x27;, // 超时 timeout: 1000000 &#125;) 登陆成功 把返回到json对象转换为json字符串，存储在浏览器上，可以通过图片方式查看 ​ localStorage.setItem(‘userInfo’,JSON.stringify(res.data)) 1234567891011121314151617181920212223242526methods: &#123; //当点击登录键的时候会调用这个handleLogin方法，校验后会发起请求 async handleLogin() &#123; this.$refs.loginForm.validate(async (valid) =&gt; &#123; //校验 if (valid) &#123; this.loading = true //发送请求，res就是请求的返回值 //通过res.code,res.data,res.msg来获取值 let res = await loginApi(this.loginForm) if (String(res.code) === &#x27;1&#x27;) &#123; //可以把员工的信息，员工实体放到data，前端页面把他转为json，存储到浏览器当中 localStorage.setItem(&#x27;userInfo&#x27;,JSON.stringify(res.data)) window.location.href= &#x27;/backend/index.html&#x27; &#125; else &#123; //这个msg是错误信息 this.$message.error(res.msg) this.loading = false &#125; &#125; &#125;) &#125; &#125;&#125;) 后台退出功能开发一点击这个退出按钮，就会调用这个方法 1234567891011methods: &#123; logout() &#123; logoutApi().then((res)=&gt;&#123; if(res.code === 1)&#123; //从浏览器中移除userInfo localStorage.removeItem(&#x27;userInfo&#x27;) //跳转到登陆界面 window.location.href = &#x27;/backend/page/login/login.html&#x27; &#125; &#125;) &#125;, 看发起的请求，点击退出键之后，的请求路径，以及请求方式等等，都能用f12网络看出来 http://localhost:8080/employee/logout ** Controller的编写思路 index.html userInfo对象的由来 123456789//当vue对象创建调用这个方法的时候，浏览器获取userInfo对象created() &#123; const userInfo = window.localStorage.getItem(&#x27;userInfo&#x27;) if (userInfo) &#123; //将userInfojson字符串转为json对象 this.userInfo = JSON.parse(userInfo) &#125; this.closeLoading()&#125;, 12345&lt;div class=&quot;right-menu&quot;&gt; &lt;div class=&quot;avatar-wrapper&quot;&gt;&#123;&#123; userInfo.name &#125;&#125;&lt;/div&gt; &lt;!-- &lt;div class=&quot;logout&quot; @click=&quot;logout&quot;&gt;退出&lt;/div&gt; --&gt; &lt;img src=&quot;images/icons/btn_close@2x.png&quot; class=&quot;outLogin&quot; alt=&quot;退出&quot; @click=&quot;logout&quot; /&gt;&lt;/div&gt; 这个userInfo.name显示的是页面上这个，也就是登路后存储的实体类信息，的name属性 Controller 123456789@PostMapping(&quot;/logout&quot;) public R&lt;String&gt; logout(HttpServletRequest request)&#123; //1.清理Session中的用户id HttpSession session = request.getSession(); session.removeAttribute(&quot;employee&quot;); //2.返回结果 return R.success(&quot;退出成功&quot;);&#125; index.html分析 12345678910&lt;iframe id=&quot;cIframe&quot; class=&quot;c_iframe&quot; name=&quot;cIframe&quot; :src=&quot;iframeUrl&quot; width=&quot;100%&quot; height=&quot;auto&quot; frameborder=&quot;0&quot; v-show=&quot;!loading&quot;&gt;&lt;/iframe&gt; 这个iframe标签就是左边栏右边的那一页面，每次点击左边栏的时候，iframeUrl机会改变，所以右边页面会变 点击调用menuHandle方法改iframeUrl 12345678menuHandle(item, goBackFlag) &#123; this.loading = true this.menuActived = item.id this.iframeUrl = item.url this.headTitle = item.name this.goBackFlag = goBackFlag this.closeLoading()&#125;, 默认的iframeUrl和menuList 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 defAct: &#x27;2&#x27;, menuActived: &#x27;2&#x27;, userInfo: &#123;&#125;, menuList: [ // &#123; // id: &#x27;1&#x27;, // name: &#x27;门店管理&#x27;, // children: [ &#123; id: &#x27;2&#x27;, name: &#x27;员工管理&#x27;, url: &#x27;page/member/list.html&#x27;, icon: &#x27;icon-member&#x27; &#125;, &#123; id: &#x27;3&#x27;, name: &#x27;分类管理&#x27;, url: &#x27;page/category/list.html&#x27;, icon: &#x27;icon-category&#x27; &#125;, &#123; id: &#x27;4&#x27;, name: &#x27;菜品管理&#x27;, url: &#x27;page/food/list.html&#x27;, icon: &#x27;icon-food&#x27; &#125;, &#123; id: &#x27;5&#x27;, name: &#x27;套餐管理&#x27;, url: &#x27;page/combo/list.html&#x27;, icon: &#x27;icon-combo&#x27; &#125;, &#123; id: &#x27;6&#x27;, name: &#x27;订单明细&#x27;, url: &#x27;page/order/list.html&#x27;, icon: &#x27;icon-order&#x27; &#125; // ], // &#125;, ], iframeUrl: &#x27;page/member/list.html&#x27;, headTitle: &#x27;员工管理&#x27;, goBackFlag: false, loading: true, timer: null&#125; 显示上面图片左边的栏 123456&lt;div v-for=&quot;item in menuList&quot; :key=&quot;item.id&quot;&gt; &lt;el-submenu :index=&quot;item.id&quot; v-if=&quot;item.children &amp;&amp; item.children.length&gt;0&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;i class=&quot;iconfont&quot; :class=&quot;item.icon&quot;&gt;&lt;/i&gt; &lt;span&gt;&#123;&#123;item.name&#125;&#125;&lt;/span&gt; &lt;/template&gt; Day2这个当中有多个工具类，类似于mvc包中的BeanUtils，javautil包中的UUID这里面都有类似的工具 123456&lt;!--有各种工具类--&gt;&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.7.17&lt;/version&gt;&lt;/dependency&gt; 完善登录功能验证这个操作的时候记得清理缓存 当改变了前端的页面的时候都要进行一下历史纪录的清除 保证只有登录成功之后才能到，index.html中去，没有登陆会跳转到登录页面 主程序 123456789101112131415161718package com.itheima.reggie;import lombok.extern.slf4j.Slf4j;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.web.servlet.ServletComponentScan;//加入日志功能@Slf4j@SpringBootApplication//使原生组件生效@ServletComponentScanpublic class ReggieApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ReggieApplication.class,args); log.info(&quot;项目启动成功&quot;); &#125;&#125; 过滤器 测试拦截， filter包下的LoginCheckFilter类 1234567891011121314151617181920212223242526package com.itheima.reggie.filter;import lombok.extern.slf4j.Slf4j;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@Slf4j//拦截所有请求，拦截器名字是loginInterceptor//@WebFilter(filterName = &quot;loginInterceptor&quot;,urlPatterns = &quot;/*&quot;)public class LoginCheckFilter implements Filter &#123; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest request=(HttpServletRequest)servletRequest; HttpServletResponse response=(HttpServletResponse)servletResponse; log.info(&quot;拦截到请求：&#123;&#125;&quot;+request.getRequestURI()); filterChain.doFilter(request,response); &#125;&#125; 完善拦截器 感觉很麻烦放弃了，想要自己搞一个拦截器 mvc的配置文件 123456789101112131415161718192021222324252627282930package com.itheima.reggie.config;import lombok.extern.slf4j.Slf4j;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Slf4j@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; //配置拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginInterceptor()) .addPathPatterns(&quot;/**&quot;) //所有请求都被拦截包括静态资源 .excludePathPatterns(&quot;/employee/login&quot;,&quot;/backend/**&quot;,&quot;/front/**&quot;); //放行的请求 &#125; //配置静态资源的映射 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; log.info(&quot;开始进行静态资源映射&quot;); //这个的意思是 /backend/**请求对应到 类路径下的backend文件夹下的资源 registry.addResourceHandler(&quot;/backend/**&quot;).addResourceLocations(&quot;classpath:backend/&quot;); registry.addResourceHandler(&quot;/front/**&quot;).addResourceLocations(&quot;classpath:front/&quot;); &#125;&#125; 拦截器类 12345678910111213141516171819202122232425262728293031323334package com.itheima.reggie.config;import com.alibaba.fastjson.JSON;import com.itheima.reggie.common.R;import lombok.extern.slf4j.Slf4j;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;@Slf4jpublic class LoginInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String requestURI=request.getRequestURI(); log.info(&quot;请求已经拦截&#123;&#125;&quot;,requestURI); //获取session HttpSession session = request.getSession(); //获取session中employee Object employee = session.getAttribute(&quot;employee&quot;); //employee不为空就是登陆了放行 if(employee!=null)&#123; //放行 return true; &#125; //如果未登录返回未登录结果，通过输出流方式向客户端页面响应数据 response.getWriter().write(JSON.toJSONString(R.error(&quot;NOLOGIN&quot;))); return false; &#125;&#125; 前端： js文件夹下的request.js 前端响应拦截器，拦截后端的响应 1234567891011121314// 响应拦截器 service.interceptors.response.use(res =&gt; &#123; //如果返回的res满足这些条件可以跳转系统登录页面 if (res.data.code === 0 &amp;&amp; res.data.msg === &#x27;NOTLOGIN&#x27;) &#123;// 返回登录页面 //打印日志 console.log(&#x27;---/backend/page/login/login.html---&#x27;) //去除浏览器userInfo localStorage.removeItem(&#x27;userInfo&#x27;) //跳转系统登陆页面 window.top.location.href = &#x27;/backend/page/login/login.html&#x27; &#125; else &#123; return res.data &#125; &#125;, 这个res中的内容是固定的，决定了返回的内容,决定了返回的对象msg一定是NOTLOGIN， 员工管理业务开发新增员工添加员工的页面是backend&#x2F;page&#x2F;member&#x2F;add.html 展示员工的页面是backend&#x2F;page&#x2F;member&#x2F;list.html st是add 123456&lt;el-button type=&quot;primary&quot; @click=&quot;addMemberHandle(&#x27;add&#x27;)&quot;&gt; + 添加员工&lt;/el-button&gt; addMemberHandler方法 st是add，能跳转到add.html 12345678910111213141516 // 添加addMemberHandle (st) &#123; if (st === &#x27;add&#x27;)&#123; window.parent.menuHandle(&#123; id: &#x27;2&#x27;, url: &#x27;/backend/page/member/add.html&#x27;, name: &#x27;添加员工&#x27; &#125;,true) &#125; else &#123; window.parent.menuHandle(&#123; id: &#x27;2&#x27;, url: &#x27;/backend/page/member/add.html?id=&#x27;+st, name: &#x27;修改员工&#x27; &#125;,true) &#125;&#125; 这menuHandler会让首页的那个iframe变为自己的这个url 这个有点类似之前说的那个一进去首页，页面是员工管理那个一样 index.html 12345678menuHandle(item, goBackFlag) &#123; this.loading = true this.menuActived = item.id this.iframeUrl = item.url this.headTitle = item.name this.goBackFlag = goBackFlag this.closeLoading()&#125;, 12345678910&lt;iframe id=&quot;cIframe&quot; class=&quot;c_iframe&quot; name=&quot;cIframe&quot; :src=&quot;iframeUrl&quot; width=&quot;100%&quot; height=&quot;auto&quot; frameborder=&quot;0&quot; v-show=&quot;!loading&quot;&gt;&lt;/iframe&gt; 点击添加员工后会跳转到add.html 点add.html中的保存会发ajax请求 12345678// 新增---添加员工function addEmployee (params) &#123; return $axios(&#123; url: &#x27;/employee&#x27;, method: &#x27;post&#x27;, data: &#123; ...params &#125; &#125;)&#125; 上面这个结论从页面也可以获得 点击add.html中的保存键，就可以出现&#x2F;employee请求，以及这些payload Controller 123456789101112131415161718192021222324/*新增员工 *///路径是/employee所以不用加@PostMapping//@RequestBody接受json数据格式 public R&lt;String&gt; saveEmployee(HttpServletRequest request,@RequestBody Employee employee)&#123; log.info(&quot;员工信息:&#123;&#125;&quot;,employee.toString()); //设置默认密码，密码进行md5加密 employee.setPassword(DigestUtils.md5DigestAsHex(&quot;123456&quot;.getBytes())); //设置开始创立时间 employee.setCreateTime(LocalDateTime.now()); //设置更新创立时间 employee.setUpdateTime(LocalDateTime.now()); //获取当前用登陆用户的id //获取的默认是Object对象，进行向下转型 long id = (Long)request.getSession().getAttribute(&quot;employee&quot;); employee.setCreateUser(id); employee.setUpdateUser(id); employeeService.save(employee); return R.success(&quot;新增员工成功&quot;);&#125; 如果假如两个username相同的字段，会出现500错误 全局异常处理器张三账号存在，如果再录入，就会出现500错误 错误信息 Duplicate entry ‘123’ for key ‘idx_username’ common包下的GlobalExceptionHandler类 123456789101112131415161718192021222324252627282930313233343536373839package com.itheima.reggie.common;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.RestController;import java.sql.SQLIntegrityConstraintViolationException;//这里是指所有Controller注解和RestController注解标记的类中的方法异常捕捉@ControllerAdvice(annotations = &#123;RestController.class, Controller.class&#125;)//返回json要加上这个注解@ResponseBody@Slf4jpublic class GlobalExceptionHandler &#123; //这里的注解的value是这个方法捕捉的异常类型 @ExceptionHandler(&#123;SQLIntegrityConstraintViolationException.class&#125;) //参数ex是异常信息 public R&lt;String&gt; exceptionHandler(SQLIntegrityConstraintViolationException ex)&#123; //获取异常信息 //Duplicate entry &#x27;123&#x27; for key &#x27;idx_username&#x27; log.error(ex.getMessage()); String message=ex.getMessage(); if(message.contains(&quot;Duplicate entry&quot;))&#123; String[] s = message.split(&quot; &quot;); //从异常信息中获取重复的用户名 message=s[2]+&quot;已存在&quot;; //这个msg内容会在页面显示 return R.error(message); &#125; return R.error(&quot;未知错误&quot;); &#125;&#125; 这里决定了返回的msg会在页面显示 这是add.html 123else &#123; this.$message.error(res.msg || &#x27;操作失败&#x27;) &#125; 员工信息分页查询 这是员工页面的一个请求，可以看出传了page和pageSize参数 created函数，在vue创建的时候就会调用 12345created() &#123; //init()方法下面有 this.init() this.user = JSON.parse(localStorage.getItem(&#x27;userInfo&#x27;)).username&#125;, init() 这里的params使用json格式来进行参数传递，但上面确是跟在url后面那种格式，下面解释 page和pageSize都有默认值在前端，page是1，pageSize是10 123456789101112131415async init () &#123; const params = &#123; page: this.page, pageSize: this.pageSize, name: this.input ? this.input : undefined &#125; await getMemberList(params).then(res =&gt; &#123; if (String(res.code) === &#x27;1&#x27;) &#123; this.tableData = res.data.records || [] this.counts = res.data.total &#125; &#125;).catch(err =&gt; &#123; this.$message.error(&#x27;请求出错了：&#x27; + err) &#125;)&#125; getMemberList方法 1234567function getMemberList (params) &#123; return $axios(&#123; url: &#x27;/employee/page&#x27;, method: &#x27;get&#x27;, params &#125;)&#125; 这就是为什么一进入list.html就会发起&#x2F;employee&#x2F;page的查询请求的原因 解释params使用json格式来进行参数传递，但上面确是跟在url后面那种格式 request.js request拦截器，拦截到get请求 1234567891011121314151617if (config.method === &#x27;get&#x27; &amp;&amp; config.params) &#123; let url = config.url + &#x27;?&#x27;; for (const propName of Object.keys(config.params)) &#123; const value = config.params[propName]; var part = encodeURIComponent(propName) + &quot;=&quot;; if (value !== null &amp;&amp; typeof(value) !== &quot;undefined&quot;) &#123; if (typeof value === &#x27;object&#x27;) &#123; for (const key of Object.keys(value)) &#123; let params = propName + &#x27;[&#x27; + key + &#x27;]&#x27;; var subPart = encodeURIComponent(params) + &quot;=&quot;; url += subPart + encodeURIComponent(value[key]) + &quot;&amp;&quot;; &#125; &#125; else &#123; url += part + encodeURIComponent(value) + &quot;&amp;&quot;; &#125; &#125; &#125; 这里就是请求成功之后，then是回调函数，所以要满足res.code&#x3D;1以及下面的一些条件 只要把数据按照规定返回，就可以进行页面渲染，页面展示 1234567891011121314151617async init () &#123; const params = &#123; page: this.page, pageSize: this.pageSize, name: this.input ? this.input : undefined &#125; await getMemberList(params).then(res =&gt; &#123; if (String(res.code) === &#x27;1&#x27;) &#123; //返回的各条记录 this.tableData = res.data.records || [] //返回的记录的总数 this.counts = res.data.total &#125; &#125;).catch(err =&gt; &#123; this.$message.error(&#x27;请求出错了：&#x27; + err) &#125;)&#125; 后端代码的开发思路 配置分页插件 在config包下的MybatisConfig类 12345678910111213141516171819202122232425package com.itheima.reggie.config;import com.baomidou.mybatisplus.annotation.DbType;import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;import org.mybatis.spring.annotation.MapperScan;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/*配置分页插件 */@MapperScan(&quot;com.itheima.reggie.mapper&quot;)@Configurationpublic class MybatisPlusConfig &#123; //往ioc容器中添加bean @Bean public MybatisPlusInterceptor mybatisPlusInterceptor()&#123; MybatisPlusInterceptor interceptor=new MybatisPlusInterceptor(); //参数中设置的式数据库类型 interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; &#125;&#125; Controller方法返回的R的data属性是Page类型的对象,因为Page类中有total和records属性，符合前端所规定的 而且除了page和pageSize还要加一个name参数 根据员工name搜索员工信息 http://localhost:8080/employee/page?page=1&amp;pageSize=10&amp;name=123，这个就是加上name的请求地址 小测试： EmployeeController 123456//查询分页信息@GetMapping(&quot;/page&quot;) public R&lt;Page&gt; page(int page,int pageSize,String name)&#123; log.info(&quot;page=&#123;&#125;,pageSize=&#123;&#125;,name=&#123;&#125;&quot;,page,pageSize,name); return null;&#125; 完善 EmployeeController 12345678910111213141516171819//查询分页信息@GetMapping(&quot;/page&quot;) public R&lt;Page&gt; page(int page,int pageSize,String name)&#123; log.info(&quot;page=&#123;&#125;,pageSize=&#123;&#125;,name=&#123;&#125;&quot;,page,pageSize,name); //构造分页构造器 Page pageInfo=new Page(page,pageSize); //构造条件构造器 LambdaQueryWrapper&lt;Employee&gt; lambdaQueryWrapper=new LambdaQueryWrapper&lt;&gt;(); //这个意思是在name不为空的情况下，加上这个条件是employee的name为传递的参数 //第一个参数为true就加上这个条件，第一个参数为false就不加这个参数 lambdaQueryWrapper.like(StringUtils.isNotEmpty(name),Employee::getName,name); //添加排序条件 lambdaQueryWrapper.orderByDesc(Employee::getUpdateTime); //查询满足这个条件构造器的记录，然后分页之后对应的数据 employeeService.page(pageInfo,lambdaQueryWrapper); return R.success(pageInfo);&#125; 没有name的查询的sql语句 SELECT id,username,name,password,phone,sex,id_number,status,create_time,update_time,create_user,update_user FROM employee ORDER BY update_time DESC LIMIT ? 有name的查询sql语句； SELECT id,username,name,password,phone,sex,id_number,status,create_time,update_time,create_user,update_user FROM employee WHERE (name LIKE ?) ORDER BY update_time DESC LIMIT ? 这是返回到json格式的数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&#123; &quot;code&quot;: 1, &quot;msg&quot;: null, &quot;data&quot;: &#123; &quot;records&quot;: [&#123; &quot;id&quot;: 1596322557820121089, &quot;username&quot;: &quot;1234&quot;, &quot;name&quot;: &quot;123&quot;, &quot;password&quot;: &quot;e10adc3949ba59abbe56e057f20f883e&quot;, &quot;phone&quot;: &quot;18364581762&quot;, &quot;sex&quot;: &quot;1&quot;, &quot;idNumber&quot;: &quot;370611200311292613&quot;, &quot;status&quot;: 1, &quot;createTime&quot;: &quot;2022-11-26T09:58:51&quot;, &quot;updateTime&quot;: &quot;2022-11-26T09:58:51&quot;, &quot;createUser&quot;: 1, &quot;updateUser&quot;: 1 &#125;, &#123; &quot;id&quot;: 1596311515371098113, &quot;username&quot;: &quot;123&quot;, &quot;name&quot;: &quot;123&quot;, &quot;password&quot;: &quot;e10adc3949ba59abbe56e057f20f883e&quot;, &quot;phone&quot;: &quot;18364581762&quot;, &quot;sex&quot;: &quot;1&quot;, &quot;idNumber&quot;: &quot;370611200311292613&quot;, &quot;status&quot;: 1, &quot;createTime&quot;: &quot;2022-11-26T09:14:58&quot;, &quot;updateTime&quot;: &quot;2022-11-26T09:14:58&quot;, &quot;createUser&quot;: 1, &quot;updateUser&quot;: 1 &#125;, &#123; &quot;id&quot;: 1, &quot;username&quot;: &quot;admin&quot;, &quot;name&quot;: &quot;管理员&quot;, &quot;password&quot;: &quot;e10adc3949ba59abbe56e057f20f883e&quot;, &quot;phone&quot;: &quot;13812312312&quot;, &quot;sex&quot;: &quot;1&quot;, &quot;idNumber&quot;: &quot;110101199001010047&quot;, &quot;status&quot;: 1, &quot;createTime&quot;: &quot;2021-05-06T17:20:07&quot;, &quot;updateTime&quot;: &quot;2021-05-10T02:24:09&quot;, &quot;createUser&quot;: 1, &quot;updateUser&quot;: 1 &#125;], &quot;total&quot;: 3, &quot;size&quot;: 10, &quot;current&quot;: 1, &quot;orders&quot;: [], &quot;optimizeCountSql&quot;: true, &quot;hitCount&quot;: false, &quot;countId&quot;: null, &quot;maxLimit&quot;: null, &quot;searchCount&quot;: true, &quot;pages&quot;: 1 &#125;, &quot;map&quot;: &#123;&#125;&#125; list.html 这个page-sizes里面是那个一页有多少数据的下拉框的内容 可以通过改变这个page-sizes中的内容，绝顶一页显示多少条数据 12345678910&lt;el-pagination class=&quot;pageList&quot; :page-sizes=&quot;[10, 20, 30, 40]&quot; :page-size=&quot;pageSize&quot; layout=&quot;total, sizes, prev, pager, next, jumper&quot; :total=&quot;counts&quot; :current-page.sync=&quot;page&quot; @size-change=&quot;handleSizeChange&quot; @current-change=&quot;handleCurrentChange&quot;&gt;&lt;/el-pagination&gt; 指定page和pageSize初始值 可以改变默认的pageSize或者page 1234567891011data() &#123; return &#123; input: &#x27;&#x27;, counts: 0, page: 1, pageSize: 10, tableData : [], id : &#x27;&#x27;, status : &#x27;&#x27;, &#125;&#125;, 当改变了前端的页面的时候都要进行一下历史纪录的清除 点击搜索号，和分页的时候都是会发起请求的，因为都是有事件绑定在这些键上的 页面上有帐号状态这一栏，对应的是数据库中的status，但是status是Integer类型的0或1，但页面显示的是正常或者已禁用 这是因为前端有一个处理 判断scope.row.status就是拿到这个查询出来的那一行的状态那个字段的值 row是行的意思 list.html 123456789&lt;el-button type=&quot;text&quot; size=&quot;small&quot; class=&quot;delBut non&quot; @click=&quot;statusHandle(scope.row)&quot; v-if=&quot;user === &#x27;admin&#x27;&quot;&gt; &#123;&#123; scope.row.status == &#x27;1&#x27; ? &#x27;禁用&#x27; : &#x27;启用&#x27; &#125;&#125;&lt;/el-button&gt; 启用禁用员工账号需求，只有管理人员才能看到禁用禁用或者启用这个按钮，并且status为1时这里是禁用，为0这里是启用 普通人员登录看不到禁用或者启用，只能看到编辑 如何实现admin能看到启用禁用，普通用户看不到? list.html 在创建vue的时候调用的代码，这个地方就获取了user的值，也就是登录的用户的username的值 12345created() &#123; this.init() //取到登陆的用户的username的值赋给this.user this.user = JSON.parse(localStorage.getItem(&#x27;userInfo&#x27;)).username&#125;, list.html 123456789101112&lt;el-button type=&quot;text&quot; size=&quot;small&quot; class=&quot;delBut non&quot; @click=&quot;statusHandle(scope.row)&quot; 这里规定只有登陆的用户名为admin才能有这个禁用或者启用按钮 v-if=&quot;user === &#x27;admin&#x27;&quot;&gt;&#123;&#123; scope.row.status == &#x27;1&#x27; ? &#x27;禁用&#x27; : &#x27;启用&#x27; &#125;&#125;&gt;&lt;/el-button&gt; 禁用启用的前端代码讲解： scope.row是这一行数据 123456789&lt;el-button type=&quot;text&quot; size=&quot;small&quot; class=&quot;delBut non&quot; @click=&quot;statusHandle(scope.row)&quot; v-if=&quot;user === &#x27;admin&#x27;&quot;&gt; &#123;&#123; scope.row.status == &#x27;1&#x27; ? &#x27;禁用&#x27; : &#x27;启用&#x27; &#125;&#125; 点击禁用或启用调用statusHandler函数 ，绑定的@click事件 12345678910111213141516171819202122//状态修改statusHandle (row) &#123; this.id = row.id this.status = row.status this.$confirm(&#x27;确认调整该账号的状态?&#x27;, &#x27;提示&#x27;, &#123; &#x27;confirmButtonText&#x27;: &#x27;确定&#x27;, &#x27;cancelButtonText&#x27;: &#x27;取消&#x27;, &#x27;type&#x27;: &#x27;warning&#x27; &#125;).then(() =&gt; &#123; //后面这个id和status是请求的参数，json格式的 //status就是当前是0就传1，当前是1就传0 enableOrDisableEmployee(&#123; &#x27;id&#x27;: this.id, &#x27;status&#x27;: !this.status ? 1 : 0 &#125;).then(res =&gt; &#123; console.log(&#x27;enableOrDisableEmployee&#x27;,res) if (String(res.code) === &#x27;1&#x27;) &#123; this.$message.success(&#x27;账号状态更改成功！&#x27;) this.handleQuery() &#125; &#125;).catch(err =&gt; &#123; this.$message.error(&#x27;请求出错了：&#x27; + err) &#125;) &#125;)&#125; statusHandler中enanbleOrDisableEmployee方法会发起请求 12345678// 修改---启用禁用接口function enableOrDisableEmployee (params) &#123; return $axios(&#123; url: &#x27;/employee&#x27;, method: &#x27;put&#x27;, data: &#123; ...params &#125; &#125;)&#125; 点击禁用之后的请求 上面这个图片的id其实就不是数据库中真实的id，不过后端响应的时候没问题 开始代码开发： 如果直接获取这个请求参数的id，就是被修改的员工的id，放到employee中，其实不是真正这个员工在数据库中得id，因为当id存储到浏览器中时，js精度只有16位，所以在浏览器中存储不准确，如果依据他修改信息则会失败 如何解决这个问题 我们可以在服务器端给页面响应json数据时进行处理，将Long型数据同意转为String字符串 第一步：提供对象转换器，基于Jackson进行java对象到json数据的转换 对象映射器放在common包下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.itheima.reggie.common;import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.module.SimpleModule;import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer;import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;import com.fasterxml.jackson.datatype.jsr310.deser.LocalTimeDeserializer;import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer;import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;import com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer;import java.math.BigInteger;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.time.format.DateTimeFormatter;import static com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES;/** * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象] * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON] */public class JacksonObjectMapper extends ObjectMapper &#123; public static final String DEFAULT_DATE_FORMAT = &quot;yyyy-MM-dd&quot;; public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;; public static final String DEFAULT_TIME_FORMAT = &quot;HH:mm:ss&quot;; public JacksonObjectMapper() &#123; super(); //收到未知属性时不报异常 this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false); //反序列化时，属性不存在的兼容处理 this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); //这几个是设置json对象转java对象 SimpleModule simpleModule = new SimpleModule() .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT))) .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT))) .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT))) //这几个是设置java对象转为json对象 .addSerializer(BigInteger.class, ToStringSerializer.instance) //这个是把返回的json对象中的long类型的数据转换为String类型 .addSerializer(Long.class, ToStringSerializer.instance) //把LocalDateTime类型的变为这种形式 public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;; .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT))) .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT))) .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT))); //注册功能模块 例如，可以添加自定义序列化器和反序列化器 this.registerModule(simpleModule); &#125;&#125; 第二步，在WebMvcConfig配置类中扩展Springmvc消息转换器，在此消息转换器中使用提供的对象转换器进行java对象到json数据的转换 WebMvcConfig中的 123456789101112//扩展mvc框架消息转换器@Overridepublic void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; //创建消息转换器对象 //作用：将controller方法的返回值转成相应的json，再通过输出流响应给我们页面 MappingJackson2HttpMessageConverter messageConverter=new MappingJackson2HttpMessageConverter(); //设置对象转换器，底层使用Jackson将java对象转换为json messageConverter.setObjectMapper(new JacksonObjectMapper()); //将上面的消息转换器对象追加到mvc框架的转换器集合中 //第一个参数是指顺序，0就是第一个，把我们的转换器放到第一个 converters.add(0,messageConverter);&#125; 这个相应看的是那个分页方法，查询后的返回的records中的内容，上面的要修改的员工的id也是从这获取的 服务器响应日期数据转变为”createTime”:”2021-05-06 17:20:07”,”updateTime”:”2021-05-10 02:24:09” 响应id数据转变为字符串：”id”:”1596311515371098113” Controller 123456789101112131415//修改员工状态方法 //前端传回来的是要修改的员工信息的id和修改之后的状态 @PutMapping public R&lt;String&gt; update(HttpServletRequest request,@RequestBody Employee employee)&#123; log.info(employee.toString());//记录更新时间，和更新的人的id //获取登录用户的id Long id = (Long) request.getSession().getAttribute(&quot;employee&quot;); employee.setUpdateUser(id); employee.setUpdateTime(LocalDateTime.now()); //进行更新操作 employeeService.updateById(employee); return R.success(&quot;员工信息修改成功&quot;); &#125; 修改成功后页面弹窗 账号状态更改成功 1234567891011enableOrDisableEmployee(&#123; &#x27;id&#x27;: this.id, &#x27;status&#x27;: !this.status ? 1 : 0 &#125;).then(res =&gt; &#123; console.log(&#x27;enableOrDisableEmployee&#x27;,res) if (String(res.code) === &#x27;1&#x27;) &#123; this.$message.success(&#x27;账号状态更改成功！&#x27;) this.handleQuery() &#125; &#125;).catch(err =&gt; &#123; this.$message.error(&#x27;请求出错了：&#x27; + err) &#125;) &#125;) &#125;, 编辑员工信息点击编辑调用addMemberHandle方法 list.html 123456789&lt;el-button type=&quot;text&quot; size=&quot;small&quot; class=&quot;blueBug&quot; @click=&quot;addMemberHandle(scope.row.id)&quot; :class=&quot;&#123;notAdmin:user !== &#x27;admin&#x27;&#125;&quot;&gt; 编辑&lt;/el-button&gt; addMemberHandler方法 st是查询出来的那一行数据的id 12345678910111213141516 // 添加addMemberHandle (st) &#123; if (st === &#x27;add&#x27;)&#123; window.parent.menuHandle(&#123; id: &#x27;2&#x27;, url: &#x27;/backend/page/member/add.html&#x27;, name: &#x27;添加员工&#x27; &#125;,true) &#125; else &#123; window.parent.menuHandle(&#123; id: &#x27;2&#x27;, url: &#x27;/backend/page/member/add.html?id=&#x27;+st, name: &#x27;修改员工&#x27; &#125;,true) &#125;&#125; 这menuHandler会让首页的那个iframe变为自己的这个url 这个有点类似之前说的那个一进去首页，页面是员工管理那个一样 index.html 12345678menuHandle(item, goBackFlag) &#123; this.loading = true this.menuActived = item.id this.iframeUrl = item.url this.headTitle = item.name this.goBackFlag = goBackFlag this.closeLoading()&#125;, 12345678910&lt;iframe id=&quot;cIframe&quot; class=&quot;c_iframe&quot; name=&quot;cIframe&quot; :src=&quot;iframeUrl&quot; width=&quot;100%&quot; height=&quot;auto&quot; frameborder=&quot;0&quot; v-show=&quot;!loading&quot;&gt;&lt;/iframe&gt; 点击编辑之后跳转add.html,然后这个页面会有这个请求，带有id，然后从数据库中查出信息，在修改页面上显示 然后对页面上信息进行修改，点击保存后带着修改完信息，发起ajax请求，然后把修改保存到数据库中，然后再在页面显示 点保存之后调用的就是上面那个启用禁用员工账号时的update方法 1234567891011121314151617181920212223created() &#123; this.id = requestUrlParam(&#x27;id&#x27;) this.actionType = this.id ? &#x27;edit&#x27; : &#x27;add&#x27; if (this.id) &#123; this.init() &#125;&#125;,mounted() &#123;&#125;,methods: &#123; async init () &#123; queryEmployeeById(this.id).then(res =&gt; &#123; console.log(res) if (String(res.code) === &#x27;1&#x27;) &#123; console.log(res.data) this.ruleForm = res.data this.ruleForm.sex = res.data.sex === &#x27;0&#x27; ? &#x27;女&#x27; : &#x27;男&#x27; // this.ruleForm.password = &#x27;&#x27; &#125; else &#123; this.$message.error(res.msg || &#x27;操作失败&#x27;) &#125; &#125;) &#125;, vue对象创建后，就调用requestUrlParam得到那个add.html请求后面的id，如果得到了就调用init()方法 queryEmployeeById 发起请求 123456// 修改页面反查详情接口function queryEmployeeById (id) &#123; return $axios(&#123; url: `/employee/$&#123;id&#125;`, method: &#x27;get&#x27; &#125;) 然后成功后回调函数为 12345678910111213async init () &#123; queryEmployeeById(this.id).then(res =&gt; &#123; console.log(res) if (String(res.code) === &#x27;1&#x27;) &#123; console.log(res.data) //把data给这个ruleForm页面就能显示信息 this.ruleForm = res.data //因为页面显示的性别不是0或1而是男女所以这里要判断一下 this.ruleForm.sex = res.data.sex === &#x27;0&#x27; ? &#x27;女&#x27; : &#x27;男&#x27; // this.ruleForm.password = &#x27;&#x27; &#125; else &#123; this.$message.error(res.msg || &#x27;操作失败&#x27;) &#125; 代码开发：Controller 1234567891011//根据id把员工信息显示到修改的页面上@GetMapping(&quot;/&#123;id&#125;&quot;)public R&lt;Employee&gt; getById(@PathVariable Long id) &#123; log.info(&quot;根据id查询员工信息&quot;); Employee employee = employeeService.getById(id); if(employee!=null) &#123; return R.success(employee); &#125; return R.error(&quot;没有查询到员工信息&quot;); &#125; Day3公共字段自动填充在新增员工时要设置创建时间创键人，修改时间，修改人等字段，在编辑员工的时候也需要设置修改时间和修改人等字段，这些字段属于公共字段，也就是很多表中都由这些字段，能否对这些公共字段在某一个地方统一处理，简化开发呢 答案就是Mybatisplus提供的公共字段填充功能 代码开发： Employee类 给要自动填充的字段加上注解 在执行数据库操作（insert或update）之前，会给这些属性自动赋值或修改，如果不添加指定注解会修改不了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.itheima.reggie.entity;import com.baomidou.mybatisplus.annotation.FieldFill;import com.baomidou.mybatisplus.annotation.TableField;import lombok.Data;import java.io.Serializable;import java.time.LocalDateTime;/*员工实体类 */@Datapublic class Employee implements Serializable &#123; private static final long serialVersionUID = 1L; private Long id; private String username; private String name; private String password; private String phone; private String sex; private String idNumber; private Integer status; //驼峰命名法和数据库表中的字段名相对应 //插入时填充字段 @TableField(fill=FieldFill.INSERT) private LocalDateTime createTime; //插入和更新时填充字段 @TableField(fill=FieldFill.INSERT_UPDATE) private LocalDateTime updateTime; private Long createUser; //插入和更新时填充字段 @TableField(fill = FieldFill.INSERT_UPDATE) private Long updateUser;&#125; 元数据处理类重点在实现MetaObjectHandler接口 这个类在common包中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.itheima.reggie.common;import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;import lombok.extern.slf4j.Slf4j;import org.apache.ibatis.reflection.MetaObject;import org.apache.tomcat.jni.Local;import org.springframework.stereotype.Component;import java.time.LocalDateTime;@Slf4j@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123; /* 插入操作的时候自动填充 */ //这个方法执行insert的时候会执行 //metaObject中存储了被修改的这个员工的所有信息，也就是元数据 @Override public void insertFill(MetaObject metaObject) &#123; log.info(&quot;公共字段自动填充[insert]...&quot;); log.info(metaObject.toString()); metaObject.setValue(&quot;createTime&quot;, LocalDateTime.now()); metaObject.setValue(&quot;updateTime&quot;,LocalDateTime.now()); metaObject.setValue(&quot;createUser&quot;,new Long(1)); metaObject.setValue(&quot;updateUser&quot;, new Long(1)); &#125; /* 更新操作的时候自动填充 */ //这个方法在update的时候会执行 @Override public void updateFill(MetaObject metaObject) &#123;log.info(&quot;公共字段自动填充[update]&quot;);log.info(metaObject.toString()); metaObject.setValue(&quot;updateTime&quot;,LocalDateTime.now()); metaObject.setValue(&quot;updateUser&quot;, new Long(1)); &#125;&#125; Controller中的新增和修改方法 12345678910111213141516171819//修改员工状态方法 //前端传回来的是要修改的员工信息的id和修改之后的状态 @PutMapping public R&lt;String&gt; update(HttpServletRequest request,@RequestBody Employee employee)&#123; log.info(employee.toString());//记录更新时间，和更新的人的id //获取登录用户的id //下面代码被自动填充代替了 /* Long id = (Long) request.getSession().getAttribute(&quot;employee&quot;); employee.setUpdateUser(id); employee.setUpdateTime(LocalDateTime.now()); */ //进行更新操作 employeeService.updateById(employee); return R.success(&quot;员工信息修改成功&quot;); &#125; 1234567891011121314151617181920212223242526272829/*新增员工 *///路径是/employee所以不用加@PostMapping//@RequestBody接受json数据格式 public R&lt;String&gt; saveEmployee(HttpServletRequest request,@RequestBody Employee employee)&#123; log.info(&quot;员工信息:&#123;&#125;&quot;,employee.toString()); //设置默认密码，密码进行md5加密 employee.setPassword(DigestUtils.md5DigestAsHex(&quot;123456&quot;.getBytes())); //下面代码被自动填充代替了 /* //设置开始创立时间 employee.setCreateTime(LocalDateTime.now()); //设置更新创立时间 employee.setUpdateTime(LocalDateTime.now()); //获取当前用登陆用户的id //获取的默认是Object对象，进行向下转型 long id = (Long)request.getSession().getAttribute(&quot;employee&quot;); employee.setCreateUser(id); employee.setUpdateUser(id); */ employeeService.save(employee); return R.success(&quot;新增员工成功&quot;);&#125; 现在有一个问题： 就是我们在设置更新人和创建人的时候使用的id是固定的，不是获得的登录人存储好的id 解决方案： 一次请求是指就是一个url:&#x2F;employee…….这种是一个请求 在拦截器，Controller和元数据对象处理中获取线程的id可能都是一个id，说明这次请求三个方法的执行在一个线程 ThreadLocal不是一个Thread，它是Thread的局部变量，它可以给当前这个线程设置一个变量，其他的线程不能够访问到这个变量， 只有自己这个线程能访问到当前这个变量 并且每一个线程都可以设置同样的变量，每个线程都由ThreadLocal，只是他们互不相干 每一个线程只能用threadLocal保存一个变量 ThreadLocal的常用方法 public void set(T value) ：设置当前线程的线程局部变量的值 public get()：返回当前线程所对应的线程局部变量的值 思路：我们可以在拦截器中获取当前登录用户的id，并调用ThreadLocal的set方法来设置当前线程的线程局部变量的值，然后再元数据对象中的updateFill方法中调用ThreadLocal的get方法来获得当前线程所对应的线程局部变量的值(用户id) 1.封装的ThreadLocal工具类 12345678910111213141516171819package com.itheima.reggie.common;/*基于ThreadLocal封装工具类，用户保存和获取当前登录用户id */public class BaseContext &#123; //因为要用它存储id，id是long型所以这个泛型是Long private static ThreadLocal&lt;Long&gt; threadLocal=new ThreadLocal&lt;&gt;(); //保存id为线程局部变量 public static void setCurrentId(Long id)&#123; threadLocal.set(id); &#125; public static Long getCurrentId()&#123; return threadLocal.get(); &#125;&#125; 2.拦截器（错误的） 获取id后存储到ThreadLocal中 WebMvcConfig中的配置 1234567891011121314151617181920//一般都是一个方法接受请求了，然后才能把一个参数设置为HttpServletRequest request，获得request对象//其实这个地方有request属性可以，但这个不是真的request对象//所以在拦截器配置方法中他不能得到这个request.getSession()，因为request是个null，会报空指针异常//reques对象public HttpServletRequest request;//配置拦截器@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123; request.getSession() log.info(&quot;拦截器加载成功&quot;); //获取登录用户的id Long id=(Long)request.getSession().getAttribute(&quot;employee&quot;); //将这个id存储到ThreadLocal中 BaseContext.setCurrentId(id); registry.addInterceptor(new LoginInterceptor()) .addPathPatterns(&quot;/**&quot;) //所有请求都被拦截包括静态资源 .excludePathPatterns(&quot;/employee/login&quot;,&quot;/backend/**&quot;,&quot;/front/**&quot;); //放行的请求&#125; 并且我经过测试，Springboot先加载自动配置的Bean然后再加载Mvc配置类中的拦截器等等 3.元数据处理对象（错误） 在当中用ThreadLocal获取存储的id ​ Long currentId &#x3D; BaseContext.getCurrentId();不能够把它作为属性，然后在方法中使用，正确的用法是在方法中调用这个方法来获取id，原因大概是因为这是一个配置类，加载这个currentId的属性的时候还不是当前请求的这个线程，导致currentId的值是空，再调用insertFill或者updateFill的时候，currentId就是空的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.itheima.reggie.common;import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;import lombok.extern.slf4j.Slf4j;import org.apache.ibatis.reflection.MetaObject;import org.apache.tomcat.jni.Local;import org.springframework.stereotype.Component;import java.time.LocalDateTime;@Slf4j@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123; //获取当前登录的用户的id Long currentId = BaseContext.getCurrentId(); /* 插入操作的时候自动填充 */ //这个方法执行insert的时候会执行 //metaObject中存储了被修改的这个员工的所有信息，也就是元数据 @Override public void insertFill(MetaObject metaObject) &#123; log.info(&quot;公共字段自动填充[insert]...&quot;); log.info(metaObject.toString()); metaObject.setValue(&quot;createTime&quot;, LocalDateTime.now()); metaObject.setValue(&quot;updateTime&quot;,LocalDateTime.now()); metaObject.setValue(&quot;createUser&quot;,currentId); metaObject.setValue(&quot;updateUser&quot;, currentId); &#125; /* 更新操作的时候自动填充 */ //这个方法在update的时候会执行 @Override public void updateFill(MetaObject metaObject) &#123;log.info(&quot;公共字段自动填充[update]&quot;);log.info(metaObject.toString()); metaObject.setValue(&quot;updateTime&quot;,LocalDateTime.now()); metaObject.setValue(&quot;updateUser&quot;, currentId); &#125;&#125; 上面是自己想的错误演示 我的问题在于把配置拦截器的WebMvcConfig中的配置拦截器的方法，当作拦截器了 其实真正的拦截器是LoginInterceptor，应该在那里面配置 正确的： 1.封装的ThreadLocal工具类 12345678910111213141516171819package com.itheima.reggie.common;/*基于ThreadLocal封装工具类，用户保存和获取当前登录用户id */public class BaseContext &#123; //因为要用它存储id，id是long型所以这个泛型是Long private static ThreadLocal&lt;Long&gt; threadLocal=new ThreadLocal&lt;&gt;(); //保存id为线程局部变量 public static void setCurrentId(Long id)&#123; threadLocal.set(id); &#125; public static Long getCurrentId()&#123; return threadLocal.get(); &#125;&#125; 2.拦截器 123456//获取session中employee Long employee = (Long) session.getAttribute(&quot;employee&quot;); //把id放到ThreadLocal中 BaseContext.setCurrentId(employee); 123456789101112131415161718192021222324252627282930313233343536373839package com.itheima.reggie.config;import com.alibaba.fastjson.JSON;import com.fasterxml.jackson.databind.ser.Serializers;import com.itheima.reggie.common.BaseContext;import com.itheima.reggie.common.R;import javafx.beans.binding.LongExpression;import lombok.extern.slf4j.Slf4j;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;@Slf4jpublic class LoginInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String requestURI=request.getRequestURI(); log.info(&quot;请求已经拦截&#123;&#125;&quot;,requestURI); //获取session HttpSession session = request.getSession(); //获取session中employee Long employee = (Long) session.getAttribute(&quot;employee&quot;); //把id放到ThreadLocal中 BaseContext.setCurrentId(employee); //employee不为空就是登陆了放行 if(employee!=null)&#123; //放行 return true; &#125; //如果未登录返回未登录结果，通过输出流方式向客户端页面响应数据 response.getWriter().write(JSON.toJSONString(R.error(&quot;NOTLOGIN&quot;))); return false; &#125;&#125; 3.元数据对象处理类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.itheima.reggie.common;import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;import lombok.extern.slf4j.Slf4j;import org.apache.ibatis.reflection.MetaObject;import org.apache.tomcat.jni.Local;import org.springframework.stereotype.Component;import java.time.LocalDateTime;@Slf4j@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123; /* 插入操作的时候自动填充 */ //这个方法执行insert的时候会执行 //metaObject中存储了被修改的这个员工的所有信息，也就是元数据 @Override public void insertFill(MetaObject metaObject) &#123; log.info(&quot;公共字段自动填充[insert]...&quot;); log.info(metaObject.toString()); metaObject.setValue(&quot;createTime&quot;, LocalDateTime.now()); metaObject.setValue(&quot;updateTime&quot;,LocalDateTime.now()); //注意这个BaseContext不能在类中当作属性获取，就是写在外面然后方法里用，是不可以的 metaObject.setValue(&quot;createUser&quot;,BaseContext.getCurrentId()); metaObject.setValue(&quot;updateUser&quot;, BaseContext.getCurrentId()); &#125; /* 更新操作的时候自动填充 */ //这个方法在update的时候会执行 @Override public void updateFill(MetaObject metaObject) &#123;log.info(&quot;公共字段自动填充[update]&quot;);log.info(metaObject.toString()); metaObject.setValue(&quot;updateTime&quot;,LocalDateTime.now()); metaObject.setValue(&quot;updateUser&quot;, BaseContext.getCurrentId()); &#125;&#125; 新增分类这个主要是开发分类管理 分类管理分为套餐分类和菜品分类 一个套餐分类（超值午餐）中对应好几种具体的套餐 一个菜品分类(湘菜)中对应好几种具体的菜品 分类管理对应的页面是backend下的page下的catgory下的list.html 分类对应的是数据库中的category表，name字段有唯一约束 从资料中拷贝Category CategoryMapper 12345678910package com.itheima.reggie.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.itheima.reggie.entity.Category;@Mapperpublic interface CategoryMapper extends BaseMapper&lt;Category&gt; &#123;&#125; CategoryServiceImpl 12345678910111213package com.itheima.reggie.service.impl;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.itheima.reggie.entity.Category;import com.itheima.reggie.entity.Employee;import com.itheima.reggie.mapper.CategoryMapper;import com.itheima.reggie.mapper.EmployeeMapper;import com.itheima.reggie.service.CategoryService;@Servicepublic class CategoryServiceImpl extends ServiceImpl&lt;CategoryMapper, Category&gt; implements CategoryService &#123;&#125; CategoryService 1234567package com.itheima.reggie.service;import com.baomidou.mybatisplus.extension.service.IService;import com.itheima.reggie.entity.Category;public interface CategoryService extends IService&lt;Category&gt; &#123;&#125; CategoryController 123456789101112131415package com.itheima.reggie.controller;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@Slf4j@RestController//这里面请求都是这个开头的@RequestMapping(&quot;/category&quot;)public class CategoryController &#123;&#125; Category 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.itheima.reggie.entity;import com.baomidou.mybatisplus.annotation.FieldFill;import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.annotation.TableField;import com.baomidou.mybatisplus.annotation.TableId;import lombok.Data;import lombok.Getter;import lombok.Setter;import java.io.Serializable;import java.time.LocalDateTime;/** * 分类 */@Datapublic class Category implements Serializable &#123; private static final long serialVersionUID = 1L; private Long id; //类型 1 菜品分类 2 套餐分类 private Integer type; //分类名称 private String name; //顺序 private Integer sort; //创建时间 @TableField(fill = FieldFill.INSERT) private LocalDateTime createTime; //更新时间 @TableField(fill = FieldFill.INSERT_UPDATE) private LocalDateTime updateTime; //创建人 @TableField(fill = FieldFill.INSERT) private Long createUser; //修改人 @TableField(fill = FieldFill.INSERT_UPDATE) private Long updateUser; //是否删除 private Integer isDeleted;&#125; 修改这些之后无法启动项目，可以点击maven中的那个小刷新号，可以重新打包一下 clean是清除之前的包，package是重新打包 点击新增菜品分类之后，填完后点击确定，会发起下面的请求，以及携带的参数 name和sort都是表单中自己填写提交的，type是自带的，用来区分是新增菜品还是套餐 点击新增套餐分类之后，填完点击确定，发的和上面的请求一样，只不过type是2 看看前端代码； backend下的page下的catgory下的list.html 1234567891011121314&lt;el-button type=&quot;primary&quot; class=&quot;continue&quot; @click=&quot;addClass(&#x27;class&#x27;)&quot; &gt; + 新增菜品分类 &lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;addClass(&#x27;meal&#x27;)&quot; &gt; + 新增套餐分类 &lt;/el-button&gt;&lt;/div&gt; addClass方法 1234567891011121314 // 添加addClass(st) &#123; if (st == &#x27;class&#x27;) &#123; this.classData.title = &#x27;新增菜品分类&#x27; this.type = &#x27;1&#x27; &#125; else &#123; this.classData.title = &#x27;新增套餐分类&#x27; this.type = &#x27;2&#x27; &#125; this.action = &#x27;add&#x27; this.classData.name = &#x27;&#x27; this.classData.sort = &#x27;&#x27; this.classData.dialogVisible = true&#125;, list.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!---这里是显示页面内容的代码--&gt;&lt;el-table-column prop=&quot;type&quot; label=&quot;分类类型&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;!--这里就是因为数据库中type是1或者2但是页面显示要是菜品分类或者套餐分类--&gt; &lt;span&gt;&#123;&#123; scope.row.type == &#x27;1&#x27; ? &#x27;菜品分类&#x27;: &#x27;套餐分类&#x27; &#125;&#125;&lt;/span&gt; &lt;/template&gt;&lt;/el-table-column&gt;&lt;el-table-column prop=&quot;updateTime&quot; label=&quot;操作时间&quot;&gt;&lt;template slot-scope=&quot;scope&quot;&gt; &#123;&#123;scope.row.updateTime&#125;&#125;&lt;/template&gt;&lt;/el-table-column&gt;&lt;el-table-column prop=&quot;sort&quot; label=&quot;排序&quot;/&gt;&lt;/el-table-column&gt;&lt;el-table-column label=&quot;操作&quot; width=&quot;160&quot; align=&quot;center&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button type=&quot;text&quot; size=&quot;small&quot; class=&quot;blueBug&quot; @click=&quot;editHandle(scope.row)&quot; &gt; 修改 &lt;/el-button&gt; &lt;el-button type=&quot;text&quot; size=&quot;small&quot; class=&quot;delBut non&quot; @click=&quot;deleteHandle(scope.row.id)&quot; &gt; 删除 &lt;/el-button&gt; 则一块是点击新增菜单分类或者新增套餐分类之后的弹框 点击确定后调用submitForm()方法 123456789101112131415161718192021222324252627282930313233343536&lt;el-form class=&quot;demo-form-inline&quot; label-width=&quot;100px&quot;&gt; &lt;el-form-item label=&quot;分类名称：&quot;&gt; &lt;el-input v-model=&quot;classData.name&quot; placeholder=&quot;请输入分类名称&quot; maxlength=&quot;14&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;排序：&quot;&gt; &lt;el-input v-model=&quot;classData.sort&quot; type=&quot;number&quot; placeholder=&quot;请输入排序&quot; /&gt; &lt;/el-form-item&gt;&lt;/el-form&gt;&lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button size=&quot;medium&quot; @click=&quot;classData.dialogVisible = false&quot; &gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; size=&quot;medium&quot; @click=&quot;submitForm()&quot; &gt;确 定&lt;/el-button&gt; &lt;el-button v-if=&quot;action != &#x27;edit&#x27;&quot; type=&quot;primary&quot; size=&quot;medium&quot; class=&quot;continue&quot; @click=&quot;submitForm(&#x27;go&#x27;)&quot; &gt; 保存并继续添加 &lt;/el-button&gt;&lt;/span&gt; submitForm() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//数据提交submitForm(st) &#123; const classData = this.classData const valid = (classData.name === 0 ||classData.name) &amp;&amp; (classData.sort === 0 || classData.sort) //添加的时候action是add,addClass方法决定的 if (this.action === &#x27;add&#x27;) &#123; if (valid) &#123; const reg = /^\\d+$/ if (reg.test(classData.sort)) &#123; addCategory(&#123;&#x27;name&#x27;: classData.name,&#x27;type&#x27;:this.type, sort: classData.sort&#125;).then(res =&gt; &#123; console.log(res) if (res.code === 1) &#123; this.$message.success(&#x27;分类添加成功！&#x27;) if (!st) &#123; this.classData.dialogVisible = false &#125; else &#123; this.classData.name = &#x27;&#x27; this.classData.sort = &#x27;&#x27; &#125; this.handleQuery() &#125; else &#123; this.$message.error(res.msg || &#x27;操作失败&#x27;) &#125; &#125;).catch(err =&gt; &#123; this.$message.error(&#x27;请求出错了：&#x27; + err) &#125;) &#125; else &#123; this.$message.error(&#x27;排序只能输入数字类型&#x27;) &#125; &#125; else &#123; this.$message.error(&#x27;请输入分类名称或排序&#x27;) &#125; &#125; else if (valid) &#123; const reg = /^\\d+$/ if (reg.test(this.classData.sort)) &#123; editCategory(&#123;&#x27;id&#x27;:this.classData.id,&#x27;name&#x27;: this.classData.name, sort: this.classData.sort&#125;).then(res =&gt; &#123; if (res.code === 1) &#123; this.$message.success(&#x27;分类修改成功！&#x27;) this.classData.dialogVisible = false this.handleQuery() &#125; else &#123; this.$message.error(res.msg || &#x27;操作失败&#x27;) &#125; &#125;).catch(err =&gt; &#123; this.$message.error(&#x27;请求出错了：&#x27; + err) &#125;) &#125; else &#123; this.$message.error(&#x27;排序只能输入数字类型&#x27;) &#125; &#125; else &#123; this.$message.error(&#x27;请输入分类名称或排序&#x27;) &#125;&#125;, 发起ajax请求的方法 12345678// 新增接口const addCategory = (params) =&gt; &#123; return $axios(&#123; url: &#x27;/category&#x27;, method: &#x27;post&#x27;, data: &#123; ...params &#125; &#125;)&#125; CategoryController 12345678910111213141516171819202122232425262728package com.itheima.reggie.controller;import com.itheima.reggie.common.R;import com.itheima.reggie.entity.Category;import com.itheima.reggie.service.impl.CategoryServiceImpl;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@Slf4j@RestController//这里面请求都是这个开头的@RequestMapping(&quot;/category&quot;)public class CategoryController &#123; @Autowired CategoryServiceImpl categoryService; @PostMapping public R&lt;String&gt; insert(@RequestBody Category category)&#123; log.info(&quot;category&#123;&#125;&quot;,category); categoryService.save(category); return R.success(&quot;新增分类成功&quot;); &#125;&#125; 分页查询分类前端代码： 这个vue对象是在点击分类管理，加载这个页面的时候创建的 1234567891011121314151617181920212223242526//created代码是在vue刚创建的时候调用的 //这个vue对象是在点击分类管理，加载这个页面的时候创建的 //然后去调用init() created() &#123; this.init() &#125;, mounted() &#123; &#125;, //这段代码是在vue刚建立时调用的 methods: &#123; async init () &#123; //这个地方是发起ajax请求的，带着page和pageSize参数 //then里面是回调函数，只要把page对象赋值到R.data返回就行了,这里和之前员工的查询都是一样的 await getCategoryPage(&#123;&#x27;page&#x27;: this.page, &#x27;pageSize&#x27;: this.pageSize&#125;).then(res =&gt; &#123; if (String(res.code) === &#x27;1&#x27;) &#123; this.tableData = res.data.records this.counts = Number(res.data.total) &#125; else &#123; //这里大概就是如果res.msg不为空这里输出res.msg如果为空输出操作失败 this.$message.error(res.msg || &#x27;操作失败&#x27;) &#125; &#125;).catch(err =&gt; &#123; //这里是捕捉错误信息 this.$message.error(&#x27;请求出错了：&#x27; + err) &#125;) &#125;, total和records都是page对象的属性 getCategoryPage 123456789// 查询列表接口//这个是发起ajax请求的const getCategoryPage = (params) =&gt; &#123; return $axios(&#123; url: &#x27;/category/page&#x27;, method: &#x27;get&#x27;, params &#125;)&#125; 这是点击分类管理页面之后会发送的请求 CategoryContorller 123456789101112@GetMapping(&quot;/page&quot;)public R&lt;Page&gt; select(int page,int pageSize)&#123; Page&lt;Category&gt; pageInfo=new Page&lt;&gt;(page,pageSize); //条件构造器 LambdaQueryWrapper&lt;Category&gt; lambdaQueryWrapper=new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper.orderByAsc(Category::getSort); //这个方法发起sql语句的时候是根据这个Category类中的属性来执行sql语句的 categoryService.page(pageInfo,lambdaQueryWrapper); log.info(pageInfo.toString()); return R.success(pageInfo);&#125; 分类类型存的是1，2在数据库中，但页面上是菜品分类和套餐分类 是因为前端做了处理 删除分类在分类管理页面，可以对某个分类进行删除操作，需要注意的是当分类关联了菜品或者套餐时，此分类不允许删除 这是点了删除以后，点击确认之后发起的请求 list.html 123456789&lt;/el-button&gt;&lt;el-button type=&quot;text&quot; size=&quot;small&quot; class=&quot;delBut non&quot; @click=&quot;deleteHandle(scope.row.id)&quot;&gt; 删除&lt;/el-button&gt; 1234567891011121314151617181920212223 //删除//当点击删除的时候调用的方法 deleteHandle(id) &#123; this.$confirm(&#x27;此操作将永久删除该文件, 是否继续?&#x27;, &#x27;提示&#x27;, &#123; &#x27;confirmButtonText&#x27;: &#x27;确定&#x27;, &#x27;cancelButtonText&#x27;: &#x27;取消&#x27;, &#x27;type&#x27;: &#x27;warning&#x27; &#125;).then(() =&gt; &#123; //点击确定后的回调函数 deleCategory(id).then(res =&gt; &#123; if (res.code === 1) &#123; this.$message.success(&#x27;删除成功！&#x27;) //这个是指回到分类查询的第一页 this.handleQuery() &#125; else &#123; //这里是如果后端返回R.error(msg)就会输出msg的内容 this.$message.error(res.msg || &#x27;操作失败&#x27;) &#125; &#125;).catch(err =&gt; &#123; this.$message.error(&#x27;请求出错了：&#x27; + err) &#125;) &#125;) &#125;, Controller 12345678@DeleteMapping//id已经变为String类型的了public R&lt;String&gt; delete( String ids)&#123; log.info(&quot;id:&#123;&#125;&quot;,ids); categoryService.removeById(ids); return R.success(&quot;删除成功了&quot;);&#125; 功能完善：前面实现了通过id删除分类的功能，但是并没有检查删除的分类是否关联了菜品或套餐，所以我们需要进行功能完善 逻辑就是用ids查询有没有菜品或者套餐是这个分类的，如果有就抛出异常，如果没有就正常删除，抛出异常之后，由异常处理器统一处理，然后再把错误信息返回给前端 先把Dish和Setmeal两个实体类加进来 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.itheima.reggie.entity;import com.baomidou.mybatisplus.annotation.FieldFill;import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.annotation.TableField;import com.baomidou.mybatisplus.annotation.TableId;import lombok.Data;import java.io.Serializable;import java.math.BigDecimal;import java.time.LocalDateTime;/** 菜品 */@Datapublic class Dish implements Serializable &#123; private static final long serialVersionUID = 1L; private Long id; //菜品名称 private String name; //菜品分类id private Long categoryId; //菜品价格 private BigDecimal price; //商品码 private String code; //图片 private String image; //描述信息 private String description; //0 停售 1 起售 private Integer status; //顺序 private Integer sort; @TableField(fill = FieldFill.INSERT) private LocalDateTime createTime; @TableField(fill = FieldFill.INSERT_UPDATE) private LocalDateTime updateTime; @TableField(fill = FieldFill.INSERT) private Long createUser; @TableField(fill = FieldFill.INSERT_UPDATE) private Long updateUser; //是否删除 private Integer isDeleted;&#125; Setmeal 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.itheima.reggie.entity;import com.baomidou.mybatisplus.annotation.FieldFill;import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.annotation.TableField;import com.baomidou.mybatisplus.annotation.TableId;import lombok.Data;import java.io.Serializable;import java.math.BigDecimal;import java.time.LocalDateTime;/** * 套餐 */@Datapublic class Setmeal implements Serializable &#123; private static final long serialVersionUID = 1L; private Long id; //分类id private Long categoryId; //套餐名称 private String name; //套餐价格 private BigDecimal price; //状态 0:停用 1:启用 private Integer status; //编码 private String code; //描述信息 private String description; //图片 private String image; @TableField(fill = FieldFill.INSERT) private LocalDateTime createTime; @TableField(fill = FieldFill.INSERT_UPDATE) private LocalDateTime updateTime; @TableField(fill = FieldFill.INSERT) private Long createUser; @TableField(fill = FieldFill.INSERT_UPDATE) private Long updateUser; //是否删除 private Integer isDeleted;&#125; CategoryController 12345678@DeleteMapping//id已经变为String类型的了public R&lt;String&gt; delete( Long ids)&#123; log.info(&quot;id:&#123;&#125;&quot;,ids);//这个remove方法是自定义的 categoryService.remove(ids); return R.success(&quot;删除成功了&quot;);&#125; Service中增加的自定义的remove方法 逻辑就是用ids查询有没有菜品或者套餐是这个分类的，如果有就抛出异常，如果没有就正常删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.itheima.reggie.service.impl;import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.itheima.reggie.common.CustomerException;import com.itheima.reggie.entity.Category;import com.itheima.reggie.entity.Dish;import com.itheima.reggie.entity.Setmeal;import com.itheima.reggie.mapper.CategoryMapper;import com.itheima.reggie.service.CategoryService;import com.itheima.reggie.service.SetmealService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Service@Slf4jpublic class CategoryServiceImpl extends ServiceImpl&lt;CategoryMapper, Category&gt; implements CategoryService &#123; @Autowired DishServiceImpl dishService; @Autowired SetmealService setmealService; @Override public void remove(Long ids) &#123; //查出这个ids有套餐与之关联抛出异常 //条件构造器 LambdaQueryWrapper&lt;Dish&gt; lambdaQueryWrapper=new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper.eq(Dish::getCategoryId, ids); //SELECT COUNT( * ) FROM dish WHERE (category_id = ?) int count = dishService.count(lambdaQueryWrapper); if(count&gt;0)&#123; //抛出异常 throw new CustomerException(&quot;这个分类有菜品与之关联&quot;); &#125; //查出这个ids有套餐与之关联抛出异常 LambdaQueryWrapper&lt;Setmeal&gt; lambdaQueryWrapper1=new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper1.eq(Setmeal::getCategoryId, ids); int count1 = setmealService.count(lambdaQueryWrapper1); if(count1&gt;0)&#123; //抛出异常 throw new CustomerException(&quot;这个分类有套餐与之关联&quot;); &#125; //正常删除 super.removeById(ids); &#125;&#125; CategoryService 12345678package com.itheima.reggie.service;import com.baomidou.mybatisplus.extension.service.IService;import com.itheima.reggie.entity.Category;public interface CategoryService extends IService&lt;Category&gt; &#123; void remove(Long ids);&#125; 自定义异常 123456789101112package com.itheima.reggie.common;public class CustomerException extends RuntimeException &#123; public CustomerException()&#123; &#125; //这个参数就是异常信息 public CustomerException(String msg)&#123; super(msg); &#125;&#125; common中的GlobalExceptionHandler中的方法处理CustomerException异常的方法 这里就是把自定义的异常信息返回给前端 抛出异常 12345@ExceptionHandler(&#123;CustomerException.class&#125;)public R&lt;String&gt; exceptionHandler1(CustomerException ex)&#123; //ex.getMessage()获取的就是自己传递的报错信息，就是那个异常类构造器参数 return R.error(ex.getMessage());&#125; 前端实现回显 1234567891011121314151617181920212223 //删除//当点击删除的时候调用的方法 deleteHandle(id) &#123; this.$confirm(&#x27;此操作将永久删除该文件, 是否继续?&#x27;, &#x27;提示&#x27;, &#123; &#x27;confirmButtonText&#x27;: &#x27;确定&#x27;, &#x27;cancelButtonText&#x27;: &#x27;取消&#x27;, &#x27;type&#x27;: &#x27;warning&#x27; &#125;).then(() =&gt; &#123; //点击确定后的回调函数 deleCategory(id).then(res =&gt; &#123; if (res.code === 1) &#123; this.$message.success(&#x27;删除成功！&#x27;) //这个是指回到分类查询的第一页 this.handleQuery() &#125; else &#123; //这里是如果后端返回R.error(msg)就会输出msg的内容 this.$message.error(res.msg || &#x27;操作失败&#x27;) &#125; &#125;).catch(err =&gt; &#123; this.$message.error(&#x27;请求出错了：&#x27; + err) &#125;) &#125;) &#125;, 修改分类list.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 //数据提交//数据提交的时候是通过this.action是否为add来分别的，如果是action是add就是新增，action edit就是修改 submitForm(st) &#123; const classData = this.classData const valid = (classData.name === 0 ||classData.name) &amp;&amp; (classData.sort === 0 || classData.sort) if (this.action === &#x27;add&#x27;) &#123; if (valid) &#123; const reg = /^\\d+$/ if (reg.test(classData.sort)) &#123; //addCategory发起请求成功返回后就会执行这个方法，返回值是res addCategory(&#123;&#x27;name&#x27;: classData.name,&#x27;type&#x27;:this.type, sort: classData.sort&#125;).then(res =&gt; &#123; //这个是它的回调函数， console.log(res) if (res.code === 1) &#123; this.$message.success(&#x27;分类添加成功！&#x27;) if (!st) &#123; this.classData.dialogVisible = false &#125; else &#123; this.classData.name = &#x27;&#x27; this.classData.sort = &#x27;&#x27; &#125; //这个是指重新回到分类查询的第一页 this.handleQuery() &#125; else &#123; this.$message.error(res.msg || &#x27;操作失败&#x27;) &#125; &#125;).catch(err =&gt; &#123; this.$message.error(&#x27;请求出错了：&#x27; + err) &#125;) &#125; else &#123; this.$message.error(&#x27;排序只能输入数字类型&#x27;) &#125; &#125; else &#123; this.$message.error(&#x27;请输入分类名称或排序&#x27;) &#125; &#125; else if (valid) &#123; const reg = /^\\d+$/ if (reg.test(this.classData.sort)) &#123; //这里是发起修改的ajax请求的地方 //返回成功之后执行then的回调函数 editCategory(&#123;&#x27;id&#x27;:this.classData.id,&#x27;name&#x27;: this.classData.name, sort: this.classData.sort&#125;).then(res =&gt; &#123; if (res.code === 1) &#123; this.$message.success(&#x27;分类修改成功！&#x27;) this.classData.dialogVisible = false //这个是指重新回到分类查询的第一页 this.handleQuery() &#125; else &#123; this.$message.error(res.msg || &#x27;操作失败&#x27;) &#125; &#125;).catch(err =&gt; &#123; this.$message.error(&#x27;请求出错了：&#x27; + err) &#125;) &#125; else &#123; this.$message.error(&#x27;排序只能输入数字类型&#x27;) &#125; &#125; else &#123; this.$message.error(&#x27;请输入分类名称或排序&#x27;) &#125; &#125;, list.html 12345678// 修改接口const editCategory = (params) =&gt; &#123; return $axios(&#123; url: &#x27;/category&#x27;, method: &#x27;put&#x27;, data: &#123; ...params &#125; &#125;)&#125; 点击确定之后发起的请求 Controller 12345@PutMappingpublic R&lt;String&gt; update(@RequestBody Category category)&#123; categoryService.updateById(category); return R.success(&quot;修改完成&quot;);&#125; Day4菜品的展示 文件的上传下载文件上传要springmvc，瑞吉外卖和springboot中三个一起看 把文件上传的页面拷贝到page的demo目录下，上传文件之后会发起的请求 上传文件的标签在源码中不显示是因为elementui的封装，但现在可以在元素看到name&#x3D;file 文件上传的Controller 12345678910111213141516171819202122232425262728package com.itheima.reggie.controller;import com.itheima.reggie.common.R;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.multipart.MultipartFile;@Slf4j@RestController@RequestMapping(&quot;/common&quot;)public class CommonController &#123; /** * 文件上传 * @param file * @return */ @PostMapping(&quot;/upload&quot;)public R&lt;String&gt; upload(@RequestParam(&quot;file&quot;) MultipartFile file)&#123; //file是一个临时文件，需要转存到指定位置，否则本次请求完成后临时文件会删除 log.info(file.toString()); return null;&#125;&#125; 完善：把图片转存到指定位置 1234567try &#123; //调用这个方法的时候除了文件可以不存在，路径上的文件夹都一定要存在 //这个方法是把file文件转存到指定路径 file.transferTo(new File(basePath+filename)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; 特点：把文件存储的路径，放到yml文件中管理方便修改 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.itheima.reggie.controller;import com.itheima.reggie.common.R;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.multipart.MultipartFile;import java.io.File;import java.io.IOException;import java.util.UUID;@Slf4j@RestController@RequestMapping(&quot;/common&quot;)public class CommonController &#123; @Value(&quot;$&#123;reggie.basePath&#125;&quot;) //从application.yml文件中获取这个路径 /* reggie: basePath: D:\\img1\\ */ private String basePath; /** * 文件上传 * @param file * @return */ @PostMapping(&quot;/upload&quot;)public R&lt;String&gt; upload(@RequestParam(&quot;file&quot;) MultipartFile file)&#123; //file是一个临时文件，需要转存到指定位置，否则本次请求完成后临时文件会删除 log.info(file.toString()); //原始文件名 String originalFilename=file.getOriginalFilename(); //获取文件的后缀名 String suffix=originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;)); //使用UUID重新生成文件名，防止文件名称重复造成文件覆盖 //uuid是一个随机生成不重复文件名的工具 String filename= UUID.randomUUID().toString()+suffix; //创建一个目录对象 File dir=new File(basePath); //判断当前目录是否存在，如果不存在就创建这个目录 if(!dir.exists())&#123; //mkdirs是用来创建文件夹的不能创建文件 dir.mkdirs(); &#125; try &#123; //调用这个方法的时候除了文件可以不存在，路径上的文件夹都一定要存在 //这个方法是把file文件转存到指定路径 file.transferTo(new File(basePath+filename)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return R.success(filename);&#125;&#125; application.yml设置basePath路径 12reggie: basePath: D:\\img1\\ application.yml设置上传文件的大小 1234567spring: servlet: multipart:#一个文件的最大的内存 max-file-size: 10MB#多文件上传的上传的所有文件的总共最大的内存 max-request-size: 100MB 文件的下载 通过文件的下载，可以实现上传的文件在浏览器页面上显示的效果 文件上传成功后，前端会自动发起文件下载在浏览器上显示的请求 1234567891011121314151617181920212223242526272829 @GetMapping(&quot;/download&quot;) public void download(String name , HttpServletResponse response) &#123; try &#123;//输入流，通过输入流读取文件内容 FileInputStream fileInputStream = new FileInputStream(new File(basePath + name)); //输出流，通过输出流将文件写回浏览器，在浏览器展示图片了 ServletOutputStream outputStream = response.getOutputStream(); //设置响应回去的文件时图片类型 response.setContentType(&quot;image/jpeg&quot;); byte[] bytes = new byte[1024]; int len = 0; //把文件通过输入流输入到byte数组 //两个流之间进行配合，输入流把文件输入到内存中，然后输出流再把文件协会到浏览器 while ((len = fileInputStream.read(bytes)) != -1) &#123; outputStream.write(bytes, 0, len); &#125; //关闭资源 outputStream.close(); fileInputStream.close(); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; 文件上传页面的前端代码 上传成功后调用handleAvatarSuccess方法，会发起文件下载（在浏览器页面上显示）请求，请求带着文件的名称 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;文件上传&lt;/title&gt; &lt;!-- 引入样式 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../../plugins/element-ui/index.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../../styles/common.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../../styles/page.css&quot; /&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;addBrand-container&quot; id=&quot;food-add-app&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;!--action就是上传文件请求的地址--&gt; &lt;!--on-success是上传成功之后要调用的方法--&gt; &lt;el-upload class=&quot;avatar-uploader&quot; action=&quot;/common/upload&quot; :show-file-list=&quot;false&quot; :on-success=&quot;handleAvatarSuccess&quot; :before-upload=&quot;beforeUpload&quot; ref=&quot;upload&quot;&gt; &lt;img v-if=&quot;imageUrl&quot; :src=&quot;imageUrl&quot; class=&quot;avatar&quot;&gt;&lt;/img&gt; &lt;i v-else class=&quot;el-icon-plus avatar-uploader-icon&quot;&gt;&lt;/i&gt; &lt;/el-upload&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src=&quot;../../plugins/vue/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- 引入组件库 --&gt; &lt;script src=&quot;../../plugins/element-ui/index.js&quot;&gt;&lt;/script&gt; &lt;!-- 引入axios --&gt; &lt;script src=&quot;../../plugins/axios/axios.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../../js/index.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#food-add-app&#x27;, data() &#123; return &#123; imageUrl: &#x27;&#x27; &#125; &#125;, methods: &#123; //这里就是上传文件成功之后，又重新发起下载文件在浏览器上显示的请求 //response.data会 handleAvatarSuccess (response, file, fileList) &#123; this.imageUrl = `/common/download?name=$&#123;response.data&#125;` &#125;, beforeUpload (file) &#123; if(file)&#123; const suffix = file.name.split(&#x27;.&#x27;)[1] const size = file.size / 1024 / 1024 &lt; 2 if([&#x27;png&#x27;,&#x27;jpeg&#x27;,&#x27;jpg&#x27;].indexOf(suffix) &lt; 0)&#123; this.$message.error(&#x27;上传图片只支持 png、jpeg、jpg 格式！&#x27;) this.$refs.upload.clearFiles() return false &#125; if(!size)&#123; this.$message.error(&#x27;上传文件大小不能超过 2MB!&#x27;) return false &#125; return file &#125; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 新增菜品这是新增菜品页面https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202212011417771.png 前面这个是dish_flavour表中的name字段，后面这个是dish_flavour表中的value字段 这个用category_id来表示 点击新建菜品之后的跳转 http://localhost:8080/backend/page/food/add 然后浏览器会发出一个请求，请求服务端获取菜品分类数据展示到下拉框中 代码开发 1.获取菜品分类数据到下拉框 CategoryController 123456789101112131415161718/*新增菜品的时候，点击新增菜品，查询菜品分类在下拉框里 */@GetMapping(&quot;/list&quot;)public R&lt;List&lt;Category&gt;&gt; list(Category category)&#123; //创建条件构造器 LambdaQueryWrapper&lt;Category&gt; lambdaQueryWrapper=new LambdaQueryWrapper&lt;&gt;(); //添加条件 lambdaQueryWrapper.eq(category.getType()!=null,Category::getType,category.getType()); //添加排序条件 lambdaQueryWrapper.orderByAsc(Category::getSort).orderByDesc(Category::getUpdateTime); //把搜索出来的放在list集合中 List&lt;Category&gt; list=categoryService.list(lambdaQueryWrapper); return R.success(list);&#125; 接受页面提交的数据 点击保存之后发起的请求和负载 除了flavors之外其他都是Dish类的属性，flavors是一个数组，前端选择了几个口味数组中就有几个元素，每个元素中的那些值都是对应DishFlavor类中的属性，在后端可以用List来接受flavors 所以不能用Dish或者DishFlavor的任何一个对象来接受所有的参数，所以要创建一个新的类来能够接受所有的参数 所以导入DishDto，用于封装页面提交的数据，在资料里面直接拿就可以了 123456789101112131415161718package com.itheima.reggie.dto;import com.itheima.reggie.entity.Dish;import com.itheima.reggie.entity.DishFlavor;import lombok.Data;import java.util.ArrayList;import java.util.List;@Data//继承了Dish之后就可以接受Dish中属性的参数public class DishDto extends Dish &#123; private List&lt;DishFlavor&gt; flavors = new ArrayList&lt;&gt;(); private String categoryName; private Integer copies;&#125; 提交的数据是json数据，所以方法接受参数的时候要加一个@RequestBody DishController 123456789101112131415161718192021222324252627282930313233343536package com.itheima.reggie.controller;import com.itheima.reggie.common.R;import com.itheima.reggie.dto.DishDto;import com.itheima.reggie.service.DishFlavorService;import com.itheima.reggie.service.DishService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@Slf4j@RestController@RequestMapping(&quot;/dish&quot;)public class DishController &#123; //菜品 @Autowired private DishService dishService; //口味 @Autowired private DishFlavorService dishFlavorService; @PostMapping public R&lt;String&gt; save( @RequestBody DishDto dishDto)&#123; //这个save里除了是Dish类是Dish类的子类也是可以的 //dishService.save(dishDto); dishService.saveWithDishFlavor(dishDto); return R.success(&quot;保存成功&quot;); &#125;&#125; 这里的saveWithDishFlavor方法是自己设计的 DishService 123456789101112package com.itheima.reggie.service;import com.baomidou.mybatisplus.extension.service.IService;import com.itheima.reggie.dto.DishDto;import com.itheima.reggie.entity.Dish;import org.apache.ibatis.annotations.Mapper;public interface DishService extends IService&lt;Dish&gt; &#123; //保存到dish中同时保存到flavor表中 public void saveWithDishFlavor(DishDto dishDto);&#125; DishServiceImpl 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.itheima.reggie.service.impl;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.itheima.reggie.dto.DishDto;import com.itheima.reggie.entity.Dish;import com.itheima.reggie.entity.DishFlavor;import com.itheima.reggie.mapper.DishMapper;import com.itheima.reggie.service.DishFlavorService;import com.itheima.reggie.service.DishService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import java.util.List;@Service@Slf4jpublic class DishServiceImpl extends ServiceImpl&lt;DishMapper, Dish&gt; implements DishService &#123; @Autowired private DishFlavorService dishFlavorService; @Override //这里涉及到多个事务，所以用注解开启事务管理 //这里是遇到所有的异常都回滚的意思 @Transactional(rollbackFor = Exception.class) public void saveWithDishFlavor(DishDto dishDto) &#123; //保存dish的属性 this.save(dishDto); List&lt;DishFlavor&gt; flavors = dishDto.getFlavors(); //获取菜品所属的类的id Long id = dishDto.getId(); //给每一个flavor复制 for (DishFlavor flavor : flavors) &#123; flavor.setDishId(id); &#125; //批量引入 dishFlavorService.saveBatch(flavors); &#125;&#125; 菜品信息的分页查询 1.页面发送ajax请求 难点：在页面的时候展示的是菜品的分类名称，但是在菜品表中只有菜品的分类的id所以要进行两表联查 这个请求是一进入菜品管理这个页面就会发起的请求，当然一进入发起的没有name参数，当搜索菜品名称的时候就有name参数了 DishController 第二个方法是分页查询的显示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.itheima.reggie.controller;import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;import com.baomidou.mybatisplus.extension.plugins.pagination.Page;import com.itheima.reggie.common.R;import com.itheima.reggie.dto.DishDto;import com.itheima.reggie.entity.Category;import com.itheima.reggie.entity.Dish;import com.itheima.reggie.service.CategoryService;import com.itheima.reggie.service.DishFlavorService;import com.itheima.reggie.service.DishService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.BeanUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.ArrayList;import java.util.List;@Slf4j@RestController@RequestMapping(&quot;/dish&quot;)public class DishController &#123; //菜品 @Autowired private DishService dishService; @Autowired private CategoryService categoryService; //口味 @Autowired private DishFlavorService dishFlavorService; @PostMapping public R&lt;String&gt; save( @RequestBody DishDto dishDto)&#123; //这个save里除了是Dish类是Dish类的子类也是可以的 //dishService.save(dishDto); dishService.saveWithDishFlavor(dishDto); return R.success(&quot;保存成功&quot;); &#125; /* 查询方法 */ //因为Dish对象中的菜品类型是以id存储的，页面需要显示的是名称，所以要把page对象中的records换一下 //要新建一个分页对象，其他属性和Dish那个分页对象一样，只有records要进行修改，把里面内容换为DishDto对象的内容 //主要是因为DishDto没有自己的Service，像这种查询的dishService必须要求这个条件构造器是Dish泛型的，所以就得向上面这样分布搞 @GetMapping(&quot;/page&quot;) public R&lt;Page&gt; page(int page,int pageSize,String name)&#123; Page&lt;Dish&gt; pageInfo=new Page&lt;&gt;(page,pageSize); Page&lt;DishDto&gt; dishDto=new Page&lt;&gt;(page,pageSize); //条件构造器 LambdaQueryWrapper&lt;Dish&gt; lambdaQueryWrapper=new LambdaQueryWrapper&lt;Dish&gt;(); lambdaQueryWrapper.like(name != null, Dish::getName, name); dishService.page(pageInfo,lambdaQueryWrapper); //把pageInfo对象中除了records属性都拷贝一份到dishDto对象中 BeanUtils.copyProperties(pageInfo,dishDto,&quot;records&quot;); List&lt;Dish&gt; records = pageInfo.getRecords(); List&lt;DishDto&gt; records2=new ArrayList&lt;&gt;(); for (Dish record : records) &#123; Long categoryId = record.getCategoryId(); Category category = categoryService.getById(categoryId); String categoryName = category.getName(); DishDto dishDto1=new DishDto(); BeanUtils.copyProperties(record,dishDto1); dishDto1.setCategoryName(categoryName); records2.add(dishDto1); &#125; dishDto.setRecords(records2); return R.success(dishDto); &#125;&#125; 这里没图片正常因为，数据库导入的只是一些数字罢了，没有真的上传图片这个操作 修改菜品信息点击修改之后，发送这个请求带着的是菜品的id 1.再修改页面获取要修改的菜品的信息 DishController 12345678910/*再修改页面上获取原本的菜品信息 */@GetMapping(&quot;/&#123;id&#125;&quot;)public R&lt;DishDto&gt; edit(@PathVariable long id)&#123; DishDto dishDto = dishService.get(id); return R.success(dishDto);&#125; DishServiceImpl 1234567891011121314151617181920212223242526272829303132/* 获取要修改的菜品的信息 */@Overridepublic DishDto get(Long id) &#123; //获取菜品对象 Dish dish = dishService.getById(id); //获取菜品对应的类型id Long categoryId = dish.getCategoryId(); //获取菜品类型 Category category = categoryService.getById(categoryId); //获取类型的名称 String name = category.getName(); //把dish中的属性都赋值到dishDto中 DishDto dishDto=new DishDto(); dishDto.setCategoryName(name); BeanUtils.copyProperties(dish,dishDto); //条件构造器 LambdaQueryWrapper&lt;DishFlavor&gt; lambdaQueryWrapper=new LambdaQueryWrapper&lt;DishFlavor&gt;(); lambdaQueryWrapper.eq(DishFlavor::getDishId,id); //获取dishDto中的flavors属性的值 List&lt;DishFlavor&gt; list = dishFlavorService.list(lambdaQueryWrapper); dishDto.setFlavors(list); return dishDto;&#125; 2.修改页面点击保存发起的请求 DishServiceImpl 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122package com.itheima.reggie.service.impl;import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;import com.baomidou.mybatisplus.core.conditions.update.LambdaUpdateWrapper;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.itheima.reggie.dto.DishDto;import com.itheima.reggie.entity.Category;import com.itheima.reggie.entity.Dish;import com.itheima.reggie.entity.DishFlavor;import com.itheima.reggie.mapper.DishMapper;import com.itheima.reggie.service.CategoryService;import com.itheima.reggie.service.DishFlavorService;import com.itheima.reggie.service.DishService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.BeanUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import org.springframework.web.bind.annotation.RequestBody;import java.util.List;@Service@Slf4jpublic class DishServiceImpl extends ServiceImpl&lt;DishMapper, Dish&gt; implements DishService &#123; @Autowired private DishFlavorService dishFlavorService; @Autowired private DishService dishService; @Autowired private CategoryService categoryService; @Override //这里涉及到多个事务，所以用注解开启事务管理 //这里是遇到所有的异常都回滚的意思 @Transactional(rollbackFor = Exception.class) public void saveWithDishFlavor(DishDto dishDto) &#123; //保存dish的属性 this.save(dishDto); List&lt;DishFlavor&gt; flavors = dishDto.getFlavors(); //获取菜品所属的类的id Long id = dishDto.getId(); //给每一个flavor复制 for (DishFlavor flavor : flavors) &#123; flavor.setDishId(id); &#125; //批量引入 dishFlavorService.saveBatch(flavors); &#125; /* 获取要修改的菜品的信息 */ @Override public DishDto get(Long id) &#123; //获取菜品对象 Dish dish = dishService.getById(id); //获取菜品对应的类型id Long categoryId = dish.getCategoryId(); //获取菜品类型 Category category = categoryService.getById(categoryId); //获取类型的名称 String name = category.getName(); //把dish中的属性都赋值到dishDto中 DishDto dishDto=new DishDto(); dishDto.setCategoryName(name); BeanUtils.copyProperties(dish,dishDto); //条件构造器 LambdaQueryWrapper&lt;DishFlavor&gt; lambdaQueryWrapper=new LambdaQueryWrapper&lt;DishFlavor&gt;(); lambdaQueryWrapper.eq(DishFlavor::getDishId,id); //获取dishDto中的flavors属性的值 List&lt;DishFlavor&gt; list = dishFlavorService.list(lambdaQueryWrapper); dishDto.setFlavors(list); return dishDto; &#125; /* 修改菜品的方法 */ @Override //既要对dish表进行修改，也要对dishFlavor表进行修改 public void updateWithDishFlavor( DishDto dishDto)&#123; //把dish表先修改了 //dishDto是Dish的子类的对象，也可以进行修改 //这个update是根据id修改 this.updateById(dishDto); //删除原本口味表中的记录 LambdaQueryWrapper&lt;DishFlavor&gt; lambdaQueryWrapper=new LambdaQueryWrapper&lt;DishFlavor&gt;(); lambdaQueryWrapper.eq(DishFlavor::getDishId,dishDto.getId()); dishFlavorService.remove(lambdaQueryWrapper); Long Dishid=dishDto.getId(); //这个flavors中的DishFlavor中的dishid都没有被赋值 List&lt;DishFlavor&gt; flavors = dishDto.getFlavors(); for (DishFlavor flavor : flavors) &#123; flavor.setDishId(Dishid); &#125; //批量对flavor表中进行插入 dishFlavorService.saveBatch(flavors); &#125;&#125; DishService 123456789101112131415161718package com.itheima.reggie.service;import com.baomidou.mybatisplus.extension.service.IService;import com.itheima.reggie.dto.DishDto;import com.itheima.reggie.entity.Dish;import org.apache.ibatis.annotations.Mapper;public interface DishService extends IService&lt;Dish&gt; &#123; //保存到dish中同时保存到flavor表中 public void saveWithDishFlavor(DishDto dishDto); //修改dish表的同时修改flavor表 public void updateWithDishFlavor(DishDto dishDto); //查找要修改的记录的数据显示到修改页面上 public DishDto get(Long id);&#125; 删除菜品信息点击删除之后服务器发起的请求 Controller 12345678910111213141516/*删除对应的信息 */@DeleteMappingpublic R&lt;String&gt; delete( long ids)&#123; //删除dish表中数据 dishService.removeById(ids); //删除dishflavor表中的数据 LambdaQueryWrapper&lt;DishFlavor&gt; lambdaQueryWrapper=new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper.eq(DishFlavor::getDishId,ids); dishFlavorService.remove(lambdaQueryWrapper); return R.success(&quot;删除成功了&quot;);&#125; 停售功能dish表中的status字段为1则是起售，为0则是停售 DishController 12345678910111213141516171819/*改变商品功能的信息 */@PostMapping(&quot;/status/&#123;status&#125;&quot;)public R&lt;String&gt; editStatus(Long ids,@PathVariable int status)&#123; //创建一个菜品对象,并把获得的id赋值给这个对象 Dish dish=new Dish(); dish.setId(ids); //将获取的id存放在dish对象中，并且设置status为传递的参数 dish.setStatus(status); //对status进行修改，创建时间和创建人什么的只写都是写过自动的 dishService.updateById(dish); return R.success(&quot;修改成功&quot;);&#125; 批量删除功能 要把原来的删除方法改一下，可以用数组来接受这种ids多值传参的情况 DishServiceImpl 123456789101112131415161718192021222324252627282930//删除记录@Overridepublic void delete(Long[] ids) &#123; //查询套餐状态，确定是否真的要删除 //条件构造器中的条件是指套餐id在这些参数里面，套餐的状态还是可用状态的 //就是可用状态的套餐是不能够随便删除的 LambdaQueryWrapper&lt;Dish&gt; lambdaQueryWrapper1=new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper1.in(Dish::getId,ids); lambdaQueryWrapper1.eq(Dish::getStatus,1); //返回符合这个条件构造器的记录的个数 int count=this.count(lambdaQueryWrapper1); if(count&gt;0)&#123; throw new CustomerException(&quot;套餐正在售卖中，不能删除&quot;); &#125; //删除dish表中数据 //这里removeByIds只能用集合来删除，但接收参数只能用数组 List&lt;Long&gt; list = Arrays.asList(ids); dishService.removeByIds(list); //删除dishflavor表中的数据 for (Long id : ids) &#123; LambdaQueryWrapper&lt;DishFlavor&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper.eq(DishFlavor::getDishId,id); dishFlavorService.remove(lambdaQueryWrapper); &#125;&#125; DishService 12//删除记录public void delete(Long ids[]); DishController 12345678910/*删除对应的信息 */@DeleteMapping@Transactionalpublic R&lt;String&gt; delete( Long ids[])&#123; dishService.delete(ids); return R.success(&quot;删除成功了&quot;);&#125; 批量停售和批量起售 在原本的起售和停售的功能上进行修改 1234567891011121314151617181920/*改变商品功能的信息 */@PostMapping(&quot;/status/&#123;status&#125;&quot;)public R&lt;String&gt; editStatus(Long ids[],@PathVariable int status)&#123; for (Long id : ids) &#123; //创建一个菜品对象,并把获得的id赋值给这个对象 Dish dish = new Dish(); dish.setId(id); //将获取的id存放在dish对象中，并且设置status为传递的参数 dish.setStatus(status); //对status进行修改，创建时间和创建人什么的只写都是写过自动的 dishService.updateById(dish); &#125; return R.success(&quot;修改成功&quot;);&#125; Day5新增套餐setdish表是套餐表，setmeal_dish是套餐和菜品的关系的表 导入DTO SetmealDto ，从资料中导入，这个是用来接受前端传来的参数，以及往前端传参数时用到的类 同时把SetmealDish实体类导入进来，SetDish类之前导入过了 SetmealDto 1234567891011121314package com.itheima.reggie.dto;import com.itheima.reggie.entity.Setmeal;import com.itheima.reggie.entity.SetmealDish;import lombok.Data;import java.util.List;@Datapublic class SetmealDto extends Setmeal &#123; private List&lt;SetmealDish&gt; setmealDishes; private String categoryName;&#125; 这个请求是，查询到套餐分类在下拉栏里显示，之前写过 这个请求是查询比如湘菜中都有哪些菜品的请求，也是放在显示栏里，就是点击添加菜品的时候出现的那个 在导航栏中可以任意切换菜品的种类，比如湘菜，川菜，饮品等等，每个发起的请求都不一样 DishController 显示每一个菜品大类下的具体的菜品的 1234567891011121314151617/*这个功能是在套餐管理添加的页面中，查询每一种菜品类型所对应的全部具体的菜品 *///用dish来接受catogoryId@GetMapping(&quot;/list&quot;)public R&lt;List&lt;Dish&gt;&gt; list(Dish dish)&#123; LambdaQueryWrapper&lt;Dish&gt; lambdaQueryWrapper=new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper.eq(dish.getCategoryId()!=null,Dish::getCategoryId,dish.getCategoryId()); //添加排序条件 lambdaQueryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime); List&lt;Dish&gt; list = dishService.list(lambdaQueryWrapper); // sql语句： SELECT id,name,category_id,price,code,image,description,status,sort,create_time,update_time,create_user,update_user,is_deleted FROM dish WHERE (category_id = ? AND status = ?) ORDER BY sort ASC,update_time DESC return R.success(list);&#125; 2.点击保存之后发起的请求 参数 保存到数据库这种有逻辑以及实现的代码最好是封装在Service中，然后Controller中直接调用 SetmealController 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.itheima.reggie.controller;import com.itheima.reggie.common.R;import com.itheima.reggie.dto.SetmealDto;import com.itheima.reggie.entity.SetmealDish;import com.itheima.reggie.service.CategoryService;import com.itheima.reggie.service.SetmealDishService;import com.itheima.reggie.service.SetmealService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.transaction.annotation.Transactional;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;/*套餐管理 */@RestController@Slf4j@RequestMapping(&quot;/setmeal&quot;)public class SetmealController &#123;@Autowired private SetmealService setmealService;@Autowired private SetmealDishService setmealDishService;@PostMapping@Transactional//多个事务要进行事务管理public R&lt;String&gt; insert(@RequestBody SetmealDto setmealDto)&#123; setmealService.saveWithDish(setmealDto); return R.success(&quot;保存成功&quot;);&#125;&#125; SetmealService 1234567891011package com.itheima.reggie.service;import com.baomidou.mybatisplus.extension.service.IService;import com.itheima.reggie.dto.DishDto;import com.itheima.reggie.dto.SetmealDto;import com.itheima.reggie.entity.Setmeal;public interface SetmealService extends IService&lt;Setmeal&gt; &#123; public void saveWithDish(SetmealDto setmealDto);&#125; SetmealServiceImpl 123456789101112131415161718192021222324252627282930313233343536373839404142package com.itheima.reggie.service.impl;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.itheima.reggie.dto.DishDto;import com.itheima.reggie.dto.SetmealDto;import com.itheima.reggie.entity.Setmeal;import com.itheima.reggie.entity.SetmealDish;import com.itheima.reggie.mapper.SetmealMapper;import com.itheima.reggie.service.SetmealDishService;import com.itheima.reggie.service.SetmealService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class SetmealServiceImpl extends ServiceImpl&lt;SetmealMapper, Setmeal&gt; implements SetmealService &#123; @Autowired private SetmealService setmealService; @Autowired private SetmealDishService setmealDishService; @Override public void saveWithDish(SetmealDto setmealDto) &#123; //先保存到setmeal表 setmealService.save(setmealDto); //保存之后的setmealDto对象就会自动有id，就是具体套餐的id Long setmealid = setmealDto.getId(); List&lt;SetmealDish&gt; setmealDishes = setmealDto.getSetmealDishes(); //这里的SetmealDish没有接收到SetmealId for (SetmealDish setmealDish : setmealDishes) &#123; setmealDish.setSetmealId(setmealid); &#125; //对setmealdish表进行保存 setmealDishService.saveBatch(setmealDishes); &#125;&#125; 套餐信息分页查询页面发起的分页请求 这里往前端返回的时候，返回的Page对象的泛型应该返回setmealdto，因为setmeal没有categoryname，但是页面上需要显示categoryname，所以用继承了setmeal的setmealdto，因为他不仅有setmeal有的属性还有setmeal没有的categoryName SetmealController 1234567891011121314151617181920212223242526272829303132333435363738//分页查询功能的实现 //这个和之前那个菜品类型管理的分页查询功能类似@GetMapping(&quot;/page&quot;) public R&lt;Page&gt; page(int page,int pageSize,String name)&#123; Page&lt;Setmeal&gt; setmealPage=new Page&lt;Setmeal&gt; (page,pageSize); Page&lt;SetmealDto&gt; setmealDtoPage=new Page&lt;&gt;(); LambdaQueryWrapper&lt;Setmeal&gt; lambdaQueryWrapper=new LambdaQueryWrapper&lt;&gt;(); //添加排序条件，根据更新时间进行like模糊查询 lambdaQueryWrapper.orderByDesc(Setmeal::getCreateTime); //添加查询条件，根据立刻进行模糊查询 lambdaQueryWrapper.like(name!=null,Setmeal::getName,name); setmealService.page(setmealPage,lambdaQueryWrapper); //把setmealPage中除了records属性都赋值给setmealDtoPage BeanUtils.copyProperties(setmealPage,setmealDtoPage,&quot;records&quot;); //下面这些是因为Setmeal对象中没有SermealDto所需要的categoryName，下面是在获取categoryName List&lt;Setmeal&gt; records = setmealPage.getRecords(); List&lt;SetmealDto&gt; records2=new ArrayList&lt;&gt;(); for (Setmeal record : records) &#123; SetmealDto setmealDto=new SetmealDto(); BeanUtils.copyProperties(record,setmealDto); //这个是这个具体的套餐对应的套餐类型的id Long categoryId = record.getCategoryId(); Category category = categoryService.getById(categoryId); if(category!=null) &#123; String categoryName = category.getName(); setmealDto.setCategoryName(categoryName); &#125; records2.add(setmealDto); &#125; setmealDtoPage.setRecords(records2); return R.success(setmealDtoPage);&#125; 删除和批量删除功能的实现点击删除的时候发起的请求 SetmealService 1234567891011121314package com.itheima.reggie.service;import com.baomidou.mybatisplus.extension.service.IService;import com.itheima.reggie.dto.DishDto;import com.itheima.reggie.dto.SetmealDto;import com.itheima.reggie.entity.Setmeal;public interface SetmealService extends IService&lt;Setmeal&gt; &#123; public void saveWithDish(SetmealDto setmealDto); //删除功能 public void deleteWithDish(Long ids[]);&#125; SetmealServiceImpl 1234567891011121314151617181920212223242526272829303132333435@Overridepublic void deleteWithDish(Long ids[]) &#123; //查询套餐状态，确定是否真的要删除 //条件构造器中的条件是指套餐id在这些参数里面，套餐的状态还是可用状态的 //就是可用状态的套餐是不能够随便删除的 LambdaQueryWrapper&lt;Setmeal&gt; lambdaQueryWrapper=new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper.in(Setmeal::getId,ids); lambdaQueryWrapper.eq(Setmeal::getStatus,1); //返回符合这个条件构造器的记录的个数 int count=this.count(lambdaQueryWrapper); if(count&gt;0)&#123; throw new CustomerException(&quot;套餐正在售卖中，不能删除&quot;); &#125; //将long类型的数组转换为集合 List&lt;Long&gt; list = Arrays.asList(ids); //从setmeal表中删除记录 setmealService.removeByIds(list); //从setmealdish表示删除数据 /* LambdaQueryWrapper&lt;SetmealDish&gt; lambdaQueryWrapper2=new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper2.eq(SetmealDish::getDishId,ids); setmealDishService.remove(lambdaQueryWrapper2);*/ LambdaQueryWrapper&lt;SetmealDish&gt; lambdaQueryWrapper1=new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper1.in(SetmealDish::getDishId,ids); //删除关系表中的数据----setmeal_dish //删除所有dishid在ids中的以及setmeal_dish表中的记录 setmealDishService.remove(lambdaQueryWrapper1);&#125; SetmealController 123456789@DeleteMapping@Transactional public R&lt;String&gt; delete(Long ids[])&#123; //删除操作 setmealService.deleteWithDish(ids); return R.success(&quot;删除成功&quot;);&#125; 停售和批量停售点击批量停售之后发起的请求 SetmealController 1234567891011@PostMapping(&quot;/status/&#123;status&#125;&quot;) public R&lt;String&gt; editStatus(Long ids[],@PathVariable int status)&#123; for (Long id : ids) &#123; LambdaUpdateWrapper&lt;Setmeal&gt; lambdaUpdateWrapper=new LambdaUpdateWrapper&lt;&gt;(); lambdaUpdateWrapper.eq(Setmeal::getId,id); lambdaUpdateWrapper.set(Setmeal::getStatus,status); setmealService.update(lambdaUpdateWrapper); &#125; return R.success(&quot;修改成功&quot;);&#125; 修改套餐信息的功能Day6阿里云短信服务 申请短信服务要添加模板，添加签名，申请了签名之后，它会自动赠送模板 模板内容，也就是短信中的内容 再设置AccessKey，也就是一对用户名密码，进行认证健全，也就是当你要用阿里云某个服务的时候，你需要这个AccessKey 点击继续使用AccessKey创建的AccessKey用户名密码一旦泄露，用户可以用这个用户名密码访问我们我们阿里云服务的所有服务，但如果点击开始使用子用户AccessKey，用这个AccessKey能访问的服务就有限，就更安全 点击AccessKey之后要创建一个新用户，名称随便， 第一个选项控制台访问是这个用户可以用账号密码访问阿里云控制台 第二个选项OpenAPI调用访问，启用AccessKeyID和AccessKey Secret，支持通过API和其他开发工具访问 生成AccessKey ID和AccessKey Secret AccessKey Secret 1oeb0As1PbClkyH4SkUqNUIBp6ZTPu0 对新增用户授权，点击用户，点击权限管理，点击新增授权，在下面指定权限范围 如果AccessKey和AccessID被泄露，可以禁用或者删除 短信发送引入依赖 12345678910111213 &lt;!--阿里云短信服务--&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;version&gt;4.5.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-dysmsapi&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 阿里云短信服务帮助文档链接 短信服务 (aliyun.com) 其中有一个SDK参考，其中一个叫做JAVASDK参考，可以参考他用java代码发送短信 SDK就是辅助开发的一个工具包，辅助开发某一类软件的相关文档、范例和工具的集合都可以叫做SDK，其实Jdk就是java sdk的缩写 API概念：说得更加通俗易懂一些，别人写好的代码，或者编译好的程序，提供给你使用，就叫做API。你使用了别人代码（或者程序）中的某个函数、类、对象，就叫做使用了某个API。 这个是java发送短信的API 1234567891011121314151617181920212223242526272829303132333435363738394041package com.itheima.reggie.common;import com.aliyuncs.DefaultAcsClient;import com.aliyuncs.IAcsClient;import com.aliyuncs.dysmsapi.model.v20170525.SendSmsRequest;import com.aliyuncs.dysmsapi.model.v20170525.SendSmsResponse;import com.aliyuncs.exceptions.ClientException;import com.aliyuncs.profile.DefaultProfile;/** * 短信发送工具类 */public class SMSUtils &#123; /** * 发送短信 * @param signName 签名，签名就是之前申请的签名 * @param templateCode 模板，申请的模板有一个属性就是模板Code * @param phoneNumbers 手机号,要发送短信的手机号 * @param param 参数，是用来把模板内容中的$&#123;code&#125;换为这个param */ public static void sendMessage(String signName, String templateCode,String phoneNumbers,String param)&#123; //后面两个参数分别是AccessID合AccessSecret DefaultProfile profile = DefaultProfile.getProfile(&quot;cn-hangzhou&quot;, &quot;LTAI5tC1JHJ7AWcoZqCjGbws&quot;, &quot;oeb0As1PbClkyH4SkUqNUIBp6ZTPu0&quot;); IAcsClient client = new DefaultAcsClient(profile); SendSmsRequest request = new SendSmsRequest(); request.setSysRegionId(&quot;cn-hangzhou&quot;); request.setPhoneNumbers(phoneNumbers); request.setSignName(signName); request.setTemplateCode(templateCode); request.setTemplateParam(&quot;&#123;\\&quot;code\\&quot;:\\&quot;&quot;+param+&quot;\\&quot;&#125;&quot;); try &#123; SendSmsResponse response = client.getAcsResponse(request); System.out.println(&quot;短信发送成功&quot;); &#125;catch (ClientException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 验证码登陆的开发为了方便用户登录，移动端通常提供手机验证码登陆的功能 把SMSUtils和ValidateCodeUtils导入到utils包下 在拦截器中放行&#x2F;user&#x2F;sendMsg和&#x2F;user&#x2F;login两个请求 &#x2F;user&#x2F;sendMsg 是点击发送验证码的请求，带着参数是phone也就是输入的号码 &#x2F;user&#x2F;login 是点击发送验证码之后又跳转回登陆页面的请求 12345678//配置拦截器@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123; log.info(&quot;拦截器加载成功&quot;); registry.addInterceptor(new LoginInterceptor()) .addPathPatterns(&quot;/**&quot;) //所有请求都被拦截包括静态资源 .excludePathPatterns(&quot;/employee/login&quot;,&quot;/backend/**&quot;,&quot;/front/**&quot;,&quot;/user/sendMsg&quot;,&quot;/user/login&quot;); //放行的请求&#125; 访问&#x2F;front&#x2F;page&#x2F;login.html这个页面是html5开发的，自适应手机页面，但是用浏览器查看的话 点击f12，然后点击第一行第二个，这个时候就是手机的适应 拦截器的类进行了修改 就是只要是用户或者客户登录都可以放行 从session中获取的东西都是Object类型的，可以进行cast 1234567//验证用户是否登录String user = (String)session.getAttribute(&quot;user&quot;);if(user!=null)&#123; //放行 return true;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.itheima.reggie.config;import com.alibaba.fastjson.JSON;import com.fasterxml.jackson.databind.ser.Serializers;import com.itheima.reggie.common.BaseContext;import com.itheima.reggie.common.R;import javafx.beans.binding.LongExpression;import lombok.extern.slf4j.Slf4j;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;@Slf4jpublic class LoginInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String requestURI=request.getRequestURI(); log.info(&quot;请求已经拦截&#123;&#125;&quot;,requestURI); //获取session HttpSession session = request.getSession(); //获取session中employee Long employee = (Long) session.getAttribute(&quot;employee&quot;); //把id放到ThreadLocal中 BaseContext.setCurrentId(employee); //employee不为空就是登陆了放行 if(employee!=null)&#123; //放行 return true; &#125; //验证用户是否登录 String user = (String)session.getAttribute(&quot;user&quot;); if(user!=null)&#123; //放行 return true; &#125; //如果未登录返回未登录结果，通过输出流方式向客户端页面响应数据 response.getWriter().write(JSON.toJSONString(R.error(&quot;NOTLOGIN&quot;))); return false; &#125;&#125; 点击发送验证码之后调用的方法 UserContoller 请求是：&#x2F;user&#x2F;sendMsg 正常这样就可以，但是现在这个请求不发起直接在前端就生成了验证码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.itheima.reggie.controller;import com.itheima.reggie.common.R;import com.itheima.reggie.entity.User;import com.itheima.reggie.service.UserService;import com.itheima.reggie.utils.SMSUtils;import com.itheima.reggie.utils.ValidateCodeUtils;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.servlet.http.HttpSession;@RestController@Slf4j@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Autowired private UserService userService; @PostMapping(&quot;/sendMsg&quot;) public R&lt;String&gt; sendMsg(@RequestBody User user, HttpSession session)&#123; //获取手机号 String phone=user.getPhone(); if(phone!=null)&#123; //获取验证码 String code = ValidateCodeUtils.generateValidateCode4String(4).toString(); //发送短信 SMSUtils.sendMessage(&quot;rgwm&quot;,&quot;SMS_262585563&quot;,phone,code); //将发送的验证码放到session域中，方便与用户输入的作比较 session.setAttribute(&quot;code&quot;,code); return R.success(&quot;手机验证码短信发送成功&quot;); &#125; return R.error(&quot;手机验证码短信发送失败&quot;); &#125;&#125; 因为前端发起的登录请求中只有一个phone，而且很简陋这个版本，就是实现一个功能 登录功能 点击登陆之后发起的请求 简化版，正常应该有验证码的比较 UserController点击登录发送的请求 1234567891011121314151617181920 @PostMapping(&quot;/login&quot;)public R&lt;User&gt; login(@RequestBody User user, HttpServletRequest request)&#123; HttpSession session = request.getSession(); LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper=new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper.eq(User::getPhone,user.getPhone()); User user1 = userService.getOne(lambdaQueryWrapper); //如果是第一次登录的用户就保存用户信息到数据库 if(user1==null)&#123; User user2=new User(); user2.setPhone(user.getPhone()); userService.save(user2); session.setAttribute(&quot;user&quot;,user2.getId()); &#125; else &#123; //这里是因为过滤器里面要求必须有user才能够放行 session.setAttribute(&quot;user&quot;, user1.getId()); &#125; return R.success(user1);&#125; 对拦截器进行改造，让用户登录或者工作人员登录都能放行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.itheima.reggie.config;import com.alibaba.fastjson.JSON;import com.fasterxml.jackson.databind.ser.Serializers;import com.itheima.reggie.common.BaseContext;import com.itheima.reggie.common.R;import javafx.beans.binding.LongExpression;import lombok.extern.slf4j.Slf4j;import org.omg.CORBA.UserException;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;@Slf4jpublic class LoginInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String requestURI=request.getRequestURI(); log.info(&quot;请求已经拦截&#123;&#125;&quot;,requestURI); //获取session HttpSession session = request.getSession(); //获取session中employee Long employee = (Long) session.getAttribute(&quot;employee&quot;); Long user=(Long) session.getAttribute(&quot;user&quot;); if(employee!=null)&#123; //把id放到ThreadLocal BaseContext.setCurrentId(employee); //放行 return true; &#125; if(user!=null)&#123; BaseContext.setCurrentId(user); return true; &#125; //如果未登录返回未登录结果，通过输出流方式向客户端页面响应数据 response.getWriter().write(JSON.toJSONString(R.error(&quot;NOTLOGIN&quot;))); return false; &#125;&#125; Day7购物车的开发 地址簿，指的是移动端消费者用户的地址信息，用户登录成功后可以维护自己的地址信息，同一个用户可以有多个地址信息，但只能有一个默认地址 菜品的展示查询所有的分类，显示在首页上，点击每一个分栏还可以查询到每一个分类中具体的菜品，这些请求之前都写过就是dish和setmeal的list方法 问题：点击选择规格的时候需要展示这个菜品的口味，所以要改造dish和setmeal的list DishController 把返回的dish的list变为dishdto的list这样就可以带着口味返回了 1234567891011121314151617181920212223242526272829303132333435363738这个功能是在套餐管理添加的页面中，查询每一种菜品类型所对应的全部具体的菜品 *///用dish来接受catogoryId@GetMapping(&quot;/list&quot;)public R&lt;List&lt;DishDto&gt;&gt; list(Dish dish)&#123; LambdaQueryWrapper&lt;Dish&gt; lambdaQueryWrapper=new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper.eq(dish.getCategoryId()!=null,Dish::getCategoryId,dish.getCategoryId()); //查询status为1的菜品，就是正在起售的菜品 lambdaQueryWrapper.eq(Dish::getStatus,1); //添加排序条件 lambdaQueryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime); List&lt;Dish&gt; list = dishService.list(lambdaQueryWrapper); List&lt;DishDto&gt; listDto=new ArrayList&lt;&gt;(); for (Dish dish1 : list) &#123; Long categoryId = dish1.getCategoryId(); Category category = categoryService.getById(categoryId); DishDto dishDto1=new DishDto(); if(category!=null) &#123; String categoryName = category.getName(); dishDto1.setCategoryName(categoryName); &#125; //通过具体菜品的id，查出它的口味 Long dishId=dish1.getId(); LambdaQueryWrapper&lt;DishFlavor&gt; lambdaQueryWrapper1=new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper1.eq(DishFlavor::getDishId,dishId); List&lt;DishFlavor&gt; dishFlavorList=dishFlavorService.list(lambdaQueryWrapper1); dishDto1.setFlavors(dishFlavorList); BeanUtils.copyProperties(dish1,dishDto1); listDto.add(dishDto1); &#125; return R.success(listDto);&#125; SetmealController 这个是它的list请求 SetmealController 显示套餐信息，他就不用选择口味，所以简单一些 123456789101112@GetMapping(&quot;/list&quot;)public R&lt;List&lt;Setmeal&gt;&gt; list (Setmeal setmeal) &#123; LambdaQueryWrapper&lt;Setmeal&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper.eq(Setmeal::getCategoryId, setmeal.getCategoryId()); lambdaQueryWrapper.eq(Setmeal::getStatus, 1); lambdaQueryWrapper.orderByAsc(Setmeal::getUpdateTime); List&lt;Setmeal&gt; list = setmealService.list(lambdaQueryWrapper); return R.success(list);&#125; 购物车业务功能的开发点击要把菜品或者套餐加入到购物车中，其实发起的请求都是一样的，但是带着的参数确是不同的 菜品是dishId，套餐是setmealId 点击上面菜品的那个加号也是，发起上面图片那个请求 ShoppingCartController 123456789101112131415161718192021222324252627282930313233343536373839404142@PostMapping(&quot;/add&quot;)public R&lt;ShoppingCart&gt; addShoppingCart(@RequestBody ShoppingCart shoppingCart)&#123; //获取当前在操作购物车的用户id Long currentId = BaseContext.getCurrentId(); shoppingCart.setUserId(currentId); //获取当前要加入的套餐或者菜品中的dishId Long dishId = shoppingCart.getDishId(); //创建条件构造器 LambdaQueryWrapper&lt;ShoppingCart&gt; lambdaQueryWrapper=new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper.eq(ShoppingCart::getUserId,currentId); if(dishId!=null)&#123; lambdaQueryWrapper.eq(ShoppingCart::getDishId,dishId); &#125; else &#123; lambdaQueryWrapper.eq(ShoppingCart::getSetmealId,shoppingCart.getSetmealId()); &#125; //如果购物车中有过这个套餐或菜品则数量加一，如果没有过则默认number为一 ShoppingCart cart = shoppingCartService.getOne(lambdaQueryWrapper); if(cart!=null)&#123; Integer number = cart.getNumber(); cart.setNumber(number+1); shoppingCartService.updateById(cart); &#125; else &#123; //shoppingCart是一开始传进来的参数 shoppingCart.setNumber(1); //设置创建的时间 shoppingCart.setCreateTime(LocalDateTime.now()); cart=shoppingCart; shoppingCartService.save(cart); &#125; return R.success(cart);&#125; 关于amount现在先不用管，现在就是一个菜品或套餐的价格，等提交订单的时候让amount乘以number就是总的价钱了 显示购物车的功能开发 一进入那个主页，页面除了会对类型发起请求，还会对购物车发起请求 ShoppingCartController 1234567891011121314 @GetMapping(&quot;/list&quot;)public R&lt;List&lt;ShoppingCart&gt;&gt; list()&#123; //获取当前用户的id Long currentId = BaseContext.getCurrentId(); LambdaQueryWrapper&lt;ShoppingCart&gt; lambdaQueryWrapper=new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper.eq(ShoppingCart::getUserId,currentId); lambdaQueryWrapper.orderByAsc(ShoppingCart::getCreateTime); List&lt;ShoppingCart&gt; list = shoppingCartService.list(lambdaQueryWrapper); return R.success(list); &#125; 添加完之后，他还会查询一次，查询到这个最新的数据 清空购物车 点击清空购物车发起请求 1234567891011@DeleteMapping(&quot;/clean&quot;)public R&lt;String&gt; clean()&#123; //获取当前用户的id Long currentId = BaseContext.getCurrentId(); LambdaQueryWrapper&lt;ShoppingCart&gt; lambdaQueryWrapper=new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper.eq(ShoppingCart::getUserId,currentId); shoppingCartService.remove(lambdaQueryWrapper); return R.success(&quot;删除成功&quot;);&#125; 减少菜品数量 点击那个减号-发起请求 ShoppingCartController 123456789101112131415161718192021222324@PostMapping(&quot;/sub&quot;)public R&lt;String&gt; sub(@RequestBody ShoppingCart shoppingCart)&#123; Long dishId = shoppingCart.getDishId(); Long userId= BaseContext.getCurrentId(); LambdaQueryWrapper&lt;ShoppingCart&gt; lambdaQueryWrapper=new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper.eq(ShoppingCart::getUserId,userId); if(dishId!=null)&#123; lambdaQueryWrapper.eq(ShoppingCart::getDishId,dishId); &#125; else &#123; lambdaQueryWrapper.eq(ShoppingCart::getSetmealId,shoppingCart.getSetmealId()); &#125; ShoppingCart cart = shoppingCartService.getOne(lambdaQueryWrapper); Integer number = cart.getNumber(); cart.setNumber(number-1); if(cart.getNumber()==0)&#123; shoppingCartService.remove(lambdaQueryWrapper); return R.success(&quot;删除成功&quot;); &#125; shoppingCartService.updateById(cart); return R.success(&quot;删除成功&quot;);&#125; 这个也是减少之后会，重新list一下 用户下单orders表中存储的是下单的用户的号码地址，地址的id等等，订单的面上的信息，但是没有这个订单中具体有什么套餐或者菜品 order_detail中存储的就是订单中的菜品或者套餐的信息 点击去支付之后发起请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package com.itheima.reggie.service.impl;import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;import com.baomidou.mybatisplus.core.toolkit.IdWorker;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.itheima.reggie.common.BaseContext;import com.itheima.reggie.common.CustomerException;import com.itheima.reggie.common.R;import com.itheima.reggie.entity.*;import com.itheima.reggie.mapper.OrderDetailMapper;import com.itheima.reggie.mapper.OrderMapper;import com.itheima.reggie.service.*;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.math.BigDecimal;import java.time.LocalDate;import java.time.LocalDateTime;import java.util.ArrayList;import java.util.List;import java.util.concurrent.atomic.AtomicInteger;@Servicepublic class OrderServiceImpl extends ServiceImpl&lt;OrderMapper, Orders&gt; implements OrderService &#123; @Autowired private ShoppingCartService shoppingCartService; @Autowired private UserService userService; @Autowired private AddressBookService addressBookService; @Autowired private OrderDetailService orderDetailService; @Override public void submit(Orders orders) &#123; //获取当前用户id Long currentId = BaseContext.getCurrentId(); //查询用户的购物车信息 LambdaQueryWrapper&lt;ShoppingCart&gt; lambdaQueryWrapper=new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper.eq(ShoppingCart::getUserId,currentId); List&lt;ShoppingCart&gt; list = shoppingCartService.list(lambdaQueryWrapper); if(list==null||list.size()==0)&#123; throw new CustomerException(&quot;当前购物车中无商品&quot;); &#125; //查询用户的个人信息 User user = userService.getById(currentId); //查询地址信息 Long addressBookId = orders.getAddressBookId(); AddressBook addressBook = addressBookService.getById(addressBookId); //向订单表中插入数据，一条数据 //插入之前对orders先赋值 long orderId= IdWorker.getId(); orders.setId(orderId); orders.setOrderTime(LocalDateTime.now()); orders.setCheckoutTime(LocalDateTime.now()); orders.setStatus(2); //计算购物车中商品的总价值 //这个可以算最后商品总价格，这个可以保证多线程安全，int和long都无法保证多线程高并发的时候安全 AtomicInteger amount=new AtomicInteger(0); List&lt;OrderDetail&gt; orderDetails=new ArrayList&lt;&gt;(); //同时获得ordetail的封装 for (ShoppingCart shoppingCart : list) &#123; OrderDetail orderDetail = new OrderDetail(); orderDetail.setOrderId(orderId); orderDetail.setNumber(shoppingCart.getNumber()); orderDetail.setDishFlavor(shoppingCart.getDishFlavor()); orderDetail.setSetmealId(shoppingCart.getSetmealId()); orderDetail.setName(shoppingCart.getName()); orderDetail.setImage(shoppingCart.getImage()); orderDetail.setAmount(shoppingCart.getAmount()); orderDetails.add(orderDetail); //intValue是将其转换为整数，amount属性是Decimal类型的X amount.addAndGet(shoppingCart.getAmount().multiply(new BigDecimal(shoppingCart.getNumber())).intValue()); &#125; orders.setAmount(new BigDecimal(amount.get())); orders.setUserId(currentId); orders.setNumber(String.valueOf(orderId)); orders.setUserName(user.getName()); orders.setConsignee(addressBook.getConsignee()); orders.setPhone(addressBook.getPhone()); orders.setAddress(addressBook.getProvinceName()==null?&quot;&quot;:addressBook.getProvinceName() +(addressBook.getCityName()==null?&quot;&quot;:addressBook.getCityName()) +(addressBook.getDistrictName()==null?&quot;&quot;:addressBook.getDistrictName()) +(addressBook.getDetail()==null?&quot;&quot;:addressBook.getDetail()) ); this.save(orders); //向订单明细表插入数据，多条数据 orderDetailService.saveBatch(orderDetails); //清空购物车数据 shoppingCartService.remove(lambdaQueryWrapper); &#125;&#125; OrderService 12345678910package com.itheima.reggie.service;import com.baomidou.mybatisplus.extension.service.IService;import com.itheima.reggie.common.R;import com.itheima.reggie.entity.Orders;public interface OrderService extends IService&lt;Orders&gt; &#123; public void submit(Orders orders);&#125; OrderController 1234567891011121314151617181920212223242526272829303132333435363738394041package com.itheima.reggie.controller;import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;import com.itheima.reggie.common.BaseContext;import com.itheima.reggie.common.CustomerException;import com.itheima.reggie.common.R;import com.itheima.reggie.entity.AddressBook;import com.itheima.reggie.entity.Orders;import com.itheima.reggie.entity.ShoppingCart;import com.itheima.reggie.entity.User;import com.itheima.reggie.service.AddressBookService;import com.itheima.reggie.service.OrderService;import com.itheima.reggie.service.ShoppingCartService;import com.itheima.reggie.service.UserService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;@RestController@Slf4j@RequestMapping(&quot;/order&quot;)public class OrderController &#123; @Autowired private OrderService orderService; @PostMapping(&quot;/submit&quot;) public R&lt;String&gt; submit( @RequestBody Orders orders)&#123;orderService.submit(orders); return R.success(&quot;下单成功&quot;); &#125;&#125; 点单页面的展示 就是显示所有的订单的开发，而且是能让订单的内容具体展示 前端页面要求返回的属性要有orderDetails,用来显示商品数量，并且orderDetails是一个OrderDetail类的集合 所以引入一个Dto OrderDto 12345678910111213141516package com.itheima.reggie.dto;import com.itheima.reggie.entity.OrderDetail;import com.itheima.reggie.entity.Orders;import lombok.Data;import java.util.List;@Datapublic class OrderDto extends Orders &#123; private List&lt;OrderDetail&gt; orderDetails;&#125; OrderController 1234567891011121314151617181920212223242526272829303132@GetMapping(&quot;/userPage&quot;)public R&lt;Page&lt;OrderDto&gt;&gt; page(int page, int pageSize)&#123; Page&lt;Orders&gt; pageInfo=new Page&lt;&gt;(page,pageSize); Page&lt;OrderDto&gt; orderDtoPage=new Page&lt;&gt;(); Long id = BaseContext.getCurrentId(); LambdaQueryWrapper&lt;Orders&gt; lambdaQueryWrapper=new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper.eq(Orders::getUserId,id); orderService.page(pageInfo,lambdaQueryWrapper); BeanUtils.copyProperties(pageInfo,orderDtoPage,&quot;records&quot;); List&lt;Orders&gt; orders = pageInfo.getRecords(); List&lt;OrderDto&gt; orderDtos=new ArrayList&lt;&gt;(); for (Orders order : orders) &#123; OrderDto orderDto=new OrderDto(); //获得订单编号 Long orderId = order.getId(); LambdaQueryWrapper&lt;OrderDetail&gt; lambdaQueryWrapper1=new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper1.eq(OrderDetail::getOrderId,orderId); //查询多个都是使用list List&lt;OrderDetail&gt; orderDetails = orderDetailService.list(lambdaQueryWrapper1); orderDto.setOrderDetails(orderDetails); BeanUtils.copyProperties(order,orderDto); orderDtos.add(orderDto); &#125; orderDtoPage.setRecords(orderDtos); return R.success(orderDtoPage);&#125; 补充管理地址修改功能的开发，点击修改地址信息发起请求 AddressBookController 12345@PutMappingpublic R&lt;AddressBook&gt; edit(@RequestBody AddressBook addressBook)&#123; addressBookService.updateById(addressBook); return R.success(addressBook);&#125; RedisRedis是一个基于内存的key-value结构数据库 基于内存存储，读写性能高，但是mysql是存在磁盘中，所以计算机肯定是对内存的读写性能高 但内存有限，所以适合存储热点数据（热点商品，咨询，新闻） Redis入门redis简介 API介绍: API接口就是我们所说的应用程序编程接口(就是软件系统不同组成部分衔接的约定)，API其实是接受你的指令传输给电脑再将电脑的反馈传递给你的一个信使，家里需要用电，墙上的插口就相当于是电力公司给我们开放的API接口，我们不需要了解怎么发电不需要知道电怎么运输到家，只需要把电器插到插座上就可以 关系型数据库(SQL)： 关系型数据库指的是使用关系模型（二维表格模型）来组织数据的数据库。 关系模型可以简单理解为二维表格模型，而一个关系型数据库就是由二维表及其之间的关系组成的一个数据组织。 为了规范性，把数据分配成为最小的逻辑表来存储避免重复，获得精简的空间利用。. 但是多个表之间的关系限制，多表管理就有点复杂。. 当然精简的存储可以节约宝贵的数据存储，但是现在随着社会的发展，磁盘上付出的代价是微不足知道的。 常见关系型数据库管理系统(ORDBMS)： Oracle MySql Microsoft SQL Server SQLite PostgreSQL IBM DB2 优势在支持通用的sql语言， 丰富的完整性大大减少了数据冗余和数据不一致的问题。并且全部由表结构组成，文件格式一致； 可以用SQL句子多个表之间做非常繁杂的查询； 数据存储在磁盘中，安全可靠。 不足： 高并发读写能力差：网站类用户的并发性访问非常高，而一台数据库的最大连接数有限，且硬盘 I&#x2F;O 有限，不能满足很多人同时连接。 量数据情况下读写效率低：对大数据量的表进行读写操作时，需要等待较长的时间等待响应。 数据模型灵活度低：关系型数据库的数据模型定义严格，无法快速容纳新的数据类型（需要提前知道需要存储什么样类型的数据）。 非关系型数据库（NOSQL）: 非关系型是平面数据集合中，数据经常可以重复，单个数据库很少被分开，而是存储成为一个整体，这种整块读取数据效率更高。. 非关系型数据库又被称为 NoSQL（Not Only SQL )，意为不仅仅是 SQL。通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定，常用于存储非结构化的数据。 常见的NOSQL数据库： 键值数据库：Redis、Memcached、Riak 列族数据库：Bigtable、HBase、Cassandra 文档数据库：MongoDB、CouchDB、MarkLogic 图形数据库：Neo4j、InfoGrid 优势： 非关系型数据库存储数据的格式可以是 key-value 形式、文档形式、图片形式等。使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。 速度快，效率高。 NoSQL 可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘 海量数据的维护和处理非常轻松，成本低。 不足：非关系型数据库暂时不提供 SQL 支持，学习和使用成本较高。 非关系数据库没有事务处理，无法保证数据的完整性和安全性。适合处理海量数据，但是不一定安全。 功能没有关系型数据库完善。 复杂表关联查询不容易实现。 KV数据库 随着NoSQL的流行，越来越多的NoSQL数据库被采用。而作为NoSQL中的KV数据库，也是经常出现在架构师的手中，被灵活的使用。 redis应用场景 1.缓存 2.任务队列 3.消息队列 4.分布式锁 linux下载redis，我就是下载在&#x2F;usr&#x2F;local下 第五行进入redis的src目录，其实是进入redis-4.0.0的目录中的src目录 启动redis是在src目录下输入redis-server就可以执行了 用src中的redis-cli文件可以链接redis数据库 现在链接redis数据库是霸屏的，可以让redis在后台进行服务，修改redis.conf在redis-4.0.0目录下 把no改为yes 然后用在redis-4.0.0目录下用 redis-server .&#x2F;redis.conf 命令就可以在后台执行redis 修改redis.conf文件，增加链接redis数据库的密码 先输入 redis-cli连接数据库（默认就是链接本地6379端口的），然后输入auth zhao1129进行认证，就可以使用数据库了 链接数据库的前提是数据库已经启动 redis-cli -h localhost -p 6379 -a zhao1129 这个是直接认证链接数据库，-p是指定端口，-h是指定主机 把redis.conf文件中bind 127.0.0.1改为 bind 0.0.0.0 再重新启动redis，就可以允许远程连接 Redis数据类型value的类型可以是很多，int也行，应该是都行 字符串类型（String）操作命令 如果用SET key value 如果key相同，后面会把前面覆盖 Hash类型的操作命令 list类型的操作命令 第二个命令的这个start是从零开始的，而且stop如果是-1就是获取从start开始的全部 这个先插入的是在尾部 集合set常用的操作命令 sdiff key1 key2是返回key1中有但是key2中没有的数据 有序集合sorted set操作命令 排序是根据score从小到大来排 第二个明林中withscores是指返回value的同时返回他们各自的分数 Redis常用命令 第二个Type key 返回的是key所存储的value的类型hash或者set之类的 ttl key 如果返回的值是-1则说明是永久存活的 JAVA中操作redisredis 的java客户端很多，官方推荐的有三种 jedis，lettuce，Redisson Spring对Redis客户端进行了整合，提供了Spring Data Redis，在Spring Boot中还提供了Starter，即spring-boot-starter-data-redis 新建项目jedis_demo 导入依赖 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Redis初体验 Jedis操作Redis 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import org.junit.Test;import redis.clients.jedis.Jedis;import java.util.Set;public class JedisTest &#123; @Test public void testRedis()&#123; //1.获取链接 //这里面第一个参数是你要用的redis在哪个主机上 //第二个参数是port Jedis jedis=new Jedis(&quot;localhost&quot;,6379); //2.执行具体操作 //set就是存入，第一个参数是key，第二个参数是value jedis.set(&quot;username&quot;,&quot;xiaoming&quot;); //get是获取参数为key对应的value String value=jedis.get(&quot;username&quot;); System.out.println(value); //删除username的key jedis.del(&quot;username&quot;); //存了一个hash结构的数据，addr是field，bj是value ，key是myhash jedis.hset(&quot;myhash&quot;,&quot;addr&quot;,&quot;bj&quot;); //获取hash中得值 //获得myhash这个hash中addr这个filed对应的value String hValue=jedis.hget(&quot;myhash&quot;,&quot;addr&quot;); System.out.println(hValue); //获取所有的key Set&lt;String&gt; keys = jedis.keys(&quot;*&quot;); keys.forEach(System.out::println); //3.关闭连接 jedis.close(); &#125;&#125; Spring Data Redis 在springboot项目中，可以使用Spring Data Redis来简化Redis操作，maven坐标 12345&lt;!--导入springdataredis来操作redis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 在yml文件中设置redis 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#tomacat端口号server: port: 8081spring: #应用的名称，不必须 application: name: reggie_take_out #配置数据源为druid redis: host: localhost port: 6379 #password database: 0 #服务跑起来之后redis默认提供16个数据库，这里写0是指默认操作0号数据库 jedis: #Redis连接池配置 pool: max-active: 8 #最大连接数 max-wait: 1ms #连接池中最大阻塞等待时间 max-idle: 4 # 连接池中的最大空闲连接 min-idle: 0 #连接池中的最小空闲连接 datasource: druid: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/reggle?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true username: root password: root #设置文件上传时最大的单个文件大小，和最大的全部文件大小 servlet: multipart: max-file-size: 10MB max-request-size: 100MBmybatis-plus: configuration: #在映射实体或者属性时，将数据库中表名和字段名中的下划线去掉，按照驼峰命名法映射 map-underscore-to-camel-case: true log-impl: org.apache.ibatis.logging.stdout.StdOutImpl global-config: db-config: id-type: ASSIGN_IDreggie: basePath: D:\\img1\\ 服务跑起来之后redis默认提供16个数据库，这里写0是指默认操作0号数据库 如果想要换到1号数据库就输入 select 1 如果想换到2号数据库就输入 select 2 redis.window.conf文件中可以修改默认的数据库数，就是 databases那一项 自己重新写这个redisTemplate，springboot自己装配的会对我们写的内容进行序列化，所以需要自己写一个bean来代替原本的 这样只能把key不进行序列化，但value还会序列化，但是没关系，我们在程序中获取value的时候，还会进行反序列化 123456789101112131415161718192021222324252627package com.example.demo;import org.springframework.cache.annotation.CachingConfigurerSupport;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnection;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.StringRedisSerializer;@Configurationpublic class RedisConfig extends CachingConfigurerSupport &#123; @Bean public RedisTemplate&lt;Object,Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) &#123; RedisTemplate&lt;Object, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); //默认的Key序列化器为：JdSerializationRedisSerializer //这里就是对key的序列化器进行了转换 redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setHashKeySerializer(new StringRedisSerializer()); redisTemplate.setConnectionFactory(connectionFactory); return redisTemplate; &#125;&#125; 测试： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.example.demo;import com.fasterxml.jackson.annotation.JacksonAnnotationsInside;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.ValueOperations;import java.util.concurrent.TimeUnit;@SpringBootTestclass RedisbootdemoApplicationTests &#123;@Autowiredprivate RedisTemplate redisTemplate;//这个方法是来测试value为String类型的操作 @Test public void testString() &#123; //获取valueOperations对象 ValueOperations valueOperations = redisTemplate.opsForValue(); //前面是key后面是value valueOperations.set(&quot;name&quot;,&quot;xiaoming&quot;); //这样获取的全都是Object类型，所以要进行强制转换 String name= (String) valueOperations.get(&quot;name&quot;); //第一个参数是key，第二个参数是value，第三个参数是过期时间，第四个参数是第三个参数的单位 //value的类型也可以用Integer valueOperations.set(&quot;age&quot;,1000,10l, TimeUnit.SECONDS); Integer age = (Integer) valueOperations.get(&quot;age&quot;); System.out.println(age); //这个如果里面原本就有city是不会进行任何操作的，并且返回false Boolean aBoolean = valueOperations.setIfAbsent(&quot;city&quot;, &quot;nanjing1&quot;); System.out.println(aBoolean); //这个就是如果原本有city会被新加入的这个覆盖 //也是返回布尔，他只要操作陈成功就返回布尔，无所谓原本city的值和要改成的值是否相同 Boolean aBoolean1 = valueOperations.setIfPresent(&quot;city&quot;, &quot;nanjing1&quot;); System.out.println(aBoolean1); &#125;&#125; 操作Hash类型的数据 12345678910111213141516171819202122232425262728293031/*操作Hash类型的数据 */@Testpublic void testHash()&#123; //获得操作hash类型数据的hashOperations对象 HashOperations hashOperations = redisTemplate.opsForHash(); //第一个参数是key，第二个参数是field，第三个参数是value hashOperations.put(&quot;002&quot;,&quot;name&quot;,&quot;xiaoming&quot;); hashOperations.put(&quot;002&quot;,&quot;age&quot;,&quot;20&quot;); hashOperations.put(&quot;002&quot;,&quot;address&quot;,&quot;bj&quot;); //取出数据 //第一个参数是key，第二个参数是field String name = (String)hashOperations.get(&quot;002&quot;, &quot;name&quot;); System.out.println(name); //获得hash结构中的所有字段,就是一个key中所有的field Set keys = hashOperations.keys(&quot;002&quot;); for (Object key : keys) &#123; System.out.println(key); &#125; //获取hash结构中所有的值 List values = hashOperations.values(&quot;002&quot;); for (Object value : values) &#123; System.out.println(value); &#125;&#125; 操作List类型的数据 1234567891011121314151617181920212223242526272829303132 /* 操作List类型的数据 */@Testpublic void testList()&#123; //得到操作list类型的数据 ListOperations listOperations = redisTemplate.opsForList(); //存储 //存储一个 listOperations.leftPush(&quot;mylist&quot;,&quot;a&quot;); //一次存储多个 listOperations.leftPushAll(&quot;mylist&quot;,&quot;b&quot;,&quot;c&quot;); //取值 //第一个参数是key，第二个参数是开始的下标，最后是结束的下标 //这个是能让list中的类型为String的 List&lt;String&gt; range = listOperations.range(&quot;mylist&quot;,0, -1); //遍历也是从0坐标开始的，而取出是从最右开始的 range.forEach(System.out::println); //获取列表长度 Long size = listOperations.size(&quot;mylist&quot;); int size1 = size.intValue(); for(int i=0;i&lt;size1;i++)&#123; //出队列 //出的是最早添加的 String mylist = (String)listOperations.rightPop(&quot;mylist&quot;); System.out.println(mylist); &#125;&#125; 操作set类型的数据 123456789101112131415161718192021222324/*操作Set类型的数据 */@Testpublic void testSet()&#123; SetOperations setOperations = redisTemplate.opsForSet(); //存储 //set是不能有重复元素的，无序序列 setOperations.add(&quot;myset&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;a&quot;); //取值 Set&lt;String&gt; myset = setOperations.members(&quot;myset&quot;); for (String s : myset) &#123; System.out.println(s); &#125; //删除成员 setOperations.remove(&quot;myset&quot;,&quot;a&quot;,&quot;b&quot;); //取值 Set&lt;String&gt; myset1 = setOperations.members(&quot;myset&quot;); for (String s : myset1) &#123; System.out.println(s); &#125;&#125; 操作sortedSet类型的数据 12345678910111213141516171819202122232425262728293031323334353637383940/*操作sortedSet类型的数据 */@Testpublic void testZset()&#123; ZSetOperations zSetOperations=redisTemplate.opsForZSet(); //存值，它是通过每一个value绑定一个score，根据score大小来排序 zSetOperations.add(&quot;myZset&quot;,&quot;a&quot;,10.0); zSetOperations.add(&quot;myZset&quot;,&quot;b&quot;,11.0); zSetOperations.add(&quot;myZset&quot;,&quot;c&quot;,12.0); //取值 //第一个参数是key，第二个参数是start，第三个参数是stop Set myZset = zSetOperations.range(&quot;myZset&quot;, 0, -1); for (Object o : myZset) &#123; System.out.println(o); &#125; //修改分数 //第一个参数是key，第二个参数是这个key其中一个value的值，第三个参数是这个value对应的score要增大多少 zSetOperations.incrementScore(&quot;myZset&quot;,&quot;b&quot;,20.0); //重新取值 Set myZset1 = zSetOperations.range(&quot;myZset&quot;, 0, -1); for (Object o : myZset1) &#123; System.out.println(o); &#125; //删除成员 zSetOperations.remove(&quot;myZset&quot;,&quot;a&quot;,&quot;b&quot;); //重新取直 Set myZset2 = zSetOperations.range(&quot;myZset&quot;, 0, -1); for (Object o : myZset2) &#123; System.out.println(o); &#125;&#125; 通用redis操作 12345678910111213141516171819202122232425/*redis中通用命令在java中的使用，就是针对不同数据类型都可以操作的 */@Testpublic void testCommon()&#123; //获取Redis中所有的key Set&lt;String&gt; keys = redisTemplate.keys(&quot;*&quot;); for (String key : keys) &#123; System.out.println(key); &#125; //判断某个key是否存在,存在返回true，不存在返回false Boolean aBoolean = redisTemplate.hasKey(&quot;name&quot;); System.out.println(aBoolean); //删除指定key,如果没有myZset，则无法删除返回false //这个delete方法中可以是key的集合，但不能直接并列多个key Boolean myZset = redisTemplate.delete(&quot;myZset&quot;); System.out.println(myZset); //获取指定key对应的value的数据类型 DataType myset = redisTemplate.type(&quot;myset&quot;); System.out.println(myset);&#125; 缓存优化问题：用户数量多，系统访问量大，频繁访问数据库，系统性能下降，用户体验差 解决：就是使用缓存，如果用户发起的请求，在缓存里有，缓存是存储在内存中的，所以会比直接读取mysql数据库方便 git管理代码 把代码提交到远程库，创建一个新的分支，v1.0，并把v1.0分支也提交到远程库 接下来的操作在分支V1.0上操作，如果没有问题就可以合并到master主分支上 环境搭建引入redis依赖 12345&lt;!--导入spring data redis的maven坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件 1234567891011spring: #应用的名称，不必须 application: name: reggie_take_out #配置数据源为druid #Redis配置 redis: host: localhost port: 6379 password: database: 0 自己配制的RedisTemplate实例放进ioc中 12345678910111213141516171819202122232425package com.itheima.reggie.config;import org.springframework.cache.annotation.CachingConfigurerSupport;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.StringRedisSerializer;@Configurationpublic class RedisConfig extends CachingConfigurerSupport &#123; @Bean public RedisTemplate&lt;Object,Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) &#123; RedisTemplate&lt;Object, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); //默认的Key序列化器为：JdSerializationRedisSerializer redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setHashKeySerializer(new StringRedisSerializer()); redisTemplate.setConnectionFactory(connectionFactory); return redisTemplate; &#125;&#125; 缓存菜品数据点击页面的菜品，每点击一次就会发起一个sql的请求，如果人多了高并发，效率就会很低 所以需要把菜品和套餐数据给缓存起来 改造update和save方法是mysql数据库中内容发生改变，也要及时清理掉缓存，如果不清理，则缓存和数据库中不同，这个就叫脏数据 给DishController的list方法加上缓存功能 缓存菜品数据是按照分类分别进行缓存，由key的构造中有dish_getCategoryId()就可以看出，key是根据分类动态生成的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 /* 这个功能是在套餐管理添加的页面中，查询每一种菜品类型所对应的全部具体的菜品*/ //用dish来接受catogoryId @GetMapping(&quot;/list&quot;) public R&lt;List&lt;DishDto&gt;&gt; list(Dish dish)&#123; List&lt;DishDto&gt; listDto=null; //每一个分类对应一个key //动态的构造一个key String key=&quot;dish_&quot;+dish.getCategoryId()+&quot;_&quot;+dish.getStatus(); //查询redis listDto = (List&lt;DishDto&gt;) redisTemplate.opsForValue().get(key); //如果存在则直接返回 if(listDto!=null)&#123; //如果存在，直接返回，无需查询数据库 return R.success(listDto); &#125; LambdaQueryWrapper&lt;Dish&gt; lambdaQueryWrapper=new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper.eq(dish.getCategoryId()!=null,Dish::getCategoryId,dish.getCategoryId()); //查询status为1的菜品，就是正在起售的菜品 lambdaQueryWrapper.eq(Dish::getStatus,1); //添加排序条件 lambdaQueryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime); List&lt;Dish&gt; list = dishService.list(lambdaQueryWrapper); listDto=new ArrayList&lt;&gt;(); for (Dish dish1 : list) &#123; Long categoryId = dish1.getCategoryId(); Category category = categoryService.getById(categoryId); DishDto dishDto1=new DishDto(); if(category!=null) &#123; String categoryName = category.getName(); dishDto1.setCategoryName(categoryName); &#125; //通过具体菜品的id，查出它的口味 Long dishId=dish1.getId(); LambdaQueryWrapper&lt;DishFlavor&gt; lambdaQueryWrapper1=new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper1.eq(DishFlavor::getDishId,dishId); List&lt;DishFlavor&gt; dishFlavorList=dishFlavorService.list(lambdaQueryWrapper1); dishDto1.setFlavors(dishFlavorList); BeanUtils.copyProperties(dish1,dishDto1); listDto.add(dishDto1); &#125; //如果不存在则查询数据库，再把查询出来的加入缓存 //设置缓存的有效时间 redisTemplate.opsForValue().set(key,listDto,60, TimeUnit.MINUTES); return R.success(listDto); &#125; save和edit时清理对应分类的缓存 下面两个都是DishController 12345678910111213141516171819@PostMappingpublic R&lt;String&gt; save( @RequestBody DishDto dishDto)&#123; //这个save里除了是Dish类是Dish类的子类也是可以的 //dishService.save(dishDto); dishService.saveWithDishFlavor(dishDto); //清理所有菜品的缓存数据 //Set keys=redisTemplate.keys(&quot;dish_*&quot;); //redisTemplate.delete(keys); //清理某个分类下面的菜品缓存数据 //菜品的status都是1所以这里写_1就可以 String key =&quot;dish_&quot;+dishDto.getCategoryId()+&quot;_1&quot;; redisTemplate.delete(key); return R.success(&quot;保存成功&quot;);&#125; 1234567891011121314151617/*提交修改之后的数据 */@PutMappingpublic R&lt;String&gt; editPlus( @RequestBody DishDto dishDto)&#123; dishService.updateWithDishFlavor(dishDto); //清理所有菜品的缓存数据 //Set keys=redisTemplate.keys(&quot;dish_*&quot;); //redisTemplate.delete(keys); //清理某个分类下面的菜品缓存数据 //菜品的status都是1所以这里写_1就可以 String key =&quot;dish_&quot;+dishDto.getCategoryId()+&quot;_1&quot;; redisTemplate.delete(key); return R.success(&quot;修改成功&quot;);&#125; 修改完之后，提交到本地库并push到远程库，然后把master分支和v1.0分支合并，而且是在master分支区合并v1.0分支 SpringCache使用SpringCache也必须有web-starter那个依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 也是一个缓存操作的框架,他可以简化我们的写缓存的代码 这里如果没有使用其他缓存技术，那么spring cache默认也有用map作为缓存技术 下面文字意思就是如果把Redis作为缓存技术，并同时要用Spring Cache技术，就把Redis缓存的依赖包导入即可 12345&lt;!--导入springdataredis来操作redis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 但使用redis作为缓存技术，还要引入一个依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt; 然后在启动类上加上@EnableCaching注解启动缓存就可以 不使用redis作为缓存技术不适用redis作为缓存技术，有了这个依赖就可以满足基本需要了 12345&lt;!--springboot--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; 这里如果没有使用其他缓存技术，那么spring cache默认也有用map作为缓存技术 也就是使用CacheManager接口的实现类,当你自动装配的时候获得的就是ConcurrentMapCacheManager这个对象(像下面代码一样) @Autowired private CacheManager cacheManager 启动类上也要加上@EnableCaching注解 Controller类中要加上这个属性自动装配 12@Autowiredprivate CacheManager cacheManager; CachePut 12345678910111213141516/** * CachePut:将方法返回值放入缓存中 * value:缓存的名称，每个缓存名称下面可以有多个key * key:缓存的key * 方法返回值就是key的value * @param user * @return *///#result是指方法的返回值//#root是指方法的内置对象，可以获得方法的一些信息@CachePut(value = &quot;userCache&quot;,key=&quot;#result.id&quot;)@PostMappingpublic User save(User user)&#123; userService.save(user); return user;&#125; 这个服务是基于内存的，如果重启服务之后，这个缓存的数据就没有了 CacheEvict 删除或更新数据库数据的时候都需要删除缓存 123456789101112131415161718192021//CacheEvict：清理指定缓存，当数据库中删除内容的时候，缓存中也会删除指定内容//value是指缓存的分类和CachePut的value属性是一个概念//key是通过#参数名 来直接获取方法参数//数据库中删除了id为参数的数据，缓存中也会删除id为参数的这个数据@CacheEvict(value=&quot;userCache&quot;,key=&quot;#id&quot;)@DeleteMapping(&quot;/&#123;id&#125;&quot;)public void delete(@PathVariable Long id)&#123; userService.removeById(id);&#125;//@CacheEvict(value=&quot;userCache&quot;,key=&quot;#p0.id&quot;)//@CacheEvict(value=&quot;userCache&quot;,key=&quot;#root.args[0].id&quot;)//@CacheEvict(value=&quot;userCache&quot;,key=&quot;#result.id&quot;)//这些注解都是一样的//数据库中修改了id为参数的数据，缓存中会删除id为参数的这个数据@CacheEvict(value=&quot;userCache&quot;,key=&quot;#user.id&quot;)@PutMappingpublic User update(User user)&#123; userService.updateById(user); return user;&#125; Cacheable注解 12345678910111213141516171819202122 //第一次请求这个查询的时候，会走这个方法，然后把返回值当作缓存存起来，下一次再请求，发现了有了注解中这个缓存就不会再走这个方法了，直接返回缓存中的内容 //condition：满足条件时才缓存数据，#result!=null就是方法返回结果不为空 //unless是如果unless中条件成立，则不缓存 //#result不能在condition中用所以这里换成了#result，condition中只能用#root @Cacheable(value=&quot;userCache&quot;,key=&quot;#id&quot;,unless =&quot;#result==null&quot;) @GetMapping(&quot;/&#123;id&#125;&quot;) public User getById(@PathVariable Long id)&#123; User user = userService.getById(id); return user; &#125; //第一次请求这个查询的时候，会走这个方法，然后把返回值当作缓存存起来，下一次再请求，发现了有了注解中这个缓存就不会再走这个方法了，直接返回缓存中的内容//condition：满足条件时才缓存数据，#result!=null就是方法返回结果不为空 @Cacheable(value=&quot;userCache&quot;,key=&quot;#user.id+&#x27;_&#x27;+#user.id&quot;,unless = &quot;#result==null&quot;) @GetMapping(&quot;/list&quot;) public List&lt;User&gt; list(User user)&#123; LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(user.getId() != null,User::getId,user.getId()); queryWrapper.eq(user.getName() != null,User::getName,user.getName()); List&lt;User&gt; list = userService.list(queryWrapper); return list; &#125; 点击key condition unless进入源码就能够看到他们能否用#result或者#root了 #result是指方法的返回值#root是指方法的内置对象，可以获得方法的一些信息 使用Redis作为缓存产品引入依赖 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 图片中的application.yml配置的cache是和redis一个层级的 1234567891011121314spring: #应用的名称，不必须 application: name: reggie_take_out #配置数据源为druid #Redis配置 redis: host: localhost port: 6379 password: database: 0 cache: redis: time-to-live: 180000 #设置缓存过期时间 其余的注解的用法还是和上面的不使用redis作为缓存技术的用法一样 缓存套餐数据使用Spring Cache框架，基于redis缓存技术进行对套餐的缓存 先引入依赖 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 配置缓存数据的过期时间 123456789101112131415spring: #应用的名称，不必须 application: name: reggie_take_out #配置数据源为druid #Redis配置 redis: host: localhost port: 6379 password: database: 0 #设置缓存数据的过期时间 cache: redis: time-to-live: 180000 #设置缓存过期时间 application.yml整体 123456789101112131415161718192021222324252627282930313233343536373839404142#tomacat端口号server: port: 8080spring: #应用的名称，不必须 application: name: reggie_take_out #配置数据源为druid #Redis配置 redis: host: localhost port: 6379 password: database: 0 cache: redis: time-to-live: 180000 #设置缓存过期时间 datasource: druid: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/reggle?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true username: root password: root #设置文件上传时最大的单个文件大小，和最大的全部文件大小 servlet: multipart: max-file-size: 10MB max-request-size: 100MBmybatis-plus: configuration: #在映射实体或者属性时，将数据库中表名和字段名中的下划线去掉，按照驼峰命名法映射 map-underscore-to-camel-case: true log-impl: org.apache.ibatis.logging.stdout.StdOutImpl global-config: db-config: id-type: ASSIGN_IDreggie: basePath: D:\\img1\\ 启动类上加入@EnableCache注解： 123456789101112131415161718192021package com.itheima.reggie;import lombok.extern.slf4j.Slf4j;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.web.servlet.ServletComponentScan;import org.springframework.cache.annotation.EnableCaching;import org.springframework.transaction.annotation.EnableTransactionManagement;//加入日志功能@Slf4j@SpringBootApplication//使原生组件生效@ServletComponentScan@EnableCachingpublic class ReggieApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ReggieApplication.class,args); log.info(&quot;项目启动成功&quot;); &#125;&#125; SetmealController的list方法加入@Cacheable注解 1234@GetMapping(&quot;/list&quot;)//#setmeal拿到方法中传递的参数,然后这个key也是用setmeal.categoryId来做的，根据套餐分类缓存@Cacheable(value=&quot;setmealCache&quot;,key=&quot;#setmeal.categoryId+&#x27;_&#x27;+#setmeal.status&quot;)public R&lt;List&lt;Setmeal&gt;&gt; list (Setmeal setmeal) &#123; list的方法返回结果是R对象，返回的结果要进行序列化，所以R类一定要实现序列化接口，实现可序列化 12@Datapublic class R&lt;T&gt; implements Serializable &#123; 这个时候就可以在redis数据库中看见缓存信息了 12345@DeleteMapping//当一个套餐被删除之后，setmealCache中也就是所有套餐的缓存都会被删除@CacheEvict(value=&quot;setmealCache&quot;,allEntries = true)@Transactionalpublic R&lt;String&gt; delete(Long ids[])&#123; 123456 @PostMapping @Transactional//多个事务要进行事务管理 //如果新插入了一个套餐，那么之前的所有套餐缓存也就是所有setmealCache中的缓存都会被删除 @CacheEvict(value=&quot;setmealCache&quot;,allEntries = true) public R&lt;String&gt; insert(@RequestBody SetmealDto setmealDto)&#123; 提交代码到本地库同时push到远程库，然后把master和v1.0合并起来 读写分离优化问题：读和写所有压力都由一台数据库承担，压力大数据库服务器磁盘损坏则数据丢失，单点故障 用户浏览数据读的是从库，如果要修改数据则是写的主库，同时主库会把数据同步给从库，这个就叫做mysql的主从复制 Mysql主从复制介绍： 从库可以有多个 在服务器上放一个数据库作为从库，在服务器上下载mysql 先删除 mariadb rpm -e –nodeps mariadb-libs-5.5.65-1.el7.x86_64 将mysql安装包上传到linux并解压 把压缩包放到了根目录下的reggie目录下mysql目录下 tar -zxvf mysql-5.7.25-1.el7.x86_64.rpm-bundle.tar.gz 用这个命令解压安装包 解压后进行安装，这个安装是有顺序的，按照下面顺序来，这些rpm软件安装包就是解压得到的 rpm -ivh mysql-community-common-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-libs-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-devel-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-libs-compat-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-client-5.7.25-1.el7.x86_64.rpm yum install net-tools yum install libaio rpm -ivh mysql-community-server-5.7.25-1.el7.x86_64.rpm yum install libaio在yum install net-tools之后执行，然后再进行最后一个rpm安装 完成mysql安装之后启动服务 任意目录使用下面这两个命令 service mysqld start也能用来启动mysql服务 service mysqld stop 也能用来关闭mysql服务 上面这两种比图片中靠谱 用cat &#x2F;var&#x2F;log&#x2F;mysqld.log | grep password 命令可以在mysqld.log文件中找到password 我设置的linux的mysql密码为zhao1129 倒数第二行最后一个root换位zhao1129那是密码位置 最后两行命令是开启这个mysql的访问权限，所有的主机够可以访问这个mysql 设置密码后重新登陆 mysql -uroot -pzhao1129 用navicat连接阿里云上mysql也没问题 实现主从复制，可以以后再接着看看，其实就是对主库和从库的配置文件修改，然后创建一个主库用户，通过这个用户能够让主库的操作给到从库 linux上创建数据库不指定字符编码，默认不是utf-8，windows上创建的数据库默认是utf-8，创建表的字符集不指定默认是和数据库一样，创建数据库字符集不指定默认和数据库服务器一样，所以以后创建数据库或者表都要确认字符集是不是utf-8 后端项目部署把打包好的jar包上传到linuxreggie 要在服务器上安装过jdk才能部署项目 java -jar reggie_take_out-1.0-SNAPSHOT.jar 有了java环境后，运行jar包 centos虚拟机开放端口是可以通过防火墙命令的，但是阿里云服务器开放端口要到阿里云控制台的安全组来开放端口，安全组就是一个模拟防火墙 同时要把安全组作用到这个实例 运行jar包之后，要停止jar包运行 netstat -nlp | grep :8080 8080是jar占用的端口，这个命令能查询到jar的进程uid为一个值 然后kill -9 uid 刚才这种运行方式，把屏幕关闭之后程序就结束了 让程序在后台运行，并且日志输出在一个文件里的方法 nohup java -jar reggie_take_out-1.0-SNAPSHOT.jar &amp;&gt; reggieapp.log &amp; 后台运行程序，并把日志输出到reggieapp.log Shell脚本自动部署项目 拉取代码是git，编译打包脚本是maven，启动是java -jar命令 1.linux中安装git git clone https://github.com/zhaozihj/reggie_take_out.git 这个是克隆代码到本地 默认是克隆的master分支 这个步骤在执行reggieStart文件之前执行的，在reggieapp文件夹下执行这个命令 目录的结构是&#x2F;reggie&#x2F;reggieapp&#x2F;reggie_take_out 2.linux中安装maven maven也装在&#x2F;usr&#x2F;local目录下 source &#x2F;etc&#x2F;profile 重新加载配置文件 mvn -version 看看maven环境有没有装好 我设置的maven仓库为&#x2F;usr&#x2F;local&#x2F;repo 记得提供镜像资源 &lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; 3.将资料中提供的shell脚本文件复制到linux bootStart.sh 这个脚本被我放到&#x2F;reggie&#x2F;reggieapp目录下了 4.为用户授权 现在我用的是root用户（超级用户）是因为自己练习，以后进入一个公司一个服务器可能你就是普通用户权限，这个时候需要别人给你授权才能执行脚本 执行ll命令能查看文件状态 最前面一共是十位，后九位代表了文件所有者（root用户），同组的用户和其他用户对这个文件的操作权限 给一种用户的三位，第一位代表读权限，第二位代表写权限，第三位代表执行权限 像这个rw- 就是说文件所有者（root用户）既有读也有写但没有执行权限 ​ r– 就是收同组用户有读权限没有写权限没有执行权限 ​ r– 其他用户有读权限没有写权限没有执行权限 用chmod为用户开放权限 用数字来表示权限，然后3个数字就可以修改好三种用户对于这个文件的权限 chmod 744 bootStart.sh 为root用户授予读写执行权限，其他用户只读 执行reggieStart.sh文件的命令 如果这个文件是在当前目录下直接 .&#x2F;reggieStart.sh就可以了但不能reggieStart.sh 如果在别的目录下，也可以用别的路径 Nginx8080 nginx是一款轻量级的web服务器&#x2F;反向代理服务器及电子邮件代理服务器 在aliyun服务器上安装Nginx服务器 我给下载到&#x2F;usr&#x2F;local下面了 Nginx常用命令这些命令都是在sbin目录下执行的 location &#x2F;{ root html&#x2F;dist; index index.html; &#125; location ^~ /api/ &#123; rewrite ^/api/(.*)$ /$1 break; proxy_pass http://39.105.5.187:8080; &#125; 查看版本号 让这些命令不仅仅能够在sbin目录下执行 可以直接在任何目录下使用nginx -v命令，前面也不用加.&#x2F;了，其他命令也都是一样 nginx配置文件的结构 Nginx具体应用部署静态资源 就是把静态资源放到html文件夹下，如果放进去一个hello.html则通过ip:port&#x2F;hello.html就可以访问到这个页面 反向代理 1.反向代理，统一了请求的入口方便管理，要不就是访问那三个web服务器，不好管理 2.这三个web服务器一般是在公司内网中才能访问，反向代理服务器可以对外开放，同时反向代理服务器和三个web服务器组成了一个局域网，可以利用反向代理服务器来访问这三个web服务器 反向代理和正向代理的区别：正向代理是基于客户端的，用户知道有一个代理服务器去转发自己的请求，并且用户需要知道自己所访问的原始服务器，但是反向代理用户不需要知道原始服务器地址，只需要访问代理服务器就可以访问到原始服务器，所以用户并不知道这是代理服务器的地址。 负载均衡 这样配置当你访问 localhost:8080的时候其实是轮流访问192.168.138.101:8080;和server 192.168.138.101:8081 默认的这种负载均衡的算法是轮询，但是也还是有别的负载均衡的算法的 加上了weight之后，一个为10另一个为5，当请求的次数足够多之后，请求两个服务器的次数可能会是2：1 前后端分离开发前后端在一起开发的困难 前端和后端先一起制定好接口，就是要发起的请求的模式，以及参数等等 后端自测可以使用postman，swagger等等进行自测，前端就是返回mock数据，mock数据当然和后端规定好的要一样，只要能展示mock数据也就能展示后端传过来的数据 apifox接口文档中的内容就是定义一个请求和响应的规范，运行的时候具体设置请求参数的值，并且测试时响应必须和规范一样才不会报错 接口用例就是每个接口规范底下的一种特殊情况 Swagger 1.引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt;&lt;/dependency&gt; 12345@EnableSwagger2@EnableKnife4j@Slf4j@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; 在WebMvcConfig上面加上@EnableSwagger2，@EnableKnife4j两个注解 在WebMvcConfig中添加两个方法 12345678910111213141516171819202122@Beanpublic Docket createRestApi()&#123; //文档类型 return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() //对应controller一个包结构，生成接口会扫描这个包 //controller中每一个公共方法都会映射成一个接口 .apis(RequestHandlerSelectors.basePackage(&quot;com.itheima.reggie.controller&quot;)) .paths(PathSelectors.any()) .build();&#125;//封装这个接口文档的标题版本描述之类的private ApiInfo apiInfo()&#123; return new ApiInfoBuilder() .title(&quot;瑞吉外卖&quot;) .version(&quot;1.0&quot;) .description(&quot;瑞吉外卖接口文档&quot;) .build();&#125; 3.设置静态资源映射 “&#x2F;doc.html”,”&#x2F;webjars&#x2F;**”,”&#x2F;swagger-resources”,”&#x2F;v2&#x2F;api-docs” 新增放行这四个请求，访问接口文档请求的是doc.html，这个是框架生成的 12345678 //配置拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; log.info(&quot;拦截器加载成功&quot;); registry.addInterceptor(new LoginInterceptor()) .addPathPatterns(&quot;/**&quot;) //所有请求都被拦截包括静态资源 .excludePathPatterns(&quot;/employee/login&quot;,&quot;/backend/**&quot;,&quot;/front/**&quot;,&quot;/user/sendMsg&quot;,&quot;/user/login&quot;,&quot;/doc.html&quot;,&quot;/webjars/**&quot;,&quot;/swagger-resources&quot;,&quot;/v2/api-docs&quot;); //放行的请求&#125; 处理静态资源的映射 registry.addResourceHandler(&quot;doc.html&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/&quot;); registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;); 1234567891011//配置静态资源的映射@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123; log.info(&quot;开始进行静态资源映射&quot;); //这个的意思是 /backend/**请求对应到 类路径下的backend文件夹下的资源 registry.addResourceHandler(&quot;/backend/**&quot;).addResourceLocations(&quot;classpath:backend/&quot;); registry.addResourceHandler(&quot;/front/**&quot;).addResourceLocations(&quot;classpath:front/&quot;); registry.addResourceHandler(&quot;doc.html&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/&quot;); registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;);&#125; 然后启动项目访问localhost:8081&#x2F;doc.html 这里可以把接口文档转换为各种离线形式的文件，也可以把这些文件导入到apifox中管理这些接口 上面中有一个Swagger Models这个就是数据模型，能检测到所有方法的返回对象 Swagger常用注解 @ApiModel这些东西加在对应的地方，在生成的文档里他们的名字都会是注解中value的值 作用在Controller类上的要这么用 1@Api(tags=&quot;套餐相关接口&quot;) 1234567891011//分页查询功能的实现//这个和之前那个菜品类型管理的分页查询功能类似@ApiOperation(&quot;套餐分页查询接口&quot;)@ApiImplicitParams(&#123; //name中的page和方法参数中page名字相同，value是说明作用，required说明这个参数是否必须 @ApiImplicitParam(name=&quot;page&quot;,value=&quot;页码&quot;,required = true), @ApiImplicitParam(name=&quot;pageSize&quot;,value=&quot;每页记录数&quot;,required = true), @ApiImplicitParam(name=&quot;name&quot;,value=&quot;套餐名称&quot;,required = false)&#125;)@GetMapping(&quot;/page&quot;)public R&lt;Page&gt; page(int page, int pageSize, String name)&#123; 12@ApiModel(&quot;套餐&quot;)public class Setmeal implements Serializable &#123; 123456789101112131415@ApiModel(&quot;套餐&quot;)public class Setmeal implements Serializable &#123; private static final long serialVersionUID = 1L; private Long id; //分类id private Long categoryId; //套餐名称 @ApiModelProperty(&quot;套餐名称&quot;) private String name; 项目部署 前端项目的部署1.把dist包传到html目录下 dist目录就是打包的前端项目，虽然我不知道是怎么打包的 2.修改Nginx配置文件nginx.conf 请求 URL: 把root设为html&#x2F;dist 默认访问&#x2F; 时访问的是html&#x2F;dist&#x2F;index.html 没有反向代理时候的url，39.105.5.187:80就是下面这个其实就是nginx服务的端口和ip http://39.105.5.187/api/employee/login,在nginx中这种请求总是会加上类似api这种前缀 下面是反向代理的设置 ^~ &#x2F;api&#x2F;可以匹配上面这种类型的请求， 然后rewrite (.*)匹配到employee&#x2F;login $1可以引用employee&#x2F;login 然后设置源地址服务器为http://39.105.5.187:8080 前端这个地方只部署了后台管理那个，客户端应该是在小程序上部署","categories":[],"tags":[]},{"title":"Redis基础","slug":"redis入门","date":"2022-09-29T15:31:35.000Z","updated":"2023-04-10T13:14:43.033Z","comments":true,"path":"2022/09/29/redis入门/","link":"","permalink":"http://example.com/2022/09/29/redis%E5%85%A5%E9%97%A8/","excerpt":"","text":"Redis快速入门Redis的常见命令和客户端使用 redis 就是一个数据库，不过与传统数据库不同的是 redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向。另外，redis 也经常用来做分布式锁。 1.初识RedisRedis是一种键值型的NoSql数据库，这里有两个关键字： 键值型 NoSql 其中键值型，是指Redis中存储的数据都是以key、value对的形式存储，而value的形式多种多样，可以是字符串、数值、甚至json： 而NoSql则是相对于传统关系型数据库而言，有很大差异的一种数据库。 1.1.认识NoSQLNoSql可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为非关系型数据库。 1.1.1.结构化与非结构化传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名、字段数据类型、字段约束等等信息，插入的数据必须遵守这些约束： 而NoSql则对数据库格式没有严格约束，往往形式松散，自由。 可以是键值型： 也可以是文档型： 甚至可以是图格式： 1.1.2.关联和非关联传统数据库的表与表之间往往存在关联，例如外键： 而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合： 123456789101112131415161718&#123; id: 1, name: &quot;张三&quot;, orders: [ &#123; id: 1, item: &#123; id: 10, title: &quot;荣耀6&quot;, price: 4999 &#125; &#125;, &#123; id: 2, item: &#123; id: 20, title: &quot;小米11&quot;, price: 3999 &#125; &#125; ]&#125; 此处要维护“张三”的订单与商品“荣耀”和“小米11”的关系，不得不冗余的将这两个商品保存在张三的订单文档中，不够优雅。还是建议用业务来维护关联关系。 1.1.3.查询方式传统关系型数据库会基于Sql语句做查询，语法有统一标准； 而不同的非关系数据库查询语法差异极大，五花八门各种各样。 1.1.4.事务传统关系型数据库能满足事务ACID的原则。 而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现基本的一致性。 1.1.5.总结除了上述四点以外，在存储方式、扩展性、查询性能上关系型与非关系型也都有着显著差异，总结如下： 存储方式 关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响 非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些 扩展性 关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。 非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。 关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦 1.2.认识RedisRedis诞生于2009年全称是Remote Dictionary Server 远程词典服务器，是一个基于内存的键值型NoSQL数据库。 特征： 键值（key-value）型，value支持多种不同数据结构，功能丰富 单线程，每个命令具备原子性 低延迟，速度快（基于内存、IO多路复用、良好的编码）。 支持数据持久化 支持主从集群、分片集群 支持多语言客户端 作者：Antirez Redis的官方网站地址：https://redis.io/ 1.3.安装Redis大多数企业都是基于Linux服务器来部署项目，而且Redis官方也没有提供Windows版本的安装包。因此课程中我们会基于Linux系统来安装Redis. 此处选择的Linux版本为CentOS 7. 1.3.1.依赖库Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖： 1yum install -y gcc tcl 1.3.2.上传安装包并解压然后将课前资料提供的Redis安装包上传到虚拟机的任意目录： 例如，我放到了&#x2F;usr&#x2F;local&#x2F;src 目录： 解压缩： 1tar -xzf redis-6.2.6.tar.gz 解压后： 进入redis目录： 1cd redis-6.2.6 运行编译命令： 1make &amp;&amp; make install 如果没有出错，应该就安装成功了。 默认的安装路径是在 /usr/local/bin目录下： 该目录已经默认配置到环境变量，因此可以在任意目录下运行这些命令。其中： redis-cli：是redis提供的命令行客户端 redis-server：是redis的服务端启动脚本 redis-sentinel：是redis的哨兵启动脚本 1.3.3.启动redis的启动方式有很多种，例如： 默认启动 指定配置启动 开机自启 1.3.4.默认启动安装完成后，在任意目录输入redis-server命令即可启动Redis： 1redis-server 如图： 这种启动属于前台启动，会阻塞整个会话窗口，窗口关闭或者按下CTRL + C则Redis停止。不推荐使用。 1.3.5.指定配置启动如果要让Redis以后台方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（/usr/local/src/redis-6.2.6），名字叫redis.conf： 我们先将这个配置文件备份一份： 1cp redis.conf redis.conf.bck 然后修改redis.conf文件中的一些配置： 123456# 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0bind 0.0.0.0# 守护进程，修改为yes后即可后台运行daemonize yes # 密码，设置后访问Redis必须输入密码requirepass 123321 Redis的其它常见配置： 12345678910# 监听的端口port 6379# 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录dir .# 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15databases 1# 设置redis能够使用的最大内存maxmemory 512mb# 日志文件，默认为空，不记录日志，可以指定日志文件名logfile &quot;redis.log&quot; 启动Redis： 1234# 进入redis安装目录 cd /usr/local/src/redis-6.2.6# 启动redis-server redis.conf 停止服务： 123# 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，# 因为之前配置了密码，因此需要通过 -u 来指定密码redis-cli -u 123321 shutdown 1.3.6.开机自启我们也可以通过配置来实现开机自启。 首先，新建一个系统服务文件： 1vi /etc/systemd/system/redis.service 内容如下： 1234567891011[Unit]Description=redis-serverAfter=network.target[Service]Type=forkingExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.confPrivateTmp=true[Install]WantedBy=multi-user.target 然后重载系统服务： 1systemctl daemon-reload 现在，我们可以用下面这组命令来操作redis了： 12345678# 启动systemctl start redis# 停止systemctl stop redis# 重启systemctl restart redis# 查看状态systemctl status redis 执行下面的命令，可以让redis开机自启： 1systemctl enable redis 1.4.Redis桌面客户端安装完成Redis，我们就可以操作Redis，实现数据的CRUD了。这需要用到Redis客户端，包括： 命令行客户端 图形化桌面客户端 编程客户端 1.4.1.Redis命令行客户端Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下： 1redis-cli [options] [commonds] 其中常见的options有： -h 127.0.0.1：指定要连接的redis节点的IP地址，默认是127.0.0.1 -p 6379：指定要连接的redis节点的端口，默认是6379 -a 123321：指定redis的访问密码 其中的commonds就是Redis的操作命令，例如： ping：与redis服务端做心跳测试，服务端正常会返回pong 不指定commond时，会进入redis-cli的交互控制台： 1.4.2.图形化桌面客户端GitHub上的大神编写了Redis的图形化桌面客户端，地址：https://github.com/uglide/RedisDesktopManager 不过该仓库提供的是RedisDesktopManager的源码，并未提供windows安装包。 在下面这个仓库可以找到安装包：https://github.com/lework/RedisDesktopManager-Windows/releases 1.4.3.安装在课前资料中可以找到Redis的图形化桌面客户端： 解压缩后，运行安装程序即可安装： 安装完成后，在安装目录下找到rdm.exe文件： 双击即可运行： 1.4.4.建立连接点击左上角的连接到Redis服务器按钮： 在弹出的窗口中填写Redis服务信息： 点击确定后，在左侧菜单会出现这个链接： 点击即可建立连接了。 Redis默认有16个仓库，编号从0至15. 通过配置文件可以设置仓库数量，但是不超过16，并且不能自定义仓库名称。 如果是基于redis-cli连接Redis服务，可以通过select命令来选择数据库： 12# 选择 0号库select 0 2.Redis常见命令2.1Redis数据结构介绍Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样： 贴心小建议：命令不要死记，学会查询就好啦 Redis为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（ https://redis.io/commands ）可以查看到不同的命令： 当然我们也可以通过Help命令来帮助我们去查看命令 2.2 Redis 通用命令通用指令是部分数据类型的，都可以使用的指令，常见的有： KEYS：查看符合模板的所有key DEL：删除一个指定的key EXISTS：判断key是否存在 EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除 TTL：查看一个KEY的剩余有效期 通过help [command] 可以查看一个命令的具体用法，例如： 课堂代码如下 KEYS *代表多个，?代表一个字符 123456789127.0.0.1:6379&gt; keys *1) &quot;name&quot;2) &quot;age&quot;127.0.0.1:6379&gt;# 查询以a开头的key127.0.0.1:6379&gt; keys a*1) &quot;age&quot;127.0.0.1:6379&gt; 贴心小提示：在生产环境下，不推荐使用keys 命令，因为这个命令在key过多的情况下，效率不高 DEL 1234567891011121314151617181920212223242526272829127.0.0.1:6379&gt; help del DEL key [key ...] summary: Delete a key since: 1.0.0 group: generic127.0.0.1:6379&gt; del name #删除单个(integer) 1 #成功删除1个127.0.0.1:6379&gt; keys *1) &quot;age&quot;127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 #批量添加数据OK127.0.0.1:6379&gt; keys *1) &quot;k3&quot;2) &quot;k2&quot;3) &quot;k1&quot;4) &quot;age&quot;127.0.0.1:6379&gt; del k1 k2 k3 k4(integer) 3 #此处返回的是成功删除的key，由于redis中只有k1,k2,k3 所以只成功删除3个，最终返回127.0.0.1:6379&gt;127.0.0.1:6379&gt; keys * #再查询全部的key1) &quot;age&quot; #只剩下一个了127.0.0.1:6379&gt; 贴心小提示：同学们在拷贝代码的时候，只需要拷贝对应的命令哦~ EXISTS 123456789101112127.0.0.1:6379&gt; help EXISTS EXISTS key [key ...] summary: Determine if a key exists since: 1.0.0 group: generic127.0.0.1:6379&gt; exists age(integer) 1127.0.0.1:6379&gt; exists name(integer) 0 EXPIRE 设置一个key的有效时间 ttl是查看一个key的剩余存活时间 贴心小提示：内存非常宝贵，对于一些数据，我们应当给他一些过期时间，当过期时间到了之后，他就会自动被删除~ 1234567891011121314151617181920212223127.0.0.1:6379&gt; expire age 10(integer) 1127.0.0.1:6379&gt; ttl age(integer) 8127.0.0.1:6379&gt; ttl age(integer) 6127.0.0.1:6379&gt; ttl age(integer) -2127.0.0.1:6379&gt; ttl age(integer) -2 #当这个key过期了，那么此时查询出来就是-2 127.0.0.1:6379&gt; keys *(empty list or set)127.0.0.1:6379&gt; set age 10 #如果没有设置过期时间OK127.0.0.1:6379&gt; ttl age(integer) -1 # ttl的返回值就是-1 2.3 Redis命令-String命令String类型，也就是字符串类型，是Redis中最简单的存储类型。 其value是字符串，不过根据字符串的格式不同，又可以分为3类： string：普通字符串 int：整数类型，可以做自增.自减操作 float：浮点类型，可以做自增.自减操作 不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同，数值类型字符串编码的时候将数字转为二进制形式作为字节去存储这样一个字节可以表示很大的数组，字符串类型就是将字符转为对应字节码再用字节数组存储 String的常见命令有： SET：添加或者修改已经存在的一个String类型的键值对 GET：根据key获取String类型的value MSET：批量添加多个String类型的键值对 MGET：根据多个key获取多个String类型的value INCR：让一个整型的key自增1 INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增 DECR 和INCR相反 DECRBY 和INCRBY相反 INCRBYFLOAT：让一个浮点类型的数字自增并指定步长 SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行 SETEX：添加一个String类型的键值对，并且指定有效期 贴心小提示：以上命令除了INCRBYFLOAT 都是常用命令 SET 和GET: 如果key不存在则是新增，如果存在则是修改 1234567891011127.0.0.1:6379&gt; set name Rose //原来不存在OK127.0.0.1:6379&gt; get name &quot;Rose&quot;127.0.0.1:6379&gt; set name Jack //原来存在，就是修改OK127.0.0.1:6379&gt; get name&quot;Jack&quot; MSET和MGET 123456789127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3OK127.0.0.1:6379&gt; MGET name age k1 k2 k31) &quot;Jack&quot; //之前存在的name2) &quot;10&quot; //之前存在的age3) &quot;v1&quot;4) &quot;v2&quot;5) &quot;v3&quot; INCR和INCRBY和DECY 123456789101112131415161718192021222324252627127.0.0.1:6379&gt; get age &quot;10&quot;127.0.0.1:6379&gt; incr age //增加1(integer) 11 127.0.0.1:6379&gt; get age //获得age&quot;11&quot;127.0.0.1:6379&gt; incrby age 2 //一次增加2(integer) 13 //返回目前的age的值 127.0.0.1:6379&gt; incrby age 2(integer) 15 127.0.0.1:6379&gt; incrby age -1 //也可以增加负数，相当于减(integer) 14 127.0.0.1:6379&gt; incrby age -2 //一次减少2个(integer) 12 127.0.0.1:6379&gt; DECR age //相当于 incr 负数，减少正常用法(integer) 11 127.0.0.1:6379&gt; get age &quot;11&quot; SETNX 1234567891011121314151617127.0.0.1:6379&gt; help setnx SETNX key value summary: Set the value of a key, only if the key does not exist since: 1.0.0 group: string127.0.0.1:6379&gt; set name Jack //设置名称OK127.0.0.1:6379&gt; setnx name lisi //如果key不存在，则添加成功(integer) 0127.0.0.1:6379&gt; get name //由于name已经存在，所以lisi的操作失败&quot;Jack&quot;127.0.0.1:6379&gt; setnx name2 lisi //name2 不存在，所以操作成功(integer) 1127.0.0.1:6379&gt; get name2 &quot;lisi&quot; SETEX 1234567891011127.0.0.1:6379&gt; setex name 10 jackOK127.0.0.1:6379&gt; ttl name(integer) 8127.0.0.1:6379&gt; ttl name(integer) 7127.0.0.1:6379&gt; ttl name(integer) 5 2.4 Redis命令-Key的层级结构Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？ 例如，需要存储用户.商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？ 我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范： Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下： 这个格式并非固定，也可以根据自己的需求来删除或添加词条。 例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key： user相关的key：heima:user:1 product相关的key：heima:product:1 如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储： KEY VALUE heima:user:1 {“id”:1, “name”: “Jack”, “age”: 21} heima:product:1 {“id”:1, “name”: “小米11”, “price”: 4999} 一旦我们向redis采用这样的方式存储，那么在可视化界面中，redis会以层级结构来进行存储，形成类似于这样的结构，更加方便Redis获取数据 2.5 Redis命令-Hash命令Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。 String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便： Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD： Hash类型的常见命令 HSET key field value：添加或者修改hash类型key的field的值 HGET key field：获取一个hash类型key的field的值 HMSET：批量添加多个hash类型key的field的值 HMGET：批量获取多个hash类型key的field的值 HGETALL：获取一个hash类型的key中的所有的field和value HKEYS：获取一个hash类型的key中的所有的field HINCRBY:让一个hash类型key的字段值自增并指定步长 HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行 贴心小提示：哈希结构也是我们以后实际开发中常用的命令哟 HSET和HGET 12345678910127.0.0.1:6379&gt; HSET heima:user:3 name Lucy//大key是 heima:user:3 小key是name，小value是Lucy(integer) 1127.0.0.1:6379&gt; HSET heima:user:3 age 21// 如果操作不存在的数据，则是新增(integer) 1127.0.0.1:6379&gt; HSET heima:user:3 age 17 //如果操作存在的数据，则是修改(integer) 0127.0.0.1:6379&gt; HGET heima:user:3 name &quot;Lucy&quot;127.0.0.1:6379&gt; HGET heima:user:3 age&quot;17&quot; HMSET和HMGET 12345678127.0.0.1:6379&gt; HMSET heima:user:4 name HanMeiMeiOK127.0.0.1:6379&gt; HMSET heima:user:4 name LiLei age 20 sex manOK127.0.0.1:6379&gt; HMGET heima:user:4 name age sex1) &quot;LiLei&quot;2) &quot;20&quot;3) &quot;man&quot; HGETALL 1234567127.0.0.1:6379&gt; HGETALL heima:user:41) &quot;name&quot;2) &quot;LiLei&quot;3) &quot;age&quot;4) &quot;20&quot;5) &quot;sex&quot;6) &quot;man&quot; HKEYS和HVALS 12345678127.0.0.1:6379&gt; HKEYS heima:user:41) &quot;name&quot;2) &quot;age&quot;3) &quot;sex&quot;127.0.0.1:6379&gt; HVALS heima:user:41) &quot;LiLei&quot;2) &quot;20&quot;3) &quot;man&quot; HINCRBY 12345678127.0.0.1:6379&gt; HINCRBY heima:user:4 age 2(integer) 22127.0.0.1:6379&gt; HVALS heima:user:41) &quot;LiLei&quot;2) &quot;22&quot;3) &quot;man&quot;127.0.0.1:6379&gt; HINCRBY heima:user:4 age -2(integer) 20 HSETNX 12345678910111213141516127.0.0.1:6379&gt; HSETNX heima:user4 sex woman(integer) 1127.0.0.1:6379&gt; HGETALL heima:user:31) &quot;name&quot;2) &quot;Lucy&quot;3) &quot;age&quot;4) &quot;17&quot;127.0.0.1:6379&gt; HSETNX heima:user:3 sex woman(integer) 1127.0.0.1:6379&gt; HGETALL heima:user:31) &quot;name&quot;2) &quot;Lucy&quot;3) &quot;age&quot;4) &quot;17&quot;5) &quot;sex&quot;6) &quot;woman&quot; 2.6 Redis命令-List命令Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。 特征也与LinkedList类似： 有序 元素可以重复 插入和删除快 查询速度一般 常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。 List的常见命令有： LPUSH key element … ：向列表左侧插入一个或多个元素 LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil RPUSH key element … ：向列表右侧插入一个或多个元素 RPOP key：移除并返回列表右侧的第一个元素 LRANGE key star end：返回一段角标范围内的所有元素，这个范围是指索引，第一个元素是索引是0 BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil LPUSH和RPUSH 1234127.0.0.1:6379&gt; LPUSH users 1 2 3(integer) 3127.0.0.1:6379&gt; RPUSH users 4 5 6(integer) 6 LPOP和RPOP 1234127.0.0.1:6379&gt; LPOP users&quot;3&quot;127.0.0.1:6379&gt; RPOP users&quot;6&quot; LRANGE 123127.0.0.1:6379&gt; LRANGE users 1 21) &quot;1&quot;2) &quot;4&quot; 入口出口同一边是指，push和pop的方向都为l或者r 入口出口不在同一边是指，push和pop的方向是相反的 2.7 Redis命令-Set命令Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征： 无序 元素不可重复 查找快 支持交集.并集.差集等功能 Set的常见命令有： SADD key member … ：向set中添加一个或多个元素 SREM key member … : 移除set中的指定元素 SCARD key： 返回set中元素的个数 SISMEMBER key member：判断一个元素是否存在于set中 SMEMBERS：获取set中的所有元素 SINTER key1 key2 … ：求key1与key2的交集 sdiff key1 key2 是返回key1中有但是key2中没有的数据 求差集 sunion key1 key2 获取key1 和key 2的并集，相同的元素只会添加一次 例如两个集合：s1和s2: 求交集：SINTER s1 s2 求s1与s2的不同：SDIFF s1 s2 练习： 将下列数据用Redis的Set集合来存储： 张三的好友有：李四、王五、赵六 李四的好友有：王五、麻子、二狗 利用Set的命令实现下列功能： 计算张三的好友有几人 计算张三和李四有哪些共同好友 查询哪些人是张三的好友却不是李四的好友 查询张三和李四的好友总共有哪些人 判断李四是否是张三的好友 判断张三是否是李四的好友 将李四从张三的好友列表中移除 2,8SortedSet类型Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。 排序是根据score从小到大来排 SortedSet具备下列特性： 可排序 元素不重复 查询速度快 因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。 SortedSet的常见命令有： ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值 ZREM key member：删除sorted set中的一个指定元素 ZSCORE key member : 获取sorted set中的指定元素的score值 ZRANK key member：获取sorted set 中的指定元素的排名，返回的排名是从0开始 zrevrank key member 获取这个元素从大到小时候的排名，也是从0开始 ZCARD key：获取sorted set中的元素个数 ZCOUNT key min max：统计score值在给定范围内的所有元素的个数 ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值 ZRANGE key min max 【withscores】：按照score排序后，获取指定排名范围内的元素，后面跟上withscores就是返回的时候带上score zrevrange key min max ：按照score从大到小排序后，获取指定排名范围的元素 ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素 ZDIFF、ZINTER、ZUNION：求差集、交集、并集 注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如： 升序获取sorted set 中的指定元素的排名：ZRANK key member 降序获取sorted set 中的指定元素的排名：ZREVRANK key memeber 练习题： 将班级的下列学生得分存入Redis的SortedSet中： Jack 85, Lucy 89, Rose 82, Tom 95, Jerry 78, Amy 92, Miles 76 并实现下列功能： 删除Tom同学 获取Amy同学的分数 获取Rose同学的排名 查询80分以下有几个学生 给Amy同学加2分 查出成绩前3名的同学 查出成绩80分以下的所有同学 3.Redis的Java客户端在Redis官网中提供了各种语言的客户端，地址：https://redis.io/docs/clients/ 其中Java客户端也包含很多： 标记为*的就是推荐使用的java客户端，包括： Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。 Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map、Queue等，而且支持跨进程的同步机制：Lock、Semaphore等待，比较适合用来实现特殊的功能需求。 jedis：以redis命令作为方法名称，学习成本低，简单实用，但是Jedis实例是线程不安全的，多线程环境下需要基于连接池来使用 3.1.Jedis客户端这里的这个jedis的测试示例可以去看那个瑞吉外卖那个 Jedis的官网地址： https://github.com/redis/jedis 3.1.1.快速入门我们先来个快速入门： 1）引入依赖： 12345678910111213&lt;!--jedis--&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--单元测试--&gt;&lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;5.7.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 2）建立连接 新建一个单元测试类，内容如下： @BeforeEach因该是在每一个测试方法前调用的方法 123456789101112private Jedis jedis;@BeforeEachvoid setUp() &#123; // 1.建立连接 // jedis = new Jedis(&quot;39.105.5.187&quot;, 6379); jedis = JedisConnectionFactory.getJedis(); // 2.设置密码 jedis.auth(&quot;zhao1129&quot;); // 3.选择库 jedis.select(0);&#125; 3）测试： 1234567891011121314151617181920@Testvoid testString() &#123; // 存入数据 String result = jedis.set(&quot;name&quot;, &quot;虎哥&quot;); System.out.println(&quot;result = &quot; + result); // 获取数据 String name = jedis.get(&quot;name&quot;); System.out.println(&quot;name = &quot; + name);&#125;@Testvoid testHash() &#123; // 插入hash数据 jedis.hset(&quot;user:1&quot;, &quot;name&quot;, &quot;Jack&quot;); jedis.hset(&quot;user:1&quot;, &quot;age&quot;, &quot;21&quot;); // 获取 Map&lt;String, String&gt; map = jedis.hgetAll(&quot;user:1&quot;); System.out.println(map);&#125; 4）释放资源 @AfterEach是在每一个测试方法后调用 123456@AfterEachvoid tearDown() &#123; if (jedis != null) &#123; jedis.close(); &#125;&#125; 瑞吉外卖中jedis使用演示 Jedis操作Redis 默认也是操作0号库 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import org.junit.Test;import redis.clients.jedis.Jedis;import java.util.Set;public class JedisTest &#123; @Test public void testRedis()&#123; //1.获取链接 //这里面第一个参数是你要用的redis在哪个主机上 //第二个参数是port Jedis jedis=new Jedis(&quot;localhost&quot;,6379); //2.执行具体操作 //set就是存入，第一个参数是key，第二个参数是value jedis.set(&quot;username&quot;,&quot;xiaoming&quot;); //get是获取参数为key对应的value String value=jedis.get(&quot;username&quot;); System.out.println(value); //删除username的key jedis.del(&quot;username&quot;); //存了一个hash结构的数据，addr是field，bj是value ，key是myhash jedis.hset(&quot;myhash&quot;,&quot;addr&quot;,&quot;bj&quot;); //获取hash中得值 //获得myhash这个hash中addr这个filed对应的value String hValue=jedis.hget(&quot;myhash&quot;,&quot;addr&quot;); System.out.println(hValue); //获取所有的key Set&lt;String&gt; keys = jedis.keys(&quot;*&quot;); keys.forEach(System.out::println); //3.关闭连接 jedis.close(); &#125;&#125; 3.2 Jedis连接池Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式 有关池化思想，并不仅仅是这里会使用，很多地方都有，比如说我们的数据库连接池，比如我们tomcat中的线程池，这些都是池化思想的体现。 3.4.1创建Jedis的连接池- 1234567891011121314151617181920212223242526public class JedisConnectionFacotry &#123; private static final JedisPool jedisPool; static &#123; //配置连接池 JedisPoolConfig poolConfig = new JedisPoolConfig(); //最大连接数 poolConfig.setMaxTotal(8); //最大空闲连接 //就是即使没有连接被使用，也保证至少八个空连接待命 poolConfig.setMaxIdle(8); //最小空闲连接 //就是当连接池中连接数少于辞职，会创建连接来补充到该值的数量 poolConfig.setMinIdle(0); //当连接池中没有可用的，等待的最多时常 poolConfig.setMaxWaitMillis(1000); //创建连接池对象 jedisPool = new JedisPool(poolConfig, &quot;192.168.150.101&quot;,6379,1000,&quot;123321&quot;); &#125; public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125; 代码说明： 1） JedisConnectionFacotry：工厂设计模式是实际开发中非常常用的一种设计模式，我们可以使用工厂，去降低代的耦合，比如Spring中的Bean的创建，就用到了工厂设计模式 2）静态代码块：随着类的加载而加载，确保只能执行一次，我们在加载当前工厂类的时候，就可以执行static的操作完成对 连接池的初始化 3.4.2改造原始代码代码说明: 1.在我们完成了使用工厂设计模式来完成代码的编写之后，我们在获得连接时，就可以通过工厂来获得。 ，而不用直接去new对象，降低耦合，并且使用的还是连接池对象。 2.当我们使用了连接池后，当我们关闭连接其实并不是关闭，而是将Jedis还回连接池的。 123456789101112131415 @BeforeEach void setUp()&#123; //建立连接 /*jedis = new Jedis(&quot;127.0.0.1&quot;,6379);*/ jedis = JedisConnectionFacotry.getJedis(); //选择库 jedis.select(0); &#125;@AfterEach void tearDown() &#123; if (jedis != null) &#123; jedis.close(); &#125; &#125; SpringDataRedis客户端SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：https://spring.io/projects/spring-data-redis 提供了对不同Redis客户端的整合（Lettuce和Jedis） 提供了RedisTemplate统一API来操作Redis 支持Redis的发布订阅模型 支持Redis哨兵和Redis集群 支持基于Lettuce的响应式编程 支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化 支持基于Redis的JDKCollection实现 String命令的value，可以是字符串可以是字节，如果想要存储java对象正常是不可以的，但是因为springdataredis支持对象存储的时候序列化，对象读取的时候反序列化，所以可以实现 SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中： 3.2.1.快速入门SpringBoot已经提供了对SpringDataRedis的支持，使用非常简单。 首先，新建一个maven项目，然后按照下面步骤执行： 1）引入依赖123456789101112&lt;dependencies&gt; &lt;!--redis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--common-pool--&gt; &lt;!--连接池依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;/dependency&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.7&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.heima&lt;/groupId&gt; &lt;artifactId&gt;redis-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;redis-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--redis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--common-pool--&gt; &lt;!--连接池依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--Jackson依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2）配置Redisredis和redis连接池的配置 1234567891011spring: redis: host: 39.105.5.187 port: 6379 password: zhao1129 lettuce: pool: max-active: 8 max-idle: 8 min-idle: 0 max-wait: 100ms 3）注入RedisTemplate因为有了SpringBoot的自动装配，我们可以拿来就用： 123456@SpringBootTestclass RedisStringTests &#123; @Autowired private RedisTemplate redisTemplate;&#125; 4）编写测试123456789101112131415@SpringBootTestclass RedisStringTests &#123; @Autowired private RedisTemplate redisTemplate; @Test void testString() &#123; // 写入一条String数据 redisTemplate.opsForValue().set(&quot;name&quot;, &quot;虎哥&quot;); // 获取string数据 Object name = redisTemplate.opsForValue().get(&quot;name&quot;); System.out.println(&quot;name = &quot; + name); &#125;&#125; 3.2.2.自定义序列化RedisTemplate可以接收任意Object作为值写入Redis： 只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的： 所谓各种序列化应该就是把对象转换为一种字符串格式，然后再以字节形式存储，比如json序列化就是把对象转化为json字符串然后再以字节形式存储，String序列化就是把对象转化为普通String字符串再以字节形式存储，用了这个springdataredis之后他会把所有的value都当作Object 缺点： 可读性差 内存占用较大 引入json处理的依赖 12345&lt;!--Jackson依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt; 可用的有两种序列化方式： GenericJackson2JsonRedisSerializer StringRedisSerializer 第一种一般是给value用的 第二种其实就是专门存储字符串的，就是用getBytes[]方法把字符串转换为字节存储，所以key一般用这个，因为key基本都是字符串 我们可以自定义RedisTemplate的序列化方式，代码如下： 12345678910111213141516171819202122@Configurationpublic class RedisConfig &#123; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory)&#123; // 创建RedisTemplate对象 RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); // 设置连接工厂 template.setConnectionFactory(connectionFactory); // 创建JSON序列化工具 GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer(); // 设置Key和hashkey使用String序列化 template.setKeySerializer(RedisSerializer.string()); template.setHashKeySerializer(RedisSerializer.string()); // 设置Value和hashValue使用JSON序列化 template.setValueSerializer(jsonRedisSerializer); template.setHashValueSerializer(jsonRedisSerializer); // 返回 return template; &#125;&#125; 这里采用了JSON序列化来代替默认的JDK序列化方式。最终结果如图： 这个图是往redis数据库中存储了一个User对象，其中有name和age属性 整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。 3.2.3.StringRedisTemplate为了节省内存空间，我们可以不使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。 因为存入和读取时的序列化及反序列化都是我们自己实现的，SpringDataRedis就不会将class信息写入Redis了。 这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。 省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用： 这里使用的json序列化工具 ObjectMapper还是依赖于jackson包 12345&lt;!--Jackson依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt; 123456789101112131415161718192021@Autowiredprivate StringRedisTemplate stringRedisTemplate;// JSON序列化工具private static final ObjectMapper mapper = new ObjectMapper();@Testvoid testSaveUser() throws JsonProcessingException &#123; // 创建对象 User user = new User(&quot;虎哥&quot;, 21); // 手动序列化 String json = mapper.writeValueAsString(user); // 写入数据 stringRedisTemplate.opsForValue().set(&quot;user:200&quot;, json); // 获取数据 String jsonUser = stringRedisTemplate.opsForValue().get(&quot;user:200&quot;); // 手动反序列化 User user1 = mapper.readValue(jsonUser, User.class); System.out.println(&quot;user1 = &quot; + user1);&#125; 此时我们再来看一看存储的数据，小伙伴们就会发现那个class数据已经不在了，节约了我们的空间~ 最后小总结： RedisTemplate的两种序列化实践方案： 方案一： 自定义RedisTemplate 修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer 方案二： 使用StringRedisTemplate 写入Redis时，手动把对象序列化为JSON 读取Redis时，手动把读取到的JSON反序列化为对象 3.2.4Hash结构操作在基础篇的最后，咱们对Hash结构操作一下，收一个小尾巴，这个代码咱们就不再解释啦 马上就开始新的篇章~~~进入到我们的Redis实战篇 1234567891011121314151617@SpringBootTestclass RedisStringTests &#123; @Autowired private StringRedisTemplate stringRedisTemplate; @Test void testHash() &#123; stringRedisTemplate.opsForHash().put(&quot;user:400&quot;, &quot;name&quot;, &quot;虎哥&quot;); stringRedisTemplate.opsForHash().put(&quot;user:400&quot;, &quot;age&quot;, &quot;21&quot;); Map&lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(&quot;user:400&quot;); System.out.println(&quot;entries = &quot; + entries); &#125;&#125; 对这些结构的操作可以看瑞吉外卖中的内容","categories":[],"tags":[]},{"title":"Redis实战","slug":"Redis实战篇","date":"2022-09-29T15:31:35.000Z","updated":"2023-04-10T13:19:24.733Z","comments":true,"path":"2022/09/29/Redis实战篇/","link":"","permalink":"http://example.com/2022/09/29/Redis%E5%AE%9E%E6%88%98%E7%AF%87/","excerpt":"","text":"实战篇Redis开篇导读亲爱的小伙伴们大家好，马上咱们就开始实战篇的内容了，相信通过本章的学习，小伙伴们就能理解各种redis的使用啦，接下来咱们来一起看看实战篇我们要学习一些什么样的内容 短信登录 这一块我们会使用redis共享session来实现 商户查询缓存 通过本章节，我们会理解缓存击穿，缓存穿透，缓存雪崩等问题，让小伙伴的对于这些概念的理解不仅仅是停留在概念上，更是能在代码中看到对应的内容 优惠卷秒杀 通过本章节，我们可以学会Redis的计数器功能， 结合Lua完成高性能的redis操作，同时学会Redis分布式锁的原理，包括Redis的三种消息队列 附近的商户 我们利用Redis的GEOHash来完成对于地理坐标的操作 UV统计 主要是使用Redis来完成统计功能 用户签到 使用Redis的BitMap数据统计功能 好友关注 基于Set集合的关注、取消关注，共同关注等等功能，这一块知识咱们之前就讲过，这次我们在项目中来使用一下 打人探店 基于List来完成点赞列表的操作，同时基于SortedSet来完成点赞的排行榜功能 以上这些内容咱们统统都会给小伙伴们讲解清楚，让大家充分理解如何使用Redis 1、短信登录1.1、导入黑马点评项目1.1.1 、导入SQL 1.1.2、有关当前模型手机或者app端发起请求，请求我们的nginx服务器，nginx基于七层模型走的事HTTP协议，可以实现基于Lua直接绕开tomcat访问redis，也可以作为静态资源服务器，轻松扛下上万并发， 负载均衡到下游tomcat服务器，打散流量，我们都知道一台4核8G的tomcat，在优化和处理简单业务的加持下，大不了就处理1000左右的并发， 经过nginx的负载均衡分流后，利用集群支撑起整个项目，同时nginx在部署了前端项目后，更是可以做到动静分离，进一步降低tomcat服务的压力，这些功能都得靠nginx起作用，所以nginx是整个项目中重要的一环。 在tomcat支撑起并发流量后，我们如果让tomcat直接去访问Mysql，根据经验Mysql企业级服务器只要上点并发，一般是16或32 核心cpu，32 或64G内存，像企业级mysql加上固态硬盘能够支撑的并发，大概就是4000起~7000左右，上万并发， 瞬间就会让Mysql服务器的cpu，硬盘全部打满，容易崩溃，所以我们在高并发场景下，会选择使用mysql集群，同时为了进一步降低Mysql的压力，同时增加访问的性能，我们也会加入Redis，同时使用Redis集群使得Redis对外提供更好的服务。 1.1.3、导入后端项目在资料中提供了一个项目源码： 1.1.4、导入前端工程 1.1.5 运行前端项目 1.2 、基于Session实现登录流程发送验证码： 用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号 如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户 短信验证码登录、注册： 用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息 校验登录状态: 用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中*，并且放行 1.3 、实现发送短信验证码功能页面流程 具体代码如下 贴心小提示： 具体逻辑上文已经分析，我们仅仅只需要按照提示的逻辑写出代码即可。 发送验证码 1234567891011121314151617@Overridepublic Result sendCode(String phone, HttpSession session) &#123; // 1.校验手机号 if (RegexUtils.isPhoneInvalid(phone)) &#123; // 2.如果不符合，返回错误信息 return Result.fail(&quot;手机号格式错误！&quot;); &#125; // 3.符合，生成验证码 String code = RandomUtil.randomNumbers(6); // 4.保存验证码到 session session.setAttribute(&quot;code&quot;,code); // 5.发送验证码 log.debug(&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;, code); // 返回ok return Result.ok();&#125; 登录 12345678910111213141516171819202122232425262728@Overridepublic Result login(LoginFormDTO loginForm, HttpSession session) &#123; // 1.校验手机号 String phone = loginForm.getPhone(); if (RegexUtils.isPhoneInvalid(phone)) &#123; // 2.如果不符合，返回错误信息 return Result.fail(&quot;手机号格式错误！&quot;); &#125; // 3.校验验证码 Object cacheCode = session.getAttribute(&quot;code&quot;); String code = loginForm.getCode(); if(cacheCode == null || !cacheCode.toString().equals(code))&#123; //3.不一致，报错 return Result.fail(&quot;验证码错误&quot;); &#125; //一致，根据手机号查询用户 User user = query().eq(&quot;phone&quot;, phone).one(); //5.判断用户是否存在 if(user == null)&#123; //不存在，则创建 user = createUserWithPhone(phone); &#125; //7.保存用户信息到session中 session.setAttribute(&quot;user&quot;,user); return Result.ok();&#125; 1.4、实现登录拦截功能温馨小贴士：tomcat的运行原理 当用户发起请求时，会访问我们像tomcat注册的端口，任何程序想要运行，都需要有一个线程对当前端口号进行监听，tomcat也不例外，当监听线程知道用户想要和tomcat连接连接时，那会由监听线程创建socket连接，socket都是成对出现的，用户通过socket像互相传递数据，当tomcat端的socket接受到数据后，此时监听线程会从tomcat的线程池中取出一个线程执行用户请求，在我们的服务部署到tomcat后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的controller，service，dao中，并且访问对应的DB，在用户执行完请求后，再统一返回，再找到tomcat端的socket，再将数据写回到用户端的socket，完成请求和响应 通过以上讲解，我们可以得知 每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据 温馨小贴士：关于threadlocal 如果小伙伴们看过threadLocal的源码，你会发现在threadLocal中，无论是他的put方法和他的get方法， 都是先从获得当前用户的线程，然后从线程中取出线程的成员变量map，只要线程不一样，map就不一样，所以可以通过这种方式来做到线程隔离 拦截器代码 1234567891011121314151617181920public class LoginInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //1.获取session HttpSession session = request.getSession(); //2.获取session中的用户 Object user = session.getAttribute(&quot;user&quot;); //3.判断用户是否存在 if(user == null)&#123; //4.不存在，拦截，返回401状态码 response.setStatus(401); return false; &#125; //5.存在，保存用户信息到Threadlocal UserHolder.saveUser((User)user); //6.放行 return true; &#125;&#125; 让拦截器生效 1234567891011121314151617181920212223@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123; @Resource private StringRedisTemplate stringRedisTemplate; @Override public void addInterceptors(InterceptorRegistry registry) &#123; // 登录拦截器 registry.addInterceptor(new LoginInterceptor()) .excludePathPatterns( &quot;/shop/**&quot;, &quot;/voucher/**&quot;, &quot;/shop-type/**&quot;, &quot;/upload/**&quot;, &quot;/blog/hot&quot;, &quot;/user/code&quot;, &quot;/user/login&quot; ).order(1); // token刷新的拦截器 registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)).addPathPatterns(&quot;/**&quot;).order(0); &#125;&#125; 1.5、隐藏用户敏感信息而且session中存储过多的信息，会给Tomcat带来压力 我们通过浏览器观察到此时用户的全部信息都在，这样极为不靠谱，所以我们应当在返回用户信息之前，将用户的敏感信息进行隐藏，采用的核心思路就是书写一个UserDto对象，这个UserDto对象就没有敏感信息了，我们在返回前，将有用户敏感信息的User对象转化成没有敏感信息的UserDto对象，那么就能够避免这个尴尬的问题了 在登录方法处修改 就相当于创建了一个UserDTO对象，然后把user对象中属性拷贝到UserDTO中，然后存储到session中 12//7.保存用户信息到session中session.setAttribute(&quot;user&quot;, BeanUtils.copyProperties(user,UserDTO.class)); 在拦截器处： 12//5.存在，保存用户信息到ThreadlocalUserHolder.saveUser((UserDTO) user); 在UserHolder处：将user对象换成UserDTO 123456789101112131415public class UserHolder &#123; private static final ThreadLocal&lt;UserDTO&gt; tl = new ThreadLocal&lt;&gt;(); public static void saveUser(UserDTO user)&#123; tl.set(user); &#125; public static UserDTO getUser()&#123; return tl.get(); &#125; public static void removeUser()&#123; tl.remove(); &#125;&#125; 1.6、session共享问题为了解决高并发问题，可以用tomcat集群服务，就是程序在多个tomcat服务器上实现负载均衡 核心思路分析： 每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了 但是这种方案具有两个大问题 1、每台服务器中都有完整的一份session数据，服务器压力过大。 2、session拷贝数据时，可能会出现延迟 所以咱们后来采用的方案都是基于redis来完成，我们把session换成redis，redis数据本身就是共享的，就可以避免session共享的问题了 内存存储读取速度会比较快，这种注册登录这种高并发的，最好是用内存存储的 1.7 Redis代替session的业务流程1.7.1、设计key的结构首先我们要思考一下利用redis来存储数据，那么到底使用哪种结构呢？由于存入的数据比较简单，我们可以考虑使用String，或者是使用哈希，如下图，如果使用String，同学们注意他的value，用多占用一点空间，如果使用哈希，则他的value中只会存储他数据本身，如果不是特别在意内存，其实使用String就可以啦。 1.7.2、设计key的具体细节所以我们可以使用String结构，就是一个简单的key，value键值对的方式，但是关于key的处理，session他是每个用户都有自己的session，但是redis的key是共享的，咱们就不能使用code了 在设计这个key的时候，我们之前讲过需要满足两点 1、key要具有唯一性 2、key要方便携带 如果我们采用phone：手机号这个的数据来存储当然是可以的，但是如果把这样的敏感数据存储到redis中并且从页面中带过来毕竟不太合适，所以我们在后台生成一个随机串token，然后让前端带来这个token就能完成我们的整体逻辑了 1.7.3、整体访问流程当注册完成后，用户去登录会去校验用户提交的手机号和验证码，是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到redis，并且生成token作为redis的key，当我们校验用户是否登录时，会去携带着token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到threadLocal中，并且放行。 登录后端返回token会保存在浏览器上，这也是为什么不能把手机号当作key存储用户信息的原因，因为不安全，前端通过一些操作会让每次发起请求的时候以authorization请求头的形式带着token，来验证登录身份 验证码也是要保存在redis中的，以验证码为value，手机号为key，因为这个key必须是唯一的，每个用户只有一个，就像每个用户只有session一样才可以，存储用户信息的时候以tocken为key这种随机生成的也是唯一的，value应该用hash类型的，因为用户信息是一个对象，用field，value这种形式方便修改，用json字符串那种不容易修改，所以用hash 1.8 基于Redis实现短信登录这里具体逻辑就不分析了，之前咱们已经重点分析过这个逻辑啦。 hutool工具类的使用这个当中有多个工具类，类似于mvc包中的BeanUtils，javautil包中的UUID这里面都有类似的工具 判断String字符串是否为空,还有JSONUtil把java对象转json字符串，json字符串转java对象 123456&lt;!--有各种工具类--&gt;&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.7.17&lt;/version&gt;&lt;/dependency&gt; UserServiceImpl代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137package com.hmdp.service.impl;import cn.hutool.core.bean.BeanUtil;import cn.hutool.core.bean.copier.CopyOptions;import cn.hutool.core.lang.UUID;import cn.hutool.core.util.RandomUtil;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.hmdp.dto.LoginFormDTO;import com.hmdp.dto.Result;import com.hmdp.dto.UserDTO;import com.hmdp.entity.User;import com.hmdp.mapper.UserMapper;import com.hmdp.service.IUserService;import com.hmdp.utils.RedisConstants;import com.hmdp.utils.RegexUtils;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.BeanUtils;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.stereotype.Service;import javax.annotation.Resource;import javax.servlet.http.HttpSession;import java.util.HashMap;import java.util.Map;import java.util.concurrent.TimeUnit;import static com.hmdp.utils.RedisConstants.*;import static com.hmdp.utils.SystemConstants.USER_NICK_NAME_PREFIX;/** * &lt;p&gt; * 服务实现类 * &lt;/p&gt; * * @author 虎哥 * @since 2021-12-22 */@Service@Slf4jpublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements IUserService &#123; @Resource private StringRedisTemplate stringRedisTemplate; /* 发送验证码 */ @Override public Result sendCode(String phone, HttpSession session) &#123; //1.校验手机号 if(RegexUtils.isPhoneInvalid(phone))&#123; //2.如果不符合，返回错误信息 return Result.fail(&quot;手机号格式错误&quot;); &#125; //3.符合，生成验证码 String code= RandomUtil.randomNumbers(6); //4.保存验证码到redis //第三个参数是key过期时间，第四个参数是时间单位 //这个LOGIN_CODE_KEY就是一个key的前缀，为了方便封装起来 stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY +phone,code,LOGIN_CODE_TTL, TimeUnit.MINUTES); //5.发送验证码 log.debug(&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;, code); //6.返回ok return Result.ok(); &#125; //这个请求也要对手机号进行校验 @Override public Result login(LoginFormDTO loginForm, HttpSession session) &#123; // 1.校验手机号 String phone = loginForm.getPhone(); if (RegexUtils.isPhoneInvalid(phone)) &#123; // 2.如果不符合，返回错误信息 return Result.fail(&quot;手机号格式错误！&quot;); &#125; // 3.校验验证码 //从redis中获取验证码 Object cacheCode = stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY+phone); String code = loginForm.getCode(); if(cacheCode == null || !cacheCode.toString().equals(code))&#123; //3.不一致，报错 return Result.fail(&quot;验证码错误&quot;); &#125; //一致，根据手机号查询用户 User user = query().eq(&quot;phone&quot;, phone).one(); UserDTO userDTO=new UserDTO(); BeanUtils.copyProperties(user,userDTO); //5.判断用户是否存在 if(user == null)&#123; //不存在，则创建 user = createUserWithPhone(phone); &#125; //7.保存用户信息到Redis中 //7.1随机生成token，作为登录令牌 //这中uuid中间是没有横杠的 String token= UUID.randomUUID().toString(true); //7.2 将User对象转为Hash存储 //把User转为map之后它有个属性是long类型，存储的时候，只能是String类型，转换不过来会报错 //自定义转map，第三个选项是自定义要求，把属性全部改为String类型 Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO,new HashMap&lt;&gt;(), CopyOptions.create().setIgnoreNullValue(true).setFieldValueEditor((fieldName, fieldValue)-&gt;fieldValue.toString() )); //7.3存储用户信息到redis String tokenKey=LOGIN_USER_KEY+token; //putall是一次设置多个filed，value，第二个参数用map stringRedisTemplate.opsForHash().putAll(tokenKey,userMap); //设置token有效期,这个有效期要模仿session，session是如果你一直访问它的有效期会一直不变，但如果你不访问的话，30分钟后过期 //redis也要实现这种功能，而不是不管访不访问30分钟后都删除key,所以在拦截其中要刷新一次key的有效期 //第二个参数是过期时间，第三个参数是单位 stringRedisTemplate.expire(tokenKey,LOGIN_USER_TTL,TimeUnit.MINUTES); //把token返回给前端 return Result.ok(token); &#125; private User createUserWithPhone(String phone)&#123; //创建用户 User user=new User(); //设置手机号 user.setPhone(phone); //设置昵称 //USER_NICK_NAME_PREFIX其实是SystemConstants中的一个静态属性 user.setNickName(USER_NICK_NAME_PREFIX+RandomUtil.randomString(10)); save(user); return user; &#125;&#125; 拦截器 拦截其中刷新用户信息key有效期 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.hmdp.utils;import cn.hutool.core.bean.BeanUtil;import cn.hutool.core.util.StrUtil;import com.hmdp.dto.UserDTO;import com.hmdp.entity.User;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.util.Map;import java.util.concurrent.TimeUnit;//这个类不是springmvc中的组件，就是上面没有@Configuration这种标记//所以不能够自动装配stringRedisTemplate，要在调用这个拦截器的地方调用有参构造，也就是MvcConfig里面public class LoginInterceptor implements HandlerInterceptor &#123; private StringRedisTemplate stringRedisTemplate; public LoginInterceptor(StringRedisTemplate stringRedisTemplater)&#123; this.stringRedisTemplate=stringRedisTemplater; &#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //1.获取请求头中的token String token =request.getHeader(&quot;authorization&quot;); if(StrUtil.isBlank(token))&#123; //不存在就拦截，返回401状态码 response.setStatus(401); return false; &#125; //2.基于token获取redis中的用户 //entries把hash转化为了map Map&lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY + token); //3.判断用户是否存在 if(entries.isEmpty())&#123; //4.不存在，拦截，返回401状态码 response.setStatus(401); return false; &#125; //map转为bean，第三个参数是指不忽略转换时候的错误 UserDTO userDTO = BeanUtil.fillBeanWithMap(entries, new UserDTO(), false); //5.存在，保存用户信息到Threadlocal //UserHolder就是用来往ThreadLocal中存储信息的 UserHolder.saveUser(userDTO); String key=RedisConstants.LOGIN_USER_KEY+token; //刷新token有效期 stringRedisTemplate.expire(key,RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES); //7.放行 return true; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; UserHolder.removeUser(); &#125;&#125; MVCconfig 12345678910111213141516171819202122232425262728293031package com.hmdp.config;import com.hmdp.utils.LoginInterceptor;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import javax.annotation.Resource;@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123; @Resource private StringRedisTemplate stringRedisTemplate; @Override public void addInterceptors(InterceptorRegistry registry) &#123; // 登录拦截器 registry.addInterceptor(new LoginInterceptor(stringRedisTemplate)) .excludePathPatterns( &quot;/shop/**&quot;, &quot;/voucher/**&quot;, &quot;/shop-type/**&quot;, &quot;/upload/**&quot;, &quot;/blog/hot&quot;, &quot;/user/code&quot;, &quot;/user/login&quot; ).order(1); &#125;&#125; Redis代替session需要考虑的问题 1.选择合适的数据结构，存验证码用String存储value，存用户信息用Hash结构 2.选择合适的key，验证码的key和用户信息的key都是一个人只有一个的 3.选择合适的存储粒度，只存储了User中不敏感的信息所以用了UserDTO 1.9 解决状态登录刷新问题1.9.1 初始方案思路总结：在这个方案中，他确实可以使用对应路径的拦截，同时刷新登录token令牌的存活时间，但是现在这个拦截器他只是拦截需要被拦截的路径，假设当前用户访问了一些不需要拦截的路径，那么这个拦截器就不会生效，所以此时令牌刷新的动作实际上就不会执行，所以这个方案他是存在问题的 1.9.2 优化方案既然之前的拦截器无法对不需要拦截的路径生效，那么我们可以添加一个拦截器，在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能。 1.9.3 代码RefreshTokenInterceptor 这个拦截器虽然叫拦截器，但是根本不拦截，就是单纯的为了刷新token有效期 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.hmdp.utils;import cn.hutool.core.bean.BeanUtil;import cn.hutool.core.util.StrUtil;import com.hmdp.dto.UserDTO;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Map;import java.util.concurrent.TimeUnit;import static com.hmdp.utils.RedisConstants.LOGIN_USER_KEY;import static com.hmdp.utils.RedisConstants.LOGIN_USER_TTL;//这个类不是springmvc中的组件，就是上面没有@Configuration这种标记//所以不能够自动装配stringRedisTemplate，要在调用这个拦截器的地方调用有参构造，也就是MvcConfig里面public class RefreshTokenInterceptor implements HandlerInterceptor &#123; private StringRedisTemplate stringRedisTemplate; public RefreshTokenInterceptor(StringRedisTemplate stringRedisTemplate) &#123; this.stringRedisTemplate = stringRedisTemplate; &#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // 1.获取请求头中的token String token = request.getHeader(&quot;authorization&quot;); if (StrUtil.isBlank(token)) &#123; return true; &#125; // 2.基于TOKEN获取redis中的用户 String key = LOGIN_USER_KEY + token; Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key); // 3.判断用户是否存在 if (userMap.isEmpty()) &#123; return true; &#125; // 5.将查询到的hash数据转为UserDTO UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false); // 6.存在，保存用户信息到 ThreadLocal UserHolder.saveUser(userDTO); // 7.刷新token有效期 stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES); // 8.放行 return true; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; // 移除用户 UserHolder.removeUser(); &#125;&#125; LoginInterceptor 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.hmdp.utils;import cn.hutool.core.bean.BeanUtil;import cn.hutool.core.util.StrUtil;import com.hmdp.dto.UserDTO;import com.hmdp.entity.User;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.util.Map;import java.util.concurrent.TimeUnit;//这个类不是springmvc中的组件，就是上面没有@Configuration这种标记//所以不能够自动装配stringRedisTemplate，要在调用这个拦截器的地方调用有参构造，也就是MvcConfig里面public class LoginInterceptor implements HandlerInterceptor &#123; private StringRedisTemplate stringRedisTemplate; public LoginInterceptor(StringRedisTemplate stringRedisTemplater)&#123; this.stringRedisTemplate=stringRedisTemplater; &#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //判断是否需要拦截(ThreadLocal中是否有用户) if(UserHolder.getUser()==null)&#123; //没有，需要拦截，设置状态码 response.setStatus(401); return false; &#125; //有用户，则放行 return true; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; UserHolder.removeUser(); &#125;&#125; MVCconfig 12345678910111213141516171819202122232425262728293031323334353637383940package com.hmdp.config;import com.hmdp.utils.LoginInterceptor;import com.hmdp.utils.RefreshTokenInterceptor;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import javax.annotation.Resource;@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123; @Resource private StringRedisTemplate stringRedisTemplate; @Override public void addInterceptors(InterceptorRegistry registry) &#123; // 登录拦截器 registry.addInterceptor(new LoginInterceptor()) .excludePathPatterns( &quot;/shop/**&quot;, &quot;/voucher/**&quot;, &quot;/shop-type/**&quot;, &quot;/upload/**&quot;, &quot;/blog/hot&quot;, &quot;/user/code&quot;, &quot;/user/login&quot; ).order(1); //希望refreshtoken过滤器先执行,所以把它的order设置的比上面那个要小，order小的先执行 registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)).addPathPatterns(&quot;/**&quot;).order(0); &#125;&#125; 2、商户查询缓存2.1 什么是缓存?前言:什么是缓存? 就像自行车,越野车的避震器 举个例子:越野车,山地自行车,都拥有”避震器”,防止车体加速后因惯性,在酷似”U”字母的地形上飞跃,硬着陆导致的损害,像个弹簧一样; 同样,实际开发中,系统也需要”避震器”,防止过高的数据访问猛冲系统,导致其操作线程无法及时处理信息而瘫痪; 这在实际开发中对企业讲,对产品口碑,用户评价都是致命的;所以企业非常重视缓存技术; 缓存(Cache),就是数据交换的缓冲区,俗称的缓存就是缓冲区内的数据,一般从数据库中获取,存储于本地代码(例如: 12345例1:Static final ConcurrentHashMap&lt;K,V&gt; map = new ConcurrentHashMap&lt;&gt;(); 本地用于高并发例2:static final Cache&lt;K,V&gt; USER_CACHE = CacheBuilder.newBuilder().build(); 用于redis等缓存例3:Static final Map&lt;K,V&gt; map = new HashMap(); 本地缓存 由于其被Static修饰,所以随着类的加载而被加载到内存之中,作为本地缓存,由于其又被final修饰,所以其引用(例3:map)和对象(例3:new HashMap())之间的关系是固定的,不能改变,因此不用担心赋值(&#x3D;)导致缓存失效; 2.1.1 为什么要使用缓存一句话:因为速度快,好用 缓存数据存储于代码中,而代码运行在内存中,内存的读写性能远高于磁盘,缓存可以大大降低用户访问并发量带来的服务器读写压力 实际开发过程中,企业的数据量,少则几十万,多则几千万,这么大数据量,如果没有缓存来作为”避震器”,系统是几乎撑不住的,所以企业会大量运用到缓存技术; 但是缓存也会增加代码复杂度和运营的成本: 2.1.2 如何使用缓存实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用 浏览器缓存：主要是存在于浏览器端的缓存 应用层缓存：可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存 数据库缓存：在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中 CPU缓存：当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存 2.2 添加商户缓存在我们查询商户信息时，我们是直接操作从数据库中去进行查询的，大致逻辑是这样，直接查询数据库那肯定慢咯，所以我们需要增加缓存 12345@GetMapping(&quot;/&#123;id&#125;&quot;)public Result queryShopById(@PathVariable(&quot;id&quot;) Long id) &#123; //这里是直接查询数据库 return shopService.queryById(id);&#125; 2.2.1 、缓存模型和思路标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。 2.1.2、代码如下点击单个商户查询时所触发的 代码思路：如果缓存有，则直接返回，如果缓存不存在，则查询数据库，然后存入redis。 1234567891011121314151617181920212223242526272829@Overridepublic Result queryById(Long id) &#123; //查询redis数据库 String key=CACHE_SHOP_KEY+id; String shopJson = stringRedisTemplate.opsForValue().get(key); if(StrUtil.isNotBlank(shopJson))&#123; //如果在redis中查询到数据 Shop shop = JSONUtil.toBean(shopJson, Shop.class); //直接返回 return Result.ok(shop); &#125; //如果redis中没有查到，去数据库中查询 Shop shop = this.getById(id); //没有查到 if(shop==null)&#123; return Result.fail(&quot;抱歉，没有查询到&quot;); &#125; //java对象转json字符串 String jsonStr = JSONUtil.toJsonStr(shop); //如果查询到，先保存到缓存中 stringRedisTemplate.opsForValue().set(key,jsonStr); //返回 return Result.ok(shop);&#125; Controller 1234@GetMapping(&quot;/&#123;id&#125;&quot;)public Result queryShopById(@PathVariable(&quot;id&quot;) Long id) &#123; return shopService.queryById(id);&#125; SHopTypeController 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.hmdp.controller;import cn.hutool.core.util.StrUtil;import cn.hutool.json.JSONUtil;import com.alibaba.fastjson.JSON;import com.hmdp.dto.Result;import com.hmdp.entity.ShopType;import com.hmdp.service.IShopTypeService;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;import java.util.ArrayList;import java.util.List;/** * &lt;p&gt; * 前端控制器 * &lt;/p&gt; * * @author 虎哥 * @since 2021-12-22 */@RestController@RequestMapping(&quot;/shop-type&quot;)public class ShopTypeController &#123; @Resource private IShopTypeService typeService; @Resource private StringRedisTemplate stringRedisTemplate; @GetMapping(&quot;list&quot;) public Result queryTypeList() &#123; String key=&quot;shopTypeList&quot;; String list = stringRedisTemplate.opsForValue().get(key); if(StrUtil.isNotBlank(list))&#123; //hool工具中的转json字符串的方法只能转单个对象，不能转list对象 //所以这里导入了阿里巴巴啊的fastjson包 System.out.println(list); List&lt;ShopType&gt; parse = (List&lt;ShopType&gt;)JSON.parse(list); return Result.ok(parse); &#125; List&lt;ShopType&gt; typeList=typeService.queryforList(); if(typeList==null)&#123; return Result.fail(&quot;查询失败&quot;); &#125; String s = JSONUtil.toJsonStr(typeList); stringRedisTemplate.opsForValue().set(key,s); return Result.ok(typeList); &#125;&#125; 2.3 缓存更新策略缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。 内存淘汰：redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式) 超时剔除：当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存 主动更新：我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题 2.3.1 、数据库缓存不一致解决方案：由于我们的缓存的数据源来自于数据库,而数据库的数据是会发生变化的,因此,如果当数据库中数据发生变化,而缓存却没有同步,此时就会有一致性问题存在,其后果是: 用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案 Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案 Read&#x2F;Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理 Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致 2.3.2 、数据库和缓存不一致采用什么方案综合考虑使用方案一，但是方案一调用者如何处理呢？这里有几个问题 操作缓存和数据库时有三个问题需要考虑： 如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来 删除缓存还是更新缓存？ 更新缓存：每次更新数据库都更新缓存，无效写操作较多 删除缓存：更新数据库时让缓存失效，查询时再更新缓存 如何保证缓存与数据库的操作的同时成功或失败？ 单体系统，将缓存与数据库操作放在一个事务 分布式系统，利用TCC等分布式事务方案 应该具体操作缓存还是操作数据库，我们应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。 先操作缓存还是先操作数据库？ 先删除缓存，再操作数据库 先操作数据库，再删除缓存 这两种其实都可能出现问题，只是先操作数据库出现问题的概率小，因为写入缓存比较快，但更新数据库操作比较慢 下面图中是会出现问题的两种情况 2.4 实现商铺和缓存与数据库双写一致核心思路如下： 修改ShopController中的业务逻辑，满足下面的需求： 根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间 根据id修改店铺时，先修改数据库，再删除缓存 修改重点代码1：修改ShopServiceImpl的queryById方法 设置redis缓存时添加过期时间 修改重点代码2 代码分析：通过之前的淘汰，我们确定了采用删除策略，来解决双写问题，当我们修改了数据之后，然后把缓存中的数据进行删除，查询时发现缓存中没有数据，则会从mysql中加载最新的数据，从而避免数据库和缓存不一致的问题 2.5 缓存穿透问题的解决思路缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。 容易被有心人利用，不断发起这种请求，搞塌数据库 常见的解决方案有两种： 缓存空对象 优点：实现简单，维护方便 缺点： 额外的内存消耗 可能造成短期的不一致，如果在空redis生效的期间，真的在数据库中有了这个数据，就会出现不一致，可以把TTL设置短一点，但其实好像也不会，只要设置更新或者插入数据的时候删除这个空缓存不就好了，向上面那个缓存与数据库双写一致那样操作 布隆过滤 优点：内存占用较少，没有多余key 缺点： 实现复杂 存在误判可能 缓存空对象思路分析：当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了 布隆过滤：布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中， 假设布隆过滤器判断这个数据不存在，则直接返回 这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突 左图使第一个，右图是布隆 2.6 编码解决商品查询的缓存穿透问题：这种解决方法是缓存空对象思路 核心思路如下： 在原来的逻辑中，我们如果发现这个数据在mysql中不存在，直接就返回404了，这样是会存在缓存穿透问题的 现在的逻辑中：如果这个数据不存在，我们不会返回404 ，还是会把这个数据写入到Redis中，并且将value设置为空，欧当再次发起查询时，我们如果发现命中之后，判断这个value是否是null，如果是null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。 ShopServiceImpl 其实就是增加了数据库中查询不到就添加空字符串缓存，和判断命中缓存的时候是不是命中了空字符串 12345678910111213141516171819202122232425262728293031323334353637383940@Overridepublic Result queryById(Long id) &#123; //查询redis数据库 String key=CACHE_SHOP_KEY+id; String shopJson = stringRedisTemplate.opsForValue().get(key); if(StrUtil.isNotBlank(shopJson))&#123; //如果在redis中查询到数据 Shop shop = JSONUtil.toBean(shopJson, Shop.class); //直接返回 return Result.ok(shop); &#125; //命中的是空字符串,因为剩下的不是null就是空字符串 if(shopJson!=null)&#123; return Result.fail(&quot;店铺信息不存在&quot;); &#125; //如果redis中没有查到，去数据库中查询 Shop shop = this.getById(id); //没有查到 if(shop==null)&#123; //将空值写入redis,并且空值的过期时间设置应该短一点 stringRedisTemplate.opsForValue().set(key,&quot;&quot;,CACHE_NULL_TTL,TimeUnit.MINUTES); return Result.fail(&quot;抱歉，没有查询到&quot;); &#125; //java对象转json字符串 String jsonStr = JSONUtil.toJsonStr(shop); //如果查询到，先保存到缓存中 //添加过期时间，兜底操作,第三个参数是过期时间 stringRedisTemplate.opsForValue().set(key,jsonStr, CACHE_SHOP_TTL, TimeUnit.MINUTES); //返回 return Result.ok(shop);&#125; 小总结： 缓存穿透产生的原因是什么？ 用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力 缓存穿透的解决方案有哪些？ 缓存null值 布隆过滤 增强id的复杂度，避免被猜测id规律，这样就可以把不符合规律的id筛除掉，以免被攻击 做好数据的基础格式校验，和上面那个一个意思 加强用户权限校验 做好热点参数的限流 2.7 缓存雪崩问题及解决思路缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。 解决方案： 给不同的Key的TTL添加随机值，key失效期限是30分钟，那么你可以随即设置31，32，33，34等等 利用Redis集群提高服务的可用性 给缓存业务添加降级限流策略，就是阻止一些访问吧，这个限流会在springcloud中讲 给业务添加多级缓存，就是指先nginx缓存未命中再redis缓存再jvm本地缓存再是数据库，这样redis一个没了还有其他的 2.8 缓存击穿问题及解决思路缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。 常见的解决方案有两种： 互斥锁 逻辑过期 逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大 解决方案一、使用锁来解决： 因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。 假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。 解决方案二、逻辑过期方案 方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。 我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。 这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。 进行对比 互斥锁方案：由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响 死锁：业务中有对多个缓存查询的需求，而在另外一个业务中也有多个缓存查询的要求，这个时候你拿到了一把锁，然后要拿另一把锁的时候，发现他在另一个业务里，就会出现互相等待的情况 逻辑过期方案： 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦 2.9 利用互斥锁解决缓存击穿问题核心思路：相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是 进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询 如果获取到了锁的线程，再去进行查询，查询后将数据写入redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑，防止缓存击穿 操作锁的代码： 核心思路就是利用redis的setnx方法来表示获取锁，该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true， 如果有这个key则插入失败，则返回0，在stringRedisTemplate返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。 123456789private boolean tryLock(String key) &#123; Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, 10, TimeUnit.SECONDS); return BooleanUtil.isTrue(flag);&#125;private void unlock(String key) &#123; stringRedisTemplate.delete(key);&#125; 操作代码： 原来的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public Shop queryWithMutex(Long id) &#123; String key = CACHE_SHOP_KEY + id; // 1、从redis中查询商铺缓存 String shopJson = stringRedisTemplate.opsForValue().get(&quot;key&quot;); // 2、判断是否存在 if (StrUtil.isNotBlank(shopJson)) &#123; // 存在,直接返回 return JSONUtil.toBean(shopJson, Shop.class); &#125; //判断命中的值是否是空值 if (shopJson != null) &#123; //返回一个错误信息 return null; &#125; // 4.实现缓存重构 //4.1 获取互斥锁 String lockKey = &quot;lock:shop:&quot; + id; Shop shop = null; try &#123; boolean isLock = tryLock(lockKey); // 4.2 判断否获取成功 if(!isLock)&#123; //4.3 失败，则休眠重试 Thread.sleep(50); return queryWithMutex(id); &#125; //4.4 成功，根据id查询数据库 shop = getById(id); // 5.不存在，返回错误 if(shop == null)&#123; //将空值写入redis stringRedisTemplate.opsForValue().set(key,&quot;&quot;,CACHE_NULL_TTL,TimeUnit.MINUTES); //返回错误信息 return null; &#125; //6.写入redis stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),CACHE_NULL_TTL,TimeUnit.MINUTES); &#125;catch (Exception e)&#123; throw new RuntimeException(e); &#125; finally &#123; //7.释放互斥锁 unlock(lockKey); &#125; return shop; &#125; 自己写的： 和上面几乎就是一样的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101 //互斥锁解决缓存击穿问题 public Shop queryWithMutext(Long id) &#123; Shop shop; //查询redis数据库 String key = CACHE_SHOP_KEY + id; String shopJson = stringRedisTemplate.opsForValue().get(key); if (StrUtil.isNotBlank(shopJson)) &#123; //如果在redis中查询到数据 shop = JSONUtil.toBean(shopJson, Shop.class); //直接返回 return shop; &#125; //命中的是空字符串,因为剩下的不是null就是空字符串 if (shopJson != null) &#123; return null; &#125; //redis没有命中的时候，先获取锁 String lockkey = &quot;lock:shop:&quot; + id; boolean trylock = trylock(lockkey);try&#123; //没获取到锁,则休眠重试 if (!trylock) &#123; Thread.sleep(10); queryWithMutext(id); &#125; //获取到锁了，根据id查询数据库 //模拟重建的延时 Thread.sleep(200); //对缓存二次检测 String shopJson1 = stringRedisTemplate.opsForValue().get(key); if (StrUtil.isNotBlank(shopJson1)) &#123; //如果在redis中查询到数据 shop = JSONUtil.toBean(shopJson1, Shop.class); //直接返回 return shop; &#125; //命中的是空字符串,因为剩下的不是null就是空字符串 if (shopJson1 != null) &#123; return null; &#125; //如果redis中没有查到，去数据库中查询 shop = this.getById(id); //没有查到 if (shop == null) &#123; //将空值写入redis,并且空值的过期时间设置应该短一点 stringRedisTemplate.opsForValue().set(key, &quot;&quot;, CACHE_NULL_TTL, TimeUnit.MINUTES); return null; &#125; //java对象转json字符串 String jsonStr = JSONUtil.toJsonStr(shop); //如果查询到，先保存到缓存中 //添加过期时间，兜底操作,第三个参数是过期时间 stringRedisTemplate.opsForValue().set(key, jsonStr, CACHE_SHOP_TTL, TimeUnit.MINUTES); &#125; catch (Exception e)&#123; throw new RuntimeException(); &#125; finally &#123; unlock(lockkey); &#125; //返回 return shop; &#125; //获取锁代码 private boolean trylock(String key)&#123; //setifpresent就是setnx Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, 10, TimeUnit.SECONDS); //直接返回flag它会进行拆箱，因为boolean和Boolean的关系，它有可能会出现空指针情况 return BooleanUtil.isTrue(flag); &#125; //释放锁 private void unlock(String key)&#123; stringRedisTemplate.delete(key); &#125; ShopServiceImpl 进行了缓存穿透和缓存击穿的封装之后 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219package com.hmdp.service.impl;import cn.hutool.core.util.BooleanUtil;import cn.hutool.core.util.StrUtil;import cn.hutool.json.JSONUtil;import com.hmdp.dto.Result;import com.hmdp.entity.Shop;import com.hmdp.mapper.ShopMapper;import com.hmdp.service.IShopService;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.hmdp.utils.RedisConstants;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.stereotype.Service;import java.util.concurrent.TimeUnit;import static com.hmdp.utils.RedisConstants.*;/** * &lt;p&gt; * 服务实现类 * &lt;/p&gt; * * @author 虎哥 * @since 2021-12-22 */@Servicepublic class ShopServiceImpl extends ServiceImpl&lt;ShopMapper, Shop&gt; implements IShopService &#123; @Autowired StringRedisTemplate stringRedisTemplate; //这个方法就是调用封装好的api，解决缓存击穿和缓存穿透问题的查询方法的api @Override public Result queryById(Long id) &#123; //解决缓存穿透的封装 //Shop shop=queryWithPassThrough(id); //互斥锁解决缓存击穿 Shop shop=queryWithMutext(id); if(shop==null)&#123; return Result.fail(&quot;店铺不存在!&quot;); &#125; //返回 return Result.ok(shop); &#125; //互斥锁解决缓存击穿问题 public Shop queryWithMutext(Long id) &#123; Shop shop; //查询redis数据库 String key = CACHE_SHOP_KEY + id; String shopJson = stringRedisTemplate.opsForValue().get(key); if (StrUtil.isNotBlank(shopJson)) &#123; //如果在redis中查询到数据 shop = JSONUtil.toBean(shopJson, Shop.class); //直接返回 return shop; &#125; //命中的是空字符串,因为剩下的不是null就是空字符串 if (shopJson != null) &#123; return null; &#125; //redis没有命中的时候，先获取锁 String lockkey = &quot;lock:shop:&quot; + id; boolean trylock = trylock(lockkey);try&#123; //没获取到锁,则休眠重试 if (!trylock) &#123; Thread.sleep(10); queryWithMutext(id); &#125; //获取到锁了，根据id查询数据库 //模拟重建的延时 Thread.sleep(200); //对缓存二次检测 String shopJson1 = stringRedisTemplate.opsForValue().get(key); if (StrUtil.isNotBlank(shopJson1)) &#123; //如果在redis中查询到数据 shop = JSONUtil.toBean(shopJson1, Shop.class); //直接返回 return shop; &#125; //命中的是空字符串,因为剩下的不是null就是空字符串 if (shopJson1 != null) &#123; return null; &#125; //如果redis中没有查到，去数据库中查询 shop = this.getById(id); //没有查到 if (shop == null) &#123; //将空值写入redis,并且空值的过期时间设置应该短一点 stringRedisTemplate.opsForValue().set(key, &quot;&quot;, CACHE_NULL_TTL, TimeUnit.MINUTES); return null; &#125; //java对象转json字符串 String jsonStr = JSONUtil.toJsonStr(shop); //如果查询到，先保存到缓存中 //添加过期时间，兜底操作,第三个参数是过期时间 stringRedisTemplate.opsForValue().set(key, jsonStr, CACHE_SHOP_TTL, TimeUnit.MINUTES); &#125; catch (Exception e)&#123; throw new RuntimeException(); &#125; finally &#123; unlock(lockkey); &#125; //返回 return shop; &#125; //获取锁代码 private boolean trylock(String key)&#123; //setifpresent就是setnx Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, 10, TimeUnit.SECONDS); //直接返回flag它会进行拆箱，因为boolean和Boolean的关系，它有可能会出现空指针情况 return BooleanUtil.isTrue(flag); &#125; //释放锁 private void unlock(String key)&#123; stringRedisTemplate.delete(key); &#125; //这个是缓存穿透的解决的方法的代码，互斥锁方法 public Shop queryWithPassThrough(Long id) &#123; //查询redis数据库 String key=CACHE_SHOP_KEY+id; String shopJson = stringRedisTemplate.opsForValue().get(key); if(StrUtil.isNotBlank(shopJson))&#123; //如果在redis中查询到数据 Shop shop = JSONUtil.toBean(shopJson, Shop.class); //直接返回 return shop; &#125; //命中的是空字符串,因为剩下的不是null就是空字符串 if(shopJson!=null)&#123; return null; &#125; //如果redis中没有查到，去数据库中查询 Shop shop = this.getById(id); //没有查到 if(shop==null)&#123; //将空值写入redis,并且空值的过期时间设置应该短一点 stringRedisTemplate.opsForValue().set(key,&quot;&quot;,CACHE_NULL_TTL,TimeUnit.MINUTES); return null; &#125; //java对象转json字符串 String jsonStr = JSONUtil.toJsonStr(shop); //如果查询到，先保存到缓存中 //添加过期时间，兜底操作,第三个参数是过期时间 stringRedisTemplate.opsForValue().set(key,jsonStr, CACHE_SHOP_TTL, TimeUnit.MINUTES); //返回 return shop; &#125; @Override public Result update(Shop shop) &#123; Long id = shop.getId(); if(id==null)&#123; return Result.fail(&quot;商品店铺不能没有id&quot;); &#125; //前面讨论过是先更新数据库再删除缓存 //更新数据库 this.updateById(shop); //删除缓存 stringRedisTemplate.delete(CACHE_SHOP_KEY+shop.getId()); return Result.ok(); &#125;&#125; 3.0 、利用逻辑过期解决缓存击穿问题使用逻辑过期的时候会提前把热key放在缓存中，而且加进去的key不会redis过期，只会逻辑过期，所以如果没有命中缓存可以直接返回空 需求：修改根据id查询商铺的业务，基于逻辑过期方式来解决缓存击穿问题 思路分析：当用户开始查询redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。 如果封装数据：因为现在redis中存储的数据的value需要带上过期时间，此时要么你去修改原来的实体类，要么你新建一个RedisData里面一个属性是过期时间，一个属性是那个可以存储shop对象也或者是其他的 步骤一、 新建一个实体类，我们采用第二个方案，这个方案，对原来代码没有侵入性。 12345@Datapublic class RedisData &#123; private LocalDateTime expireTime; private Object data;&#125; 步骤二、 在ShopServiceImpl 新增此方法，利用单元测试进行缓存预热 这个方法就是用来提前把热key加入到缓存中 和上面图片一样 12345678910111213141516public void saveShop2Redis(Long id,Long expireSeconds)&#123; //查询店铺数据 Shop shop = getById(id); //封装逻辑过期时间 RedisData redisData=new RedisData(); redisData.setData(shop); //这里是设置逻辑过期时间，是当前时间再加上参数的秒数 redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds)); //写入redis stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY+id,JSONUtil.toJsonStr(redisData));&#125; 在测试类中 步骤三：正式代码 ShopServiceImpl 1234567891011121314151617181920212223242526272829303132333435363738394041private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);public Shop queryWithLogicalExpire( Long id ) &#123; String key = CACHE_SHOP_KEY + id; // 1.从redis查询商铺缓存 String json = stringRedisTemplate.opsForValue().get(key); // 2.判断是否存在 if (StrUtil.isBlank(json)) &#123; // 3.存在，直接返回 return null; &#125; // 4.命中，需要先把json反序列化为对象 RedisData redisData = JSONUtil.toBean(json, RedisData.class); Shop shop = JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class); LocalDateTime expireTime = redisData.getExpireTime(); // 5.判断是否过期 if(expireTime.isAfter(LocalDateTime.now())) &#123; // 5.1.未过期，直接返回店铺信息 return shop; &#125; // 5.2.已过期，需要缓存重建 // 6.缓存重建 // 6.1.获取互斥锁 String lockKey = LOCK_SHOP_KEY + id; boolean isLock = tryLock(lockKey); // 6.2.判断是否获取锁成功 if (isLock)&#123; CACHE_REBUILD_EXECUTOR.submit( ()-&gt;&#123; try&#123; //重建缓存 this.saveShop2Redis(id,20L); &#125;catch (Exception e)&#123; throw new RuntimeException(e); &#125;finally &#123; unlock(lockKey); &#125; &#125;); &#125; // 6.4.返回过期的商铺信息 return shop;&#125; ShopServiceImpl 自己写的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//这个方法就是调用封装好的api，解决缓存击穿和缓存穿透问题的查询方法的api@Overridepublic Result queryById(Long id) &#123;//解决缓存穿透的封装//Shop shop=queryWithPassThrough(id); //互斥锁解决缓存击穿 // Shop shop=queryWithMutext(id); Shop shop=queryWithLogical(id); if(shop==null)&#123; return Result.fail(&quot;店铺不存在!&quot;); &#125; //返回 return Result.ok(shop);&#125;//定义一个10个线程的线程池private static final ExecutorService CACHE_REBUILD_EXECUTOR= Executors.newFixedThreadPool(10);//这个是缓存穿透的解决的方法的代码，逻辑过期方法public Shop queryWithLogical(Long id) &#123; //1，查询redis数据库 String key=CACHE_SHOP_KEY+id; String shopJson = stringRedisTemplate.opsForValue().get(key); //2.未命中缓存或者返回是空字符串直接返回空 if(StrUtil.isBlank(shopJson))&#123; return null; &#125; //3.命中了缓存，把字符串转换为RedisData对象 RedisData redisData = JSONUtil.toBean(shopJson, RedisData.class); //4.获取shop对象 //获取的data是Object类型，可以转为JSONObject类型作为第一个参数 Shop shop1 = JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class); //取出过期时间 LocalDateTime expireTime = redisData.getExpireTime(); //5.判断是否过期 if(expireTime.isAfter(LocalDateTime.now()))&#123; //未过期 return shop1; &#125; //6.过期了，就要去重建缓存 String lockkey= LOCK_SHOP_KEY +id; boolean trylock = trylock(lockkey); //7.判断是否拿到锁 if(trylock)&#123; //8.拿到锁了 //开启独立线程，实现缓存重建 CACHE_REBUILD_EXECUTOR.submit(()-&gt;&#123; try &#123; //重建缓存 //正常是30分钟，但是为了测试这里先写30秒 saveShop2Redis(id, 30L); &#125; catch (Exception e)&#123; throw new RuntimeException(e); &#125; finally &#123; //释放锁 unlock(lockkey); &#125; &#125;); &#125; //没拿到锁 //返回过期商铺信息 return shop1;&#125;public void saveShop2Redis(Long id,Long expireSeconds) throws InterruptedException &#123; //查询店铺数据 Shop shop = getById(id); //模拟重建缓存延迟 Thread.sleep(200); //封装逻辑过期时间 RedisData redisData=new RedisData(); redisData.setData(shop); //这里是设置逻辑过期时间，是当前时间再加上参数的秒数 redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds)); //写入redis stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY+id,JSONUtil.toJsonStr(redisData));&#125; 3.1、封装Redis工具类基于StringRedisTemplate封装一个缓存工具类，满足下列需求： 方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间 方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓 存击穿问题 方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题 方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题 将逻辑进行封装 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166@Slf4j@Componentpublic class CacheClient &#123; private final StringRedisTemplate stringRedisTemplate; private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10); public CacheClient(StringRedisTemplate stringRedisTemplate) &#123; this.stringRedisTemplate = stringRedisTemplate; &#125; public void set(String key, Object value, Long time, TimeUnit unit) &#123; stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit); &#125; public void setWithLogicalExpire(String key, Object value, Long time, TimeUnit unit) &#123; // 设置逻辑过期 RedisData redisData = new RedisData(); redisData.setData(value); redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time))); // 写入Redis stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData)); &#125; //解决缓存穿透的方法 public &lt;R,ID&gt; R queryWithPassThrough( //keyPrefix是那个key的前缀，keyRrefix和id加起来是要保存的key,ID类型未知所以用泛型，Class&lt;R&gt; type指类型 //有参有返回值类型的函数是Function&lt;ID,R&gt; dbFallback ,第一个泛型是函数参数类型，第二个泛型是返回值类型 //添加非空缓存的时间，添加空缓存的时间是由CACHE_NULL_TTL在某个类中定义的 String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)&#123; String key = keyPrefix + id; // 1.从redis查询商铺缓存 String json = stringRedisTemplate.opsForValue().get(key); // 2.判断是否存在 if (StrUtil.isNotBlank(json)) &#123; // 3.存在，直接返回 return JSONUtil.toBean(json, type); &#125; // 判断命中的是否是空值 if (json != null) &#123; // 返回一个错误信息 return null; &#125; // 4.不存在，根据id查询数据库 R r = dbFallback.apply(id); // 5.不存在，返回错误 if (r == null) &#123; // 将空值写入redis stringRedisTemplate.opsForValue().set(key, &quot;&quot;, CACHE_NULL_TTL, TimeUnit.MINUTES); // 返回错误信息 return null; &#125; // 6.存在，写入redis this.set(key, r, time, unit); return r; &#125; //封装这个逻辑过期解决缓存击穿 public &lt;R, ID&gt; R queryWithLogicalExpire( String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit) &#123; String key = keyPrefix + id; // 1.从redis查询商铺缓存 String json = stringRedisTemplate.opsForValue().get(key); // 2.判断是否存在 if (StrUtil.isBlank(json)) &#123; // 3.不存在，直接返回 return null; &#125; // 4.命中，需要先把json反序列化为对象 RedisData redisData = JSONUtil.toBean(json, RedisData.class); R r = JSONUtil.toBean((JSONObject) redisData.getData(), type); LocalDateTime expireTime = redisData.getExpireTime(); // 5.判断是否过期 if(expireTime.isAfter(LocalDateTime.now())) &#123; // 5.1.未过期，直接返回店铺信息 return r; &#125; // 5.2.已过期，需要缓存重建 // 6.缓存重建 // 6.1.获取互斥锁 String lockKey = LOCK_SHOP_KEY + id; boolean isLock = tryLock(lockKey); // 6.2.判断是否获取锁成功 if (isLock)&#123; // 6.3.成功，开启独立线程，实现缓存重建 CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123; try &#123; // 查询数据库 R newR = dbFallback.apply(id); // 重建缓存 this.setWithLogicalExpire(key, newR, time, unit); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125;finally &#123; // 释放锁 unlock(lockKey); &#125; &#125;); &#125; // 6.4.返回过期的商铺信息 return r; &#125; //用互斥锁解决缓存击穿 public &lt;R, ID&gt; R queryWithMutex( String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit) &#123; String key = keyPrefix + id; // 1.从redis查询商铺缓存 String shopJson = stringRedisTemplate.opsForValue().get(key); // 2.判断是否存在 if (StrUtil.isNotBlank(shopJson)) &#123; // 3.存在，直接返回 return JSONUtil.toBean(shopJson, type); &#125; // 判断命中的是否是空值 if (shopJson != null) &#123; // 返回一个错误信息 return null; &#125; // 4.实现缓存重建 // 4.1.获取互斥锁 String lockKey = LOCK_SHOP_KEY + id; R r = null; try &#123; boolean isLock = tryLock(lockKey); // 4.2.判断是否获取成功 if (!isLock) &#123; // 4.3.获取锁失败，休眠并重试 Thread.sleep(50); return queryWithMutex(keyPrefix, id, type, dbFallback, time, unit); &#125; // 4.4.获取锁成功，根据id查询数据库 r = dbFallback.apply(id); // 5.不存在，返回错误 if (r == null) &#123; // 将空值写入redis stringRedisTemplate.opsForValue().set(key, &quot;&quot;, CACHE_NULL_TTL, TimeUnit.MINUTES); // 返回错误信息 return null; &#125; // 6.存在，写入redis this.set(key, r, time, unit); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125;finally &#123; // 7.释放锁 unlock(lockKey); &#125; // 8.返回 return r; &#125; private boolean tryLock(String key) &#123; Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, 10, TimeUnit.SECONDS); return BooleanUtil.isTrue(flag); &#125; private void unlock(String key) &#123; stringRedisTemplate.delete(key); &#125;&#125; 在ShopServiceImpl 中 1234567891011121314151617181920212223@Resourceprivate CacheClient cacheClient; @Override public Result queryById(Long id) &#123; // 解决缓存穿透 Shop shop = cacheClient .queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES); // 互斥锁解决缓存击穿 // Shop shop = cacheClient // .queryWithMutex(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES); // 逻辑过期解决缓存击穿 // Shop shop = cacheClient // .queryWithLogicalExpire(CACHE_SHOP_KEY, id, Shop.class, this::getById, 20L, TimeUnit.SECONDS); if (shop == null) &#123; return Result.fail(&quot;店铺不存在！&quot;); &#125; // 7.返回 return Result.ok(shop); &#125; 3、优惠卷秒杀3.1 -全局唯一ID每个店铺都可以发布优惠券： 当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中，而订单表如果使用数据库自增ID就存在一些问题： id的规律性太明显 受单表数据量的限制，当订单太多一个mysql表放不下就要用第二个表，那么第二个表id也是从1开始，会出现id重复的情况，但是订单id是不应该重复的 场景分析：如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。 场景分析二：随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的， 于是乎我们需要保证id的唯一性。 全局ID生成器，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性： 用redis的String类型value中的自增长数值作为id 为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息： ID的组成部分：符号位：1bit，永远为0 时间戳：31bit，以秒为单位，可以使用69年 序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID 3.2 -Redis实现全局唯一Id12345678910111213141516171819202122232425262728293031323334353637@Componentpublic class RedisIdWorker &#123; /** * 开始时间戳 */ private static final long BEGIN_TIMESTAMP = 1640995200L; /** * 序列号的位数 */ private static final int COUNT_BITS = 32; private StringRedisTemplate stringRedisTemplate; public RedisIdWorker(StringRedisTemplate stringRedisTemplate) &#123; this.stringRedisTemplate = stringRedisTemplate; &#125; public long nextId(String keyPrefix) &#123; // 1.生成时间戳 LocalDateTime now = LocalDateTime.now(); long nowSecond = now.toEpochSecond(ZoneOffset.UTC); long timestamp = nowSecond - BEGIN_TIMESTAMP; // 2.生成序列号 // 2.1.获取当前日期，精确到天 String date = now.format(DateTimeFormatter.ofPattern(&quot;yyyy:MM:dd&quot;)); // 2.2.自增长 //这里是每一天的订单通过一个key来存储数量 //key中有yyyy:MM:dd方便统计年月日分别的总订单量 //increment返回值是从1一直按照步长增加，也就是value的值 long count = stringRedisTemplate.opsForValue().increment(&quot;icr:&quot; + keyPrefix + &quot;:&quot; + date); // 3.拼接并返回 //时间戳向左移32位，COUNT_BITS就是32，左移32位之后全是零，然后或count，拼接的值就是count的值 return timestamp &lt;&lt; COUNT_BITS | count; &#125;&#125; 测试类 知识小贴士：关于countdownlatch countdownlatch名为信号枪：主要的作用是同步协调在多线程的等待于唤醒问题 我们如果没有CountDownLatch ，那么由于程序是异步的，当异步程序没有执行完时，主线程就已经执行完了，然后我们期望的是分线程全部走完之后，主线程再走，所以我们此时需要使用到CountDownLatch CountDownLatch 中有两个最重要的方法 1、countDown 2、await await 方法 是阻塞方法，我们担心分线程没有执行完时，main线程就先执行，所以使用await可以让main线程阻塞，那么什么时候main线程不再阻塞呢？当CountDownLatch 内部维护的 变量变为0时，就不再阻塞，直接放行，那么什么时候CountDownLatch 维护的变量变为0 呢，我们只需要调用一次countDown ，内部变量就减少1，我们让分线程和变量绑定， 执行完一个分线程就减少一个变量，当分线程全部走完，CountDownLatch 维护的变量就是0，此时await就不再阻塞，统计出来的时间也就是所有分线程执行完后的时间。 12345678910111213141516171819@Testvoid testIdWorker() throws InterruptedException &#123; CountDownLatch latch = new CountDownLatch(300); Runnable task = () -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; long id = redisIdWorker.nextId(&quot;order&quot;); System.out.println(&quot;id = &quot; + id); &#125; latch.countDown(); &#125;; long begin = System.currentTimeMillis(); for (int i = 0; i &lt; 300; i++) &#123; es.submit(task); &#125; latch.await(); long end = System.currentTimeMillis(); System.out.println(&quot;time = &quot; + (end - begin));&#125; 对上面做了一个补充 12345678910111213141516171819202122232425262728293031323334353637383940package com.hmdp;import com.hmdp.service.impl.ShopServiceImpl;import com.hmdp.utils.RedisIdWorker;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import javax.annotation.Resource;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;@SpringBootTestclass HmDianPingApplicationTests &#123; @Resource private RedisIdWorker redisIdWorker; private ExecutorService es= Executors.newFixedThreadPool(500); @Test void testIdWorker() throws InterruptedException &#123; CountDownLatch latch = new CountDownLatch(300); Runnable task = () -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; long id = redisIdWorker.nextId(&quot;order&quot;); System.out.println(&quot;id = &quot; + id); &#125; latch.countDown(); &#125;; long begin = System.currentTimeMillis(); for (int i = 0; i &lt; 300; i++) &#123; es.submit(task); &#125; latch.await(); long end = System.currentTimeMillis(); System.out.println(&quot;time = &quot; + (end - begin)); &#125;&#125; 3.3 添加优惠卷每个店铺都可以发布优惠券，分为平价券和特价券。平价券可以任意购买，而特价券需要秒杀抢购： tb_voucher：优惠券的基本信息，优惠金额、使用规则等tb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息 平价卷由于优惠力度并不是很大，所以是可以任意领取 而代金券由于优惠力度大，所以像第二种卷，就得限制数量，从表结构上也能看出，特价卷除了具有优惠卷的基本信息以外，还具有库存，抢购时间，结束时间等等字段 **新增普通卷代码： **VoucherController 12345@PostMappingpublic Result addVoucher(@RequestBody Voucher voucher) &#123; voucherService.save(voucher); return Result.ok(voucher.getId());&#125; 新增秒杀卷代码： VoucherController 12345@PostMapping(&quot;seckill&quot;)public Result addSeckillVoucher(@RequestBody Voucher voucher) &#123; voucherService.addSeckillVoucher(voucher); return Result.ok(voucher.getId());&#125; VoucherServiceImpl 123456789101112131415@Override@Transactionalpublic void addSeckillVoucher(Voucher voucher) &#123; // 保存优惠券 save(voucher); // 保存秒杀信息 SeckillVoucher seckillVoucher = new SeckillVoucher(); seckillVoucher.setVoucherId(voucher.getId()); seckillVoucher.setStock(voucher.getStock()); seckillVoucher.setBeginTime(voucher.getBeginTime()); seckillVoucher.setEndTime(voucher.getEndTime()); seckillVoucherService.save(seckillVoucher); // 保存秒杀库存到Redis中 stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());&#125; 3.4 实现秒杀下单下单核心思路：当我们点击抢购时，会触发右侧的请求，我们只需要编写对应的controller即可 秒杀下单应该思考的内容： 下单时需要判断两点： 秒杀是否开始或结束，如果尚未开始或已经结束则无法下单 库存是否充足，不足则无法下单 下单核心逻辑分析： 当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件 比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束。 VoucherOrderServiceImpl 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.hmdp.service.impl;import com.hmdp.dto.Result;import com.hmdp.entity.SeckillVoucher;import com.hmdp.entity.VoucherOrder;import com.hmdp.mapper.VoucherOrderMapper;import com.hmdp.service.ISeckillVoucherService;import com.hmdp.service.IVoucherOrderService;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.hmdp.utils.RedisIdWorker;import com.hmdp.utils.UserHolder;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.time.LocalDateTime;/** * &lt;p&gt; * 服务实现类 * &lt;/p&gt; * * @author 虎哥 * @since 2021-12-22 */@Servicepublic class VoucherOrderServiceImpl extends ServiceImpl&lt;VoucherOrderMapper, VoucherOrder&gt; implements IVoucherOrderService &#123;@Resourceprivate ISeckillVoucherService seckillVoucherService;@Resource private RedisIdWorker redisIdWorker; //订购秒杀卷的方法 @Override public Result seckillVoucher(Long voucherId) &#123; // 1.查询优惠券 SeckillVoucher voucher = seckillVoucherService.getById(voucherId); // 2.判断秒杀是否开始 if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123; // 尚未开始 return Result.fail(&quot;秒杀尚未开始！&quot;); &#125; // 3.判断秒杀是否已经结束 if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123; // 尚未开始 return Result.fail(&quot;秒杀已经结束！&quot;); &#125; // 4.判断库存是否充足 if (voucher.getStock() &lt; 1) &#123; // 库存不足 return Result.fail(&quot;库存不足！&quot;); &#125; //5，扣减库存 boolean success = seckillVoucherService.update() .setSql(&quot;stock= stock -1&quot;) .eq(&quot;voucher_id&quot;, voucherId).update(); if (!success) &#123; //扣减库存 return Result.fail(&quot;库存不足！&quot;); &#125; //6.创建订单 VoucherOrder voucherOrder = new VoucherOrder(); // 6.1.订单id long orderId = redisIdWorker.nextId(&quot;order&quot;); voucherOrder.setId(orderId); // 6.2.用户id Long userId = UserHolder.getUser().getId(); voucherOrder.setUserId(userId); // 6.3.代金券id voucherOrder.setVoucherId(voucherId); save(voucherOrder); return Result.ok(orderId); &#125;&#125; 3.5 库存超卖问题分析有关超卖问题分析：在我们原有代码中是这么写的 123456789101112if (voucher.getStock() &lt; 1) &#123; // 库存不足 return Result.fail(&quot;库存不足！&quot;); &#125; //5，扣减库存 boolean success = seckillVoucherService.update() .setSql(&quot;stock= stock -1&quot;) .eq(&quot;voucher_id&quot;, voucherId).update(); if (!success) &#123; //扣减库存 return Result.fail(&quot;库存不足！&quot;); &#125; 假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。 超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：而对于加锁，我们通常有两种解决方案：见下图： 悲观锁： 悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等 乐观锁： 乐观锁：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如cas 乐观锁的典型代表：就是cas，利用cas进行无锁化机制加锁，var5 是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 &#x3D;&#x3D; 内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值 其中do while 是为了在操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次。 123456int var5;do &#123; var5 = this.getIntVolatile(var1, var2);&#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));return var5; 课程中的使用方式： 课程中的使用方式是没有像cas一样带自旋的操作，也没有对version的版本号+1 ，他的操作逻辑是在操作时，对版本号进行+1 操作，然后要求version 如果是1 的情况下，才能操作，那么第一个线程在操作后，数据库中的version变成了2，但是他自己满足version&#x3D;1 ，所以没有问题，此时线程2执行，线程2 最后也需要加上条件version &#x3D;1 ，但是现在由于线程1已经操作过了，所以线程2，操作时就不满足version&#x3D;1 的条件了，所以线程2无法执行成功 3.6 乐观锁解决超卖问题修改代码方案一、 VoucherOrderServiceImpl 在扣减库存时，改为： 这里就是拿这个库存数量当作版本号 扣减更新库存之前，先查询库存，乐观锁是保证查询的库存和后来要进行修改时候的库存是相同的才能进行修改 123boolean success = seckillVoucherService.update() .setSql(&quot;stock= stock -1&quot;) //set stock = stock -1 .eq(&quot;voucher_id&quot;, voucherId).eq(&quot;stock&quot;,voucher.getStock()).update(); //where id = ？ and stock = ? 以上逻辑的核心含义是：只要我扣减库存时的库存和之前我查询到的库存是一样的，就意味着没有人在中间修改过库存，那么此时就是安全的，但是以上这种方式通过测试发现会有很多失败的情况，失败的原因在于：在使用乐观锁过程中假设100个线程同时都拿到了100的库存，然后大家一起去进行扣减，但是100个人中只有1个人能扣减成功，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败 修改代码方案二、 之前的方式要修改前后都保持一致，但是这样我们分析过，成功的概率太低，所以我们的乐观锁需要变一下，改成stock大于0 即可 123boolean success = seckillVoucherService.update() .setSql(&quot;stock= stock -1&quot;) .eq(&quot;voucher_id&quot;, voucherId).update().gt(&quot;stock&quot;,0); //where id = ? and stock &gt; 0 知识小扩展： 针对cas中的自旋压力过大，我们可以使用Longaddr这个类去解决 Java8 提供的一个对AtomicLong改进后的一个类，LongAdder 大量线程并发更新一个原子性的时候，天然的问题就是自旋，会导致并发性问题，当然这也比我们直接使用syn来的好 所以利用这么一个类，LongAdder来进行优化 如果获取某个值，则会对cell和base的值进行递增，最后返回一个完整的值 3.6 优惠券秒杀-一人一单需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单 现在的问题在于： 优惠卷是为了引流，但是目前的情况是，一个人可以无限制的抢这个优惠卷，所以我们应当增加一层逻辑，让一个用户只能下一个单，而不是让一个用户下多个单 具体操作逻辑如下：比如秒杀是否开始，如果秒杀开始，则进一步判断库存是否足够，然后再根据优惠卷id和用户id查询是否已经下过这个订单，如果下过这个订单，则不再下单，否则进行下单 VoucherOrderServiceImpl 初步代码：增加一人一单逻辑 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.hmdp.service.impl;import com.hmdp.dto.Result;import com.hmdp.entity.SeckillVoucher;import com.hmdp.entity.VoucherOrder;import com.hmdp.mapper.VoucherOrderMapper;import com.hmdp.service.ISeckillVoucherService;import com.hmdp.service.IVoucherOrderService;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.hmdp.utils.RedisIdWorker;import com.hmdp.utils.UserHolder;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.time.LocalDateTime;/** * &lt;p&gt; * 服务实现类 * &lt;/p&gt; * * @author 虎哥 * @since 2021-12-22 */@Servicepublic class VoucherOrderServiceImpl extends ServiceImpl&lt;VoucherOrderMapper, VoucherOrder&gt; implements IVoucherOrderService &#123;@Resourceprivate ISeckillVoucherService seckillVoucherService;@Resourceprivate RedisIdWorker redisIdWorker; @Override public Result seckillVoucher(Long voucherId) &#123; // 1.查询优惠券 SeckillVoucher voucher = seckillVoucherService.getById(voucherId); // 2.判断秒杀是否开始 if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123; // 尚未开始 return Result.fail(&quot;秒杀尚未开始！&quot;); &#125; // 3.判断秒杀是否已经结束 if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123; // 尚未开始 return Result.fail(&quot;秒杀已经结束！&quot;); &#125; // 4.判断库存是否充足 if (voucher.getStock() &lt; 1) &#123; // 库存不足 return Result.fail(&quot;库存不足！&quot;); &#125; // 5.一人一单逻辑 // 5.1.用户id Long userId = UserHolder.getUser().getId(); int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count(); // 5.2.判断是否存在 if (count &gt; 0) &#123; // 用户已经购买过了 return Result.fail(&quot;用户已经购买过一次！&quot;); &#125; //6，扣减库存 boolean success = seckillVoucherService.update() .setSql(&quot;stock= stock -1&quot;) .eq(&quot;voucher_id&quot;, voucherId).gt(&quot;stock&quot;,0).update(); if (!success) &#123; //扣减库存 return Result.fail(&quot;库存不足！&quot;); &#125; //7.创建订单 VoucherOrder voucherOrder = new VoucherOrder(); // 7.1.订单id long orderId = redisIdWorker.nextId(&quot;order&quot;); voucherOrder.setId(orderId); voucherOrder.setUserId(userId); // 7.3.代金券id voucherOrder.setVoucherId(voucherId); save(voucherOrder); return Result.ok(orderId); &#125;&#125; 存在问题：现在的问题还是和之前一样，并发过来，查询数据库，都不存在优惠卷秒杀订单，所以我们还是需要加锁，但是乐观锁比较适合更新数据，更新数据时方便版本号更新，而现在是插入订单数据，乐观锁用起来会不方便，所以我们需要使用悲观锁操作 这里其实合适用悲观锁我认为，因为一个人只能抢一张票，只有第一个线程获得锁插入订单之后，其他线程就失败就可以了 注意：在这里提到了非常多的问题，我们需要慢慢的来思考，首先我们的初始方案是封装了一个createVoucherOrder方法，同时为了确保他线程安全，在方法上添加了一把synchronized 锁 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.hmdp.service.impl;import com.hmdp.dto.Result;import com.hmdp.entity.SeckillVoucher;import com.hmdp.entity.VoucherOrder;import com.hmdp.mapper.VoucherOrderMapper;import com.hmdp.service.ISeckillVoucherService;import com.hmdp.service.IVoucherOrderService;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.hmdp.utils.RedisIdWorker;import com.hmdp.utils.UserHolder;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import javax.annotation.Resource;import java.time.LocalDateTime;/** * &lt;p&gt; * 服务实现类 * &lt;/p&gt; * * @author 虎哥 * @since 2021-12-22 */@Servicepublic class VoucherOrderServiceImpl extends ServiceImpl&lt;VoucherOrderMapper, VoucherOrder&gt; implements IVoucherOrderService &#123;@Resourceprivate ISeckillVoucherService seckillVoucherService;@Resourceprivate RedisIdWorker redisIdWorker; @Override public Result seckillVoucher(Long voucherId) &#123; // 1.查询优惠券 SeckillVoucher voucher = seckillVoucherService.getById(voucherId); // 2.判断秒杀是否开始 if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123; // 尚未开始 return Result.fail(&quot;秒杀尚未开始！&quot;); &#125; // 3.判断秒杀是否已经结束 if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123; // 尚未开始 return Result.fail(&quot;秒杀已经结束！&quot;); &#125; // 4.判断库存是否充足 if (voucher.getStock() &lt; 1) &#123; // 库存不足 return Result.fail(&quot;库存不足！&quot;); &#125; return createVoucherOrder(voucherId); &#125; @Transactional public synchronized Result createVoucherOrder(Long voucherId)&#123; // 5.一人一单逻辑 // 5.1.用户id Long userId = UserHolder.getUser().getId(); int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count(); // 5.2.判断是否存在 if (count &gt; 0) &#123; // 用户已经购买过了 return Result.fail(&quot;用户已经购买过一次！&quot;); &#125; //6，扣减库存 boolean success = seckillVoucherService.update() .setSql(&quot;stock= stock -1&quot;) .eq(&quot;voucher_id&quot;, voucherId).gt(&quot;stock&quot;,0).update(); if (!success) &#123; //扣减库存 return Result.fail(&quot;库存不足！&quot;); &#125; //7.创建订单 VoucherOrder voucherOrder = new VoucherOrder(); // 7.1.订单id long orderId = redisIdWorker.nextId(&quot;order&quot;); voucherOrder.setId(orderId); voucherOrder.setUserId(userId); // 7.3.代金券id voucherOrder.setVoucherId(voucherId); save(voucherOrder); return Result.ok(orderId); &#125; &#125; ，但是这样添加锁，锁的粒度太粗了，在使用锁过程中，控制锁粒度 是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会锁住，所以我们需要去控制锁的粒度，以下这段代码需要修改为：intern() 这个方法是从常量池中拿到和这个字符串对象内容一样的数据，如果我们直接使用userId.toString() 他拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法 123456789101112131415161718192021222324252627282930313233343536373839@Transactionalpublic Result createVoucherOrder(Long voucherId) &#123; // 5.一人一单逻辑 // 5.1.用户id Long userId = UserHolder.getUser().getId(); synchronized (userId.toString().intern()) &#123; //同一个id在一个时间只能有一个线程操作下面这些代码，如果只有userId.toString()那么即使userId相同，String对象也是不同的，所以用intern()能保证拿到的锁都是一个 int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count(); // 5.2.判断是否存在 if (count &gt; 0) &#123; // 用户已经购买过了 return Result.fail(&quot;用户已经购买过一次！&quot;); &#125; //6，扣减库存 boolean success = seckillVoucherService.update() .setSql(&quot;stock= stock -1&quot;) .eq(&quot;voucher_id&quot;, voucherId).gt(&quot;stock&quot;, 0).update(); if (!success) &#123; //扣减库存 return Result.fail(&quot;库存不足！&quot;); &#125; //7.创建订单 VoucherOrder voucherOrder = new VoucherOrder(); // 7.1.订单id long orderId = redisIdWorker.nextId(&quot;order&quot;); voucherOrder.setId(orderId); voucherOrder.setUserId(userId); // 7.3.代金券id voucherOrder.setVoucherId(voucherId); save(voucherOrder); return Result.ok(orderId); &#125;&#125; 但是以上代码还是存在问题，问题的原因在于当前方法被spring的事务控制，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放（当 synchronized{}中的内容执行完毕锁就会释放）也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题：如下： 在seckillVoucher 方法中，添加以下逻辑，这样就能保证事务的特性，同时也控制了锁的粒度 但是以上做法依然有问题，因为你调用的方法，其实是this.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务 下面两个操作是上面使用代理对象的前提 引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;&lt;/dependency&gt; 在启动类中加注解暴露代理对象 12345//暴露代理对象@EnableAspectJAutoProxy(exposeProxy = true)@MapperScan(&quot;com.hmdp.mapper&quot;)@SpringBootApplicationpublic class HmDianPingApplication &#123; 3.7 集群环境下的并发问题通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。 1、我们将服务启动两份，端口分别为8081和8082： 2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡： ​ 修改nginx.conf,配置这个集群环境 12345678910111213141516171819202122232425location /api &#123; default_type application/json; #internal; keepalive_timeout 30s; keepalive_requests 1000; #支持keep-alive proxy_http_version 1.1; rewrite /api(/.*) $1 break; proxy_pass_request_headers on; #more_clear_input_headers Accept-Encoding; proxy_next_upstream error timeout; #proxy_pass http://127.0.0.1:8081; proxy_pass http://backend; &#125; &#125; upstream backend &#123; server 127.0.0.1:8081 max_fails=5 fail_timeout=10s weight=1; server 127.0.0.1:8090 max_fails=5 fail_timeout=10s weight=1; &#125; 具体操作(略) 有关锁失效原因分析 由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程1和线程3无法实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。 4、分布式锁4.1 、基本原理和实现方式对比分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。 分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路 核心是能让多个jvm中的线程，共用一个监视器 那么分布式锁他应该满足一些什么样的条件呢？ 可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思 互斥：互斥是分布式锁的最基本的条件，使得程序串行执行 高可用：程序不易崩溃，时时刻刻都保证较高的可用性 高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能 安全性：安全也是程序中必不可少的一环 常见的分布式锁有三种 Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见 Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁 Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，由于本套视频并不讲解zookeeper的原理和分布式锁的实现，所以不过多阐述 如果服务出现问题，不能释放锁，redis可以通过设置key的超时时间来进行一个兜底 4.2 、Redis分布式锁的实现核心思路实现分布式锁时需要实现的两个基本方法： 获取锁： 互斥：确保只能有一个线程获取锁 非阻塞：尝试一次，成功返回true，失败返回false SET lock thread1 NX EX 10 NX就是setnx只有lock不存在才能set,EX就是设置过期时间 拿不到锁：有两种结果：1.直接返回一个结果，这个是非阻塞式 ​ 2.一直等待，这个是阻塞式 ​ 我们下面实现的是如果获取不到锁就返回一个值非阻塞式 释放锁： 手动释放 超时释放：获取锁时添加一个超时时间 如果服务出现问题，不能释放锁，redis可以通过设置key的超时时间来进行一个兜底 核心思路： 我们利用redis 的setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可 4.3 实现分布式锁版本一 加锁逻辑 锁的基本接口 SimpleRedisLock 利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性 设置key的名称要根据业务来设置，因为总不能不同的业务设置的是同一个锁吧 12345678910private static final String KEY_PREFIX=&quot;lock:&quot;@Overridepublic boolean tryLock(long timeoutSec) &#123; // 获取线程标示 String threadId = Thread.currentThread().getId() // 获取锁 Boolean success = stringRedisTemplate.opsForValue() .setIfAbsent(KEY_PREFIX + name, threadId + &quot;&quot;, timeoutSec, TimeUnit.SECONDS); return Boolean.TRUE.equals(success);&#125; 释放锁逻辑 SimpleRedisLock 释放锁，防止删除别人的锁 1234public void unlock() &#123; //通过del删除锁 stringRedisTemplate.delete(KEY_PREFIX + name);&#125; 获取锁和释放锁的API，和上面俩一样 暂时获取锁的时候key的value中内容存储什么无所谓，但是下面会说必须是当前线程标识符+UUID的原因 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.hmdp.utils;import org.springframework.data.redis.core.StringRedisTemplate;import javax.annotation.Resource;import java.util.concurrent.TimeUnit;public class SimpleRedisLock implements ILock &#123; private StringRedisTemplate stringRedisTemplate; private String name; private static final String KEY_PREFIX=&quot;lock&quot;; public SimpleRedisLock(StringRedisTemplate stringRedisTemplate, String name) &#123; this.stringRedisTemplate = stringRedisTemplate; this.name = name; &#125; @Override public boolean tryLock(long timeoutSect) &#123; //key String key=KEY_PREFIX+name; //value //这个是线程id，每一个线程是唯一的标识符 long threadId=Thread.currentThread().getId(); //获取锁,这个只有key不存在的时候才能成功 Boolean success=stringRedisTemplate.opsForValue().setIfAbsent(key,threadId+&quot;&quot;,timeoutSect, TimeUnit.SECONDS); //直接返回success会有一个自动拆箱过程 //所以通过这种方式 return Boolean.TRUE.equals(success); &#125; @Override public void unlock() &#123; //删除key stringRedisTemplate.delete(KEY_PREFIX+name); &#125;&#125; 修改业务代码 12345678910111213141516171819202122232425262728293031323334353637383940@Override public Result seckillVoucher(Long voucherId) &#123; // 1.查询优惠券 SeckillVoucher voucher = seckillVoucherService.getById(voucherId); // 2.判断秒杀是否开始 if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123; // 尚未开始 return Result.fail(&quot;秒杀尚未开始！&quot;); &#125; // 3.判断秒杀是否已经结束 if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123; // 尚未开始 return Result.fail(&quot;秒杀已经结束！&quot;); &#125; // 4.判断库存是否充足 if (voucher.getStock() &lt; 1) &#123; // 库存不足 return Result.fail(&quot;库存不足！&quot;); &#125; Long userId = UserHolder.getUser().getId(); //同一个用户需要加锁，就是同一个用户对于这个买票要上锁，不同用户就不用上锁，所以key中要有userId //创建锁对象(新增代码) SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate); //获取锁对象 boolean isLock = lock.tryLock(1200);//加锁失败 if (!isLock) &#123; return Result.fail(&quot;不允许重复下单&quot;); &#125; try &#123; //获取代理对象(事务) IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy(); return proxy.createVoucherOrder(voucherId); &#125; finally &#123; //释放锁 lock.unlock(); &#125; &#125; 4.4 Redis分布式锁误删情况说明逻辑说明： 持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明,这个时候线程3再进来又能获得锁然后执行业务，现在就有线程2和线程3两个线程同时在执行任务 解决方案：解决方案就是在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。 4.5 解决Redis分布式锁误删问题需求：修改之前的分布式锁实现，满足：在获取锁时存入线程标示（可以用UUID表示）在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致 如果一致则释放锁 如果不一致则不释放锁 核心逻辑：在存入锁时，放入自己线程的标识，在删除锁时，判断当前这把锁的标识是不是自己存入的，如果是，则进行删除，如果不是，则不进行删除。 具体代码如下：加锁 标识是UUID+线程的标识，因为如果只用线程标识，那么如果tomcat集群，多个jvm分别维护多个标识会有重复的 12345678910private static final String ID_PREFIX = UUID.randomUUID().toString(true) + &quot;-&quot;;@Overridepublic boolean tryLock(long timeoutSec) &#123; // 获取线程标示 String threadId = ID_PREFIX + Thread.currentThread().getId(); // 获取锁 Boolean success = stringRedisTemplate.opsForValue() .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS); return Boolean.TRUE.equals(success);&#125; 释放锁 1234567891011public void unlock() &#123; // 获取线程标示 String threadId = ID_PREFIX + Thread.currentThread().getId(); // 获取锁中的标示 String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name); // 判断标示是否一致 if(threadId.equals(id)) &#123; // 释放锁 stringRedisTemplate.delete(KEY_PREFIX + name); &#125;&#125; SimpleRedisLock 1234567891011121314151617181920212223242526272829303132333435//线程的标识前缀private static final String ID_PREFIX= UUID.randomUUID().toString(true)+&quot;-&quot;;@Overridepublic boolean tryLock(long timeoutSect) &#123; //key String key=KEY_PREFIX+name; //value String threadId=ID_PREFIX+Thread.currentThread().getId(); //获取锁,这个只有key不存在的时候才能成功 Boolean success=stringRedisTemplate.opsForValue().setIfAbsent(key,threadId,timeoutSect, TimeUnit.SECONDS); //直接返回success会有一个自动拆箱过程 //所以通过这种方式 return Boolean.TRUE.equals(success);&#125;@Overridepublic void unlock() &#123; //获取线程标识 String threadId=ID_PREFIX+Thread.currentThread().getId(); String id= stringRedisTemplate.opsForValue().get(KEY_PREFIX+name); if(threadId.equals(id))&#123; //释放锁 //删除key stringRedisTemplate.delete(KEY_PREFIX+name); &#125;&#125; 有关代码实操说明： 在我们修改完此处代码后，我们重启工程，然后启动两个线程，第一个线程持有锁后，手动释放锁，第二个线程 此时进入到锁内部，再放行第一个线程，此时第一个线程由于锁的value值并非是自己，所以不能释放锁，也就无法删除别人的锁，此时第二个线程能够正确释放锁，通过这个案例初步说明我们解决了锁误删的问题。 4.6 分布式锁的原子性问题更为极端的误删逻辑说明： 线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁（因为垃圾回收这个时候线程1阻塞了），正好此时他的锁到期了，那么此时线程2进来，线程2顺利的拿到锁执行业务员，然后线程1的阻塞结束了，线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，但是他删除的锁其实是线程2的，相当于条件判断并没有起到作用，然后线程3又顺利拿到锁执行业务，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生， 最主要的原因是判断标识相同和删除锁是两个动作，我们必须确保判断标识相同和删除锁两个动作是原子性的 4.7 Lua脚本解决多条命令原子性问题Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站：https://www.runoob.com/lua/lua-tutorial.html，这里重点介绍Redis提供的调用函数，我们可以使用lua去操作redis，又能保证他的原子性，这样就可以实现拿锁比锁删锁是一个原子性动作了，作为Java程序员这一块并不作一个简单要求，并不需要大家过于精通，只需要知道他有什么作用即可。 这里重点介绍Redis提供的调用函数，语法如下： 1redis.call(&#x27;命令名称&#x27;, &#x27;key&#x27;, &#x27;其它参数&#x27;, ...) 例如，我们要执行set name jack，则脚本是这样： 12# 执行 set name jackredis.call(&#x27;set&#x27;, &#x27;name&#x27;, &#x27;jack&#x27;) 例如，我们要先执行set name Rose，再执行get name，则脚本如下： 123456# 先执行 set name jackredis.call(&#x27;set&#x27;, &#x27;name&#x27;, &#x27;Rose&#x27;)# 再执行 get namelocal name = redis.call(&#x27;get&#x27;, &#x27;name&#x27;)# 返回return name 写好脚本以后，需要用Redis命令来调用脚本，调用脚本的常见命令如下： 例如，我们要执行 redis.call(‘set’, ‘name’, ‘jack’) 这个脚本，语法如下： 后面跟着一个0就说明这个脚本是无参的，跟着1就说明脚本有1个参数 如果脚本中的key、value不想写死，可以作为参数传递。key类型参数会放入KEYS数组，其它参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些参数： 后面数字代表key类型参数的个数，就是说，如果这个数字是1，则这个数字后面的一个参数为key放进keys数组中，并且keys数组是以1索引开始的，把其他参数放进ARGV数组中，也是以1为第一个参数的索引 接下来我们来回一下我们释放锁的逻辑： 释放锁的业务流程是这样的 ​ 1、获取锁中的线程标示 ​ 2、判断是否与指定的标示（当前线程标示）一致 ​ 3、如果一致则释放锁（删除） ​ 4、如果不一致则什么都不做 如果用Lua脚本来表示则是这样的： 最终我们操作redis的拿锁比锁删锁的lua脚本就会变成这样 12345678-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示-- 获取锁中的标示，判断是否与当前线程标示一致if (redis.call(&#x27;GET&#x27;, KEYS[1]) == ARGV[1]) then -- 一致，则删除锁 return redis.call(&#x27;DEL&#x27;, KEYS[1])end-- 不一致，则直接返回return 0 4.8 利用Java代码调用Lua脚本改造分布式锁lua脚本本身并不需要大家花费太多时间去研究，只需要知道如何调用，大致是什么意思即可，所以在笔记中并不会详细的去解释这些lua表达式的含义。 我们的RedisTemplate中，可以利用execute方法去执行lua脚本，参数对应关系就如下图股 这个script就是lua脚本，key是key参数，arg是argv参数，execute方法不用加number因为list存储的key就能知道key的数量 Java代码 123456789101112131415private static final DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT; static &#123; UNLOCK_SCRIPT = new DefaultRedisScript&lt;&gt;(); UNLOCK_SCRIPT.setLocation(new ClassPathResource(&quot;unlock.lua&quot;)); UNLOCK_SCRIPT.setResultType(Long.class); &#125;public void unlock() &#123; // 调用lua脚本 stringRedisTemplate.execute( UNLOCK_SCRIPT, Collections.singletonList(KEY_PREFIX + name), ID_PREFIX + Thread.currentThread().getId());&#125;经过以上代码改造后，我们就能够实现 拿锁比锁删锁的原子性动作了~ 放在resources文件夹下的lua脚本 1234if(redis.call(&#x27;get&#x27;,KEYS[1])==ARGV[1]) then return redis.call(&#x27;del&#x27;,KEYS[1])endreturn 0 修改SimpleRedislock里面的unlock方法 12345678910111213141516171819202122//初始化lua脚本，static块和static属性类加载的时候就赋值调用了，且staic块中的内容只在类加载的时候执行一次，而普通初始化块中的内容每次创建对象都会执行 private static final DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT; static&#123; UNLOCK_SCRIPT=new DefaultRedisScript&lt;&gt;(); //指定lua脚本的位置，ClassPathResource里的参数就是在resources文件下找 UNLOCK_SCRIPT.setLocation(new ClassPathResource(&quot;unlock.lua&quot;)); //配返回值 UNLOCK_SCRIPT.setResultType(Long.class); &#125; @Override public void unlock()&#123; //传key和arvg的参数 stringRedisTemplate.execute( UNLOCK_SCRIPT, //这个参数要求是集合，这个方法能生成简单集合 Collections.singletonList(KEY_PREFIX+name), ID_PREFIX+Thread.currentThread().getId());//调用lua脚本 &#125; 小总结： 基于Redis的分布式锁实现思路： 利用set nx ex获取锁，并设置过期时间，保存线程标示 释放锁时先判断线程标示是否与自己一致，一致则删除锁 特性： 利用set nx满足互斥性 利用set ex保证故障时锁依然能释放，避免死锁，提高安全性 利用Redis集群保证高可用和高并发特性 笔者总结：我们一路走来，利用添加过期时间，防止死锁问题的发生，但是有了过期时间之后，可能出现误删别人锁的问题，这个问题我们开始是利用删之前 通过拿锁，比锁，删锁这个逻辑来解决的，也就是删之前判断一下当前这把锁是否是属于自己的，但是现在还有原子性问题，也就是我们没法保证拿锁比锁删锁是一个原子性的动作，最后通过lua表达式来解决这个问题 但是目前还剩下一个问题锁不住，什么是锁不住呢，你想一想，如果当过期时间到了之后，我们可以给他续期一下，比如续个30s，就好像是网吧上网， 网费到了之后，然后说，来，网管，再给我来10块的，是不是后边的问题都不会发生了，那么续期问题怎么解决呢，可以依赖于我们接下来要学习redission啦 测试逻辑： 第一个线程进来，得到了锁，手动删除锁，模拟锁超时了，其他线程会执行lua来抢锁，当第一天线程利用lua删除锁时，lua能保证他不能删除他的锁，第二个线程删除锁时，利用lua同样可以保证不会删除别人的锁，同时还能保证原子性。 5、分布式锁-redission5.1 分布式锁-redission功能介绍基于setnx实现的分布式锁存在下面的问题： 重入问题：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。 不可重试：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。 超时释放：我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患 业务还没执行完，锁就过期了，其他线程也会获得这个锁，执行同样的业务，就容易出现问题了 主从一致性： 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，从就会变成主，但是从的标识还没有被拿到，就会出现多个线程拿到锁的问题。 那么什么是Redission呢 Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。 Redission提供了分布式锁的多种多样的功能 5.2 分布式锁-Redission快速入门引入依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson&lt;/artifactId&gt; &lt;version&gt;3.13.6&lt;/version&gt;&lt;/dependency&gt; 配置Redisson客户端： 123456789101112131415@Configurationpublic class RedissonConfig &#123; @Bean public RedissonClient redissonClient()&#123; // 配置 Config config = new Config(); //添加了redis地址，这里添加了单点的地址，也可以使用config.useClusterServers()添加集群地址 config.useSingleServer().setAddress(&quot;redis://39.105.5.187:6379&quot;) .setPassword(&quot;zhao1129&quot;); // 创建RedissonClient对象 return Redisson.create(config); &#125;&#125; 如何使用Redission的分布式锁 1234567891011121314151617181920212223242526@Resourceprivate RedissionClient redissonClient;@Testvoid testRedisson() throws Exception&#123; //获取锁(可重入)，指定锁的名称 //这个参数是存储的key的名称 RLock lock = redissonClient.getLock(&quot;anyLock&quot;); //尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位 //没有第一个参数默认就是不等待， //这个方法是要抛出异常的 boolean isLock = lock.tryLock(1L,10L,TimeUnit.SECONDS); //判断获取锁成功 if(isLock)&#123; try&#123; System.out.println(&quot;执行业务&quot;); &#125;finally&#123; //释放锁 lock.unlock(); &#125; &#125; &#125; 在 VoucherOrderServiceImpl 注入RedissonClient 123456789101112131415161718192021222324252627282930313233343536373839404142@Resourceprivate RedissonClient redissonClient;@Overridepublic Result seckillVoucher(Long voucherId) &#123; // 1.查询优惠券 SeckillVoucher voucher = seckillVoucherService.getById(voucherId); // 2.判断秒杀是否开始 if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123; // 尚未开始 return Result.fail(&quot;秒杀尚未开始！&quot;); &#125; // 3.判断秒杀是否已经结束 if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123; // 尚未开始 return Result.fail(&quot;秒杀已经结束！&quot;); &#125; // 4.判断库存是否充足 if (voucher.getStock() &lt; 1) &#123; // 库存不足 return Result.fail(&quot;库存不足！&quot;); &#125; Long userId = UserHolder.getUser().getId(); //创建锁对象 这个代码不用了，因为我们现在要使用分布式锁 //SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate); RLock lock = redissonClient.getLock(&quot;lock:order:&quot; + userId); //获取锁对象 boolean isLock = lock.tryLock(); //加锁失败 if (!isLock) &#123; return Result.fail(&quot;不允许重复下单&quot;); &#125; try &#123; //获取代理对象(事务) IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy(); return proxy.createVoucherOrder(voucherId); &#125; finally &#123; //释放锁 lock.unlock(); &#125; &#125; 和上面那个方法一样 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Overridepublic Result seckillVoucher(Long voucherId) throws InterruptedException &#123; // 1.查询优惠券 SeckillVoucher voucher = seckillVoucherService.getById(voucherId); // 2.判断秒杀是否开始 if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123; // 尚未开始 return Result.fail(&quot;秒杀尚未开始！&quot;); &#125; // 3.判断秒杀是否已经结束 if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123; // 尚未开始 return Result.fail(&quot;秒杀已经结束！&quot;); &#125; // 4.判断库存是否充足 if (voucher.getStock() &lt; 1) &#123; // 库存不足 return Result.fail(&quot;库存不足！&quot;); &#125; Long userId = UserHolder.getUser().getId(); //同一个用户需要加锁，就是同一个用户对于这个买票要上锁，不同用户就不用上锁 //获取锁对象 //SimpleRedisLock simpleRedisLock = new SimpleRedisLock(stringRedisTemplate, &quot;order:&quot; + userId); //尝试获取锁 //这个参数是存储的key的名称 RLock anylock = redissonClient.getLock(&quot;lock:order:&quot;+userId); boolean isLock = anylock.tryLock(); //如果没有获取到锁，说明已经有自己的请求获取到锁了，直接返回错误信息即可 if (!isLock) &#123; return Result.ok(&quot;不能重复下单&quot;); &#125; try &#123; IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy(); //即使return后方法结束，finally还是可以执行完毕 return proxy.createVoucherOrder(voucherId); &#125;finally&#123; //执行完毕之后就会释放锁 anylock.unlock(); &#125;&#125; 5.3 分布式锁-redission可重入锁原理在Lock锁中，他是借助于底层的一个voaltile的一个state变量来记录重入的状态的，比如当前没有人持有这把锁，那么state&#x3D;0，假如有人持有这把锁，那么state&#x3D;1，如果持有这把锁的人再次持有这把锁，那么state就会+1 ，如果是对于synchronized而言，他在c语言代码中会有一个count，原理和state类似，也是重入一次就加一，释放一次就-1 ，直到减少成0 时，表示当前这把锁没有被人持有。 在redission中，我们的也支持支持可重入锁 在分布式锁中，他采用hash结构用来存储锁，其中大key表示表示这把锁是否存在，用小key表示当前这把锁被哪个线程持有，所以接下来我们一起分析一下当前的这个lua表达式 这个地方一共有3个参数 KEYS[1] ： 锁名称 ARGV[1]： 锁失效时间 ARGV[2]： id + “:” + threadId; 锁的小key exists: 判断数据是否存在 name：是lock是否存在,如果&#x3D;&#x3D;0，就表示当前这把锁不存在 redis.call(‘hset’, KEYS[1], ARGV[2], 1);此时他就开始往redis里边去写数据 ，写成一个hash结构 Lock{ ​ id + “:” + threadId : 1 } 如果当前这把锁存在，则第一个条件不满足，再判断 redis.call(‘hexists’, KEYS[1], ARGV[2]) &#x3D;&#x3D; 1 此时需要通过大key+小key判断当前这把锁是否是属于自己的，如果是自己的，则进行 redis.call(‘hincrby’, KEYS[1], ARGV[2], 1) 将当前这个锁的value进行+1 ，redis.call(‘pexpire’, KEYS[1], ARGV[1]); 然后再对其设置过期时间，如果以上两个条件都不满足，则表示当前这把锁抢锁失败，最后返回pttl，即为当前这把锁的失效时间 如果小伙帮们看了前边的源码， 你会发现他会去判断当前这个方法的返回值是否为null，如果是null，则对应则前两个if对应的条件，退出抢锁逻辑，如果返回的不是null，即走了第三个分支，在源码处会进行while(true)的自旋抢锁。 这是获取锁的lua脚本 1234567891011121314//自己的锁第一次被拿&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot; + &quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot; + &quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot; + &quot;return nil; &quot; + &quot;end; &quot; +//自己的锁被拿到过，然后自己又拿 &quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot; + &quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot; + &quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot; + &quot;return nil; &quot; + &quot;end; &quot; +//没拿到自己的锁，自己的锁可能是过期了 &quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot; 释放锁的lua脚本 12345678910111213&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[3]) == 0) then &quot; + &quot;return nil;&quot; + &quot;end; &quot; + &quot;local counter = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[3], -1); &quot; + &quot;if (counter &gt; 0) then &quot; + &quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]); &quot; + &quot;return 0; &quot; + &quot;else &quot; + &quot;redis.call(&#x27;del&#x27;, KEYS[1]); &quot; + &quot;redis.call(&#x27;publish&#x27;, KEYS[2], ARGV[1]); &quot; + &quot;return 1; &quot; + &quot;end; &quot; + &quot;return nil;&quot;, 5.4 分布式锁-redission锁重试和WatchDog机制说明：由于课程中已经说明了有关tryLock的源码解析以及其看门狗原理，所以笔者在这里给大家分析lock()方法的源码解析，希望大家在学习过程中，能够掌握更多的知识 抢锁过程中，获得当前线程，通过tryAcquire进行抢锁，该抢锁逻辑和之前逻辑相同 1、先判断当前这把锁是否存在，如果不存在，插入一把锁，返回null 2、判断当前这把锁是否是属于当前线程，如果是，则返回null 所以如果返回是null，则代表着当前这哥们已经抢锁完毕，或者可重入完毕，但是如果以上两个条件都不满足，则进入到第三个条件，返回的是锁的失效时间，同学们可以自行往下翻一点点，你能发现有个while( true) 再次进行tryAcquire进行抢锁 123456long threadId = Thread.currentThread().getId();Long ttl = tryAcquire(-1, leaseTime, unit, threadId);// lock acquiredif (ttl == null) &#123; return;&#125; 接下来会有一个条件分支，因为lock方法有重载方法，一个是带参数，一个是不带参数，如果带带参数传入的值是-1，如果传入参数，则leaseTime是他本身，所以如果传入了参数，此时leaseTime !&#x3D; -1 则会进去抢锁，抢锁的逻辑就是之前说的那三个逻辑 123if (leaseTime != -1) &#123; return tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);&#125; 如果是没有传入时间，则此时也会进行抢锁， 而且抢锁时间是默认看门狗时间 commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout() ttlRemainingFuture.onComplete((ttlRemaining, e) 这句话相当于对以上抢锁进行了监听，也就是说当上边抢锁完毕后，此方法会被调用，具体调用的逻辑就是去后台开启一个线程，进行续约逻辑，也就是看门狗线程 1234567891011121314RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(waitTime, commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123; if (e != null) &#123; return; &#125; // lock acquired if (ttlRemaining == null) &#123; scheduleExpirationRenewal(threadId); &#125;&#125;);return ttlRemainingFuture; 此逻辑就是续约逻辑，注意看commandExecutor.getConnectionManager().newTimeout（） 此方法 Method( new TimerTask() {},参数2 ，参数3 ) 指的是：通过参数2，参数3 去描述什么时候去做参数1的事情，现在的情况是：10s之后去做参数一的事情 因为锁的失效时间是30s，当10s之后，此时这个timeTask 就触发了，他就去进行续约，把当前这把锁续约成30s，如果操作成功，那么此时就会递归调用自己，再重新设置一个timeTask()，于是再过10s后又再设置一个timerTask，完成不停的续约 那么大家可以想一想，假设我们的线程出现了宕机他还会续约吗？当然不会，因为没有人再去调用renewExpiration这个方法，所以等到时间之后自然就释放了。 1234567891011121314151617181920212223242526272829303132333435private void renewExpiration() &#123; ExpirationEntry ee = EXPIRATION_RENEWAL_MAP.get(getEntryName()); if (ee == null) &#123; return; &#125; Timeout task = commandExecutor.getConnectionManager().newTimeout(new TimerTask() &#123; @Override public void run(Timeout timeout) throws Exception &#123; ExpirationEntry ent = EXPIRATION_RENEWAL_MAP.get(getEntryName()); if (ent == null) &#123; return; &#125; Long threadId = ent.getFirstThreadId(); if (threadId == null) &#123; return; &#125; RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId); future.onComplete((res, e) -&gt; &#123; if (e != null) &#123; log.error(&quot;Can&#x27;t update lock &quot; + getName() + &quot; expiration&quot;, e); return; &#125; if (res) &#123; // reschedule itself renewExpiration(); &#125; &#125;); &#125; &#125;, internalLockLeaseTime / 3, TimeUnit.MILLISECONDS); ee.setTimeout(task);&#125; 5.5 分布式锁-redission锁的MutiLock原理为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例 此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。 为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。 那么MutiLock 加锁原理是什么呢？笔者画了一幅图来说明 当我们去设置了多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁，但是会有一个总共的加锁时间，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功， 那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试. 6、秒杀优化6.1 秒杀优化-异步秒杀思路我们来回顾一下下单流程 当用户发起请求，此时会请求nginx，nginx会访问到tomcat，而tomcat中的程序，会进行串行操作，分成如下几个步骤 1、查询优惠卷 2、判断秒杀库存是否足够 3、查询订单 4、校验是否是一人一单 5、扣减库存 6、创建订单 在这六步操作中，又有很多操作是要去操作数据库的，而且还是一个线程串行执行， 这样就会导致我们的程序执行的很慢，所以我们需要异步程序执行，那么如何加速呢？ 在这里笔者想给大家分享一下课程内没有的思路，看看有没有小伙伴这么想，比如，我们可以不可以使用异步编排来做，或者说我开启N多线程，N多个线程，一个线程执行查询优惠卷，一个执行判断扣减库存，一个去创建订单等等，然后再统一做返回，这种做法和课程中有哪种好呢？答案是课程中的好，因为如果你采用我刚说的方式，如果访问的人很多，那么线程池中的线程可能一下子就被消耗完了，而且你使用上述方案，最大的特点在于，你觉得时效性会非常重要，但是你想想是吗？并不是，比如我只要确定他能做这件事，然后我后边慢慢做就可以了，我并不需要他一口气做完这件事，所以我们应当采用的是课程中，类似消息队列的方式来完成我们的需求，而不是使用线程池或者是异步编排的方式来完成这个需求 这个大概就是异步的思想 判断是否有秒杀资格的时间比较短，可以一个线程判断是否有秒杀资格，完成之后，再重开一个线程减库存和创建订单，这种对数据库的操作用时就会比较长，然后那个秒杀资格判断线程就可以再去判断下一个用户是否有资格了 优化方案：我们将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程慢慢的去执行queue里边的消息，这样程序不就超级快了吗？而且也不用担心线程池消耗殆尽的问题，因为这里我们的程序中并没有手动使用任何线程池，当然这里边有两个难点 第一个难点是我们怎么在redis中去快速校验一人一单，还有库存判断 第二个难点是由于我们校验和tomct下单是两个线程，那么我们如何知道到底哪个单他最后是否成功，或者是下单完成，为了完成这件事我们在redis操作完之后，我们会将一些信息返回给前端，同时也会把这些信息丢到异步queue中去，后续操作中，可以通过这个id来查询我们tomcat中的下单逻辑是否完成了。 我们现在来看看整体思路：当用户下单之后，判断库存是否充足只需要导redis中去根据key找对应的value是否大于0即可，如果不充足，则直接结束，如果充足，继续在redis中判断用户是否可以下单，如果set集合中没有这条数据，说明他可以下单，如果set集合中没有这条记录，则将userId和优惠卷存入到redis中，并且返回0，整个过程需要保证是原子性的，我们可以使用lua来操作 当以上判断逻辑走完之后，我们可以判断当前redis中返回的结果是否是0 ，如果是0，则表示可以下单，则将之前说的信息存入到到queue中去，然后返回，然后再来个线程异步的下单，前端可以通过返回的订单id来判断是否下单成功。 把stock的数量存放在redis中，把操作过stock的用户的id存储在这个order:vid:7的key的set中，来实现一人一单的功能 如果lua脚本返回0表示用户可以下单再把用户id，优惠卷id和订单id加入到消息队列中 6.2 秒杀优化-Redis完成秒杀资格判断需求： 新增秒杀优惠券的同时，将优惠券信息保存到Redis中 基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功 前面这两个步骤，没有涉及到数据库所以会完成的很快，所以下单这个功能，就会完成的很快，下单完成但数据库内的操作不一定完成 如果抢购成功，将优惠券id和用户id封装后存入阻塞队列 开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能 VoucherServiceImpl 1234567891011121314151617@Override@Transactionalpublic void addSeckillVoucher(Voucher voucher) &#123; // 保存优惠券 save(voucher); // 保存秒杀信息 SeckillVoucher seckillVoucher = new SeckillVoucher(); seckillVoucher.setVoucherId(voucher.getId()); seckillVoucher.setStock(voucher.getStock()); seckillVoucher.setBeginTime(voucher.getBeginTime()); seckillVoucher.setEndTime(voucher.getEndTime()); seckillVoucherService.save(seckillVoucher); // 保存秒杀库存到Redis中 //SECKILL_STOCK_KEY 这个变量定义在RedisConstans中 //private static final String SECKILL_STOCK_KEY =&quot;seckill:stock:&quot; stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());&#125; lua表达式 123456789101112131415161718192021222324252627282930313233343536373839-- 1.参数列表-- 1.1.优惠券idlocal voucherId = ARGV[1]-- 1.2.用户idlocal userId = ARGV[2]-- 1.3.订单idlocal orderId = ARGV[3]-- 2.数据key-- 2.1.库存key--..是拼接字符串的意思local stockKey = &#x27;seckill:stock:&#x27; .. voucherId-- 2.2.订单key--这个key是用来存储买过这个优惠卷的用户id的local orderKey = &#x27;seckill:order:&#x27; .. voucherId-- 3.脚本业务-- 3.1.判断库存是否充足 get stockKey--用get得到的是字符串，tonumber是给他转成数字类型if(tonumber(redis.call(&#x27;get&#x27;, stockKey)) &lt;= 0) then -- 3.2.库存不足，返回1 return 1end-- 3.2.判断用户是否下单 SISMEMBER orderKey userId--判断userId是否是这个set集合中的成员if(redis.call(&#x27;sismember&#x27;, orderKey, userId) == 1) then -- 3.3.存在，说明是重复下单，返回2 return 2end-- 3.4.扣库存 incrby stockKey -1redis.call(&#x27;incrby&#x27;, stockKey, -1)-- 3.5.下单（保存用户）sadd orderKey userId--把自己的id保存在set集合中redis.call(&#x27;sadd&#x27;, orderKey, userId)return 0--暂时先不用这个3.6-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...--redis.call(&#x27;xadd&#x27;, &#x27;stream.orders&#x27;, &#x27;*&#x27;, &#x27;userId&#x27;, userId, &#x27;voucherId&#x27;, voucherId, &#x27;id&#x27;, orderId) 当以上lua表达式执行完毕后，剩下的就是根据步骤3,4来执行我们接下来的任务了 VoucherOrderServiceImpl 12345678910111213141516171819202122232425262728293031323334353637//初始化lua脚本，static块和static属性类加载的时候就赋值调用了，且staic块中的内容只在类加载的时候执行一次，而普通初始化块中的内容每次创建对象都会执行 private static final DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT; static&#123; SECKILL_SCRIPT=new DefaultRedisScript&lt;&gt;(); //指定lua脚本的位置，ClassPathResource里的参数就是在resources文件下找 SECKILL_SCRIPT.setLocation(new ClassPathResource(&quot;seckill.lua&quot;)); //配返回值 SECKILL_SCRIPT.setResultType(Long.class); &#125; @Override public Result seckillVoucher(Long voucherId) throws InterruptedException &#123; //获取用户id Long userId = UserHolder.getUser().getId(); //执行lua脚本 Long result=stringRedisTemplate.execute( SECKILL_SCRIPT, //传了一个空集合 Collections.emptyList(), voucherId.toString(),userId.toString() ); //2.判断结果是否为0 //2.1不为零，没有购买资格 int result1 = result.intValue(); if(result1!=0)&#123; return Result.fail(result1==1?&quot;库存不足&quot;:&quot;不能重复下单&quot;); &#125; //2.2为零，有购买资格,把下单信息保存到阻塞队列 long orderId = redisIdWorker.nextId(&quot;order&quot;); //把订单id返回给客户 return Result.ok(orderId); &#125; 这个时候这个操作还是仅仅在redis那一端完成的，还没有对数据库进行操作，没有进行阻塞队列的操作 也就是仅仅完成了需求的前两个 新增秒杀优惠券的同时，将优惠券信息保存到Redis中 基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功 6.3 秒杀优化-基于阻塞队列实现秒杀优化VoucherOrderServiceImpl 修改下单动作，现在我们去下单时，是通过lua表达式去原子执行判断逻辑，如果判断我出来不为0 ，则要么是库存不足，要么是重复下单，返回错误信息，如果是0，则把下单的逻辑保存到队列中去，然后异步执行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205package com.hmdp.service.impl;import com.hmdp.dto.Result;import com.hmdp.entity.SeckillVoucher;import com.hmdp.entity.VoucherOrder;import com.hmdp.mapper.VoucherOrderMapper;import com.hmdp.service.ISeckillVoucherService;import com.hmdp.service.IVoucherOrderService;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.hmdp.utils.RedisIdWorker;import com.hmdp.utils.SimpleRedisLock;import com.hmdp.utils.UserHolder;import lombok.extern.slf4j.Slf4j;import org.redisson.api.RLock;import org.redisson.api.RedissonClient;import org.springframework.aop.framework.AopContext;import org.springframework.core.io.ClassPathResource;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.core.script.DefaultRedisScript;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import javax.annotation.PostConstruct;import javax.annotation.Resource;import java.time.LocalDateTime;import java.util.Collections;import java.util.concurrent.*;/** * &lt;p&gt; * 服务实现类 * &lt;/p&gt; * * @author 虎哥 * @since 2021-12-22 */@Service@Slf4jpublic class VoucherOrderServiceImpl extends ServiceImpl&lt;VoucherOrderMapper, VoucherOrder&gt; implements IVoucherOrderService &#123;@Resourceprivate ISeckillVoucherService seckillVoucherService;@Resourceprivate StringRedisTemplate stringRedisTemplate;@Resource private RedisIdWorker redisIdWorker; @Resource private RedissonClient redissonClient; //初始化lua脚本，static块和static属性类加载的时候就赋值调用了，且staic块中的内容只在类加载的时候执行一次，而普通初始化块中的内容每次创建对象都会执行 private static final DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT; static&#123; SECKILL_SCRIPT=new DefaultRedisScript&lt;&gt;(); //指定lua脚本的位置，ClassPathResource里的参数就是在resources文件下找 SECKILL_SCRIPT.setLocation(new ClassPathResource(&quot;seckill.lua&quot;)); //配返回值 SECKILL_SCRIPT.setResultType(Long.class); &#125; //阻塞队列，特点是当一个线程尝试从队列中获取元素的时候，如果没有元素这个线程就会被阻塞，只有有了元素才会被唤醒 private BlockingQueue&lt;VoucherOrder&gt; orderTasks=new ArrayBlockingQueue&lt;&gt;(1024*1024); //专门处理下单操作数据库的线程,这里是获取一个单线程 private static final ExecutorService SECKILL_ORDER_EXECUTOR= Executors.newSingleThreadExecutor(); @PostConstruct private void init()&#123; //让这个任务在类初始化完毕就会执行 SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler()); &#125; //这个任务应该在类初始化的时候都执行了 private class VoucherOrderHandler implements Runnable&#123; @Override public void run()&#123; while(true)&#123; try &#123; //1.获取队列中的订单信息 //这个take是阻塞含义，如果没有不会往下执行 VoucherOrder voucherOrder=orderTasks.take(); //2.创建订单 handleVoucherOrder(voucherOrder); &#125; catch (InterruptedException e) &#123; log.error(&quot;处理订单异常&quot;); &#125; &#125; &#125; &#125; public void handleVoucherOrder(VoucherOrder voucherOrder)&#123; //现在是多线程了从UserHolder里面是取不到userId了 //1.获取用户id Long userId=voucherOrder.getUserId(); //尝试获取锁 //这个参数是存储的key的名称 RLock anylock = redissonClient.getLock(&quot;lock:order:&quot;+userId); boolean isLock = anylock.tryLock(); //如果没有获取到锁，说明已经有自己的请求获取到锁了，直接返回错误信息即可 if (!isLock) &#123; log.error(&quot;不能重复下单&quot;); &#125; try &#123; //即使return后方法结束，finally还是可以执行完毕 proxy.createVoucherOrder(voucherOrder); &#125;finally&#123; //执行完毕之后就会释放锁 anylock.unlock(); &#125; &#125; private IVoucherOrderService proxy; @Override public Result seckillVoucher(Long voucherId) throws InterruptedException &#123; //获取用户id Long userId = UserHolder.getUser().getId(); //执行lua脚本 Long result=stringRedisTemplate.execute( SECKILL_SCRIPT, //传了一个空集合 Collections.emptyList(), voucherId.toString(),userId.toString() ); //2.判断结果是否为0 //2.1不为零，没有购买资格 int result1 = result.intValue(); if(result1!=0)&#123; return Result.fail(result1==1?&quot;库存不足&quot;:&quot;不能重复下单&quot;); &#125; //2.2为零，有购买资格,把下单信息保存到阻塞队列 long orderId = redisIdWorker.nextId(&quot;order&quot;); VoucherOrder voucherOrder = new VoucherOrder(); //订单id voucherOrder.setId(orderId); //用户id voucherOrder.setUserId(userId);// 7.3.代金券id //代金卷id voucherOrder.setVoucherId(voucherId); //把封装好的订单信息放到阻塞队列中 orderTasks.add(voucherOrder); //获取代理对象 //获取代理对象是基于ThreadLocal的，在handleVoucherOrder方法是在子线程中执行，子线程无法操作threadLocal所以放到父线程中来获取，子线程中使用即可 proxy = (IVoucherOrderService) AopContext.currentProxy(); //把订单id返回给客户 return Result.ok(orderId); &#125; //其实在这个方法中我们不必判断一人一单的操作，因为redis中已经弄好了，但保险起见还是搞上了 @Override @Transactional public void createVoucherOrder(VoucherOrder voucherOrder)&#123; // 5.一人一单逻辑 // 5.1.用户id Long userId = voucherOrder.getUserId(); //优惠卷id Long voucherId=voucherOrder.getVoucherId(); //订单id Long orderId=voucherOrder.getId(); int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count(); // 5.2.判断是否存在 if (count &gt; 0) &#123; // 用户已经购买过了 log.error(&quot;用户已经购买过了&quot;); &#125; else &#123;//6，扣减库存 boolean success = seckillVoucherService.update() .setSql(&quot;stock= stock -1&quot;) .eq(&quot;voucher_id&quot;, voucherId).gt(&quot;stock&quot;, 0).update(); if (!success) &#123; //扣减库存 log.error(&quot;库存不足&quot;); &#125; else &#123; //7.保存订单 save(voucherOrder); &#125; &#125; &#125;&#125; lua脚本 1234567891011121314151617181920212223242526272829303132333435-- 1.参数列表-- 1.1.优惠券idlocal voucherId = ARGV[1]-- 1.2.用户idlocal userId = ARGV[2]-- 1.3.订单idlocal orderId = ARGV[3]-- 2.数据key-- 2.1.库存key--..是拼接字符串的意思local stockKey = &#x27;seckill:stock:&#x27; .. voucherId-- 2.2.订单key--这个key是用来存储买过这个优惠卷的用户id的local orderKey = &#x27;seckill:order:&#x27; .. voucherId-- 3.脚本业务-- 3.1.判断库存是否充足 get stockKey--用get得到的是字符串，tonumber是给他转成数字类型if(tonumber(redis.call(&#x27;get&#x27;, stockKey)) &lt;= 0) then -- 3.2.库存不足，返回1 return 1end-- 3.2.判断用户是否下单 SISMEMBER orderKey userId--判断userId是否是这个set集合中的成员if(redis.call(&#x27;sismember&#x27;, orderKey, userId) == 1) then -- 3.3.存在，说明是重复下单，返回2 return 2end-- 3.4.扣库存 incrby stockKey -1redis.call(&#x27;incrby&#x27;, stockKey, -1)-- 3.5.下单（保存用户）sadd orderKey userId--把自己的id保存在set集合中redis.call(&#x27;sadd&#x27;, orderKey, userId)return 0 小总结： 秒杀业务的优化思路是什么？ 先利用Redis完成库存余量、一人一单判断，完成抢单业务 再将下单业务放入阻塞队列，利用独立线程异步下单 基于阻塞队列的异步秒杀存在哪些问题？ 内存限制问题，如果同一时间请求过多，jvm消息队列可能会超出上线 数据安全问题，如果出现宕机异常，阻塞队列中的任务会全部丢失 7、Redis消息队列7.1 Redis消息队列-认识消息队列什么是消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色： 消息队列：存储和管理消息，也被称为消息代理（Message Broker） 生产者：发送消息到消息队列 消费者：从消息队列获取消息并处理消息 使用队列的好处在于 解耦：所谓解耦，举一个生活中的例子就是：快递员(生产者)把快递放到快递柜里边(Message Queue)去，我们(消费者)从快递柜里边去拿东西，这就是一个异步，如果耦合，那么这个快递员相当于直接把快递交给你，这事固然好，但是万一你不在家，那么快递员就会一直等你，这就浪费了快递员的时间，所以这种思想在我们日常开发中，是非常有必要的。 这种场景在我们秒杀中就变成了：我们下单之后，利用redis去进行校验下单条件，再通过队列把消息发送出去，然后再启动一个线程去消费这个消息，完成解耦，同时也加快我们的响应速度。 这里我们可以使用一些现成的mq，比如kafka，rabbitmq等等，但是呢，如果没有安装mq，我们也可以直接使用redis提供的mq方案，降低我们的部署和学习成本。 7.2 Redis消息队列-基于List实现消息队列基于List结构模拟消息队列 消息队列（Message Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个双向链表，很容易模拟出队列效果。 队列是先进先出 队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。 基于List的消息队列有哪些优缺点？优点： 利用Redis存储，不受限于JVM内存上限 基于Redis的持久化机制，数据安全性有保证 可以满足消息有序性 缺点： 无法避免消息丢失，如果我从消息队列里取到一条消息，还没来得及处理我服务器就挂了，那消息就丢失了 只支持单消费者,一个消费者拿走了消息，其他消费者就拿不到了 7.3 Redis消息队列-基于PubSub的消息队列PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。 一个频道可以被多个消费者订阅 SUBSCRIBE channel [channel] ：订阅一个或多个频道 PUBLISH channel msg ：向一个频道发送消息 PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道 消费者退出之后，不能再收到退出的时候生产者发送的消息 基于PubSub的消息队列有哪些优缺点？优点： 采用发布订阅模型，支持多生产、多消费 缺点： 不支持数据持久化 无法避免消息丢失 消息堆积有上限，超出时数据丢失 7.4 Redis消息队列-基于Stream的消息队列Stream 是 Redis 5.0 引入的一种新数据类型，可以实现一个功能非常完善的消息队列。 发送消息的命令： key是队列的名称，第二个参数如果有值，就代表不自动创建 例如： 返回的是消息队列的唯一id 读取消息的方式之一：XREAD 例如，使用XREAD读取第一个消息： 在stream中这个消息你读出来之后它是不会删除的 XREAD阻塞方式，读取最新的消息： 在业务开发中，我们可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下 注意：当我们指定起始ID为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题 STREAM类型消息队列的XREAD命令特点： 消息可回溯，消息读完之后不消失随时可以看 一个消息可以被多个消费者读取 可以阻塞读取 有消息漏读的风险 7.5 Redis消息队列-基于Stream的消息队列-消费者组消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点： 第三个消息确认解决了拿到消息后宕机了，消息会消失的问题，确保所有的消息只要被拿到都会被消费 它是基于stream的，所以它处理完消息之后也不会删除，但是会哦那个pending-list中移除 创建消费者组：key：队列名称groupName：消费者组名称ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息MKSTREAM：队列不存在时自动创建队列其它常见命令： 删除指定的消费者组 1XGROUP DESTORY key groupName 给指定的消费者组添加消费者 1XGROUP CREATECONSUMER key groupname consumername 删除消费者组中的指定消费者 1XGROUP DELCONSUMER key groupname consumername 从消费者组读取消息： 1XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...] group：消费组名称 consumer：消费者名称，如果消费者不存在，会自动创建一个消费者 count：本次查询的最大数量 BLOCK milliseconds：当没有消息时最长等待时间 NOACK：无需手动ACK，获取到消息后自动确认，这个如果加上这个参数可能会出现消息漏读 STREAMS key：指定队列名称 ID：获取消息的起始ID： “&gt;”：从下一个未消费的消息开始，就是还没在pending-list中其它：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始，1即使从pending-list中第二个开始 思路就是：先用&gt;来把消息获取，这时候消息在pending-list中，然后再确认，消息从pending-list中删除，然后有些出现异常的就是在pending-list中但是没有确认，现在我们需要把&gt;换成0，这就是处理pending-list中的第一个消息 消费者监听消息的基本思路： STREAM类型消息队列的XREADGROUP命令特点： 消息可回溯 可以多消费者争抢消息，加快消费速度 可以阻塞读取 没有消息漏读的风险 有消息确认机制，保证消息至少被消费一次 最后我们来个小对比 7.6 基于Redis的Stream结构作为消息队列，实现异步秒杀下单需求： 创建一个Stream类型的消息队列，名为stream.orders xgroup create stream.orders g1 0 MKSTREAM 修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId 项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单\\ 修改lua表达式,新增3.6 123456789101112131415161718192021222324252627282930313233343536373839-- 1.参数列表-- 1.1.优惠券idlocal voucherId = ARGV[1]-- 1.2.用户idlocal userId = ARGV[2]-- 1.3.订单idlocal orderId = ARGV[3]-- 2.数据key-- 2.1.库存key--..是拼接字符串的意思local stockKey = &#x27;seckill:stock:&#x27; .. voucherId-- 2.2.订单key--这个key是用来存储买过这个优惠卷的用户id的local orderKey = &#x27;seckill:order:&#x27; .. voucherId-- 3.脚本业务-- 3.1.判断库存是否充足 get stockKey--用get得到的是字符串，tonumber是给他转成数字类型if(tonumber(redis.call(&#x27;get&#x27;, stockKey)) &lt;= 0) then -- 3.2.库存不足，返回1 return 1end-- 3.2.判断用户是否下单 SISMEMBER orderKey userId--判断userId是否是这个set集合中的成员if(redis.call(&#x27;sismember&#x27;, orderKey, userId) == 1) then -- 3.3.存在，说明是重复下单，返回2 return 2end-- 3.4.扣库存 incrby stockKey -1redis.call(&#x27;incrby&#x27;, stockKey, -1)-- 3.5.下单（保存用户）sadd orderKey userId--把自己的id保存在set集合中redis.call(&#x27;sadd&#x27;, orderKey, userId)--3.6发送消息到队列当中,XADD stream.orders * k1 v1 k2 v2--这里用最后一个参数叫id是因为voucherorder类中那个属性叫id，以后方便用redis.call(&#x27;xadd&#x27;,&#x27;stream.orders&#x27;,&#x27;*&#x27;,&#x27;userId&#x27;,userId,&#x27;voucherId&#x27;,voucherId,&#x27;id&#x27;,orderId);return 0 VoucherOrderServiceImpl 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220public class VoucherOrderServiceImpl extends ServiceImpl&lt;VoucherOrderMapper, VoucherOrder&gt; implements IVoucherOrderService &#123;@Resourceprivate ISeckillVoucherService seckillVoucherService;@Resourceprivate StringRedisTemplate stringRedisTemplate;@Resource private RedisIdWorker redisIdWorker; @Resource private RedissonClient redissonClient; //初始化lua脚本，static块和static属性类加载的时候就赋值调用了，且staic块中的内容只在类加载的时候执行一次，而普通初始化块中的内容每次创建对象都会执行 private static final DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT; static&#123; SECKILL_SCRIPT=new DefaultRedisScript&lt;&gt;(); //指定lua脚本的位置，ClassPathResource里的参数就是在resources文件下找 SECKILL_SCRIPT.setLocation(new ClassPathResource(&quot;seckill.lua&quot;)); //配返回值 SECKILL_SCRIPT.setResultType(Long.class); &#125; //专门处理下单操作数据库的线程,这里是获取一个单线程,这个线程是专门下单的 private static final ExecutorService SECKILL_ORDER_EXECUTOR= Executors.newSingleThreadExecutor(); @PostConstruct private void init()&#123; //让这个任务在类初始化完毕就会执行 SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler()); &#125; //这个任务应该在类初始化的时候都执行了，就是一个阻塞效果，一开始拿不到就阻塞，等到消息队列中有了东西，直接获取就可以 private class VoucherOrderHandler implements Runnable&#123; String queueName=&quot;streams.order&quot;; @Override public void run() &#123; while (true) &#123; try &#123; // 1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt; List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read( //第一个参数是组的名称，第二个是消费者名称 GROUP g1 c1 Consumer.from(&quot;g1&quot;, &quot;c1&quot;), //读取的选项，先empty()创建一个空的，然后count说明读取一个，block指堵塞多久 就是COUNT 1 BLOCK StreamReadOptions.empty().count(1).block(Duration.ofSeconds(2)), //消息队列的名称和读取标识，就是STREAMS s1 &gt; //queueName streams.order StreamOffset.create(queueName, ReadOffset.lastConsumed()) ); // 2.判断订单信息是否为空 if (list == null || list.isEmpty()) &#123; // 如果为null，说明没有消息，继续下一次循环 continue; &#125; // 解析数据 MapRecord&lt;String, Object, Object&gt; record = list.get(0); //能得到这种map形式的 Map&lt;Object, Object&gt; value = record.getValue(); //map转成voucherOrder对象 VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true); // 3.创建订单 createVoucherOrder(voucherOrder); // 4.确认消息 XACK stringRedisTemplate.opsForStream().acknowledge(queueName, &quot;g1&quot;, record.getId()); &#125; catch (Exception e) &#123; log.error(&quot;处理订单异常&quot;, e); //处理异常消息 handlePendingList(); &#125; &#125; &#125; private void handlePendingList() &#123; while (true) &#123; try &#123; // 1.获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 0 List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read( Consumer.from(&quot;g1&quot;, &quot;c1&quot;), StreamReadOptions.empty().count(1), //最后一个参数是读取标识是零 StreamOffset.create(&quot;stream.orders&quot;, ReadOffset.from(&quot;0&quot;)) ); // 2.判断订单信息是否为空 if (list == null || list.isEmpty()) &#123; // 如果为null，说明没有异常消息，结束循环 break; &#125; // 解析数据 MapRecord&lt;String, Object, Object&gt; record = list.get(0); Map&lt;Object, Object&gt; value = record.getValue(); VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true); // 3.创建订单 createVoucherOrder(voucherOrder); // 4.确认消息 XACK //最后一个参数是指消息队列中这条消息的id stringRedisTemplate.opsForStream().acknowledge(queueName, &quot;g1&quot;, record.getId()); &#125; catch (Exception e) &#123; log.error(&quot;处理pendding订单异常&quot;, e); try&#123; Thread.sleep(20); &#125;catch(Exception ex)&#123; ex.printStackTrace(); &#125; &#125; &#125; &#125; &#125; public void handleVoucherOrder(VoucherOrder voucherOrder)&#123; //现在是多线程了从UserHolder里面是取不到userId了 //1.获取用户id Long userId=voucherOrder.getUserId(); //尝试获取锁 //这个参数是存储的key的名称 RLock anylock = redissonClient.getLock(&quot;lock:order:&quot;+userId); boolean isLock = anylock.tryLock(); //如果没有获取到锁，说明已经有自己的请求获取到锁了，直接返回错误信息即可 if (!isLock) &#123; log.error(&quot;不能重复下单&quot;); &#125; try &#123; //即使return后方法结束，finally还是可以执行完毕 proxy.createVoucherOrder(voucherOrder); &#125;finally&#123; //执行完毕之后就会释放锁 anylock.unlock(); &#125; &#125; private IVoucherOrderService proxy; //基于消息队列 @Override public Result seckillVoucher(Long voucherId) throws InterruptedException &#123; //获取用户id Long userId = UserHolder.getUser().getId(); //获取订单id Long orderId = redisIdWorker.nextId(&quot;order&quot;); //执行lua脚本 Long result=stringRedisTemplate.execute( SECKILL_SCRIPT, //传了一个空集合 Collections.emptyList(), voucherId.toString(),userId.toString(),orderId.toString() ); //2.判断结果是否为0 //2.1不为零，没有购买资格 int result1 = result.intValue(); if(result1!=0)&#123; return Result.fail(result1==1?&quot;库存不足&quot;:&quot;不能重复下单&quot;); &#125; //获取代理对象 //获取代理对象是基于ThreadLocal的，在handleVoucherOrder方法是在子线程中执行，子线程无法操作threadLocal所以放到父线程中来获取，子线程中使用即可 proxy = (IVoucherOrderService) AopContext.currentProxy(); //把订单id返回给客户 return Result.ok(orderId); &#125; //其实在这个方法中我们不必判断一人一单的操作，因为redis中已经弄好了，但保险起见还是搞上了 @Override @Transactional public void createVoucherOrder(VoucherOrder voucherOrder)&#123; // 5.一人一单逻辑 // 5.1.用户id Long userId = voucherOrder.getUserId(); //优惠卷id Long voucherId=voucherOrder.getVoucherId(); //订单id Long orderId=voucherOrder.getId(); int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count(); // 5.2.判断是否存在 if (count &gt; 0) &#123; // 用户已经购买过了 log.error(&quot;用户已经购买过了&quot;); &#125; else &#123;//6，扣减库存 boolean success = seckillVoucherService.update() .setSql(&quot;stock= stock -1&quot;) .eq(&quot;voucher_id&quot;, voucherId).gt(&quot;stock&quot;, 0).update(); if (!success) &#123; //扣减库存 log.error(&quot;库存不足&quot;); &#125; else &#123; //7.保存订单 save(voucherOrder); &#125; &#125; &#125; &#125; 8、达人探店8.1、达人探店-发布探店笔记发布探店笔记 探店笔记类似点评网站的评价，往往是图文结合。对应的表有两个：tb_blog：探店笔记表，包含笔记中的标题、文字、图片等tb_blog_comments：其他用户对探店笔记的评价 具体发布流程 上传接口 1234567891011121314151617181920212223@Slf4j@RestController@RequestMapping(&quot;upload&quot;)public class UploadController &#123; @PostMapping(&quot;blog&quot;) public Result uploadImage(@RequestParam(&quot;file&quot;) MultipartFile image) &#123; try &#123; // 获取原始文件名称 String originalFilename = image.getOriginalFilename(); // 生成新文件名 String fileName = createNewFileName(originalFilename); // 保存文件 image.transferTo(new File(SystemConstants.IMAGE_UPLOAD_DIR, fileName)); // 返回结果 log.debug(&quot;文件上传成功，&#123;&#125;&quot;, fileName); return Result.ok(fileName); &#125; catch (IOException e) &#123; throw new RuntimeException(&quot;文件上传失败&quot;, e); &#125; &#125;&#125; 注意：同学们在操作时，需要修改SystemConstants.IMAGE_UPLOAD_DIR 自己图片所在的地址，在实际开发中图片一般会放在nginx上或者是云存储上。 BlogController 123456789101112131415161718@RestController@RequestMapping(&quot;/blog&quot;)public class BlogController &#123; @Resource private IBlogService blogService; @PostMapping public Result saveBlog(@RequestBody Blog blog) &#123; //获取登录用户 UserDTO user = UserHolder.getUser(); blog.setUpdateTime(user.getId()); //保存探店博文 blogService.saveBlog(blog); //返回id return Result.ok(blog.getId()); &#125;&#125; 8.2 达人探店-查看探店笔记实现查看发布探店笔记的接口 实现代码： 这个查询的请求参数是Blog的id BlogServiceImpl 123456789101112@Overridepublic Result queryBlogById(Long id) &#123; // 1.查询blog Blog blog = getById(id); if (blog == null) &#123; return Result.fail(&quot;笔记不存在！&quot;); &#125; // 2.查询blog有关的用户 queryBlogUser(blog); return Result.ok(blog);&#125; BlogController 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.hmdp.controller;import com.baomidou.mybatisplus.extension.plugins.pagination.Page;import com.hmdp.dto.Result;import com.hmdp.dto.UserDTO;import com.hmdp.entity.Blog;import com.hmdp.entity.User;import com.hmdp.service.IBlogService;import com.hmdp.service.IUserService;import com.hmdp.utils.SystemConstants;import com.hmdp.utils.UserHolder;import org.springframework.web.bind.annotation.*;import javax.annotation.Resource;import java.util.List;/** * &lt;p&gt; * 前端控制器 * &lt;/p&gt; * * @author 虎哥 * @since 2021-12-22 */@RestController@RequestMapping(&quot;/blog&quot;)public class BlogController &#123; @Resource private IBlogService blogService; @Resource private IUserService userService; @PostMapping public Result saveBlog(@RequestBody Blog blog) &#123; // 获取登录用户 UserDTO user = UserHolder.getUser(); blog.setUserId(user.getId()); // 保存探店博文 blogService.save(blog); // 返回id return Result.ok(blog.getId()); &#125; @PutMapping(&quot;/like/&#123;id&#125;&quot;) public Result likeBlog(@PathVariable(&quot;id&quot;) Long id) &#123; // 修改点赞数量 blogService.update() .setSql(&quot;liked = liked + 1&quot;).eq(&quot;id&quot;, id).update(); return Result.ok(); &#125; @GetMapping(&quot;/of/me&quot;) public Result queryMyBlog(@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;) Integer current) &#123; // 获取登录用户 UserDTO user = UserHolder.getUser(); // 根据用户查询 Page&lt;Blog&gt; page = blogService.query() .eq(&quot;user_id&quot;, user.getId()).page(new Page&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE)); // 获取当前页数据 List&lt;Blog&gt; records = page.getRecords(); return Result.ok(records); &#125; //分页查询博客信息，就是页面上那个 @GetMapping(&quot;/hot&quot;) public Result queryHotBlog(@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;) Integer current) &#123; return blogService.queryHotBlog(current); &#125; //展示博文的具体内容 @GetMapping(&quot;/&#123;id&#125;&quot;) public Result queryBlogById(@PathVariable(&quot;id&quot;) Long id) &#123; return blogService.queryBlogById(id); &#125;&#125; BlogServiceImpl 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.hmdp.service.impl;import com.baomidou.mybatisplus.extension.plugins.pagination.Page;import com.hmdp.dto.Result;import com.hmdp.entity.Blog;import com.hmdp.entity.User;import com.hmdp.mapper.BlogMapper;import com.hmdp.service.IBlogService;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.hmdp.service.IUserService;import com.hmdp.utils.SystemConstants;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;/** * &lt;p&gt; * 服务实现类 * &lt;/p&gt; * * @author 虎哥 * @since 2021-12-22 */@Servicepublic class BlogServiceImpl extends ServiceImpl&lt;BlogMapper, Blog&gt; implements IBlogService &#123; @Autowired private IBlogService blogService; @Autowired private IUserService userService; @Override public Result queryHotBlog(Integer current) &#123; // 根据用户查询 Page&lt;Blog&gt; page = blogService.query() .orderByDesc(&quot;liked&quot;) .page(new Page&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE)); // 获取当前页数据 List&lt;Blog&gt; records = page.getRecords(); // 查询用户 records.forEach(this::queryBlogUser); return Result.ok(records); &#125; @Override public Result queryBlogById(Long id) &#123; //1.查询blog Blog blog=getById(id); if(blog==null)&#123; return Result.fail(&quot;笔记不存在&quot;); &#125; queryBlogUser(blog); return Result.ok(blog); &#125; //用来给blog加上用户的信息 private void queryBlogUser(Blog blog)&#123; //2.查询blog有关的用户 Long userId=blog.getUserId(); User user=userService.getById(userId); blog.setName(user.getNickName()); blog.setIcon(user.getIcon()); &#125;&#125; IBlogService 12345678910111213141516171819package com.hmdp.service;import com.hmdp.dto.Result;import com.hmdp.entity.Blog;import com.baomidou.mybatisplus.extension.service.IService;/** * &lt;p&gt; * 服务类 * &lt;/p&gt; * * @author 虎哥 * @since 2021-12-22 */public interface IBlogService extends IService&lt;Blog&gt; &#123;Result queryHotBlog(Integer current);Result queryBlogById(Long id);&#125; 8.3 达人探店-点赞功能初始代码 123456@GetMapping(&quot;/likes/&#123;id&#125;&quot;)public Result queryBlogLikes(@PathVariable(&quot;id&quot;) Long id) &#123; //修改点赞数量 blogService.update().setSql(&quot;liked = liked +1 &quot;).eq(&quot;id&quot;,id).update(); return Result.ok();&#125; 问题分析：这种方式会导致一个用户无限点赞，明显是不合理的 造成这个问题的原因是，我们现在的逻辑，发起请求只是给数据库+1，所以才会出现这个问题 完善点赞功能 需求： 同一个用户只能点赞一次，再次点击则取消点赞 如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段Blog类的isLike属性） 实现步骤： 给Blog类中添加一个isLike字段，标示是否被当前用户点赞 修改点赞功能，利用Redis的set集合判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1 修改根据id查询Blog的业务，判断当前登录用户是否点赞过，赋值给isLike字段 修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段 为什么采用set集合： 因为我们的数据是不能重复的，当用户操作过之后，无论他怎么操作，都是 具体步骤： 1、在Blog 添加一个字段 12@TableField(exist = false)private Boolean isLike; 2、修改代码 12345678910111213141516171819202122232425262728@Overridepublic Result likeBlog(Long id) &#123; // 1.获取登录用户 Long userId = UserHolder.getUser().getId(); // 2.判断当前登录用户是否已经点赞 //因为是每个商品都只可以被点赞一次，所以用blog的id作为key String key = BLOG_LIKED_KEY + id; //这个语句是判断这个当前的这个userId是否存储在Set中 Boolean isMember = stringRedisTemplate.opsForSet().isMember(key, userId.toString()); if (BooleanUtil.isFalse(isMember)) &#123; //3.如果未点赞，可以点赞 //3.1 数据库点赞数+1 boolean isSuccess = update().setSql(&quot;liked = liked + 1&quot;).eq(&quot;id&quot;, id).update(); //3.2 保存用户到Redis的set集合 if (isSuccess) &#123; stringRedisTemplate.opsForSet().add(key, userId.toString()); &#125; &#125; else &#123; //4.如果已点赞，取消点赞 //4.1 数据库点赞数-1 boolean isSuccess = update().setSql(&quot;liked = liked - 1&quot;).eq(&quot;id&quot;, id).update(); //4.2 把用户从Redis的set集合移除 if (isSuccess) &#123; stringRedisTemplate.opsForSet().remove(key, userId.toString()); &#125; &#125; return Result.ok(&quot;点赞成功&quot;);&#125; BlogController 123456 //liked字段代表点赞数 @PutMapping(&quot;/like/&#123;id&#125;&quot;) public Result likeBlog(@PathVariable(&quot;id&quot;) Long id) &#123; // 修改点赞数量 update tb_blog set liked=liked+1 where id =?return blogService.likeBlog(id); &#125; BlogServiceImpl 两个查询博客的方法，都要加上对于判断当前用户是否点过赞的操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Overridepublic Result queryHotBlog(Integer current) &#123; // 根据用户查询 Page&lt;Blog&gt; page = blogService.query() .orderByDesc(&quot;liked&quot;) .page(new Page&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE)); // 获取当前页数据 List&lt;Blog&gt; records = page.getRecords(); // 查询用户 records.forEach(blog-&gt;&#123; //查询blog用户，查询是否被点赞 this.queryBlogUser(blog); this.isBlogLiked(blog); &#125;); return Result.ok(records);&#125;@Overridepublic Result queryBlogById(Long id) &#123; //1.查询blog Blog blog = getById(id); if (blog == null) &#123; return Result.fail(&quot;笔记不存在&quot;); &#125; //查询发布blog的用户，给icon，等等用户有关属性赋值 queryBlogUser(blog); //3.查询blog是否被点赞,并给isLiked赋值 isBlogLiked(blog); return Result.ok(blog);&#125;//判断这个博客用户是否点过赞private void isBlogLiked(Blog blog) &#123; // 1.获取登录用户 Long userId = UserHolder.getUser().getId(); // 2.判断当前登录用户是否已经点赞 //因为是每个商品都只可以被点赞一次，所以用blog的id作为key String key = BLOG_LIKED_KEY + blog.getId(); //这个语句是判断这个当前的这个userId是否存储在Set中 Boolean isMember = stringRedisTemplate.opsForSet().isMember(key, userId.toString()); blog.setIsLike(BooleanUtil.isTrue(isMember));&#125; 8.4 达人探店-点赞排行榜在探店笔记的详情页面，应该把给该笔记点赞的人显示出来，比如最早点赞的TOP5，形成点赞排行榜： 之前的点赞是放到set集合，但是set集合是不能排序的，所以这个时候，咱们可以采用一个可以排序的set集合，就是咱们的sortedSet 我们接下来来对比一下这些集合的区别是什么 所有点赞的人，需要是唯一的，所以我们应当使用set或者是sortedSet 其次我们需要排序，就可以直接锁定使用sortedSet啦 修改代码 BlogServiceImpl 点赞逻辑代码 点赞的用户的id要往SortedSet里面存，而不是Set了 12345678910111213141516171819202122232425262728293031323334353637383940414243 @Override public Result likeBlog(Long id) &#123; // 1.获取登录用户 Long userId = UserHolder.getUser().getId(); // 2.判断当前登录用户是否已经点赞 String key = BLOG_LIKED_KEY + id; Double score = stringRedisTemplate.opsForZSet().score(key, userId.toString()); if (score == null) &#123; // 3.如果未点赞，可以点赞 // 3.1.数据库点赞数 + 1 boolean isSuccess = update().setSql(&quot;liked = liked + 1&quot;).eq(&quot;id&quot;, id).update(); // 3.2.保存用户到Redis的set集合 zadd key value score if (isSuccess) &#123; //第一个参数是key，第二个参数时userId,第三个参数是score stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis()); &#125; &#125; else &#123; // 4.如果已点赞，取消点赞 // 4.1.数据库点赞数 -1 boolean isSuccess = update().setSql(&quot;liked = liked - 1&quot;).eq(&quot;id&quot;, id).update(); // 4.2.把用户从Redis的set集合移除 if (isSuccess) &#123; stringRedisTemplate.opsForZSet().remove(key, userId.toString()); &#125; &#125; return Result.ok(); &#125;//判断这个博客是否被点赞过 private void isBlogLiked(Blog blog) &#123; // 1.获取登录用户 UserDTO user = UserHolder.getUser(); if (user == null) &#123; // 用户未登录，无需查询是否点赞 return; &#125; Long userId = user.getId(); // 2.判断当前登录用户是否已经点赞 String key = &quot;blog:liked:&quot; + blog.getId(); Double score = stringRedisTemplate.opsForZSet().score(key, userId.toString()); blog.setIsLike(score != null); &#125; 点赞列表查询列表 BlogController 12345@GetMapping(&quot;/likes/&#123;id&#125;&quot;)public Result queryBlogLikes(@PathVariable(&quot;id&quot;) Long id) &#123; return blogService.queryBlogLikes(id);&#125; BlogService 1234567891011121314151617181920212223@Override public Result queryBlogLikes(Long id) &#123; String key = BLOG_LIKED_KEY + id; // 1.查询top5的点赞用户 zrange key 0 4 Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, 0, 4); if (top5 == null || top5.isEmpty()) &#123; return Result.ok(Collections.emptyList()); &#125; // 2.解析出其中的用户id List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList()); String idStr = StrUtil.join(&quot;,&quot;, ids); // 3.根据用户id查询用户 WHERE id IN ( 5 , 1 ) ORDER BY FIELD(id, 5, 1) //只用in的时候就是直接userService.listByIds(ids) 这种sql语句其实就是直接用in(ids) 所以这里不能这样直接用 //要让查询结果按照自己传的id顺序， .last就是指在后面加上sql语句，.list是指最后返回一个List集合 List&lt;UserDTO&gt; userDTOS = userService.query() .in(&quot;id&quot;, ids).last(&quot;ORDER BY FIELD(id,&quot; + idStr + &quot;)&quot;).list() .stream() .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class)) .collect(Collectors.toList()); // 4.返回 return Result.ok(userDTOS); &#125; 9、好友关注9.1 好友关注-关注和取消关注针对用户的操作：可以对用户进行关注和取消关注功能。 实现思路： 需求：基于该表数据结构，实现两个接口： 关注和取关接口 判断是否关注的接口 关注是User之间的关系，是博主与粉丝的关系，数据库中有一张tb_follow表来标示： 注意: 这里需要把主键修改为自增长，简化开发。 FollowController 12345678910//关注或取关@PutMapping(&quot;/&#123;id&#125;/&#123;isFollow&#125;&quot;)public Result follow(@PathVariable(&quot;id&quot;) Long followUserId, @PathVariable(&quot;isFollow&quot;) Boolean isFollow) &#123; return followService.follow(followUserId, isFollow);&#125;//判断是否关注@GetMapping(&quot;/or/not/&#123;id&#125;&quot;)public Result isFollow(@PathVariable(&quot;id&quot;) Long followUserId) &#123; return followService.isFollow(followUserId);&#125; FollowService 123456789101112131415161718192021222324252627282930313233判断是否关注service@Overridepublic Result isFollow(Long followUserId) &#123; // 1.获取登录用户 Long userId = UserHolder.getUser().getId(); // 2.查询是否关注 select count(*) from tb_follow where user_id = ? and follow_user_id = ? Integer count = query().eq(&quot;user_id&quot;, userId).eq(&quot;follow_user_id&quot;, followUserId).count(); // 3.判断 return Result.ok(count &gt; 0); &#125; 关注或取关service @Override public Result follow(Long followUserId, Boolean isFollow) &#123; // 1.获取登录用户 Long userId = UserHolder.getUser().getId(); String key = &quot;follows:&quot; + userId; // 1.判断到底是关注还是取关 if (isFollow) &#123; // 2.关注，新增数据 Follow follow = new Follow(); follow.setUserId(userId); follow.setFollowUserId(followUserId); boolean isSuccess = save(follow); &#125; else &#123; // 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ? remove(new QueryWrapper&lt;Follow&gt;() .eq(&quot;user_id&quot;, userId).eq(&quot;follow_user_id&quot;, followUserId)); &#125; return Result.ok(); &#125; 9.2 好友关注-共同关注想要去看共同关注的好友，需要首先进入到这个页面，这个页面会发起两个请求 1、去查询用户的详情 2、去查询用户的笔记 以上两个功能和共同关注没有什么关系，大家可以自行将笔记中的代码拷贝到idea中就可以实现这两个功能了，我们的重点在于共同关注功能。 12345678910111213141516171819202122232425// UserController 根据id查询用户@GetMapping(&quot;/&#123;id&#125;&quot;)public Result queryUserById(@PathVariable(&quot;id&quot;) Long userId)&#123; // 查询详情 User user = userService.getById(userId); if (user == null) &#123; return Result.ok(); &#125; UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class); // 返回 return Result.ok(userDTO);&#125;// BlogController 根据id查询博主的探店笔记@GetMapping(&quot;/of/user&quot;)public Result queryBlogByUserId( @RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;) Integer current, @RequestParam(&quot;id&quot;) Long id) &#123; // 根据用户查询 Page&lt;Blog&gt; page = blogService.query() .eq(&quot;user_id&quot;, id).page(new Page&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE)); // 获取当前页数据 List&lt;Blog&gt; records = page.getRecords(); return Result.ok(records);&#125; 接下来我们来看看共同关注如何实现： 需求：利用Redis中恰当的数据结构，实现共同关注功能。在博主个人页面展示出当前用户与博主的共同关注呢。 当然是使用我们之前学习过的set集合咯，在set集合中，有交集并集补集的api，我们可以把两人的关注的人分别放入到一个set集合中，然后再通过api去查看这两个set集合中的交集数据。 我们先来改造当前的关注列表 改造原因是因为我们需要在用户关注了某位用户后，需要将数据放入到set集合中，方便后续进行共同关注，同时当取消关注时，也需要从set集合中进行删除 FollowServiceImpl 123456789101112131415161718192021222324252627@Overridepublic Result follow(Long followUserId, Boolean isFollow) &#123; // 1.获取登录用户 Long userId = UserHolder.getUser().getId(); String key = &quot;follows:&quot; + userId; // 1.判断到底是关注还是取关 if (isFollow) &#123; // 2.关注，新增数据 Follow follow = new Follow(); follow.setUserId(userId); follow.setFollowUserId(followUserId); boolean isSuccess = save(follow); if (isSuccess) &#123; // 把关注用户的id，放入redis的set集合 sadd userId followerUserId stringRedisTemplate.opsForSet().add(key, followUserId.toString()); &#125; &#125; else &#123; // 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ? boolean isSuccess = remove(new QueryWrapper&lt;Follow&gt;() .eq(&quot;user_id&quot;, userId).eq(&quot;follow_user_id&quot;, followUserId)); if (isSuccess) &#123; // 把关注用户的id从Redis集合中移除 stringRedisTemplate.opsForSet().remove(key, followUserId.toString()); &#125; &#125; return Result.ok();&#125; 具体的关注代码： FollowServiceImpl 123456789101112131415161718192021@Overridepublic Result followCommons(Long id) &#123; // 1.获取当前用户 Long userId = UserHolder.getUser().getId(); String key = &quot;follows:&quot; + userId; // 2.求交集 String key2 = &quot;follows:&quot; + id; Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(key, key2); if (intersect == null || intersect.isEmpty()) &#123; // 无交集 return Result.ok(Collections.emptyList()); &#125; // 3.解析id集合 List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList()); // 4.查询用户 List&lt;UserDTO&gt; users = userService.listByIds(ids) .stream() .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class)) .collect(Collectors.toList()); return Result.ok(users);&#125; 9.3 好友关注-Feed流实现方案当我们关注了用户后，这个用户发了动态，那么我们应该把这些数据推送给用户，这个需求，其实我们又把他叫做Feed流，关注推送也叫做Feed流，直译为投喂。为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息。 对于传统的模式的内容解锁：我们是需要用户去通过搜索引擎或者是其他的方式去解锁想要看的内容 对于新型的Feed流的的效果：不需要我们用户再去推送信息，而是系统分析用户到底想要什么，然后直接把内容推送给用户，从而使用户能够更加的节约时间，不用主动去寻找。 Feed流的实现有两种模式： Feed流产品有两种常见模式：Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈 优点：信息全面，不会有缺失。并且实现也相对简单 缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低 智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户 优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷 缺点：如果算法不精准，可能起到反作用本例中的个人页面，是基于关注的好友来做Feed流，因此采用Timeline的模式。该模式的实现方案有三种： 我们本次针对好友的操作，采用的就是Timeline的方式，只需要拿到我们关注用户的信息，然后按照时间排序即可 ，因此采用Timeline的模式。该模式的实现方案有三种： 拉模式 推模式 推拉结合 拉模式：也叫做读扩散 该模式的核心含义就是：当张三和李四和王五发了消息后，都会保存在自己的邮箱中，假设赵六要读取信息，那么他会从读取他自己的收件箱，此时系统会从他关注的人群中，把他关注人的信息全部都进行拉取，然后在进行排序 优点：比较节约空间，因为赵六在读信息时，并没有重复读取，而且读取完之后可以把他的收件箱进行清楚。 缺点：比较延迟，当用户读取数据时才去关注的人里边去读取数据，假设用户关注了大量的用户，那么此时就会拉取海量的内容，对服务器压力巨大。 把关注这些人的发件箱的里面的内容都拿过来然后放到收件箱中再按照顺序排列起来 推模式：也叫做写扩散。 推模式是没有写邮箱的，当张三写了一个内容，此时会主动的把张三写的内容发送到他的粉丝收件箱中去，假设此时李四再来读取，就不用再去临时拉取了 优点：时效快，不用临时拉取 缺点：内存压力大，假设一个大V写信息，很多人关注他， 就会写很多分数据到粉丝那边去 推拉结合模式：也叫做读写混合，兼具推和拉两种模式的优点。 推拉模式是一个折中的方案，站在发件人这一段，如果是个普通的人，那么我们采用写扩散的方式，直接把数据写入到他的粉丝中去，因为普通的人他的粉丝关注量比较小，所以这样做没有压力，如果是大V，那么他是直接将数据先写入到一份到发件箱里边去，然后再直接写一份到活跃粉丝收件箱里边去，现在站在收件人这端来看，如果是活跃粉丝，那么大V和普通的人发的都会直接写入到自己收件箱里边来，而如果是普通的粉丝，由于他们上线不是很频繁，所以等他们上线时，再从发件箱里边去拉信息。 9.4 好友关注-推送到粉丝收件箱需求： 修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱 收件箱满足可以根据时间戳排序，必须用Redis的数据结构实现 查询收件箱数据时，可以实现分页查询 Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。 传统了分页在feed流是不适用的，因为我们的数据会随时发生变化 假设在t1 时刻，我们去读取第一页，此时page &#x3D; 1 ，size &#x3D; 5 ，那么我们拿到的就是106 这几条记录，假设现在t2时候又发布了一条记录，此时t3 时刻，我们来读取第二页，读取第二页传入的参数是page&#x3D;2 ，size&#x3D;5 ，那么此时读取到的第二页实际上是从6 开始，然后是62 ，那么我们就读取到了重复的数据，所以feed流的分页，不能采用原始方案来做。 Feed流的滚动分页 我们需要记录每次操作的最后一条，然后从这个位置开始去读取数据 举个例子：我们从t1时刻开始，拿第一页数据，拿到了10~6，然后记录下当前最后一次拿取的记录，就是6，t2时刻发布了新的记录，此时这个11放到最顶上，但是不会影响我们之前记录的6，此时t3时刻来拿第二页，第二页这个时候拿数据，还是从6后一点的5去拿，就拿到了5-1的记录。我们这个地方可以采用sortedSet来做，可以进行范围查询，并且还可以记录当前获取数据时间戳最小值，就可以实现滚动分页了 list只能通过索引脚标来确定元素位置，但是sortedset可以通过用时间戳为score，可以记录上一次查询到的时间戳最小值，然后下一次查询找比他更小的 核心的意思：就是我们在保存完探店笔记后，获得到当前笔记的粉丝，然后把数据推送到粉丝的redis中去。 1234567891011121314151617181920212223@Overridepublic Result saveBlog(Blog blog) &#123; // 1.获取登录用户 UserDTO user = UserHolder.getUser(); blog.setUserId(user.getId()); // 2.保存探店笔记 boolean isSuccess = save(blog); if(!isSuccess)&#123; return Result.fail(&quot;新增笔记失败!&quot;); &#125; // 3.查询笔记作者的所有粉丝 select * from tb_follow where follow_user_id = ? List&lt;Follow&gt; follows = followService.query().eq(&quot;follow_user_id&quot;, user.getId()).list(); // 4.推送笔记id给所有粉丝 for (Follow follow : follows) &#123; // 4.1.获取粉丝id Long userId = follow.getUserId(); // 4.2.推送 String key = FEED_KEY + userId; stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis()); &#125; // 5.返回id return Result.ok(blog.getId());&#125; 9.5好友关注-实现分页查询收邮箱需求：在个人主页的“关注”卡片中，查询并展示推送的Blog信息： 具体操作如下： 1、每次查询完成后，我们要分析出查询出数据的最小时间戳，这个值会作为下一次查询的条件 2、我们需要找到与上一次查询相同的查询个数作为偏移量，下次查询时，跳过这些查询过的数据，拿到我们需要的数据 综上：我们的请求参数中就需要携带 lastId：上一次查询的最小时间戳 和偏移量这两个参数。 这两个参数第一次会由前端来指定，以后的查询就根据后台结果作为条件，再次传递到后台。 ZREVRANGEBYSCORE z1 1000 0 WITHSCORES LIMIT 0 3 LIMIT 0,3 0是指偏移量就是0就是说从小于等于最大值的第一个数开始，3是说查询三个，1000 和 0是指查询score小于等于1000大于等于0的范围 **第二次查询的时候 ** ZREVRANGEBYSCORE z1 5 0 WITHSCORES LIMIT 1 3 5是指第一次查询的时候score的最小值，作为第二次查询的时候最大值，所以第二次不能再查询5，所以LIMIT第一个数是1 问题：如果score出现相同情况，就是第一次查询出来的最后两个score相同，你把最后一个的score当作下一次查询最大值，然后只跳过一个，那么上次查询出来的最后一个还是会出现在第二次查询里面 一、定义出来具体的返回值实体类 123456@Datapublic class ScrollResult &#123; private List&lt;?&gt; list; private Long minTime; private Integer offset;&#125; BlogController 注意：RequestParam 表示接受url地址栏传参的注解，当方法上参数的名称和url地址栏不相同时，可以通过RequestParam 来进行指定 12345@GetMapping(&quot;/of/follow&quot;)public Result queryBlogOfFollow( @RequestParam(&quot;lastId&quot;) Long max, @RequestParam(value = &quot;offset&quot;, defaultValue = &quot;0&quot;) Integer offset)&#123; return blogService.queryBlogOfFollow(max, offset);&#125; BlogServiceImpl Score存储的是Double类型的，所以可以用double.longvalue() 如果是String类型的，用Long.valueof(String) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Overridepublic Result queryBlogOfFollow(Long max, Integer offset) &#123; // 1.获取当前用户 Long userId = UserHolder.getUser().getId(); // 2.查询收件箱 ZREVRANGEBYSCORE key Max Min LIMIT offset count String key = FEED_KEY + userId; Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet() .reverseRangeByScoreWithScores(key, 0, max, offset, 2); // 3.非空判断 if (typedTuples == null || typedTuples.isEmpty()) &#123; return Result.ok(); &#125; // 4.解析数据：blogId、minTime（时间戳）、offset List&lt;Long&gt; ids = new ArrayList&lt;&gt;(typedTuples.size()); long minTime = 0; // 2 int os = 1; // 2 for (ZSetOperations.TypedTuple&lt;String&gt; tuple : typedTuples) &#123; // 5 4 4 2 2 // 4.1.获取id ids.add(Long.valueOf(tuple.getValue())); // 4.2.获取分数(时间戳） long time = tuple.getScore().longValue(); if(time == minTime)&#123; os++; &#125;else&#123; minTime = time; os = 1; &#125; &#125; // 5.根据id查询blog String idStr = StrUtil.join(&quot;,&quot;, ids); List&lt;Blog&gt; blogs = query().in(&quot;id&quot;, ids).last(&quot;ORDER BY FIELD(id,&quot; + idStr + &quot;)&quot;).list(); for (Blog blog : blogs) &#123; // 5.1.查询blog有关的用户 queryBlogUser(blog); // 5.2.查询blog是否被点赞 isBlogLiked(blog); &#125; // 6.封装并返回 ScrollResult r = new ScrollResult(); r.setList(blogs); r.setOffset(os); r.setMinTime(minTime); return Result.ok(r);&#125; 10、附近商户10.1、附近商户-GEO数据结构的基本用法GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有： GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member） GEODIST：计算指定的两个点之间的距离并返回 GEOHASH：将指定member的坐标转为hash字符串形式并返回 GEOPOS：返回指定member的坐标 GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.以后已废弃 GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能 GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key(sortedset)。 6.2.新功能 10.2、 附近商户-导入店铺数据到GEO具体场景说明： 当我们点击美食之后，会出现一系列的商家，商家中可以按照多种排序方式，我们此时关注的是距离，这个地方就需要使用到我们的GEO，向后台传入当前app收集的地址(我们此处是写死的) ，以当前坐标作为圆心，同时绑定相同的店家类型type，以及分页信息，把这几个条件传入后台，后台查询出对应的数据再返回。 我们要做的事情是：将数据库表中的数据导入到redis中去，redis中的GEO，GEO在redis中就一个menber和一个经纬度，我们把x和y轴传入到redis做的经纬度位置去，但我们不能把所有的数据都放入到menber中去，毕竟作为redis是一个内存级数据库，如果存海量数据，redis还是力不从心，所以我们在这个地方存储他的id即可。 但是这个时候还有一个问题，就是在redis中并没有存储type，所以我们无法根据type来对数据进行筛选，所以我们可以按照商户类型做分组，类型相同的商户作为同一组，以typeId为key存入同一个GEO集合中即可 代码 HmDianPingApplicationTests 12345678910111213141516171819202122232425@Testvoid loadShopData() &#123; // 1.查询店铺信息 List&lt;Shop&gt; list = shopService.list(); // 2.把店铺分组，按照typeId分组，typeId一致的放到一个集合 Map&lt;Long, List&lt;Shop&gt;&gt; map = list.stream().collect(Collectors.groupingBy(Shop::getTypeId)); // 3.分批完成写入Redis for (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123; // 3.1.获取类型id Long typeId = entry.getKey(); String key = SHOP_GEO_KEY + typeId; // 3.2.获取同类型的店铺的集合 List&lt;Shop&gt; value = entry.getValue(); List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = new ArrayList&lt;&gt;(value.size()); // 3.3.写入redis GEOADD key 经度 纬度 member for (Shop shop : value) &#123; // stringRedisTemplate.opsForGeo().add(key, new Point(shop.getX(), shop.getY()), shop.getId().toString()); locations.add(new RedisGeoCommands.GeoLocation&lt;&gt;( shop.getId().toString(), new Point(shop.getX(), shop.getY()) )); &#125; stringRedisTemplate.opsForGeo().add(key, locations); &#125;&#125; 10.3 附近商户-实现附近商户功能SpringDataRedis的2.3.9版本并不支持Redis 6.2提供的GEOSEARCH命令，因此我们需要提示其版本，修改自己的POM 第一步：导入pom 123456789101112131415161718192021222324&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt; &lt;groupId&gt;io.lettuce&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.lettuce&lt;/groupId&gt; &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt; &lt;version&gt;6.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt; 第二步： ShopController 123456789@GetMapping(&quot;/of/type&quot;)public Result queryShopByType( @RequestParam(&quot;typeId&quot;) Integer typeId, @RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;) Integer current, @RequestParam(value = &quot;x&quot;, required = false) Double x, @RequestParam(value = &quot;y&quot;, required = false) Double y) &#123; return shopService.queryShopByType(typeId, current, x, y);&#125; ShopServiceImpl 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Override public Result queryShopByType(Integer typeId, Integer current, Double x, Double y) &#123; // 1.判断是否需要根据坐标查询 if (x == null || y == null) &#123; // 不需要坐标查询，按数据库查询 Page&lt;Shop&gt; page = query() .eq(&quot;type_id&quot;, typeId) .page(new Page&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE)); // 返回数据 return Result.ok(page.getRecords()); &#125; // 2.计算分页参数 int from = (current - 1) * SystemConstants.DEFAULT_PAGE_SIZE; int end = current * SystemConstants.DEFAULT_PAGE_SIZE; // 3.查询redis、按照距离排序、分页。结果：shopId、distance String key = SHOP_GEO_KEY + typeId; GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo() // GEOSEARCH key BYLONLAT x y BYRADIUS 10 WITHDISTANCE .search( key, GeoReference.fromCoordinate(x, y), new Distance(5000), RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end) ); // 4.解析出id if (results == null) &#123; return Result.ok(Collections.emptyList()); &#125; List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent(); if (list.size() &lt;= from) &#123; // 没有下一页了，结束 return Result.ok(Collections.emptyList()); &#125; // 4.1.截取 from ~ end的部分 List&lt;Long&gt; ids = new ArrayList&lt;&gt;(list.size()); Map&lt;String, Distance&gt; distanceMap = new HashMap&lt;&gt;(list.size()); list.stream().skip(from).forEach(result -&gt; &#123; // 4.2.获取店铺id String shopIdStr = result.getContent().getName(); ids.add(Long.valueOf(shopIdStr)); // 4.3.获取距离 Distance distance = result.getDistance(); distanceMap.put(shopIdStr, distance); &#125;); // 5.根据id查询Shop String idStr = StrUtil.join(&quot;,&quot;, ids); List&lt;Shop&gt; shops = query().in(&quot;id&quot;, ids).last(&quot;ORDER BY FIELD(id,&quot; + idStr + &quot;)&quot;).list(); for (Shop shop : shops) &#123; shop.setDistance(distanceMap.get(shop.getId().toString()).getValue()); &#125; // 6.返回 return Result.ok(shops); &#125; 11、用户签到11.1、用户签到-BitMap功能演示我们针对签到功能完全可以通过mysql来完成，比如说以下这张表 用户一次签到，就是一条记录，假如有1000万用户，平均每人每年签到次数为10次，则这张表一年的数据量为 1亿条 每签到一次需要使用（8 + 8 + 1 + 1 + 3 + 1）共22 字节的内存，一个月则最多需要600多字节 我们如何能够简化一点呢？其实可以考虑小时候一个挺常见的方案，就是小时候，咱们准备一张小小的卡片，你只要签到就打上一个勾，我最后判断你是否签到，其实只需要到小卡片上看一看就知道了 我们可以采用类似这样的方案来实现我们的签到需求。 我们按月来统计用户签到信息，签到记录为1，未签到则记录为0. 把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这种思路就称为位图（BitMap）。这样我们就用极小的空间，来实现了大量数据的表示 Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是 2^32个bit位。 BitMap的操作命令有： SETBIT：向指定位置（offset）存入一个0或1 GETBIT ：获取指定位置（offset）的bit值 BITCOUNT ：统计BitMap中值为1的bit位的数量 BITFIELD ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值 BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回 BITOP ：将多个BitMap的结果做位运算（与 、或、异或） BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置 11.2 、用户签到-实现签到功能需求：实现签到接口，将当前用户当天签到信息保存到Redis中 思路：我们可以把年和月作为bitMap的key，然后保存到一个bitMap中，每次签到就到对应的位上把数字从0变成1，只要对应是1，就表明说明这一天已经签到了，反之则没有签到。 我们通过接口文档发现，此接口并没有传递任何的参数，没有参数怎么确实是哪一天签到呢？这个很容易，可以通过后台代码直接获取即可，然后到对应的地址上去修改bitMap。 代码 UserController 1234@PostMapping(&quot;/sign&quot;)public Result sign()&#123; return userService.sign();&#125; UserServiceImpl 123456789101112131415@Overridepublic Result sign() &#123; // 1.获取当前登录用户 Long userId = UserHolder.getUser().getId(); // 2.获取日期 LocalDateTime now = LocalDateTime.now(); // 3.拼接key String keySuffix = now.format(DateTimeFormatter.ofPattern(&quot;:yyyyMM&quot;)); String key = USER_SIGN_KEY + userId + keySuffix; // 4.获取今天是本月的第几天 int dayOfMonth = now.getDayOfMonth(); // 5.写入Redis SETBIT key offset 1 stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - 1, true); return Result.ok();&#125; 11.3 用户签到-签到统计问题1：什么叫做连续签到天数？从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。 Java逻辑代码：获得当前这个月的最后一次签到数据，定义一个计数器，然后不停的向前统计，直到获得第一个非0的数字即可，每得到一个非0的数字计数器+1，直到遍历完所有的数据，就可以获得当前月的签到总天数了 问题2：如何得到本月到今天为止的所有签到数据？ BITFIELD key GET u[dayOfMonth] 0 假设今天是10号，那么我们就可以从当前月的第一天开始，获得到当前这一天的位数，是10号，那么就是10位，去拿这段时间的数据，就能拿到所有的数据了，那么这10天里边签到了多少次呢？统计有多少个1即可。 问题3：如何从后向前遍历每个bit位？ 注意：bitMap返回的数据是10进制，哪假如说返回一个数字8，那么我哪儿知道到底哪些是0，哪些是1呢？我们只需要让得到的10进制数字和1做与运算就可以了，因为1只有遇见1 才是1，其他数字都是0 ，我们把签到结果和1进行与操作，每与一次，就把签到结果向右移动一位，依次内推，我们就能完成逐个遍历的效果了。 需求：实现下面接口，统计当前用户截止当前时间在本月的连续签到天数 有用户有时间我们就可以组织出对应的key，此时就能找到这个用户截止这天的所有签到记录，再根据这套算法，就能统计出来他连续签到的次数了 代码 UserController 1234@GetMapping(&quot;/sign/count&quot;)public Result signCount()&#123; return userService.signCount();&#125; UserServiceImpl 1234567891011121314151617181920212223242526272829303132333435363738394041@Overridepublic Result signCount() &#123; // 1.获取当前登录用户 Long userId = UserHolder.getUser().getId(); // 2.获取日期 LocalDateTime now = LocalDateTime.now(); // 3.拼接key String keySuffix = now.format(DateTimeFormatter.ofPattern(&quot;:yyyyMM&quot;)); String key = USER_SIGN_KEY + userId + keySuffix; // 4.获取今天是本月的第几天 int dayOfMonth = now.getDayOfMonth(); // 5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0 List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField( key, BitFieldSubCommands.create() .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(0) ); if (result == null || result.isEmpty()) &#123; // 没有任何签到结果 return Result.ok(0); &#125; Long num = result.get(0); if (num == null || num == 0) &#123; return Result.ok(0); &#125; // 6.循环遍历 int count = 0; while (true) &#123; // 6.1.让这个数字与1做与运算，得到数字的最后一个bit位 // 判断这个bit位是否为0 if ((num &amp; 1) == 0) &#123; // 如果为0，说明未签到，结束 break; &#125;else &#123; // 如果不为0，说明已签到，计数器+1 count++; &#125; // 把数字右移一位，抛弃最后一个bit位，继续下一个bit位 num &gt;&gt;&gt;= 1; &#125; return Result.ok(count);&#125; 11.4 额外加餐-关于使用bitmap来解决缓存穿透的方案回顾缓存穿透： 发起了一个数据库不存在的，redis里边也不存在的数据，通常你可以把他看成一个攻击 解决方案： 判断id&lt;0 如果数据库是空，那么就可以直接往redis里边把这个空数据缓存起来 第一种解决方案：遇到的问题是如果用户访问的是id不存在的数据，则此时就无法生效 第二种解决方案：遇到的问题是：如果是不同的id那就可以防止下次过来直击数据 所以我们如何解决呢？ 我们可以将数据库的数据，所对应的id写入到一个list集合中，当用户过来访问的时候，我们直接去判断list中是否包含当前的要查询的数据，如果说用户要查询的id数据并不在list集合中，则直接返回，如果list中包含对应查询的id数据，则说明不是一次缓存穿透数据，则直接放行。 现在的问题是这个主键其实并没有那么短，而是很长的一个 主键 哪怕你单独去提取这个主键，但是在11年左右，淘宝的商品总量就已经超过10亿个 所以如果采用以上方案，这个list也会很大，所以我们可以使用bitmap来减少list的存储空间 我们可以把list数据抽象成一个非常大的bitmap，我们不再使用list，而是将db中的id数据利用哈希思想，比如： id % bitmap.size &#x3D; 算出当前这个id对应应该落在bitmap的哪个索引上，然后将这个值从0变成1，然后当用户来查询数据时，此时已经没有了list，让用户用他查询的id去用相同的哈希算法， 算出来当前这个id应当落在bitmap的哪一位，然后判断这一位是0，还是1，如果是0则表明这一位上的数据一定不存在， 采用这种方式来处理，需要重点考虑一个事情，就是误差率，所谓的误差率就是指当发生哈希冲突的时候，产生的误差。 12、UV统计12.1 、UV统计-HyperLogLog首先我们搞懂两个概念： UV：全称Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。 PV：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。 通常来说UV会比PV大很多，所以衡量同一个网站的访问量，我们需要综合考虑很多因素，所以我们只是单纯的把这两个值作为一个参考值 UV统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到Redis中，数据量会非常恐怖，那怎么处理呢？ Hyperloglog(HLL)是从Loglog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。相关算法原理大家可以参考：https://juejin.cn/post/6844903785744056333#heading-0Redis中的HLL是基于string结构实现的，单个HLL的内存永远小于16kb，内存占用低的令人发指！作为代价，其测量结果是概率性的，有小于0.81％的误差。不过对于UV统计来说，这完全可以忽略。 12.2 UV统计-测试百万数据的统计测试思路：我们直接利用单元测试，向HyperLogLog中添加100万条数据，看看内存占用和统计效果如何 经过测试：我们会发生他的误差是在允许范围内，并且内存占用极小","categories":[],"tags":[]},{"title":"javaweb","slug":"javaweb","date":"2022-09-29T11:22:42.000Z","updated":"2022-10-13T07:32:36.113Z","comments":true,"path":"2022/09/29/javaweb/","link":"","permalink":"http://example.com/2022/09/29/javaweb/","excerpt":"","text":"Javaweb HTML.CSS,Javascript前端三刺客HTML是超文本标记语言，是一个网站页面的主要内容和主体框架（主要是实现内容） CSS是层叠样式表，主要用来控制调整网页的样式，它与网页的结构和内容没有关系，仅仅是通过不同语义的标签来调整网页内容的不同表现样式。(主要是实现表现，一种呈现的效果) JavaScript是一种完整的网页脚本语言，有自己独立的语法，可以完成复杂的程序逻辑，而HTML和CSS仅仅是标记语言，不具备编程语言的程序逻辑。(行为，指的是页面中元素与输入设备交互的响应，一般使用javascript技术实现) B&#x2F;S软件结构： 客户端：浏览器 服务器端：web服务器 HTMLhtml书写规范1234567891011&lt;!DOCTYPE html&gt;&lt;!--约束，声明--&gt;&lt;html lang=&quot;zh_CN&quot;&gt;&lt;!--html标签表示html的开始 lang=&quot;zh_CN表示中文&quot;--&gt;&lt;!--html标签中一般分为两部分，head和body--&gt;&lt;head&gt; &lt;!--表示头部信息，一般包含三部分内容，title标签，css样式，js代码--&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;!--表示当前页面使用UTF-8字符集--&gt; &lt;title&gt;标题&lt;/title&gt;&lt;!--表示标题--&gt;&lt;/head&gt;&lt;body&gt;&lt;!--body标签是整个html页面显示的主体内容--&gt;hello&lt;/body&gt;&lt;/html&gt; html标签1.标签名大小写不敏感 2.标签名有自己的属性 基本属性：bgcolor&#x3D;“red” 可以修改简单的样式 12&lt;!--背景颜色属性--&gt;&lt;body bgcolor=&quot;green&quot;&gt;&lt;!--body标签是整个html页面显示的主体内容--&gt; 事件属性： onclick&#x3D;“alert(‘你好’);” 点击body主题内容触发 12&lt;!--onclick表示点击事件--&gt;&lt;body onclick=&quot;alert(1)&quot;&gt;&lt;!--body标签是整个html页面显示的主体内容--&gt; 3.分为单标签和双标签 &lt;标签名 &#x2F;&gt; 和&lt;标签名&gt; &lt;&#x2F;标签名&gt; 1&lt;br /&gt;换行 &lt;hr /&gt; 标签语法 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;0-标签语法.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- ①标签不能交叉嵌套 --&gt; 正确：&lt;div&gt;&lt;span&gt;早安，尚硅谷&lt;/span&gt;&lt;/div&gt; 错误：&lt;div&gt;&lt;span&gt;早安，尚硅谷&lt;/div&gt;&lt;/span&gt; &lt;hr /&gt; &lt;!-- ②标签必须正确关闭(闭合) --&gt; &lt;!-- i.有文本内容的标签： --&gt; 正确：&lt;div&gt;早安，尚硅谷&lt;/div&gt; 错误：&lt;div&gt;早安，尚硅谷 &lt;hr /&gt; &lt;!-- ii.没有文本内容的标签： --&gt; 正确：&lt;br /&gt;1 错误：&lt;br &gt;2 &lt;hr /&gt; &lt;!-- ③属性必须有值，属性值必须加引号 --&gt; 正确：&lt;font color=&quot;blue&quot;&gt;早安，尚硅谷&lt;/font&gt; 错误：&lt;font color=blue&gt;早安，尚硅谷&lt;/font&gt; 错误：&lt;font color&gt;早安，尚硅谷&lt;/font&gt; &lt;hr /&gt; &lt;!-- ④注释不能嵌套 --&gt; 正确：&lt;!-- 注释内容 --&gt; &lt;br/&gt; 错误：&lt;!-- 注释内容 &lt;!-- 注释内容 --&gt;--&gt; &lt;hr /&gt;&lt;/body&gt;&lt;/html&gt; font标签 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;1.font标签.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 字体标签 需求1：在网页上显示 我是字体标签 ，并修改字体为 宋体，颜色为红色。 font标签是字体标签,它可以用来修改文本的字体,颜色,大小(尺寸) color属性修改颜色 face属性修改字体 size属性修改文本大小 --&gt; &lt;font color=&quot;red&quot; face=&quot;宋体&quot; size=&quot;7&quot;&gt;我是字体标签&lt;/font&gt;&lt;/body&gt;&lt;/html&gt; 特殊字符 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;2.特殊字符.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 特殊字符 需求1：把 &lt;br&gt; 换行标签 变成文本 转换成字符显示在页面上 常用的特殊字符: &lt; ===&gt;&gt;&gt;&gt; &amp;lt; &gt; ===&gt;&gt;&gt;&gt; &amp;gt; 空格 ===&gt;&gt;&gt;&gt; &amp;nbsp;如果在html文件中出现多个空白字符，那么就只保留一个，必须用特殊字符才可以出现多个空格 --&gt; 我是&amp;lt;br&amp;gt;标签&lt;br/&gt; 国哥好&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;帅啊!&lt;/body&gt;&lt;/html&gt; 标题标签 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;3.标题标签.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 标题标签 需求1：演示标题1到 标题6的 h1 - h6 都是标题标签 h1 最大 h6 最小 align 属性是对齐属性 left 左对齐(默认) center 剧中 right 右对齐 --&gt; &lt;h1 align=&quot;left&quot;&gt;标题1&lt;/h1&gt; &lt;h2 align=&quot;center&quot;&gt;标题2&lt;/h2&gt; &lt;h3 align=&quot;right&quot;&gt;标题3&lt;/h3&gt; &lt;h4&gt;标题4&lt;/h4&gt; &lt;h5&gt;标题5&lt;/h5&gt; &lt;h6&gt;标题6&lt;/h6&gt; &lt;h7&gt;标题7&lt;/h7&gt;&lt;/body&gt;&lt;/html&gt; 超链接标签 网页中点击跳转的内容就是超链接 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;4.超链接.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- a标签是 超链接 href属性设置连接的地址 target属性设置哪个目标进行跳转 _self 表示当前页面(默认值) _blank 表示打开新页面来进行跳转 --&gt; &lt;a href=&quot;http://localhost:8080&quot;&gt;百度&lt;/a&gt;&lt;br/&gt; &lt;a href=&quot;http://localhost:8080&quot; target=&quot;_self&quot;&gt;百度_self&lt;/a&gt;&lt;br/&gt; &lt;a href=&quot;http://localhost:8080&quot; target=&quot;_blank&quot;&gt;百度_blank&lt;/a&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 列表标签 和浏览器有关的或多或少都会有一些兼容问题，所以换了个浏览器可能会不一样比如下面的type 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--需求1：使用无序，列表方式，把东北F4，赵四，刘能，小沈阳，宋小宝，展示出来 ul 是无序列表 type属性可以修改列表项前面的符号 li 是列表项 --&gt; &lt;!--无序列表--&gt; &lt;ul type=&quot;none&quot;&gt; &lt;li&gt;赵四&lt;/li&gt; &lt;li&gt;刘能&lt;/li&gt; &lt;li&gt;小沈阳&lt;/li&gt; &lt;li&gt;宋小宝&lt;/li&gt; &lt;/ul&gt; &lt;!--有序列表,前面会加上序号--&gt; &lt;ol type=&quot;none&quot;&gt; &lt;li&gt;赵四&lt;/li&gt; &lt;li&gt;刘能&lt;/li&gt; &lt;li&gt;小沈阳&lt;/li&gt; &lt;li&gt;宋小宝&lt;/li&gt; &lt;/ol&gt;&lt;/body&gt;&lt;/html&gt; img标签 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;5.img标签.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--需求1：使用img标签显示一张美女的照片。并修改宽高，和边框属性 img标签是图片标签,用来显示图片 src属性可以设置图片的路径 width属性设置图片的宽度 height属性设置图片的高度 border属性设置图片边框大小 alt属性设置当指定路径找不到图片时,用来代替显示的文本内容 在JavaSE中路径也分为相对路径和绝对路径. 相对路径:从工程名开始算 绝对路径:盘符:/目录/文件名 在web中路径分为相对路径和绝对路径两种 相对路径: . 表示当前文件所在的目录 .. 表示当前文件所在的上一级目录 文件名 表示当前文件所在目录的文件,相当于 ./文件名 ./ 可以省略 绝对路径: 正确格式是: http://ip:port/工程名/资源路径 错误格式是: 盘符:/目录/文件名 --&gt; &lt;!--下面这些值的单位是像素--&gt; &lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;260&quot; border=&quot;1&quot; alt=&quot;美女找不到&quot;/&gt; &lt;img src=&quot;../../2.jpg&quot; width=&quot;200&quot; height=&quot;260&quot; alt=&quot;美女找不到&quot; /&gt; &lt;img src=&quot;../imgs/3.jpg&quot; width=&quot;200&quot; height=&quot;260&quot; /&gt; &lt;img src=&quot;../imgs/4.jpg&quot; width=&quot;200&quot; height=&quot;260&quot; /&gt; &lt;img src=&quot;../imgs/5.jpg&quot; width=&quot;200&quot; height=&quot;260&quot; /&gt; &lt;img src=&quot;../imgs/6.jpg&quot; width=&quot;200&quot; height=&quot;260&quot; /&gt;&lt;/body&gt;&lt;/html&gt; 表格标签 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;表格标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 需求1：做一个 带表头的 ，三行，三列的表格，并显示边框 需求2：修改表格的宽度，高度，表格的对齐方式，单元格间距。 table 标签是表格标签 border 设置表格标框 width 设置表格宽度 height 设置表格高度 align 设置表格相对于页面的对齐方式 cellspacing 设置单元格间距 tr 是行标签 th 是表头标签 td 是单元格标签 align 设置单元格文本对齐方式 b 是加粗标签 --&gt;&lt;table align=&quot;center&quot; border=&quot;1&quot; width=&quot;300&quot; height=&quot;300&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;th&gt;1.1&lt;/th&gt; &lt;!--注释上面和下面的两个标签是等价的--&gt; &lt;td align=&quot;center&quot;&gt;&lt;b&gt;1.1&lt;/b&gt;&lt;/td&gt; &lt;th&gt;1.2&lt;/th&gt; &lt;th&gt;1.3&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2.1&lt;/td&gt; &lt;td&gt;2.2&lt;/td&gt; &lt;td&gt;2.3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3.1&lt;/td&gt; &lt;td&gt;3.2&lt;/td&gt; &lt;td&gt;3.3&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 表格跨行跨列标签 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;7.表格的跨行跨列&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;!-- 需求1： 新建一个五行，五列的表格， 第一行，第一列的单元格要跨两列， 第二行第一列的单元格跨两行， 第四行第四列的单元格跨两行两列。 colspan 属性设置跨列，被作用的单元格横向合并一个 rowspan 属性设置跨行,指的是被作用的单元格向下合并一个 --&gt; &lt;table width=&quot;500&quot; height=&quot;500&quot; cellspacing=&quot;0&quot; border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;1.1&lt;/td&gt; &lt;td&gt;1.3&lt;/td&gt; &lt;td&gt;1.4&lt;/td&gt; &lt;td&gt;1.5&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspqn=&quot;2&quot;&gt;2.1&lt;/td&gt; &lt;td&gt;2.2&lt;/td&gt; &lt;td&gt;2.3&lt;/td&gt; &lt;td&gt;2.4&lt;/td&gt; &lt;td&gt;2.5&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3.2&lt;/td&gt; &lt;td&gt;3.3&lt;/td&gt; &lt;td&gt;3.4&lt;/td&gt; &lt;td&gt;3.5&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;4.1&lt;/td&gt; &lt;td&gt;4.2&lt;/td&gt; &lt;td&gt;4.3&lt;/td&gt; &lt;td colspan=&quot;2&quot; rowspan=&quot;2&quot;&gt;4.4&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;5.1&lt;/td&gt; &lt;td&gt;5.2&lt;/td&gt; &lt;td&gt;5.3&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; iframe标签 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;8.iframe标签.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 我是一个单独的完整的页面&lt;br/&gt;&lt;br/&gt; &lt;!--ifarme标签可以在页面上开辟一个小区域显示一个单独的页面 ifarme和a标签组合使用的步骤: 1 在iframe标签中使用name属性定义一个名称 2 在a标签的target属性上设置iframe的name的属性值 --&gt; &lt;iframe src=&quot;3.标题标签.html&quot; width=&quot;200&quot; height=&quot;200&quot; name=&quot;abc&quot;&gt;&lt;/iframe&gt; &lt;br/&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;0-标签语法.html&quot; target=&quot;abc&quot;&gt;0-标签语法.html&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;1.font标签.html&quot; target=&quot;abc&quot;&gt;1.font标签.html&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;2.特殊字符.html&quot; target=&quot;abc&quot;&gt;2.特殊字符.html&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 表单显示 什么是表单，表单就是html页面中用来收集用户信息的所有元素的集合，然后把这些信息发送给服务器 同时用标签让表单像表格一样的形式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;表单的显示&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--需求1:创建一个个人信息注册的表单界面。包含用户名，密码，确认密码。性别（单选），兴趣爱好（多选），国籍（下拉列表）。隐藏域，自我评价（多行文本域）。重置，提交。--&gt; &lt;!-- form标签就是表单 input type=text 是文件输入框 value设置默认显示内容 input type=password 是密码输入框 value设置默认显示内容 input type=radio 是单选框 name属性可以对其进行分组 checked=&quot;checked&quot;表示默认选中 input type=checkbox 是复选框 checked=&quot;checked&quot;表示默认选中 input type=reset 是重置按钮 value属性修改按钮上的文本 input type=submit 是提交按钮 value属性修改按钮上的文本 input type=button 是按钮 value属性修改按钮上的文本 input type=file 是文件上传域 input type=hidden 是隐藏域 当我们要发送某些信息，而这些信息，不需要用户参与，就可以使用隐藏域（提交的时候同时发送给服务器） select 标签是下拉列表框 option 标签是下拉列表框中的选项 selected=&quot;selected&quot;设置默认选中 textarea 表示多行文本输入框 （起始标签和结束标签中的内容是默认值） rows 属性设置可以显示几行的高度 cols 属性设置每行可以显示几个字符宽度 --&gt; &lt;form&gt; &lt;h1 align=&quot;center&quot;&gt;用户注册&lt;/h1&gt; &lt;table align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td&gt; 用户名称：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; value=&quot;默认值&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 用户密码：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; value=&quot;abc&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;确认密码：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; value=&quot;abc&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot;/&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked=&quot;checked&quot; /&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 兴趣爱好：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; /&gt;Java &lt;input type=&quot;checkbox&quot; /&gt;JavaScript &lt;input type=&quot;checkbox&quot; /&gt;C++ &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;国籍：&lt;/td&gt; &lt;td&gt; &lt;select&gt; &lt;option&gt;--请选择国籍--&lt;/option&gt; &lt;option selected=&quot;selected&quot;&gt;中国&lt;/option&gt; &lt;option&gt;美国&lt;/option&gt; &lt;option&gt;小日本&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;自我评价：&lt;/td&gt; &lt;td&gt;&lt;textarea rows=&quot;10&quot; cols=&quot;20&quot;&gt;我才是默认值&lt;/textarea&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;reset&quot; /&gt;&lt;/td&gt; &lt;td align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;文件上传&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;file&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 表单提交的细节 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;表单的显示&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- form标签是表单标签 action属性设置提交的服务器地址 method属性设置提交的方式GET(默认值)或POST 表单提交的时候，数据没有发送给服务器的三种情况： 1、表单项没有name属性值(可是我测试的真实情况是没有也可以) 2、单选、复选（下拉列表中的option标签）都需要添加value属性，以便发送给服务器 3、表单项不在提交的form标签中 GET请求的特点是： 1、浏览器地址栏中的地址是：action属性[+?+请求参数] 请求参数的格式是：name=value&amp;name=value 2、不安全 3、它有数据长度的限制 POST请求的特点是： 1、浏览器地址栏中只有action属性值 2、相对于GET请求要安全 3、理论上没有数据长度的限制 --&gt; &lt;form action=&quot;http://www.baidu.com&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;login&quot; /&gt; &lt;h1 align=&quot;center&quot;&gt;用户注册&lt;/h1&gt; &lt;table align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td&gt; 用户名称：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;默认值&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 用户密码：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;abc&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;boy&quot;/&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked=&quot;checked&quot; value=&quot;girl&quot; /&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 兴趣爱好：&lt;/td&gt; &lt;td&gt; &lt;input name=&quot;hobby&quot; type=&quot;checkbox&quot; checked=&quot;checked&quot; value=&quot;java&quot;/&gt;Java &lt;input name=&quot;hobby&quot; type=&quot;checkbox&quot; value=&quot;js&quot;/&gt;JavaScript &lt;input name=&quot;hobby&quot; type=&quot;checkbox&quot; value=&quot;cpp&quot;/&gt;C++ &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;国籍：&lt;/td&gt; &lt;td&gt; &lt;select name=&quot;country&quot;&gt; &lt;option value=&quot;none&quot;&gt;--请选择国籍--&lt;/option&gt; &lt;option value=&quot;cn&quot; selected=&quot;selected&quot;&gt;中国&lt;/option&gt; &lt;option value=&quot;usa&quot;&gt;美国&lt;/option&gt; &lt;option value=&quot;jp&quot;&gt;小日本&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;自我评价：&lt;/td&gt; &lt;td&gt;&lt;textarea name=&quot;desc&quot; rows=&quot;10&quot; cols=&quot;20&quot;&gt;我才是默认值&lt;/textarea&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;reset&quot; /&gt;&lt;/td&gt; &lt;td align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 其他标签div span p等等 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;其他标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--需求1：div、span、p标签的演示 div标签 默认独占一行 span标签 它的长度是封装数据的长度 p段落标签 默认会在段落的上方和下方各空出一行来（如果已有就不再空） --&gt; &lt;div&gt;div标签1&lt;/div&gt; &lt;div&gt;div标签2&lt;/div&gt; &lt;span&gt;span标签1&lt;/span&gt; &lt;span&gt;span标签2&lt;/span&gt; &lt;p&gt;p段落标签1&lt;/p&gt; &lt;p&gt;p段落标签2&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; CSScss是层叠样式表单，是用于控制网页样式并允许将样式信息与网页内容分割的一种标记性语言 选择器：1.浏览器根据选择器绝顶受css样式影响的html元素&lt;标签&gt; 属性：是你要改变的样式名，并且每一个属性都有一个值，属性和值被冒号分开，并由花括号包裹，这样就是一个完整的声明，例如 p{color:blue} 多个声明：如果要定义不止一个声明，则需要用分号将每个声明分开，虽然最后一条声明的最后可以不加分号，但尽量在每条声明的末尾加上分号 例如： p{ color:red; font-size:30px; } 不过一般一行只写一个属性 css注释&#x2F;* *&#x2F; CSS和HTML的结合方式结合方式一 在标签的属性上设置“key:value value”,修改标签样式 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--需求1：分别定义两个 div、span标签，分别修改每个 div 标签的样式为：边框1个像素，实线，红色。--&gt; &lt;div style=&quot;border: 1px solid red;&quot;&gt;div标签1&lt;/div&gt; &lt;div style=&quot;border: 1px solid red;&quot;&gt;div标签2&lt;/div&gt; &lt;span style=&quot;border: 1px solid red;&quot;&gt;span标签1&lt;/span&gt; &lt;span style=&quot;border: 1px solid red;&quot;&gt;span标签2&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 缺点：1.如果标签写多了，样式多了，代码量太大 ​ 2.可读性非常差 ​ 3.Css代码没有什么复用性可言 结合方式二 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--style标签专门用来定义css样式代码--&gt; &lt;style type=&quot;text/css&quot;&gt; /* 需求1：分别定义两个 div、span标签，分别修改每个 div 标签的样式为：边框1个像素，实线，红色。*/ div&#123; border: 1px solid red; &#125; span&#123; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;div标签1&lt;/div&gt; &lt;div&gt;div标签2&lt;/div&gt; &lt;span&gt;span标签1&lt;/span&gt; &lt;span&gt;span标签2&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 缺点：1.只能在一个页面内复用代码，不能再多个页面中复用css代码 ​ 2.维护起来不方便，实际的项目中会有成千上万的也买你，要到每个页面中去修改，工作量太大了 结合方式三 把css样式写成一个单独的css文件，再通过link标签引入即可复用 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--link标签专门用来引入css样式代码--&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;1.css&quot;/&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;div标签1&lt;/div&gt; &lt;div&gt;div标签2&lt;/div&gt; &lt;span&gt;span标签1&lt;/span&gt; &lt;span&gt;span标签2&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 标签名选择器标签名选择器的格式是 标签名{ 属性:值 } 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;CSS选择器&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123; border: 1px solid yellow; color: blue; font-size: 30px; &#125; span&#123; border: 5px dashed blue; color: yellow; font-size: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 需求1：在所有div标签上修改字体颜色为蓝色，字体大小30个像素。边框为1像素黄色实线。 并且修改所有span 标签的字体颜色为黄色，字体大小20个像素。边框为5像素蓝色虚线。 --&gt; &lt;div&gt;div标签1&lt;/div&gt; &lt;div&gt;div标签2&lt;/div&gt; &lt;span&gt;span标签1&lt;/span&gt; &lt;span&gt;span标签2&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 标签名选择器可以决定哪些标签被动的使用这个样式 id选择器id选择器的格式是： #id 属性值{ 属性:值 } id选择器，可以让我们通过id属性选择性的去使用这个样式 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;ID选择器&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #id001&#123; color: blue; font-size: 30px; border: 1px yellow solid; &#125; #id002&#123; color: red; font-size: 20px; border: 5px blue dotted ; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 需求1：分别定义两个 div 标签， 第一个div 标签定义 id 为 id001 ，然后根据id 属性定义css样式修改字体颜色为蓝色， 字体大小30个像素。边框为1像素黄色实线。 第二个div 标签定义 id 为 id002 ，然后根据id 属性定义css样式 修改的字体颜色为红色，字体大小20个像素。 边框为5像素蓝色点线。 --&gt; &lt;div id=&quot;id002&quot;&gt;div标签1&lt;/div&gt; &lt;div id=&quot;id001&quot;&gt;div标签2&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; class选择器class 类型选择器的格式是 .class属性值{ 属性:值 } class类型选择器可以通过class属性有效的选择地去使用这个样式 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;class类型选择器&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .class01&#123; color: blue; font-size: 30px; border: 1px solid yellow; &#125; .class02&#123; color: grey; font-size: 26px; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 需求1：修改 class 属性值为 class01的 span 或 div 标签，字体颜色为蓝色，字体大小30个像素。边框为1像素黄色实线。 需求2：修改 class 属性值为 class02的 div 标签，字体颜色为灰色，字体大小26个像素。边框为1像素红色实线。 --&gt; &lt;div class=&quot;class01&quot;&gt;div标签class01&lt;/div&gt; &lt;div class=&quot;class02&quot;&gt;div标签&lt;/div&gt; &lt;span class=&quot;class02&quot;&gt;span标签class01&lt;/span&gt; &lt;span&gt;span标签2&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 组合选择器组合选择器的格式是： 选择器1,选择器2,选择器n{ 属性:值 } 让多个选择器或者多种类型的选择器共用同一块代码 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;class类型选择器&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .class01 , #id01&#123; color: blue; font-size: 20px; border: yellow 1px solid; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 需求1：修改 class=&quot;class01&quot; 的div 标签 和 id=&quot;id01&quot; 所有的span标签， 字体颜色为蓝色，字体大小20个像素。边框为1像素黄色实线。 --&gt; &lt;div id=&quot;id01&quot;&gt;div标签class01&lt;/div&gt; &lt;br /&gt; &lt;span class=&quot;class01&quot;&gt;span 标签&lt;/span&gt; &lt;br /&gt; &lt;div&gt;div标签&lt;/div&gt; &lt;br /&gt; &lt;div&gt;div标签id01&lt;/div&gt; &lt;br /&gt;&lt;/body&gt;&lt;/html&gt; css常用样式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;06-css常用样式.html&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123; color: red; 红色 border: 1px yellow solid; 边框属性 width: 300px; 宽度 height: 300px; 高度 background-color: green; 背景颜色 font-size: 30px; 字体大小 margin-left: auto; 这个和下面那个两行表示div居中 margin-right: auto; text-align: center; 文字居中 &#125; table&#123; border: 1px red solid; 设置边框 border-collapse: collapse; 将边框合并，就是td单元格的边框和表格的边框合并 &#125; td&#123; border: 1px red solid; &#125; a&#123; text-decoration: none; 超链接去下划线 &#125; ul&#123; list-style: none; 列表去除修饰 &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;11111111111&lt;/li&gt; &lt;li&gt;11111111111&lt;/li&gt; &lt;li&gt;11111111111&lt;/li&gt; &lt;li&gt;11111111111&lt;/li&gt; &lt;li&gt;11111111111&lt;/li&gt; &lt;/ul&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;1.1&lt;/td&gt; &lt;td&gt;1.2&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; &lt;div&gt;我是div标签&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; JavascriptjQueryjQuery就是javascript和查询，他就是辅助javascript开发的js类库 jQuery 的核心思想就是write less ，do more 所以他实现了很多浏览器的兼容问题 基础使用 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; // window.onload = function () &#123; // var btnObj = document.getElementById(&quot;btnId&quot;); // // alert(btnObj);//[object HTMLButtonElement] ====&gt;&gt;&gt; dom对象 // btnObj.onclick = function () &#123; // alert(&quot;js 原生的单击事件&quot;); // &#125; // &#125; $(function () &#123; // 表示页面加载完成 之后，相当 window.onload = function () &#123;&#125; var $btnObj = $(&quot;#btnId&quot;); // 表示按id查询标签对象，jQuery对象变量都加一个$ $btnObj.click(function () &#123; // 绑定单击事件 alert(&quot;jQuery 的单击事件&quot;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btnId&quot;&gt;SayHello&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; jQuery中的$是一个函数 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt; &lt;!--引入jQuery文件--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; //使用$()代替window.onload$(function()&#123; //使用选择器获取按钮对象，随后绑定单击响应函数 //表示按id查询对象 $(&quot;#btnId&quot;).click(function()&#123; //弹出Hello alert(&#x27;Hello&#x27;); &#125;); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btnId&quot;&gt;SayHello&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 为按钮添加响应函数 1.使用jQuery查询到标签对象 2.使用标签对象.click(function(){}); $介绍$是jQuery的核心函数，能完成jQuery的很多功能，$()就是调用$这个函数 1.传入的参数是函数时 表示页面加载完成之后。相当于window.onload&#x3D;function(){}; 2.传入的参数为HTML字符串时，会对我们创建这个html标签对象 3.传入参数为【选择器字符串时】， $(“#id属性值”)：id选择器，根据id查询标签对象 $(“标签名”): 标签名选择器，根据指定的标签名查询标签对象 $(“.class属性值”):类型选择器，根据class属性查询标签对象 4.传入的参数是dom对象，将这个dom对象转换为jQuery对象 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; //核心函数的4个作用 $(function () &#123; // alert(&quot;页面加载完成之后，自动调用&quot;);//将生成的html标签对象直接加给了body标签，这样就可以显示 $(&quot; &lt;div&gt;&quot; + &quot; &lt;span&gt;div-span1&lt;/span&gt;&quot; + &quot; &lt;span&gt;div-span2&lt;/span&gt;&quot; + &quot; &lt;/div&gt;&quot;).appendTo(&quot;body&quot;); // alert($(&quot;button&quot;).length); var btnObj = document.getElementById(&quot;btn01&quot;); // alert(btnObj); // alert( $(btnObj) ); // alert( $(&quot;&lt;h1&gt;&lt;/h1&gt;&quot;) ); alert($(&quot;button&quot;)); &#125;); //传入参数为[函数]时：在文档加载完成后执行这个函数 //传入参数为[HTML字符串]时：根据这个字符串创建元素节点对象，创建的是jQuery对象 //传入参数为[选择器字符串]时：根据这个字符串查找元素节点对象，创建的是jQuery对象 //传入参数为[DOM对象]时：将DOM对象包装为jQuery对象返回&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn01&quot;&gt;按钮1&lt;/button&gt; &lt;button&gt;按钮2&lt;/button&gt; &lt;button&gt;按钮3&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; jQuery对象和dom对象区分DOM对象 1.通过各种方法查询出来的标签对象是dom对象 jQuery对象 1.通过jQuery提供的API创建的对象，是jQuery对象 alert( $(““) ); 2.通过JQuery包装的Dom对象，也是JQuery对象 alert( $(btnObj) ); btnObj是一个dom对象 3.它通过JQuery提供的API查询到的对象，是JQuery对象 alert($(“button”)); JQuery对象alert出来的效果是[Object Object] jQuery对象的本质jQuery对象是 dom对象的数组+jQuery提供的一系列功能函数 jQuery对象和Dom对象的使用区别jQuery对象不能使用dom对象的属性和方法 dom对象也不能使用jQuery对象的属性和方法 Dom对象和JQuery对象之间的相互转换1.dom对象转化为jQUery对象 现有Dom对象，然后 $(Dom)对象就可以转换为jQuery对象 2.jQuery对象转为dom对象 现有jQuery对象，jQuery对象[下标]取出相应的dom对象 Insert title here ​ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 //jQuery对象的本质的演示 $(function()&#123; //testDiv.css(&quot;color&quot;,&quot;red&quot;) //testDiv.style.color = &quot;blue&quot;; // var arr = [12,&quot;abc&quot;,true]; // // var $btns = $(&quot;button&quot;); // // for (var i = 0; i &lt; $btns.length; i++)&#123; // alert($btns[i]); // &#125; //jQuery和Dom的使用区别的演示 //document.getElementById(&quot;testDiv&quot;).innerHTML = &quot;这是dom对象的属性InnerHTML&quot;; //$(&quot;#testDiv&quot;).innerHTML = &quot;这是dom对象的属性InnerHTML&quot;; //$(&quot;#testDiv&quot;).click(function () &#123; //alert(&quot;click()是jQuery对象的方法&quot;); //&#125;); //document.getElementById(&quot;testDiv&quot;).click(function () &#123; //alert(&quot;click()是jQuery对象的方法&quot;); //&#125;); //下面是jQuery对象转换为dom对象的演示，用下标来取出 // alert( $(document.getElementById(&quot;testDiv&quot;))[0] ); alert( $(&quot;button:first&quot;) ); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;testDiv&quot;&gt;Atguigu is Very Good!&lt;/div&gt; &lt;button id=&quot;dom2dom&quot;&gt;使用DOM对象调用DOM方法&lt;/button&gt; &lt;button id=&quot;dom2jQuery&quot;&gt;使用DOM对象调用jQuery方法&lt;/button&gt; &lt;button id=&quot;jQuery2jQuery&quot;&gt;使用jQuery对象调用jQuery方法&lt;/button&gt; &lt;button id=&quot;jQuery2dom&quot;&gt;使用jQuery对象调用DOM方法&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; jQuery基本选择器基本选择器 #ID 选择器：根据id查找标签对象 .class 选择器：根据class查找标签对象 element 选择器：根据标签名查找标签对象 *选择器：表示任意的，所有的元素 selector1,selector2 组合器：合并选择器1,选择器2的结果并返回 特殊的 p.myClass表示标签名必须是p标签，而且class类型还要是myClass 基本选择器的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; &lt;!--应该是div标签且class为mini--&gt; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; //1.选择 id 为 one 的元素 &quot;background-color&quot;,&quot;#bbffaa&quot; $(&quot;#btn1&quot;).click(function () &#123; // css() 方法 可以设置和获取样式,第二个参数是颜色属性的值 $(&quot;#one&quot;).css(&quot;background-color&quot;,&quot;#bbffaa&quot;); &#125;); //2.选择 class 为 mini 的所有元素 $(&quot;#btn2&quot;).click(function () &#123; $(&quot;.mini&quot;).css(&quot;background-color&quot;,&quot;#bbffaa&quot;); &#125;); //3.选择 元素名是 div 的所有元素 $(&quot;#btn3&quot;).click(function () &#123; $(&quot;div&quot;).css(&quot;background-color&quot;,&quot;#bbffaa&quot;); &#125;); //4.选择所有的元素 $(&quot;#btn4&quot;).click(function () &#123; $(&quot;*&quot;).css(&quot;background-color&quot;,&quot;#bbffaa&quot;); &#125;); //5.选择所有的 span 元素和id为two的元素 $(&quot;#btn5&quot;).click(function () &#123; $(&quot;span,#two&quot;).css(&quot;background-color&quot;,&quot;#bbffaa&quot;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;!-- &lt;div&gt; &lt;h1&gt;基本选择器&lt;/h1&gt; &lt;/div&gt; --&gt; &lt;input type=&quot;button&quot; value=&quot;选择 id 为 one 的元素&quot; id=&quot;btn1&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择 class 为 mini 的所有元素&quot; id=&quot;btn2&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择 元素名是 div 的所有元素&quot; id=&quot;btn3&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择 所有的元素&quot; id=&quot;btn4&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择 所有的 span 元素和id为two的元素&quot; id=&quot;btn5&quot; /&gt; &lt;br&gt; &lt;div class=&quot;one&quot; id=&quot;one&quot;&gt; id 为 one,class 为 one 的div &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot; id=&quot;two&quot; title=&quot;test&quot;&gt; id为two,class为one,title为test的div &lt;div class=&quot;mini&quot; title=&quot;other&quot;&gt;class为mini,title为other&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;test&quot;&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;tesst&quot;&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;!--display:none就是不显示--&gt; &lt;div style=&quot;display:none;&quot; class=&quot;none&quot;&gt;style的display为&quot;none&quot;的div&lt;/div&gt; &lt;div class=&quot;hide&quot;&gt;class为&quot;hide&quot;的div&lt;/div&gt; &lt;div&gt; 包含input的type为&quot;hidden&quot;的div&lt;input type=&quot;hidden&quot; size=&quot;8&quot;&gt; &lt;/div&gt; &lt;span class=&quot;one&quot; id=&quot;span&quot;&gt;^^span元素^^&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; jQuery层级选择器ancestor descendant 后代选择器 ：在给定的祖先元素下匹配所有的后代元素 parent &gt; child 子元素选择器：在给定的父元素下匹配所有的子元素 prev + next 相邻元素选择器：匹配所有紧接在 prev 元素后的 next 元素 prev ~ sibings 之后的兄弟元素选择器：匹配 prev 元素之后的所有 siblings 元素 儿子元素和孙子元素是有区别的，而且后代元素包括所有的后代包括儿子孙子 $(“lable + input”) 所有紧跟在lable标签后面的input标签，必须是紧跟 $(“form &gt; input”)匹配表单中所有的子级input元素，只有儿子辈的，没有孙子辈的 $(“form input”)匹配form后代的所有的input元素 $(“form ~input”)找到form后面所有与form同辈的input元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; //$(function()&#123;&#125;);的全写 //1.选择 body 内的所有 div 元素 $(&quot;#btn1&quot;).click(function()&#123; $(&quot;body div&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //2.在 body 内, 选择div子元素 $(&quot;#btn2&quot;).click(function()&#123; $(&quot;body &gt; div&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //3.选择 id 为 one 的下一个 div 元素 $(&quot;#btn3&quot;).click(function()&#123; $(&quot;#one+div&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //4.选择 id 为 two 的元素后面的所有 div 兄弟元素 $(&quot;#btn4&quot;).click(function()&#123; $(&quot;#two~div&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- &lt;div&gt; &lt;h1&gt;层级选择器:根据元素的层级关系选择元素&lt;/h1&gt; ancestor descendant ： parent &gt; child ： prev + next ： prev ~ siblings ： &lt;/div&gt; --&gt; &lt;input type=&quot;button&quot; value=&quot;选择 body 内的所有 div 元素&quot; id=&quot;btn1&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;在 body 内, 选择div子元素&quot; id=&quot;btn2&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择 id 为 one 的下一个 div 元素&quot; id=&quot;btn3&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择 id 为 two 的元素后面的所有 div 兄弟元素&quot; id=&quot;btn4&quot; /&gt; &lt;br&gt;&lt;br&gt; &lt;div class=&quot;one&quot; id=&quot;one&quot;&gt; id 为 one,class 为 one 的div &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot; id=&quot;two&quot; title=&quot;test&quot;&gt; id为two,class为one,title为test的div &lt;div class=&quot;mini&quot; title=&quot;other&quot;&gt;class为mini,title为other&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;test&quot;&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;tesst&quot;&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;display:none;&quot; class=&quot;none&quot;&gt;style的display为&quot;none&quot;的div&lt;/div&gt; &lt;div class=&quot;hide&quot;&gt;class为&quot;hide&quot;的div&lt;/div&gt; &lt;div&gt; 包含input的type为&quot;hidden&quot;的div&lt;input type=&quot;hidden&quot; size=&quot;8&quot;&gt; &lt;/div&gt; &lt;span id=&quot;span&quot;&gt;^^span元素^^&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; jQuery基本过滤选择器:first 获取第一个元素 :last 获取最后个元素 :not(selector) 去除所有与给定选择器匹配的元素 :even 匹配所有索引值为偶数的元素，从 0 开始计数 :odd 匹配所有索引值为奇数的元素，从 0 开始计数 :eq(index) 匹配一个给定索引值的元素 :gt(index) 匹配所有大于给定索引值的元素 :lt(index) 匹配所有小于给定索引值的元素 :header 匹配如 h1, h2, h3 之类的标题元素 :animated 匹配所有正在执行动画效果的元 :hidden匹配被隐藏起来的元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; //这是一个动画的代码 $(document).ready(function()&#123; function anmateIt()&#123; $(&quot;#mover&quot;).slideToggle(&quot;slow&quot;, anmateIt); &#125; anmateIt(); &#125;); $(document).ready(function()&#123; //1.选择第一个 div 元素 $(&quot;#btn1&quot;).click(function()&#123; $(&quot;div:first&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //2.选择最后一个 div 元素 $(&quot;#btn2&quot;).click(function()&#123; $(&quot;div:last&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //3.选择class不为 one 的所有 div 元素 $(&quot;#btn3&quot;).click(function()&#123; $(&quot;div:not(.one)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //4.选择索引值为偶数的 div 元素 $(&quot;#btn4&quot;).click(function()&#123; $(&quot;div:even&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //5.选择索引值为奇数的 div 元素 $(&quot;#btn5&quot;).click(function()&#123; $(&quot;div:odd&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //6.选择索引值为大于 3 的 div 元素 $(&quot;#btn6&quot;).click(function()&#123; $(&quot;div:gt(3)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //7.选择索引值为等于 3 的 div 元素 $(&quot;#btn7&quot;).click(function()&#123; $(&quot;div:eq(3)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //8.选择索引值为小于 3 的 div 元素 $(&quot;#btn8&quot;).click(function()&#123; $(&quot;div:lt(3)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //9.选择所有的标题元素 $(&quot;#btn9&quot;).click(function()&#123; $(&quot;:header&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //10.选择当前正在执行动画的所有元素 $(&quot;#btn10&quot;).click(function()&#123; $(&quot;:animated&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //11.选择没有执行动画的最后一个div $(&quot;#btn11&quot;).click(function()&#123; $(&quot;div:not(:animated):last&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;选择第一个 div 元素&quot; id=&quot;btn1&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择最后一个 div 元素&quot; id=&quot;btn2&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择class不为 one 的所有 div 元素&quot; id=&quot;btn3&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择索引值为偶数的 div 元素&quot; id=&quot;btn4&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择索引值为奇数的 div 元素&quot; id=&quot;btn5&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择索引值为大于 3 的 div 元素&quot; id=&quot;btn6&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择索引值为等于 3 的 div 元素&quot; id=&quot;btn7&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择索引值为小于 3 的 div 元素&quot; id=&quot;btn8&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择所有的标题元素&quot; id=&quot;btn9&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择当前正在执行动画的所有元素&quot; id=&quot;btn10&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择没有执行动画的最后一个div&quot; id=&quot;btn11&quot; /&gt; &lt;h3&gt;基本选择器.&lt;/h3&gt; &lt;br&gt;&lt;br&gt; &lt;div class=&quot;one&quot; id=&quot;one&quot;&gt; id 为 one,class 为 one 的div &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot; id=&quot;two&quot; title=&quot;test&quot;&gt; id为two,class为one,title为test的div &lt;div class=&quot;mini&quot; title=&quot;other&quot;&gt;class为mini,title为other&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;test&quot;&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;tesst&quot;&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;display:none;&quot; class=&quot;none&quot;&gt;style的display为&quot;none&quot;的div&lt;/div&gt; &lt;div class=&quot;hide&quot;&gt;class为&quot;hide&quot;的div&lt;/div&gt; &lt;div&gt; 包含input的type为&quot;hidden&quot;的div&lt;input type=&quot;hidden&quot; size=&quot;8&quot;&gt; &lt;/div&gt; &lt;div id=&quot;mover&quot;&gt;正在执行动画的div元素.&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; jQuery内容过滤器文本也算是子元素 :contains(text) 匹配包含给定文本的元素 :empty 匹配所有不包含子元素或者文本的空元素 :parent 匹配含有子元素或者文本的元素 :has(selector) 匹配含有选择器所匹配的元素的元 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; function anmateIt()&#123; $(&quot;#mover&quot;).slideToggle(&quot;slow&quot;, anmateIt); &#125; anmateIt(); &#125;); /** :contains(text) :empty :has(selector) :parent */ $(document).ready(function()&#123; //1.选择 含有文本 &#x27;di&#x27; 的 div 元素 $(&quot;#btn1&quot;).click(function()&#123; $(&quot;div:contains(&#x27;di&#x27;)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //2.选择不包含子元素(包括文本元素) 的 div 空元素 $(&quot;#btn2&quot;).click(function()&#123; $(&quot;div:empty&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //3.选择含有 class 为 mini 元素的 div 元素 $(&quot;#btn3&quot;).click(function()&#123; $(&quot;div:has(.mini)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //4.选择含有子元素(包括文本元素)的div元素 $(&quot;#btn4&quot;).click(function()&#123; $(&quot;div:parent&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;选择 含有文本 &#x27;di&#x27; 的 div 元素&quot; id=&quot;btn1&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择不包含子元素(或者文本元素) 的 div 空元素&quot; id=&quot;btn2&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择含有 class 为 mini 元素的 div 元素&quot; id=&quot;btn3&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择含有子元素(或者文本元素)的div元素&quot; id=&quot;btn4&quot; /&gt; &lt;br&gt;&lt;br&gt; &lt;div class=&quot;one&quot; id=&quot;one&quot;&gt; id 为 one,class 为 one 的div &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot; id=&quot;two&quot; title=&quot;test&quot;&gt; id为two,class为one,title为test的div &lt;div class=&quot;mini&quot; title=&quot;other&quot;&gt;class为mini,title为other&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;test&quot;&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;tesst&quot;&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;display:none;&quot; class=&quot;none&quot;&gt;style的display为&quot;none&quot;的div&lt;/div&gt; &lt;div class=&quot;hide&quot;&gt;class为&quot;hide&quot;的div&lt;/div&gt; &lt;div&gt; 包含input的type为&quot;hidden&quot;的div&lt;input type=&quot;hidden&quot; size=&quot;8&quot;&gt; &lt;/div&gt; &lt;div id=&quot;mover&quot;&gt;正在执行动画的div元素.&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; jQuery属性过滤选择器[attribute] 匹配包含给定属性的元素。 [attribute&#x3D;value] 匹配给定的属性是某个特定值的元素 [attribute!&#x3D;value] 匹配所有不含有指定的属性，或者属性不等于特定值的元素。 [attribute^&#x3D;value] 匹配给定的属性是以某些值开始的元素 [attribute$&#x3D;value] 匹配给定的属性是以某些值结尾的元素 [attribute*&#x3D;value] 匹配给定的属性是以包含某些值的元素 [attrSel1][attrSel2][attrSelN] 复合属性选择器，需要同时满足多个条件时使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Untitled Document&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;div,span,p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana;&#125;div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px;&#125;div.hide &#123; display: none;&#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; /**[attribute] [attribute=value] [attribute!=value] [attribute^=value] [attribute$=value] [attribute*=value] [attrSel1][attrSel2][attrSelN] */ $(function() &#123; //1.选取含有 属性title 的div元素 $(&quot;#btn1&quot;).click(function() &#123; $(&quot;div[title]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //2.选取 属性title值等于&#x27;test&#x27;的div元素 $(&quot;#btn2&quot;).click(function() &#123; $(&quot;div[title=&#x27;test&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //3.选取 属性title值不等于&#x27;test&#x27;的div元素(*没有属性title的也将被选中) $(&quot;#btn3&quot;).click(function() &#123; $(&quot;div[title!=&#x27;test&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //4.选取 属性title值 以&#x27;te&#x27;开始 的div元素 $(&quot;#btn4&quot;).click(function() &#123; $(&quot;div[title^=&#x27;te&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //5.选取 属性title值 以&#x27;est&#x27;结束 的div元素 $(&quot;#btn5&quot;).click(function() &#123; $(&quot;div[title$=&#x27;est&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //6.选取 属性title值 含有&#x27;es&#x27;的div元素 $(&quot;#btn6&quot;).click(function() &#123; $(&quot;div[title*=&#x27;es&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //7.首先选取有属性id的div元素，然后在结果中 选取属性title值 含有&#x27;es&#x27;的 div 元素 $(&quot;#btn7&quot;).click(function() &#123; $(&quot;div[id][title*=&#x27;es&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //8.选取 含有 title 属性值, 且title 属性值不等于 test 的 div 元素 $(&quot;#btn8&quot;).click(function() &#123; $(&quot;div[title][title!=&#x27;test&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;选取含有 属性title 的div元素.&quot; id=&quot;btn1&quot; style=&quot;display: none;&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;选取 属性title值等于&#x27;test&#x27;的div元素.&quot; id=&quot;btn2&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选取 属性title值不等于&#x27;test&#x27;的div元素(没有属性title的也将被选中).&quot; id=&quot;btn3&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选取 属性title值 以&#x27;te&#x27;开始 的div元素.&quot; id=&quot;btn4&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选取 属性title值 以&#x27;est&#x27;结束 的div元素.&quot; id=&quot;btn5&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选取 属性title值 含有&#x27;es&#x27;的div元素.&quot; id=&quot;btn6&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;组合属性选择器,首先选取有属性id的div元素，然后在结果中 选取属性title值 含有&#x27;es&#x27;的 div 元素.&quot; id=&quot;btn7&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选取 含有 title 属性值, 且title 属性值不等于 test 的 div 元素.&quot; id=&quot;btn8&quot; /&gt; &lt;br&gt; &lt;br&gt; &lt;div class=&quot;one&quot; id=&quot;one&quot;&gt; id 为 one,class 为 one 的div &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot; id=&quot;two&quot; title=&quot;test&quot;&gt; id为two,class为one,title为test的div &lt;div class=&quot;mini&quot; title=&quot;other&quot;&gt;class为mini,title为other&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;test&quot;&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;tesst&quot;&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;display: none;&quot; class=&quot;none&quot;&gt;style的display为&quot;none&quot;的div&lt;/div&gt; &lt;div class=&quot;hide&quot;&gt;class为&quot;hide&quot;的div&lt;/div&gt; &lt;div&gt; 包含input的type为&quot;hidden&quot;的div&lt;input type=&quot;hidden&quot; value=&quot;123456789&quot; size=&quot;8&quot;&gt; &lt;/div&gt; &lt;div id=&quot;mover&quot;&gt;正在执行动画的div元素.&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; jQuery表单过滤选择器:input 匹配所有 input, textarea, select 和 button 元素 :text 匹配所有 文本输入框 :password 匹配所有的密码输入框 :radio 匹配所有的单选框 :checkbox 匹配所有的复选框 :submit 匹配所有提交按钮 :image 匹配所有 img 标签 :reset 匹配所有重置按钮 :button 匹配所有 input type&#x3D;button 按钮 :file 匹配所有 input type&#x3D;file 文件上传 :hidden 匹配所有不可见元素 display:none :enabled 匹配所有可用元素 :disabled 匹配所有不可用元素 :checked 匹配所有选中的单选，复选，和下拉列表中选中的 option 标签对象 :selected 匹配所有选中的 option 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; /** :input :text :password :radio :checkbox :submit :image :reset :button :file :hidden 表单对象的属性 :enabled :disabled :checked :selected */ //1.对表单内 可用input 赋值操作 $(&quot;#btn1&quot;).click(function()&#123; // val()可以操作表单项的value属性值 //表单项是那个form标签里面的那些 // 它可以设置和获取 $(&quot;:text:enabled&quot;).val(&quot;我是万能的程序员&quot;); &#125;); //2.对表单内 不可用input 赋值操作 $(&quot;#btn2&quot;).click(function()&#123; $(&quot;:text:disabled&quot;).val(&quot;管你可用不可用，反正我是万能的程序员&quot;); &#125;); //3.获取多选框选中的个数 使用size()方法获取选取到的元素集合的元素个数 $(&quot;#btn3&quot;).click(function()&#123; alert( $(&quot;:checkbox:checked&quot;).length ); &#125;); //4.获取多选框，每个选中的value值 $(&quot;#btn4&quot;).click(function()&#123; // 获取全部选中的复选框标签对象 var $checkboies = $(&quot;:checkbox:checked&quot;); // 老式遍历 // for (var i = 0; i &lt; $checkboies.length; i++)&#123; // alert( $checkboies[i].value ); // &#125; // each方法是jQuery对象提供用来遍历元素的方法 // 在遍历的function函数中，有一个this对象，这个this对象，就是当前遍历到的dom对象 $checkboies.each(function () &#123; alert( this.value ); &#125;); &#125;); //5.获取下拉框选中的内容 $(&quot;#btn5&quot;).click(function()&#123; // 选中select后代的option标签且被选中的 var $options = $(&quot;select option:selected&quot;); // 遍历，获取option标签中的文本内容 $options.each(function () &#123; // 在each遍历的function函数中，有一个this对象。这个this对象是当前正在遍历到的dom对象 alert(this.innerHTML); &#125;); &#125;); &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;表单对象属性过滤选择器&lt;/h3&gt; &lt;button id=&quot;btn1&quot;&gt;对表单内 可用input 赋值操作.&lt;/button&gt; &lt;button id=&quot;btn2&quot;&gt;对表单内 不可用input 赋值操作.&lt;/button&gt;&lt;br /&gt;&lt;br /&gt; &lt;button id=&quot;btn3&quot;&gt;获取多选框选中的个数.&lt;/button&gt; &lt;button id=&quot;btn4&quot;&gt;获取多选框选中的内容.&lt;/button&gt;&lt;br /&gt;&lt;br /&gt; &lt;button id=&quot;btn5&quot;&gt;获取下拉框选中的内容.&lt;/button&gt;&lt;br /&gt;&lt;br /&gt; &lt;form id=&quot;form1&quot; action=&quot;#&quot;&gt; 可用元素: &lt;input name=&quot;add&quot; value=&quot;可用文本框1&quot;/&gt;&lt;br&gt; &lt;!--diabled=&quot;disabled就是让文本框不可选&quot;--&gt; 不可用元素: &lt;input name=&quot;email&quot; disabled=&quot;disabled&quot; value=&quot;不可用文本框&quot;/&gt;&lt;br&gt; 可用元素: &lt;input name=&quot;che&quot; value=&quot;可用文本框2&quot;/&gt;&lt;br&gt; 不可用元素: &lt;input name=&quot;name&quot; disabled=&quot;disabled&quot; value=&quot;不可用文本框&quot;/&gt;&lt;br&gt; &lt;br&gt; 多选框: &lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;newsletter&quot; checked=&quot;checked&quot; value=&quot;test1&quot; /&gt;test1 &lt;input type=&quot;checkbox&quot; name=&quot;newsletter&quot; value=&quot;test2&quot; /&gt;test2 &lt;input type=&quot;checkbox&quot; name=&quot;newsletter&quot; value=&quot;test3&quot; /&gt;test3 &lt;input type=&quot;checkbox&quot; name=&quot;newsletter&quot; checked=&quot;checked&quot; value=&quot;test4&quot; /&gt;test4 &lt;input type=&quot;checkbox&quot; name=&quot;newsletter&quot; value=&quot;test5&quot; /&gt;test5 &lt;br&gt;&lt;br&gt; 下拉列表1: &lt;br&gt; &lt;!--multiple属性决定了这个下拉表可以多选--&gt; &lt;select name=&quot;test&quot; multiple=&quot;multiple&quot; style=&quot;height: 100px&quot; id=&quot;sele1&quot;&gt; &lt;option&gt;浙江&lt;/option&gt; &lt;option selected=&quot;selected&quot;&gt;辽宁&lt;/option&gt; &lt;option&gt;北京&lt;/option&gt; &lt;option selected=&quot;selected&quot;&gt;天津&lt;/option&gt; &lt;option&gt;广州&lt;/option&gt; &lt;option&gt;湖北&lt;/option&gt; &lt;/select&gt; &lt;br&gt;&lt;br&gt; 下拉列表2: &lt;br&gt; &lt;select name=&quot;test2&quot;&gt; &lt;option&gt;浙江&lt;/option&gt; &lt;option&gt;辽宁&lt;/option&gt; &lt;option selected=&quot;selected&quot;&gt;北京&lt;/option&gt; &lt;option&gt;天津&lt;/option&gt; &lt;option&gt;广州&lt;/option&gt; &lt;option&gt;湖北&lt;/option&gt; &lt;/select&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; jQuery元素的筛选eq() 获取给定索引的元素 功能跟 :eq() 一样 first() 获取第一个元素 功能跟 :first 一样 last() 获取最后一个元素 功能跟 :last 一样 filter(exp) 留下匹配的元素 is(exp) 判断是否匹配给定的选择器，只要有一个匹配就返回，true has(exp) 返回包含有匹配选择器的元素的元素 功能跟 :has 一样 not(exp) 删除匹配选择器的元素 功能跟 :not 一样 children(exp) 返回匹配给定选择器的子元素 功能跟 parent&gt;child 一样 find(exp) 返回匹配给定选择器的后代元素 功能跟 ancestor descendant 一样 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;DOM查询&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; function anmateIt()&#123; $(&quot;#mover&quot;).slideToggle(&quot;slow&quot;, anmateIt); &#125; anmateIt(); /** 过滤 eq(index|-index) first() last() hasClass(class) filter(expr|obj|ele|fn) is(expr|obj|ele|fn)1.6* has(expr|ele) not(expr|ele|fn) slice(start,[end]) 查找 children([expr]) closest(expr,[con]|obj|ele)1.6* find(expr|obj|ele) next([expr]) nextall([expr]) nextUntil([exp|ele][,fil])1.6* parent([expr]) parents([expr]) parentsUntil([exp|ele][,fil])1.6* prev([expr]) prevall([expr]) prevUntil([exp|ele][,fil])1.6* siblings([expr]) 串联 add(expr|ele|html|obj[,con]) */ //(1)eq() 选择索引值为等于 3 的 div 元素 $(&quot;#btn1&quot;).click(function()&#123; $(&quot;div&quot;).eq(3).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(2)first()选择第一个 div 元素 $(&quot;#btn2&quot;).click(function()&#123; //first() 选取第一个元素 $(&quot;div&quot;).first().css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(3)last()选择最后一个 div 元素 $(&quot;#btn3&quot;).click(function()&#123; //last() 选取最后一个元素 $(&quot;div&quot;).last().css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(4)filter()在div中选择索引为偶数的 $(&quot;#btn4&quot;).click(function()&#123; //filter() 过滤 传入的是选择器字符串 $(&quot;div&quot;).filter(&quot;:even&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(5)is()判断#one是否为:empty或:parent //is用来检测jq对象是否符合指定的选择器 $(&quot;#btn5&quot;).click(function()&#123; alert( $(&quot;#one&quot;).is(&quot;:empty&quot;) ); &#125;); //(6)has()选择div中包含.mini的 $(&quot;#btn6&quot;).click(function()&#123; //has(selector) 选择器字符串 是否包含selector $(&quot;div&quot;).has(&quot;.mini&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(7)not()选择div中class不为one的 $(&quot;#btn7&quot;).click(function()&#123; //not(selector) 选择不是selector的元素 $(&quot;div&quot;).not(&#x27;.one&#x27;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(8)children()在body中选择所有class为one的div子元素 $(&quot;#btn8&quot;).click(function()&#123; //children() 选出所有的子元素 $(&quot;body&quot;).children(&quot;div.one&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(9)find()在body中选择所有class为mini的div元素 $(&quot;#btn9&quot;).click(function()&#123; //find() 选出所有的后代元素 $(&quot;body&quot;).find(&quot;div.mini&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(10)next() #one的下一个div $(&quot;#btn10&quot;).click(function()&#123; //next() 选择下一个兄弟元素 $(&quot;#one&quot;).next(&quot;div&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(11)nextAll() #one后面所有的span元素 $(&quot;#btn11&quot;).click(function()&#123; //nextAll() 选出后面所有的元素 $(&quot;#one&quot;).nextAll(&quot;span&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(12)nextUntil() #one和span之间的元素，不算两边 $(&quot;#btn12&quot;).click(function()&#123; // $(&quot;#one&quot;).nextUntil(&quot;span&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;) &#125;); //(13)parent() .mini的父元素 $(&quot;#btn13&quot;).click(function()&#123; $(&quot;.mini&quot;).parent().css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(14)prev() #two的上一个div $(&quot;#btn14&quot;).click(function()&#123; //prev() $(&quot;#two&quot;).prev(&quot;div&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;) &#125;); //(15)prevAll() span前面所有的div $(&quot;#btn15&quot;).click(function()&#123; //prevAll() 选出前面所有的元素 $(&quot;span&quot;).prevAll(&quot;div&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;) &#125;); //(16)prevUntil() span向前直到#one的元素，都不算两个边界 $(&quot;#btn16&quot;).click(function()&#123; //prevUntil(exp) 找到之前所有的兄弟元素直到找到exp停止 $(&quot;span&quot;).prevUntil(&quot;#one&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;) &#125;); //(17)siblings() #two的所有兄弟元素 $(&quot;#btn17&quot;).click(function()&#123; //siblings() 找到所有的兄弟元素，包括前面的和后面的 $(&quot;#two&quot;).siblings().css(&quot;background-color&quot;,&quot;#bfa&quot;) &#125;); //(18)add()选择所有的 span 元素和id为two的元素 $(&quot;#btn18&quot;).click(function()&#123; // $(&quot;span,#two,.mini,#one&quot;) $(&quot;span&quot;).add(&quot;#two&quot;).add(&quot;#one&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;eq()选择索引值为等于 3 的 div 元素&quot; id=&quot;btn1&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;first()选择第一个 div 元素&quot; id=&quot;btn2&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;last()选择最后一个 div 元素&quot; id=&quot;btn3&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;filter()在div中选择索引为偶数的&quot; id=&quot;btn4&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;is()判断#one是否为:empty或:parent&quot; id=&quot;btn5&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;has()选择div中包含.mini的&quot; id=&quot;btn6&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;not()选择div中class不为one的&quot; id=&quot;btn7&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;children()在body中选择所有class为one的div子元素&quot; id=&quot;btn8&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;find()在body中选择所有class为mini的div后代元素&quot; id=&quot;btn9&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;next()#one的下一个div&quot; id=&quot;btn10&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;nextAll()#one后面所有的span元素&quot; id=&quot;btn11&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;nextUntil()#one和span之间的元素&quot; id=&quot;btn12&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;parent().mini的父元素&quot; id=&quot;btn13&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;prev()#two的上一个div&quot; id=&quot;btn14&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;prevAll()span前面所有的div&quot; id=&quot;btn15&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;prevUntil()span向前直到#one的元素&quot; id=&quot;btn16&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;siblings()#two的所有兄弟元素&quot; id=&quot;btn17&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;add()选择所有的 span 元素和id为two的元素&quot; id=&quot;btn18&quot; /&gt; &lt;h3&gt;基本选择器.&lt;/h3&gt; &lt;br /&gt;&lt;br /&gt; 文本框&lt;input type=&quot;text&quot; name=&quot;account&quot; disabled=&quot;disabled&quot; /&gt; &lt;br&gt;&lt;br&gt; &lt;div class=&quot;one&quot; id=&quot;one&quot;&gt; id 为 one,class 为 one 的div &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot; id=&quot;two&quot; title=&quot;test&quot;&gt; id为two,class为one,title为test的div &lt;div class=&quot;mini&quot; title=&quot;other&quot;&gt;&lt;b&gt;class为mini,title为other&lt;/b&gt;&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;test&quot;&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;tesst&quot;&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;display:none;&quot; class=&quot;none&quot;&gt;style的display为&quot;none&quot;的div&lt;/div&gt; &lt;div class=&quot;hide&quot;&gt;class为&quot;hide&quot;的div&lt;/div&gt; &lt;span id=&quot;span1&quot;&gt;^^span元素 111^^&lt;/span&gt; &lt;div&gt; 包含input的type为&quot;hidden&quot;的div&lt;input type=&quot;hidden&quot; size=&quot;8&quot;&gt; &lt;/div&gt; &lt;span id=&quot;span2&quot;&gt;^^span元素 222^^&lt;/span&gt; &lt;div id=&quot;mover&quot;&gt;正在执行动画的div元素.&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; jQuery属性操作html() 它可以设置和获取起始标签和结束标签中的内容，根dom属性innerHTML一样 不传参数是获取，传入参数是设置 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh_CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;$(function()&#123; alert($(&quot;div&quot;).html());//获取 $(&quot;div&quot;).html(&quot;&lt;h1&gt;我是赵梓皓&lt;/h1&gt;&quot;);//设置&#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;我是div标签&lt;span&gt;我是div中的spqn&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; text() 它可以设置和获取起始标签和结束标签中的文本，根dom属性innerText一样 不传参数是获取，传入参数是设置 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh_CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;$(function()&#123; alert($(&quot;div&quot;).text()); $(&quot;div&quot;).text(&quot;&lt;h1&gt;我是赵梓皓&lt;/h1&gt;&quot;);&#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;我是div标签&lt;span&gt;我是div中的spqn&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; text()方法只能让内容全部以文本形式显示，不能识别标签，但html标签可以 val() 它可以设置和获取表单项的value属性值 跟dom属性value一样 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh_CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123;$(&quot;button&quot;).click(function()&#123;alert($(&quot;#username&quot;).val());&#125;);$(&quot;#username&quot;).val(&quot;超级程序员&quot;);&#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;我是div标签&lt;span&gt;我是div中的spqn&lt;/span&gt;&lt;/div&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; /&gt;&lt;button&gt;操作输入框&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 表单选择器练习 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh_CN&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Title&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;$(function () &#123;/*// 批量操作单选$(&quot;:radio&quot;).val([&quot;radio2&quot;]);// 批量操作筛选框的选中状态$(&quot;:checkbox&quot;).val([&quot;checkbox3&quot;,&quot;checkbox2&quot;]);// 批量操作多选的下拉框选中状态$(&quot;#multiple&quot;).val([&quot;mul2&quot;,&quot;mul3&quot;,&quot;mul4&quot;]);// 操作单选的下拉框选中状态$(&quot;#single&quot;).val([&quot;sin2&quot;]);*/$(&quot;#multiple,#single,:radio,:checkbox&quot;).val([&quot;radio2&quot;,&quot;checkbox1&quot;,&quot;checkbox3&quot;,&quot;mul1&quot;,&quot;mul4&quot;,&quot;sin3&quot;]);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;body&gt;单选：&lt;input name=&quot;radio&quot; type=&quot;radio&quot; value=&quot;radio1&quot; /&gt;radio1&lt;input name=&quot;radio&quot; type=&quot;radio&quot; value=&quot;radio2&quot; /&gt;radio2&lt;br/&gt;多选：&lt;input name=&quot;checkbox&quot; type=&quot;checkbox&quot; value=&quot;checkbox1&quot; /&gt;checkbox1&lt;input name=&quot;checkbox&quot; type=&quot;checkbox&quot; value=&quot;checkbox2&quot; /&gt;checkbox2&lt;input name=&quot;checkbox&quot; type=&quot;checkbox&quot; value=&quot;checkbox3&quot; /&gt;checkbox3&lt;br/&gt;下拉多选 ：&lt;select id=&quot;multiple&quot; multiple=&quot;multiple&quot; size=&quot;4&quot;&gt;&lt;option value=&quot;mul1&quot;&gt;mul1&lt;/option&gt;&lt;option value=&quot;mul2&quot;&gt;mul2&lt;/option&gt;&lt;option value=&quot;mul3&quot;&gt;mul3&lt;/option&gt;&lt;option value=&quot;mul4&quot;&gt;mul4&lt;/option&gt;&lt;/select&gt;&lt;br/&gt;下拉单选 ：&lt;select id=&quot;single&quot;&gt;&lt;option value=&quot;sin1&quot;&gt;sin1&lt;/option&gt;&lt;option value=&quot;sin2&quot;&gt;sin2&lt;/option&gt;&lt;option value=&quot;sin3&quot;&gt;sin3&lt;/option&gt;&lt;/select&gt;&lt;/body&gt;&lt;/body&gt;&lt;/html&gt; attr() 可以设置和获取属性的值，不推荐操作checked，readOnly，selected，disabled等等 还不可以操作非标准的属性，比如自定义属性：abc什么的 prop() 可以设置和获取属性的值，只推荐操作上面不操作的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh_CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;$(function () &#123;//attralert($(&quot;:checkbox:first&quot;).attr(&quot;name&quot;));//获取属性的值$(&quot;:checkbox:first&quot;).attr(&quot;name&quot;,&quot;abc&quot;);alert($(&quot;:checkbox:first&quot;).attr(&quot;checked&quot;));//会返回undefined，但是这个时候没办法判断是没被选还是没有这个属性，所以用到prop()alert($(&quot;:checkbox:first&quot;).prop(&quot;checked&quot;));//返回的是false$(&quot;:checkbox&quot;).prop(&quot;checked&quot;,true);//让所有多选框都选中$(&quot;:checkbox:first&quot;).attr(&quot;abc&quot;,&quot;abcvalue&quot;);//设置自定义属性alert($(&quot;:checkbox:first&quot;).attr(&quot;abc&quot;));//查看自定义属性//&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;body&gt;单选：&lt;input name=&quot;radio&quot; type=&quot;radio&quot; value=&quot;radio1&quot; /&gt;radio1&lt;input name=&quot;radio&quot; type=&quot;radio&quot; value=&quot;radio2&quot; /&gt;radio2&lt;br/&gt;多选：&lt;input name=&quot;checkbox&quot; type=&quot;checkbox&quot; value=&quot;checkbox1&quot; /&gt;checkbox1&lt;input name=&quot;checkbox&quot; type=&quot;checkbox&quot; value=&quot;checkbox2&quot; /&gt;checkbox2&lt;input name=&quot;checkbox&quot; type=&quot;checkbox&quot; value=&quot;checkbox3&quot; /&gt;checkbox3&lt;br/&gt;下拉多选 ：&lt;select id=&quot;multiple&quot; multiple=&quot;multiple&quot; size=&quot;4&quot;&gt; &lt;option value=&quot;mul1&quot;&gt;mul1&lt;/option&gt; &lt;option value=&quot;mul2&quot;&gt;mul2&lt;/option&gt; &lt;option value=&quot;mul3&quot;&gt;mul3&lt;/option&gt; &lt;option value=&quot;mul4&quot;&gt;mul4&lt;/option&gt;&lt;/select&gt;&lt;br/&gt;下拉单选 ：&lt;select id=&quot;single&quot;&gt; &lt;option value=&quot;sin1&quot;&gt;sin1&lt;/option&gt; &lt;option value=&quot;sin2&quot;&gt;sin2&lt;/option&gt; &lt;option value=&quot;sin3&quot;&gt;sin3&lt;/option&gt;&lt;/select&gt;&lt;/body&gt;&lt;/body&gt;&lt;/html&gt; jQuery练习（全选全不选）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; //给全选绑定单击事件 $(&quot;#checkedAllBtn&quot;).click(function()&#123; $(&quot;:checkbox&quot;).prop(&quot;checked&quot;,true);//这个地方checked的属性值是true，且属性名checked也要加双引号 &#125;); //给全不选绑定单击事件 $(&quot;#checkedNoBtn&quot;).click(function()&#123; $(&quot;:checkbox&quot;).prop(&quot;checked&quot;,false); &#125;); //给反选绑定单击事件 $(&quot;#checkedRevBtn&quot;).click(function()&#123; //查询全部球类的复选框 $(&quot;:checkbox[name=&#x27;items&#x27;]&quot;).each(function()&#123; //each方法中这个this就是每一个dom对象，也就是jQuery数组中的一个元素 this.checked=!this.checked; &#125;); //要检查是否满选 //获取球类运动总数 var length=$(&quot;:checkbox[name=&#x27;items&#x27;]&quot;).length; //获取被选中的球类运动总数 var length2=$(&quot;:checkbox[name=&#x27;items&#x27;]:checked&quot;).length; //比较,两种 /* if(length==length2)&#123; $(&quot;#checkedAllBox&quot;).prop(&quot;checked&quot;,true); &#125;*/ $(&quot;#checkedAllBox&quot;).prop(&quot;checked&quot;,length==length2); &#125;); //给提交按钮绑定事件 $(&quot;#sendBtn&quot;).click(function()&#123; $(&quot;:checkbox[name=&#x27;items&#x27;]:checked&quot;).each(function()&#123; alert(this.value); &#125;); &#125;);//给全选或者全不选那个框框榜单机事件$(&quot;#checkedAllBox&quot;).click(function()&#123;//再事件的function函数中，有一个this对象，这个this对象是当前正在响应事件的dom对象$(&quot;:checkbox[name=&#x27;items&#x27;]&quot;).prop(&quot;checked&quot;,this.checked);&#125;);//给全部球类绑定单击事件,让所有框被选上之后也可以让全选框被选$(&quot;[name=items]&quot;).click(function()&#123; var length=$(&quot;:checkbox[name=&#x27;items&#x27;]&quot;).length; //获取被选中的球类运动总数 var length2=$(&quot;:checkbox[name=&#x27;items&#x27;]:checked&quot;).length; $(&quot;#checkedAllBox&quot;).prop(&quot;checked&quot;,length==length2); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form method=&quot;post&quot; action=&quot;&quot;&gt; 你爱好的运动是？&lt;input type=&quot;checkbox&quot; id=&quot;checkedAllBox&quot; /&gt;全选/全不选 &lt;br /&gt; &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;足球&quot; /&gt;足球 &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;篮球&quot; /&gt;篮球 &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;羽毛球&quot; /&gt;羽毛球 &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;乒乓球&quot; /&gt;乒乓球 &lt;br /&gt; &lt;input type=&quot;button&quot; id=&quot;checkedAllBtn&quot; value=&quot;全 选&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;checkedNoBtn&quot; value=&quot;全不选&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;checkedRevBtn&quot; value=&quot;反 选&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;sendBtn&quot; value=&quot;提 交&quot; /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; jQuery 对标签的增删改内部插入 用jQuery对象的方法来操作标签的增删改 appendTo a.appendTo(b) 把a插入到b子元素末尾，成为最后一个子元素 prependTo() a.prependTo(b) 把a插入到b所有子元素之前，成为第一个子元素 外部插入 insertAfter() a.insertAfter(b) 得到ba insertBefore() a.insertBefore(b) 得到ab 替换 replaceWith() a.replaceWith(b) 用b替换掉a replaceAll() a.replaceAll(b) 用a替换掉所有b 删除 remove() a.remove(); 删除a标签 empty() a.empty(); 清空标签里的内容 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh_CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;//$(&quot;&lt;h1&gt;标题&lt;/h1&gt;&quot;).appendTo(&quot;div&quot;);//$(&quot;&lt;h1&gt;标题&lt;/h1&gt;&quot;).prependTo(&quot;div&quot;);//$(&quot;&lt;h1&gt;标题&lt;/h1&gt;&quot;).insertAfter(&quot;div&quot;);//$(&quot;&lt;h1&gt;标题&lt;/h1&gt;&quot;).insertBefore($(&quot;div&quot;));//$(&quot;&lt;h1&gt;标题&lt;/h1&gt;&quot;).replaceWith(&quot;div&quot;);//$(&quot;div&quot;).replaceWith(&quot;&lt;h1&gt;标题&lt;/h1&gt;&quot;);//$(&quot;&lt;h1&gt;标题&lt;/h1&gt;&quot;).replaceAll&quot;div&quot;);//$(&quot;div&quot;).remove();//$(&quot;div&quot;).empty(); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;1234&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; jQuery练习从左到右从右到左 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; select &#123; width: 100px; height: 140px; &#125; div &#123; width: 130px; float: left; text-align: center; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; //实现左边的可以添加到右边 $(function()&#123; $(&quot;button:first&quot;).click(function()&#123;//这个就是叫先找标签select的第一个然后找他后代的所有option中被选中的 $(&quot;select:eq(0) option:selected&quot;).appendTo($(&quot;select:eq(1)&quot;)); &#125;); //实现将左边的全部添加到右边 $(&quot;button:eq(1)&quot;).click(function()&#123; $(&quot;select:eq(0) option&quot;).appendTo($(&quot;select:eq(1)&quot;)); &#125;); //将右边的添加到左边 $(&quot;button:eq(2)&quot;).click(function()&#123;//这个就是叫先找标签select的第一个然后找他后代的所有option中被选中的 $(&quot;select:eq(1) option:selected&quot;).appendTo($(&quot;select:eq(0)&quot;)); &#125;); //将右边的全部添加到左边 $(&quot;button:eq(3)&quot;).click(function()&#123; $(&quot;select:eq(1) option&quot;).appendTo($(&quot;select:eq(0)&quot;)); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;left&quot;&gt; &lt;select multiple=&quot;multiple&quot; name=&quot;sel01&quot;&gt; &lt;option value=&quot;opt01&quot;&gt;选项1&lt;/option&gt; &lt;option value=&quot;opt02&quot;&gt;选项2&lt;/option&gt; &lt;option value=&quot;opt03&quot;&gt;选项3&lt;/option&gt; &lt;option value=&quot;opt04&quot;&gt;选项4&lt;/option&gt; &lt;option value=&quot;opt05&quot;&gt;选项5&lt;/option&gt; &lt;option value=&quot;opt06&quot;&gt;选项6&lt;/option&gt; &lt;option value=&quot;opt07&quot;&gt;选项7&lt;/option&gt; &lt;option value=&quot;opt08&quot;&gt;选项8&lt;/option&gt; &lt;/select&gt; &lt;button&gt;选中添加到右边&lt;/button&gt; &lt;button&gt;全部添加到右边&lt;/button&gt; &lt;/div&gt; &lt;div id=&quot;rigth&quot;&gt; &lt;select multiple=&quot;multiple&quot; name=&quot;sel02&quot;&gt; &lt;/select&gt; &lt;button&gt;选中删除到左边&lt;/button&gt; &lt;button&gt;全部删除到左边&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; jQuery练习，删除添加记录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Untitled Document&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styleB/css.css&quot; /&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; $(&quot;#addEmpButton&quot;).click(function()&#123; //获取输入框的内容 var name=$(&quot;#empName&quot;).val(); var email=$(&quot;#email&quot;).val(); var salary=$(&quot;#salary&quot;).val(); //创建一个行标签对象，添加到显示数据的表格中 var $tobr=$(&quot;&lt;tr&gt;&quot;+ &quot;&lt;td&gt;&quot;+name+&quot;&lt;/td&gt;&quot;+ &quot;&lt;td&gt;&quot;+email+&quot;&lt;/td&gt;&quot;+ &quot;&lt;td&gt;&quot;+salary+&quot;&lt;/td&gt;&quot;+ &quot;&lt;td&gt;&lt;a href=\\&quot;deleteEmp?id=002\\&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt;&quot;+ &quot;&lt;/tr&gt;&quot;); //添加到显示数据的表格中 $tobr.appendTo($(&quot;#employeeTable&quot;)); //这里是每次添加新的信息之后，给他绑定删除事件，防止新添加的这些无法删除 $tobr.find(&quot;a&quot;).click(function()&#123; //在事件响应function的时候会有一个this对象，这个this对象是当前正在响应事件的dom对象 //得到a标签对象的父亲的父亲 var $tbr=$(this).parent().parent(); //获取第一个td标签的内容 var name=$tbr.find(&quot;td:first&quot;).text(); //confirm是js提供的一个确认提示框，你给他传什么它就提示什么，用户点击确定就返回true，点击取消就返回false if(confirm(&quot;你确定要删除&quot;+name+&quot;么&quot;))&#123; $tbr.remove(); &#125; //return false; 可以阻止，元素的默认行为 return false;//可以点击标签时不跳转 &#125;); &#125;); //给删除a标签绑定单机事件 $(&quot;a&quot;).click(function()&#123; //在事件响应function的时候会有一个this对象，这个this对象是当前正在响应事件的dom对象 //得到a标签对象的父亲的父亲 var $tbr=$(this).parent().parent(); //获取第一个td标签的内容 var name=$tbr.find(&quot;td:first&quot;).text(); //confirm是js提供的一个确认提示框，你给他传什么它就提示什么，用户点击确定就返回true，点击取消就返回false if(confirm(&quot;你确定要删除&quot;+name+&quot;么&quot;))&#123; $tbr.remove(); &#125; //return false; 可以阻止，元素的默认行为 return false;//可以点击标签时不跳转 &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;table id=&quot;employeeTable&quot;&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Email&lt;/th&gt; &lt;th&gt;Salary&lt;/th&gt; &lt;th&gt;&amp;nbsp;&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Tom&lt;/td&gt; &lt;td&gt;tom@tom.com&lt;/td&gt; &lt;td&gt;5000&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteEmp?id=001&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Jerry&lt;/td&gt; &lt;td&gt;jerry@sohu.com&lt;/td&gt; &lt;td&gt;8000&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteEmp?id=002&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Bob&lt;/td&gt; &lt;td&gt;bob@tom.com&lt;/td&gt; &lt;td&gt;10000&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteEmp?id=003&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div id=&quot;formDiv&quot;&gt; &lt;h4&gt;添加新员工&lt;/h4&gt; &lt;table&gt; &lt;tr&gt; &lt;td class=&quot;word&quot;&gt;name: &lt;/td&gt; &lt;td class=&quot;inp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;empName&quot; id=&quot;empName&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;word&quot;&gt;email: &lt;/td&gt; &lt;td class=&quot;inp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot; id=&quot;email&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;word&quot;&gt;salary: &lt;/td&gt; &lt;td class=&quot;inp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;salary&quot; id=&quot;salary&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt; &lt;button id=&quot;addEmpButton&quot; value=&quot;abc&quot;&gt; Submit &lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 优化后，封装函数复用的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Untitled Document&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styleB/css.css&quot; /&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; var deleteFun=function()&#123; //在事件响应function的时候会有一个this对象，这个this对象是当前正在响应事件的dom对象 //得到a标签对象的父亲的父亲 var $tbr=$(this).parent().parent(); //获取第一个td标签的内容 var name=$tbr.find(&quot;td:first&quot;).text(); //confirm是js提供的一个确认提示框，你给他传什么它就提示什么，用户点击确定就返回true，点击取消就返回false if(confirm(&quot;你确定要删除&quot;+name+&quot;么&quot;))&#123; $tbr.remove(); &#125; //return false; 可以阻止，元素的默认行为 return false;//可以点击标签时不跳转 &#125;; $(&quot;#addEmpButton&quot;).click(function()&#123; //获取输入框的内容 var name=$(&quot;#empName&quot;).val(); var email=$(&quot;#email&quot;).val(); var salary=$(&quot;#salary&quot;).val(); //创建一个行标签对象，添加到显示数据的表格中 var $tobr=$(&quot;&lt;tr&gt;&quot;+ &quot;&lt;td&gt;&quot;+name+&quot;&lt;/td&gt;&quot;+ &quot;&lt;td&gt;&quot;+email+&quot;&lt;/td&gt;&quot;+ &quot;&lt;td&gt;&quot;+salary+&quot;&lt;/td&gt;&quot;+ &quot;&lt;td&gt;&lt;a href=\\&quot;deleteEmp?id=002\\&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt;&quot;+ &quot;&lt;/tr&gt;&quot;); //添加到显示数据的表格中 $tobr.appendTo($(&quot;#employeeTable&quot;)); //这里是每次添加新的信息之后，给他绑定删除事件，防止新添加的这些无法删除 $tobr.find(&quot;a&quot;).click(deleteFun);&#125;); //给删除a标签绑定单机事件 $(&quot;a&quot;).click(deleteFun); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;table id=&quot;employeeTable&quot;&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Email&lt;/th&gt; &lt;th&gt;Salary&lt;/th&gt; &lt;th&gt;&amp;nbsp;&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Tom&lt;/td&gt; &lt;td&gt;tom@tom.com&lt;/td&gt; &lt;td&gt;5000&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteEmp?id=001&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Jerry&lt;/td&gt; &lt;td&gt;jerry@sohu.com&lt;/td&gt; &lt;td&gt;8000&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteEmp?id=002&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Bob&lt;/td&gt; &lt;td&gt;bob@tom.com&lt;/td&gt; &lt;td&gt;10000&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteEmp?id=003&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div id=&quot;formDiv&quot;&gt; &lt;h4&gt;添加新员工&lt;/h4&gt; &lt;table&gt; &lt;tr&gt; &lt;td class=&quot;word&quot;&gt;name: &lt;/td&gt; &lt;td class=&quot;inp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;empName&quot; id=&quot;empName&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;word&quot;&gt;email: &lt;/td&gt; &lt;td class=&quot;inp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot; id=&quot;email&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;word&quot;&gt;salary: &lt;/td&gt; &lt;td class=&quot;inp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;salary&quot; id=&quot;salary&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt; &lt;button id=&quot;addEmpButton&quot; value=&quot;abc&quot;&gt; Submit &lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; jQuery中css样式操作addClass() 添加样式 removeClass() 删除样式 toggleClass() 有就删除，没有就添加样式 offset() 获取和设置元素的坐标，下面是这个的样例显示 top: 10.777777671813965, left: 118.55555725097656} 这两个参数top是符合条件的标签到浏览器顶上的距离，left是到左边框距离 123div.whiteborder&#123; border: 2px white solid;&#125; 这个div是指这个样式只能给div这个标签使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt; div&#123; width:100px; height:260px; &#125; div.whiteborder&#123; border: 2px white solid; &#125; div.redDiv&#123; background-color: red; &#125; div.blueBorder&#123; border: 5px blue solid; &#125; &lt;/style&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; var $divEle = $(&#x27;div:first&#x27;); $(&#x27;#btn01&#x27;).click(function()&#123; //addClass() - 向被选元素添加一个或多个类 $divEle.addClass(&quot;redDiv blueBorder&quot;); &#125;); $(&#x27;#btn02&#x27;).click(function()&#123; //removeClass() - 从被选元素删除一个或多个类 $divEle.removeClass(&quot;redDiv blueBorder&quot;); //$divEle.removeClass();全部删除 &#125;); $(&#x27;#btn03&#x27;).click(function()&#123; //toggleClass() - 对被选元素进行添加/删除类的切换操作 $divEle.toggleClass(&#x27;redDiv&#x27;); &#125;); $(&#x27;#btn04&#x27;).click(function()&#123; //offset() - 返回第一个匹配元素相对于文档的位置。 var pos=$divEle.offset(); //得到top和left console.log(pos); //还可以自己设置top和left，不一定是自己输入的值，按照当前屏幕大小给的值 $divEle.offset(&#123; top:100, left:50 &#125;); &#125;); &#125;)&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;table align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td&gt; &lt;div class=&quot;border&quot;&gt; &lt;/div&gt; &lt;/td&gt; &lt;td&gt; &lt;div class=&quot;btn&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;addClass()&quot; id=&quot;btn01&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;removeClass()&quot; id=&quot;btn02&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;toggleClass()&quot; id=&quot;btn03&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;offset()&quot; id=&quot;btn04&quot;/&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;/body&gt;&lt;/html&gt; jQuery动画基本动画 show() 将隐藏的元素显示 hide() 将可见的元素隐藏 toggle() 可见就隐藏，不可见就显示 以上动画方法都可以添加参数 这七个函数的参数都是这俩，只有fadeTo是不一样的，因为fadeTo多一个透明度的参数 ​ 1.第一个参数是动画执行的时常，以毫秒为单位 ​ 2.第二个参数是动画的回调函数（动画完成后自动调用的函数） 淡入淡出动画 fadeln() 淡入 慢慢可见 fadeOut() 淡出 慢慢消失 fadeTo() 在指定时常内慢慢的将透明度修改到指定的值 0透明 0.5半透明 1不透明 fadeToggle() 淡入淡出切换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;link href=&quot;css/style.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; /* 基本 show([speed,[easing],[fn]]) hide([speed,[easing],[fn]]) toggle([speed],[easing],[fn]) 滑动 slideDown([spe],[eas],[fn]) slideUp([speed,[easing],[fn]]) slideToggle([speed],[easing],[fn]) 淡入淡出 fadeIn([speed],[eas],[fn]) fadeOut([speed],[eas],[fn]) fadeTo([[spe],opa,[eas],[fn]]) fadeToggle([speed,[eas],[fn]]) */ $(function()&#123; //显示 show() $(&quot;#btn1&quot;).click(function()&#123; $(&quot;#div1&quot;).show(1000,function()&#123; alert(&quot;show动画完成&quot;) &#125;); &#125;); //隐藏 hide() $(&quot;#btn2&quot;).click(function()&#123; $(&quot;#div1&quot;).hide(1000,function()&#123; alert(&quot;hide动画执行完成&quot;) &#125;); &#125;); //切换 toggle() $(&quot;#btn3&quot;).click(function()&#123; $(&quot;#div1&quot;).toggle(1000,function()&#123; alert(&quot;toggle动画执行完成&quot;) &#125;); &#125;); //动画的演示方式，就是不断的调用他自己 /*var abc=function()&#123; $(&quot;#div1&quot;).toggle(1000,abc); &#125; abc();*/ //淡入 fadeIn() $(&quot;#btn4&quot;).click(function()&#123; $(&#x27;#div1&#x27;).fadeIn(2000,function()&#123; alert(&quot;淡入完成&quot;); &#125;); &#125;); //淡出 fadeOut() $(&quot;#btn5&quot;).click(function()&#123; $(&#x27;#div1&#x27;).fadeOut(2000,function()&#123; alert(&quot;淡出完成&quot;); &#125;); &#125;); //淡化到 fadeTo() $(&quot;#btn6&quot;).click(function()&#123; $(&quot;#div1&quot;).fadeTo(2000,0.5,function()&#123; alert(&quot;fadeTo完成&quot;); &#125;); &#125;); //淡化切换 fadeToggle() $(&quot;#btn7&quot;).click(function()&#123; $(&#x27;#div1&#x27;).fadeToggle(2000,function()&#123; alert(&quot;切换完成&quot;); &#125;); &#125;); &#125;)&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;table style=&quot;float: left;&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;button id=&quot;btn1&quot;&gt;显示show()&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button id=&quot;btn2&quot;&gt;隐藏hide()&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button id=&quot;btn3&quot;&gt;显示/隐藏切换 toggle()&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button id=&quot;btn4&quot;&gt;淡入fadeIn()&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button id=&quot;btn5&quot;&gt;淡出fadeOut()&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button id=&quot;btn6&quot;&gt;淡化到fadeTo()&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button id=&quot;btn7&quot;&gt;淡化切换fadeToggle()&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div id=&quot;div1&quot; style=&quot;float:left;border: 1px solid;background-color: blue;width: 300px;height: 200px;&quot;&gt; jquery动画定义了很多种动画效果，可以很方便的使用这些动画效果 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; jQuery动画练习1234.showmore a span &#123; padding-left: 15px; background: url(img/down.gif) no-repeat 0 0;&#125; 这个css选择器的意思是 类选择器 且用这个选择器的标签子代必须有一个a，a的子代必须有一个span 添加cssclass样式的时候既可以用prop也可以用addClass 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;品牌展示练习&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;* &#123; margin: 0; padding: 0;&#125;body &#123; font-size: 12px; text-align: center;&#125;a &#123; color: #04D; text-decoration: none;&#125;a:hover &#123; color: #F50; text-decoration: underline;&#125;.SubCategoryBox &#123; width: 600px; margin: 0 auto; text-align: center; margin-top: 40px;&#125;.SubCategoryBox ul &#123; list-style: none;&#125;.SubCategoryBox ul li &#123; display: block; float: left; width: 200px; line-height: 20px;&#125;.showmore , .showless&#123; clear: both; text-align: center; padding-top: 10px;&#125;.showmore a , .showless a&#123; display: block; width: 120px; margin: 0 auto; line-height: 24px; border: 1px solid #AAA;&#125;.showmore a span &#123; padding-left: 15px; background: url(img/down.gif) no-repeat 0 0;&#125;.showless a span &#123; padding-left: 15px; background: url(img/up.gif) no-repeat 0 0;&#125;.promoted a &#123; color: #F50;&#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function() &#123; //基本初始状态$(&quot;li:gt(5):not(:last)&quot;).hide();//hide是动画操作//给功能的按钮绑定单击事件$(&quot;div div a&quot;).click(function()&#123;$(&quot;li:gt(5):not(:last)&quot;).toggle();//切换回显示//按钮上的文本，1.显示全部品牌，角标向下，文字显示全部品牌if( $(&quot;li:gt(5):not(:last)&quot;).is(&quot;:hidden&quot;))&#123;$(&quot;div div a span&quot;).text(&quot;显示全部品牌&quot;);$(&quot;div div&quot;).removeClass();$(&quot;div div&quot;).addClass(&quot;showmore&quot;);//$(&quot;div div&quot;).prop(&quot;class&quot;,&quot;showmore&quot;);,添加自己定义的css类的时候也可以用prop//高亮取消$(&quot;li:contains(&#x27;索尼&#x27;)&quot;).removeClass(&quot;promoted&quot;);&#125;else&#123;//显示精简品牌，角标向上，且文字是显示精简品牌$(&quot;div div a span&quot;).text(&quot;显示精简品牌&quot;);$(&quot;div div&quot;).removeClass();$(&quot;div div&quot;).addClass(&quot;showless&quot;);//$(&quot;div div&quot;).prop(&quot;class&quot;,&quot;showless&quot;);//高亮取消$(&quot;li:contains(&#x27;索尼&#x27;)&quot;).addClass(&quot;promoted&quot;);&#125;return false;&#125;); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;SubCategoryBox&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;佳能&lt;/a&gt;&lt;i&gt;(30440) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;索尼&lt;/a&gt;&lt;i&gt;(27220) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;三星&lt;/a&gt;&lt;i&gt;(20808) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;尼康&lt;/a&gt;&lt;i&gt;(17821) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;松下&lt;/a&gt;&lt;i&gt;(12289) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;卡西欧&lt;/a&gt;&lt;i&gt;(8242) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;富士&lt;/a&gt;&lt;i&gt;(14894) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;柯达&lt;/a&gt;&lt;i&gt;(9520) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;宾得&lt;/a&gt;&lt;i&gt;(2195) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;理光&lt;/a&gt;&lt;i&gt;(4114) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;奥林巴斯&lt;/a&gt;&lt;i&gt;(12205) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;明基&lt;/a&gt;&lt;i&gt;(1466) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;爱国者&lt;/a&gt;&lt;i&gt;(3091) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;其它品牌相机&lt;/a&gt;&lt;i&gt;(7275) &lt;/i&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;showmore&quot;&gt; &lt;a href=&quot;more.html&quot;&gt;&lt;span&gt;显示全部品牌&lt;/span&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 原生js和jQuery页面加载完成之后的区别$( function(){} ); 和 window.onload &#x3D; function(){} 的区别？ 他们分别是在什么时候触发？ 1、jQuery 的页面加载完成之后是浏览器的内核解析完页面的标签创建好 DOM 对象之后就会马上执行。 2、原生 js 的页面加载完成之后，除了要等浏览器内核解析完标签创建好 DOM 对象，还要等标签显示时需要的内容加载 完成。 他们触发的顺序？ 1、jQuery 页面加载完成之后先执行 2、原生 js 的页面加载完成之后 他们执行的次数？ 1、原生 js 的页面加载完成之后，只会执行最后一次的赋值函数。 2、jQuery 的页面加载完成之后是全部把注册的 function 函数，依次顺序全部执行 jQuery中常用的事件处理方法click() 可以绑定单击事件，以及触发单击事件 mouseover() 鼠标移入事件 mouseout() 鼠标移出事件 bind() 可以给元素一次性绑定一个或多个事件 one() 使用上和bind一样，但是one方法绑定的事件只会触发一次 unbind () 和bind方法相反的操作，解除事件的绑定 live() 也是用来绑定事件的，可以用来绑定选择器匹配的所有元素的事件，哪怕这个元素是后面动态创建出来的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;link href=&quot;css/style.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; //1.通常绑定事件的方式 //3.合并“鼠标移入”和“鼠标移出”事件 //4.合并单击事件 //5.切换元素可见状态 //6.只绑定一次 // 触发事件的讲解 $(&quot;h5&quot;).click(function()&#123;//传function是绑定事件 alert(&quot;h5单击事件&quot;); &#125;); /*$(&quot;button&quot;).click(function()&#123; $(&quot;h5&quot;).click();//不传function是触发事件，就是调用了h5的绑定事件 &#125;);*/ //鼠标移入事件 /*$(&quot;h5&quot;).mouseover(function()&#123; console.log(&quot;你进来了&quot;); &#125;);*/ //鼠标移除事件 /*$(&quot;h5&quot;).mouseout(function()&#123; console.log(&quot;你出来了&quot;); &#125;);*/ //jQuery提供的绑定方式：bind()函数 /*$(&quot;h5&quot;).bind(&quot;click mouseover mouseout&quot;,function()&#123; console.log(&quot;这是bind绑定的事件&quot;); &#125;);*/ //one()函数 /* $(&quot;h5&quot;).one(&quot;click mouseover mouseout&quot;,function()&#123; console.log(&quot;这是one绑定的事件&quot;); &#125;);*/ //unbind()函数,不加参数就全删了 /*$(&quot;h5&quot;).unbind(&quot;click mouseover&quot;);*/ //live()函数 //正常的绑定函数就是只有一开始那个被绑定的标签有效果，现在后来添加的标签依然是有效果的 $(&quot;h5&quot;).live(&quot;click&quot;,function()&#123; alert(&#x27;h5单击事件==live方法绑定&#x27;); &#125;); $(&#x27;&lt;h5 class=&quot;head&quot;&gt;什么是jQuery?&lt;/h5&gt;&#x27;).appendTo($(&quot;#panel&quot;)); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;panel&quot;&gt; &lt;h5 class=&quot;head&quot;&gt;什么是jQuery?&lt;/h5&gt; &lt;div class=&quot;content&quot;&gt; jQuery是继Prototype之后又一个优秀的JavaScript库，它是一个由 John Resig 创建于2006年1月的开源项目。jQuery凭借简洁的语法和跨平台的兼容性，极大地简化了JavaScript开发人员遍历HTML文档、操作DOM、处理事件、执行动画和开发Ajax。它独特而又优雅的代码风格改变了JavaScript程序员的设计思路和编写程序的方式。 &lt;/div&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; jQuery事件的冒泡事件冒泡是指父子元素同时监听一个事件，当触发子元素事件的时候，同一个事件也被传递到了父元素的事件里去响应 在子元素事件函数体内，return false 可以阻止事件的冒泡传递 简单来说就是，如果父子元素绑定同一个事件，子元素的事件被触发的时候，父元素的这个事件也会被触发 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0; padding: 0; &#125; body&#123; font-size: 13px; line-height: 130%; padding: 60px; &#125; #content&#123; width: 220px; border: 1px solid #0050D0; background: #96E555; &#125; span&#123; width: 200px; margin: 10px; background: #666666; cursor: pointer; color: white; display: block; &#125; p&#123; width: 200px; background: #888; color: white; height: 16px; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; $(&quot;#content&quot;).click(function()&#123; alert(&quot;这是div&quot;); &#125;); $(&quot;span&quot;).click(function()&#123; alert(&quot;这是span&quot;); //return false; &#125;); &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;content&quot;&gt; 外层div元素 &lt;span&gt;内层span元素&lt;/span&gt; 外层div元素 &lt;/div&gt; &lt;div id=&quot;msg&quot;&gt;&lt;/div&gt; &lt;br&gt;&lt;br&gt; &lt;a href=&quot;http://www.hao123.com&quot;&gt;WWW.HAO123.COM&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; jQuery事件对象事件对象，是封装有触发的事件信息的一个javascript对象 我们重点关心的是怎么拿到这个javasccript的事件对象 再给元素绑定事件的时候，在事件的function参数列表中添加一个参数，这个event就是javasccript传递参事件处理函数的事件对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt; #areaDiv &#123; border: 1px solid black; width: 300px; height: 50px; margin-bottom: 10px; &#125; #showMsg &#123; border: 1px solid black; width: 300px; height: 20px; &#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; //1.原生javascript获取 事件对象 /*window.onload=function()&#123; document.getElementById(&quot;areaDiv&quot;).onclick=function(event)&#123; console.log(event); &#125; &#125;;*/ //2.JQuery代码获取 事件对象 /*$(function()&#123; $(&quot;#areaDiv&quot;).click(function(event)&#123; console.log(event); &#125;); &#125;);*/ //3.使用bind同时对多个事件绑定同一个函数。怎么获取当前操作是什么事件。 //这个操作可以让bind绑定的多个事件做不一样的事情 $(function()&#123; $(&quot;#areaDiv&quot;).bind(&quot;mouseout mouseover&quot;,function(event)&#123; if(event.type==&quot;mouseover&quot;)&#123; console.log(&quot;鼠标移入&quot;); &#125; else if(event.type==&quot;mouseout&quot;) &#123; console.log(&quot;鼠标移出&quot;); &#125; &#125;); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;areaDiv&quot;&gt;&lt;/div&gt; &lt;div id=&quot;showMsg&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; jQuery练习，图片跟随123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt; body &#123; text-align: center; &#125; #small &#123; margin-top: 150px; &#125; #showBig &#123; position: absolute; display: none; &#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; $(&quot;#small&quot;).bind(&quot;mouseover mouseout mousemove&quot;,function(event)&#123; if(event.type==&quot;mouseover&quot;)&#123; $(&quot;#showBig&quot;).show(); &#125; else if(event.type==&quot;mouseout&quot;)&#123; $(&quot;#showBig&quot;).hide(); &#125; else if(event.type==&quot;mousemove&quot;)&#123; $(&quot;#showBig&quot;).offset(&#123; left:event.pageX+10, top:event.pageY+10 &#125;); &#125; &#125;); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;img id=&quot;small&quot; src=&quot;img/small.jpg&quot; /&gt; &lt;div id=&quot;showBig&quot;&gt; &lt;img src=&quot;img/big.jpg&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 书城项目的第一个阶段表单验证规定了注册时用户名密码的格式，以及错误提示等等， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;尚硅谷会员注册页面&lt;/title&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;../../static/css/style.css&quot; &gt; &lt;script src=&quot;../../static/script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; //1.验证用户名，必须由数字字母下划线组成，并且长度为5到12位 $(&quot;#sub_btn&quot;).click(function()&#123; //1.获取用户名输入框中的内容 var username=$(&quot;#username&quot;).val(); //2.创建正则表达式对象 var pattern=/^\\w&#123;5,12&#125;$/; //3.使用test方法进行验证 if(!pattern.test(username))&#123; $(&quot;span.errorMsg&quot;).text(&quot;用户名不合法&quot;); //有了return false不会跳转 return false; &#125;//2.验证密码 //1.获取用户名输入框中的内容 var password=$(&quot;#password&quot;).val(); //2.创建正则表达式对象 var pspattern=/^\\w&#123;5,12&#125;$/; //3.使用test方法进行验证 if(!pspattern.test(password))&#123; $(&quot;span.errorMsg&quot;).text(&quot;密码不合法&quot;); //有了return false不会跳转 return false; &#125;//3.确认密码 //1.获取确认密码内容 var repassword =$(&quot;#repwd&quot;).val(); if(repassword!=password)&#123; $(&quot;span.errorMsg&quot;).text(&quot;确认密码与密码不一致&quot;); return false; &#125;//4.验证邮箱 //1.获取邮箱当中的内容 var emailText=$(&quot;#email&quot;).val(); var emailpt=/^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]&#123;2,6&#125;)$/; if(!emailpt.test(emailText))&#123; $(&quot;span.errorMsg&quot;).text(&quot;邮箱格式不合法&quot;); return false; &#125;//5.验证码，验证由输入内容即可 var codeText=$(&quot;#code&quot;).val(); //去掉验证码前后空格 codeText=$.trim(codeText); if(codeText==null||codeText==&quot;&quot;)&#123; $(&quot;span.errorMsg&quot;).text(&quot;无验证码&quot;); return false; &#125; $(&quot;span.errorMsg&quot;).text(&quot;&quot;);//如果用户名密码邮箱又合法了再给他改过来&#125;); &#125;); &lt;/script&gt;&lt;style type=&quot;text/css&quot;&gt; .login_form&#123; height:420px; margin-top: 25px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;login_header&quot;&gt; &lt;img class=&quot;logo_img&quot; alt=&quot;&quot; src=&quot;../../static/img/logo.gif&quot; &gt; &lt;/div&gt; &lt;div class=&quot;login_banner&quot;&gt; &lt;div id=&quot;l_content&quot;&gt; &lt;span class=&quot;login_word&quot;&gt;欢迎注册&lt;/span&gt; &lt;/div&gt; &lt;div id=&quot;content&quot;&gt; &lt;div class=&quot;login_form&quot;&gt; &lt;div class=&quot;login_box&quot;&gt; &lt;div class=&quot;tit&quot;&gt; &lt;h1&gt;注册尚硅谷会员&lt;/h1&gt; &lt;span class=&quot;errorMsg&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;form&quot;&gt; &lt;form action=&quot;regist_success.html&quot;&gt; &lt;label&gt;用户名称：&lt;/label&gt; &lt;input class=&quot;itxt&quot; type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; autocomplete=&quot;off&quot; tabindex=&quot;1&quot; name=&quot;username&quot; id=&quot;username&quot; /&gt; &lt;br /&gt; &lt;br /&gt; &lt;label&gt;用户密码：&lt;/label&gt; &lt;input class=&quot;itxt&quot; type=&quot;password&quot; placeholder=&quot;请输入密码&quot; autocomplete=&quot;off&quot; tabindex=&quot;1&quot; name=&quot;password&quot; id=&quot;password&quot; /&gt; &lt;br /&gt; &lt;br /&gt; &lt;label&gt;确认密码：&lt;/label&gt; &lt;input class=&quot;itxt&quot; type=&quot;password&quot; placeholder=&quot;确认密码&quot; autocomplete=&quot;off&quot; tabindex=&quot;1&quot; name=&quot;repwd&quot; id=&quot;repwd&quot; /&gt; &lt;br /&gt; &lt;br /&gt; &lt;label&gt;电子邮件：&lt;/label&gt; &lt;input class=&quot;itxt&quot; type=&quot;text&quot; placeholder=&quot;请输入邮箱地址&quot; autocomplete=&quot;off&quot; tabindex=&quot;1&quot; name=&quot;email&quot; id=&quot;email&quot; /&gt; &lt;br /&gt; &lt;br /&gt; &lt;label&gt;验证码：&lt;/label&gt; &lt;input class=&quot;itxt&quot; type=&quot;text&quot; style=&quot;width: 150px;&quot; id=&quot;code&quot;/&gt; &lt;img alt=&quot;&quot; src=&quot;../../static/img/code.bmp&quot; style=&quot;float: right; margin-right: 40px&quot;&gt; &lt;br /&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot; id=&quot;sub_btn&quot; /&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;bottom&quot;&gt; &lt;span&gt; 尚硅谷书城.Copyright &amp;copy;2015 &lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; XML什么是XML？ xml是可扩展性标记性语言 XML的作用 ​ 1.用来保存数据，而且这些数据具有自我描述性 ​ 2.它还可以做为项目或者模块的配置文件 ​ 3.还可以作为网络传输数据的格式(JSON为主) 示例 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;以上内容就是xml文件的声明version=&quot;1.0&quot; encoding=&quot;utf-8&quot; version表示xml的版本 encoding表示xml文件本身的编码--&gt;&lt;books&gt; &lt;book sb=&quot;SN123412123412&quot;&gt;&lt;!--book表示一个图书信息 sn属性表示图书序列号--&gt; &lt;name&gt;时间监视&lt;/name&gt;&lt;!--name标签表示书名--&gt; &lt;author&gt;霍金&lt;/author&gt;&lt;!--author表示作者--&gt; &lt;price&gt;75&lt;/price&gt;&lt;!--price表示图书价格--&gt; &lt;/book&gt; &lt;book sb=&quot;SN123412123411&quot;&gt;&lt;!--book表示一个图书信息 sn属性表示图书序列号--&gt; &lt;name&gt;java入门&lt;/name&gt;&lt;!--name标签表示书名--&gt; &lt;author&gt;沙老师&lt;/author&gt;&lt;!--author表示作者--&gt; &lt;price&gt;9.9&lt;/price&gt;&lt;!--price表示图书价格--&gt; &lt;/book&gt;&lt;/books&gt; XML文件的写法 1-2 xml 发明的目的： 传输和 存储数据。 **xml 发明的*目的*： *传输和 存储数据。* xml 发明的目的： 传输和 存储数据。 **xml 发明的*目的*： *传输和 存储数据。* xml 不是为了展示数据， html 才是为了展示数据用的。 所有的xml 必须要有一个根节点： 这种写法是错误的 正确的写法： 浏览器展示 第二章： xml的 基本语法。 Xml的头声明， 可以有，也可以省略 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&quot;&quot;&quot;version参数是版本号&quot;&quot;&quot; encoding是编码&lt;!--&lt;a&gt;ddd &lt;b&gt;hh&lt;/a&gt;&lt;/b&gt;--&gt;&quot;&quot;&quot;这里是一个xml文件的一个注释&quot;&quot;&quot;&lt;root&gt; &lt;shuibian&gt;....&lt;/shuibian&gt; &lt;xie&gt;...&lt;/xie&gt;&lt;/root&gt; 标签交叉，在xml 是不允许的。 属性：就是描述这个标签额外的信息。 例子：比如img 标签，必须要有 src属性 。 Img 标签，本身的目的：就是个图片标签 。 Src 属性 的作用是： 告诉你要展示的图片 在哪里 属性规则： 但是在xml中，我们不需要额外的信息进行展示。 因为我们是自定义标签的 。 Html标签，必须要用到属性，因为我们不能自定义html标签。 Xml 中，属性就是鸡肋。 属性，在xml中可以用。但是用的真不多 CDATA的写法 展示效果： DTD简介 1.对xml文件的格式进行约束，保证xml是一个有效的xml 2.dtd可以分为两种，内部dtd(你在写xml代码的时候就把内部dtd写好了)，外部dtd(他是一个外部的单独的dtd文件，需要引入进来) 使用 内部的dtd的定义，语法如下： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--声明dtd--&gt;&lt;!DOCTYPE scores [&lt;!ELEMENT scores (student*)&gt;&lt;!--这里的星号表示出现任意次--&gt;&lt;!ELEMENT student (name,course,score)&gt;&lt;!ATTLIST student id CDATA #REQUIRED&gt;&lt;!ELEMENT name (#PCDATA)&gt;&lt;!ELEMENT score (#PCDATA)&gt;&lt;!ELEMENT course (#PCDATA)&gt;&lt;!--让name标签里面只能写文本而不能写其他的标签之类的--&gt;&lt;!--PCDATA 是会被解析器解析的文本。. 这些文本将被解析器检查实体以及标记。. 文本中的标签会被当作标记来处理，而实体会被展开。. 不过，被解析的字符数据不应当包含任何 &amp; &lt; &gt; 字符；需要使用 &amp; &lt; &gt; 实体来分别替换它们--&gt;&lt;!ENTITY jt &quot;Joe Test&quot;&gt;&lt;!--实例--&gt;&lt;!ENTITY % jtt &quot;Joe Test&quot;&gt;&lt;!--这相当于声明了一个对象，只能在dtd文件中使用,用的时候就是%jjt;--&gt;&lt;scores&gt; &lt;student id=&quot;1&quot;&gt; &lt;name&gt;王同&lt;/name&gt; &lt;course&gt;java&lt;/course&gt; &lt;score&gt;89&lt;/score&gt; &lt;/student&gt; &lt;student id=&quot;2&quot;&gt; &lt;name&gt;李佳&lt;/name&gt; &lt;course&gt;sql&lt;/course&gt; &lt;score&gt;58&lt;/score&gt; &lt;test&gt;&amp;jt;&lt;/test&gt; &lt;!--实例，这里的;不会显示--&gt; &lt;/student&gt;&lt;/scores&gt;]&gt;&lt;!--加入了dtd之后，写xml文件之后就有模板有提示了--&gt; 12345678910111213141516171819202122这就是&lt;!ATTLIST student id CDATA #REQUIRED&gt;条代码的解释基本语法：&lt;!ATTLIST 元素名称 属性名称 属性类型 默认值&gt;上面对id属性的限制的最后一个参数类型有#REQUIRED 表示属性值必须#IMPLIED 表示属性值不是必须的#FIXED value 属性值是固定的值 默认值上面对id属性的限制倒数第二个参数类型有CDATA 字符或数字(en1|en2|……) 枚举类型 ID 属性唯一IDREF 对某个唯一属性进行引用 123456789101112131415&lt;!ELEMENT 元素名称 类别&gt; 或&lt;!ELEMENT 元素名称 (元素内容)&gt;类别：约束标签的内容EMPTY：空标签(#PCDATA)：普通字符串（没有子标签）ANY ： 可以是任何内容（包含子标签）(元素内容)： 标签包含子标签的情况顺序问题：(A,B,C,D): 按顺序依次出现(A|B|C|D): 任意出现一个(枚举式出现) 数量词 + 表示出现一次或者多次，至少一次 ?表示出现0次或1次 *表示出现任意次 外部dtd 1.创建一个外部的dtd文件 这是一个文件的格式 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--声明dtd--&gt;&lt;!ELEMENT scores (student*)&gt;&lt;!--上面的空格是必须要有的--&gt;&lt;!--这里的星号表示出现任意次--&gt;&lt;!ELEMENT student (name,course,score)&gt;&lt;!ATTLIST student id CDATA #REQUIRED&gt;&lt;!ELEMENT name (#PCDATA)&gt;&lt;!ELEMENT score (#PCDATA)&gt;&lt;!ELEMENT course (#PCDATA)&gt; 2.在xml中引入一个外部的dtd文件 1&lt;!DPCTYPE scores SYSTEM “scores.dtd&quot;&gt; 这有的浏览器对其可能不支持 第二个是根标签，scores.dtd是一个要引入的文件，SYSTEM也是必要的 ENTITY的使用实例 关于ENTITY的讲解，在xxe漏洞当中介绍 XML解析技术介绍xml 可扩展的标记语言。 不管是 html 文件还是 xml 文件它们都是标记型文档，都可以使用 w3c 组织制定的 dom 技术来解析 document 对象表示的是整个文档（可以是 html 文档，也可以是 xml 文档） 使用dom4j读取xml文件得到document对象dom4j的使用直接看pdf 被用来解析的xml文件 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;books&gt; &lt;book sn=&quot;SN12341232&quot;&gt; &lt;name&gt;辟邪剑谱&lt;/name&gt; &lt;price&gt;9.9&lt;/price&gt; &lt;author&gt;班主任&lt;/author&gt; &lt;/book&gt; &lt;book sn=&quot;SN12341231&quot;&gt; &lt;name&gt;葵花宝典&lt;/name&gt; &lt;price&gt;99.99&lt;/price&gt; &lt;author&gt;班长&lt;/author&gt; &lt;/book&gt;&lt;/books&gt; 解析xml文件的代码 @Test是指一个测试方法，这个方法使用需要导包导关于junit4的包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import com.atguigu.pojo.Book;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;import org.junit.Test;import java.util.List;import static java.lang.Double.parseDouble;public class Dom4jTest &#123; @Test//是指这是一个测试方法，可以不用主方法来调用 public void test1() throws DocumentException &#123; //创建一个SaxReader输入流，去读取xml配置文件，生成Document对象 SAXReader saxReader=new SAXReader(); Document document = saxReader.read(&quot;src/books.xml&quot;); System.out.println(document); &#125; @Test public void test2() throws DocumentException &#123; //1.读取books.xml文件 SAXReader reader= new SAXReader(); // 2.通过Document对象获取根元素 //在Junit测试中，相对路径是从模块开始的也就是从xml模块开始的，所以路径中第一个是src Document read = reader.read(&quot;src/books.xml&quot;); //3.通过根元素获取book标签对象 Element element = read.getRootElement(); //element()和elements()都是通过标签名查找子元素，elements()返回多个，element()返回一个 List&lt;Element&gt; books = element.elements(&quot;book&quot;); //4.遍历，处理每个book标签转化为Book类 for(Element book:books)&#123; //asXML()把标签对象转换为标签字符串 Element nameElement=book.element(&quot;name&quot;); //getText()获取标签文本内容 String nameText=nameElement.getText(); //直接获取指定标签名的文本内容 String priceText=book.elementText(&quot;price&quot;); String authorText=book.elementText(&quot;author&quot;); //获取属性值 String snValue=book.attributeValue(&quot;sn&quot;); System.out.println(new Book(snValue,nameText,parseDouble(priceText),authorText)); &#125; &#125;&#125; Idea文件结构项目-&gt;模块-&gt;包 src文件夹中放置你的源代码，out目录放置src文件夹里面的java程序 Tomcatjavaweb概念javaweb是指所有通过java语言编写的可以通过浏览器访问的程序的总成称叫javaweb java是基于请求和响应来开发的 什么是请求 请求是指客户端发给服务器发送数据，叫请求request 什么是响应 相应是指服务器给客户端回传数据，叫响应reponse 请求和响应的关系 成对出现的，有请求就有回应 2.Web 资源的分类 web 资源按实现的技术和呈现的效果的不同，又分为静态资源和动态资源两种。 静态资源： html、css、js、txt、mp4 视频 , jpg 图片 动态资源： jsp 页面、Servlet 程序 3.常用的 Web 服务器 Tomcat：由 Apache 组织提供的一种 Web 服务器，提供对 jsp 和 Servlet 的支持。它是一种轻量级的 javaWeb 容器（服务 器），也是当前应用最广的 JavaWeb 服务器（免费）。 Jboss：是一个遵从 JavaEE 规范的、开放源代码的、纯 Java 的 EJB 服务器，它支持所有的 JavaEE 规范（免费）。 GlassFish： 由 Oracle 公司开发的一款 JavaWeb 服务器，是一款强健的商业服务器，达到产品级质量（应用很少）。 Resin：是 CAUCHO 公司的产品，是一个非常流行的服务器，对 servlet 和 JSP 提供了良好的支持， 性能也比较优良，resin 自身采用 JAVA 语言开发（收费，应用比较多）。 WebLogic：是 Oracle 公司的产品，是目前应用最广泛的 Web 服务器，支持 JavaEE 规范， 而且不断的完善以适应新的开发要求，适合大型项目（收费，用的不多，适合大公司）。 Tomcat服务器和Servelet版本的对应关系 Tomcat使用安装 找到你需要用的 Tomcat 版本对应的 zip 压缩包，解压到需要安装的目录即可。 目录介绍bin 专门用来存放 Tomcat 服务器的可执行程序 conf 专门用来存放 Tocmat 服务器的配置文件 lib 专门用来存放 Tomcat 服务器的 jar 包 logs 专门用来存放 Tomcat 服务器运行时输出的日记信息 temp 专门用来存放 Tomcdat 运行时产生的临时数据 webapps 专门用来存放部署的 Web 工程。 work 是 Tomcat 工作时的目录，用来存放 Tomcat 运行时 jsp 翻译为 Servlet 的源码，和 Session 钝化（序列化）的目录 如何启动tomcat服务器 找到 Tomcat 目录下的 bin 目录下的 startup.bat 文件，双击，就可以启动 Tomcat 服务器 另一种启动Tomcat服务器的方式 1、打开命令行 2、cd 到 你的 Tomcat 的 bin 目录下 3、敲入启动命令： catalina ru 直接在命令行里输入D:就可以进入D盘 Tomcat的停止1、点击 tomcat 服务器窗口的 x 关闭按钮 2、把 Tomcat 服务器窗口置为当前窗口，然后按快捷键 Ctrl+C 3、找到 Tomcat 的 bin 目录下的 shutdown.bat 双击，就可以停止 Tomcat 服务器 如何修改Tomcat默认的端口号Mysql 默认的端口号是：3306 Tomcat 默认的端口号是：8080 找到 Tomcat 目录下的 conf 目录，找到 server.xml 配置文件。 修改port属性来修改服务器端口 如何把web工程部署到tomcat服务器中第一种方法：只需要把web工程的目录拷贝到Tomcat服务器的webapps目录下即可 第二种方法 123http://localhost:8080/abc/index.html 这个xml文件名和那个path不一定非得一样，且这个xml文件在变成xml文件之前必须是UTF-8的记事本文件，然后改名为xml文件 1.让txt文件变成html文件被访问的时候，用ANSI编码格式，否则会出现乱码 Tomcat中创建动态的web工程csdn中记载那样创建 先创建一个java模块，然后右键java模块找到add framework support 再在WEB-INF目录里创建lib目录，存放jar包，将jar复制进去之后，右键jar包，选add as libray Application server 是自己找到那个自己的Tomcat 如何在 IDEA 中部署工程到 Tomcat 上运行看pdf文件即可 如何给Tomcat添加第三方jar包看pdf即可 Servlet路径 什么是·Servlet 1.Servlet是javaEE规范之一，规范就是接口 2.Servlet是javaweb三大组件之一，三大组件分别是servlet程序，filter过滤器，listener监听器 3.Servlet是运行在服务器上的Java小程序，它可以接受客户端发送过来的请求，并响应数据给客户端 手动实现Servlet程序1.编写一个类去实现Servlet接口 2.实现service方法，处理请求，并响应数据 3.到web.xml中配置servlet程序的访问地址 实现servlet接口的程序 12345678910111213141516171819202122232425262728293031package com.atguigu.servlet;import javax.servlet.*;import java.io.IOException;public class HelloServlet implements Servlet &#123; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; /*service方法是专门用来处理请求和响应的*/ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println(&quot;hello servlet访问了&quot;); &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; &#125;&#125; web.xml文件 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;!--servlet标签给Tomcat配置Servlet程序--&gt; &lt;servlet-name&gt; HelloServlet &lt;!--这个名字一般是和类名一样的，但也是别名可以不同，但一定要和下面的servlet-mapping中的name相同，servlet-class是必须和真实类名相同的--&gt; &lt;/servlet-name&gt; &lt;!--servlet-class是Servlet程序的全类名--&gt; &lt;servlet-class&gt; com.atguigu.servlet.HelloServlet &lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;!--servlet-name标签的作用是告诉服务器，我当前配置的地址给那个Servlet程序使用--&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!--servlet-name标签的作用是告诉服务器，我当前配置的地址给那个Servlet程序使用--&gt; &lt;!-- url-pattern标签配置访问地址 / 斜杠在服务器解析的时候，表示地址为http://ip:port/工程路径 /hello 表示地址为:http://ip:port/工程路径/hello --&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;!--这里的这个hello最好是和servlet的名字有点联系，一眼能看出--&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 运行tomcat实例之后，在url后面添加&#x2F;hello就可以访问到这个HelloServlet程序，也就是调用了上面java代码中的service方法 常见的错误 url地址如何定位servlet程序去访问的 Servlet的生命周期一个servlet的执行顺序 1.执行Servlet构造器方法 2.执行init初始化方法 第一二步是在第一次方法的时候创建Servlet程序会调用，就是如果刷新页面再次访问不会再执行1，2 3.执行service方法 每次访问都会调用，每次刷新页面再次访问就会调用 4.执行destroy方法 第四步，在web工程停止的时候会调用 四个方法实现的演示 1234567891011121314151617181920212223242526272829303132333435package com.atguigu.servlet;import javax.servlet.*;import java.io.IOException;public class HelloServlet implements Servlet &#123; public HelloServlet() &#123; System.out.println(&quot;1 构造器方法&quot;); &#125; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; System.out.println(&quot;2.ini方法&quot;); &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; /*service方法是专门用来处理请求和响应的*/ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println(&quot;3 service===hello servlet访问了&quot;); &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; System.out.println(&quot;4.destroy方法&quot;); &#125;&#125; 12345启动服务器之后，访问http://localhost:8080/ab/hello结果：1 构造器方法 2.ini方法 3 service===hello servlet访问了 Servlet请求的分发处理1在模块文件夹下的html文件，可以通过http://localhost:8080/servlet/a.html访问 a.html前面的都是工程路径 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://localhost:8080/servlet/hello&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; method可以有post和get，对应不同的操作，所以应该对Servlet程序进行改良 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.atguigu.servlet;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;public class HelloServlet implements Servlet &#123; public HelloServlet() &#123; System.out.println(&quot;1 构造器方法&quot;); &#125; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; System.out.println(&quot;2.ini方法&quot;); &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; /*service方法是专门用来处理请求和响应的*/ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; //类型转换，HttpServletRequest是ServletRequest的子接口，Servlet没有getMethod方法 HttpServletRequest httpServletRequest= (HttpServletRequest) servletRequest; //获取请求的方式 String method = httpServletRequest.getMethod(); if(&quot;GET&quot;.equals(method))&#123; System.out.println(&quot;get请求&quot;); &#125; else if(&quot;POST&quot;.equals(&quot;post请求&quot;))&#123; System.out.println(&quot;post请求&quot;); &#125; &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; System.out.println(&quot;4.destroy方法&quot;); &#125;&#125; 一个方法中又执行get又执行post不太好，将这两个方法分开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.atguigu.servlet;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;public class HelloServlet implements Servlet &#123; public HelloServlet() &#123; System.out.println(&quot;1 构造器方法&quot;); &#125; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; System.out.println(&quot;2.ini方法&quot;); &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; /*service方法是专门用来处理请求和响应的*/ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; //类型转换，HttpServletRequest是ServletRequest的子接口，Servlet没有getMethod方法 HttpServletRequest httpServletRequest= (HttpServletRequest) servletRequest; //获取请求的方式 String method = httpServletRequest.getMethod(); if(&quot;GET&quot;.equals(method))&#123; doGet(); &#125; else if(&quot;POST&quot;.equals(&quot;post请求&quot;))&#123; doPost(); &#125; &#125; public void doGet()&#123; System.out.println(&quot;get请求&quot;); System.out.println(&quot;get请求&quot;); System.out.println(&quot;get请求&quot;); System.out.println(&quot;get请求&quot;); System.out.println(&quot;get请求&quot;); &#125; public void doPost()&#123; System.out.println(&quot;post请求&quot;); System.out.println(&quot;post请求&quot;); System.out.println(&quot;post请求&quot;); System.out.println(&quot;post请求&quot;); System.out.println(&quot;post请求&quot;); &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; System.out.println(&quot;4.destroy方法&quot;); &#125;&#125; 通过继承HttpServlet实现Servlet程序一般在实际项目中，都是使用继承HttpServlet类的方式去实现Servlet程序 1.编写一个类去继承 HttpServlet类 2.根据业务需要重写doGet或者doPost方法 3.到web.xml中配置Servlet程序的访问地址 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://localhost:8080/servlet/hello2&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class HelloServlet2 extends HttpServlet &#123; /* doGet()方法在Get请求的时候调用 doPost()方法在Post请求的时候调用 */ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;helloservlet2 doget&quot;); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;helloservlet2 dopost&quot;); &#125;&#125; 使用IDEA菜单生成Servlet程序整个Servlet类的继承体系 ServletConfig类ServletConfig从类名上看，就是Servlet程序的配置信息类 servlet程序和servletConfig对象都是由Tomcat负责创建，我们负责使用 Servlet程序默认是第一次访问的时候创建，ServletConfig是每个Servlet程序创建的时候，就创建一个对应的ServletConfig对象 三大作用 1.可以获取Servlet的别名额就是servlet-name的值 2.获取初始化参数init-param 3.获取servletContext对象 init方法体现了ServletConfig的三大作用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.atguigu.servlet;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;public class HelloServlet implements Servlet &#123; public HelloServlet() &#123; System.out.println(&quot;1 构造器方法&quot;); &#125; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; System.out.println(&quot;2.ini方法&quot;); // 1.可以获取Servlet的别名额就是servlet-name的值System.out.println(&quot;servlet的别名是:&quot;+servletConfig.getServletName()); //2.获取初始化参数init-paramSystem.out.println(&quot;初始化参数username的值为&quot;+servletConfig.getInitParameter(&quot;username&quot;));System.out.println(&quot;初始化参数password的值为&quot;+servletConfig.getInitParameter(&quot;password&quot;)); //3.获取servletContext对象 System.out.println(servletConfig.getServletContext()); &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; /*service方法是专门用来处理请求和响应的*/ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; //类型转换，HttpServletRequest是ServletRequest的子接口，Servlet没有getMethod方法 HttpServletRequest httpServletRequest= (HttpServletRequest) servletRequest; //获取请求的方式 String method = httpServletRequest.getMethod(); if(&quot;GET&quot;.equals(method))&#123; doGet(); &#125; else if(&quot;POST&quot;.equals(&quot;post请求&quot;))&#123; doPost(); &#125; &#125; public void doGet()&#123; System.out.println(&quot;get请求&quot;); System.out.println(&quot;get请求&quot;); System.out.println(&quot;get请求&quot;); System.out.println(&quot;get请求&quot;); System.out.println(&quot;get请求&quot;); &#125; public void doPost()&#123; System.out.println(&quot;post请求&quot;); System.out.println(&quot;post请求&quot;); System.out.println(&quot;post请求&quot;); System.out.println(&quot;post请求&quot;); System.out.println(&quot;post请求&quot;); &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; System.out.println(&quot;4.destroy方法&quot;); &#125;&#125; 每个Servlet程序对应一个ServletConfig对象，所以不可能在HelloServlet2中获得的ServletConfig对象来获取给HelloServlet1配置的信息 1234567891011121314151617181920212223242526272829303132package com.atguigu.servlet;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class HelloServlet2 extends HttpServlet &#123; /* doGet()方法在Get请求的时候调用 doPost()方法在Post请求的时候调用 */ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;helloservlet2 doget&quot;); //可以使用getServletConfig()方法来获得servletConfig对象 ServletConfig servletConfig=getServletConfig(); System.out.println(servletConfig); System.out.println(&quot;初始化参数username的值为&quot;+servletConfig.getInitParameter(&quot;username&quot;)); System.out.println(&quot;初始化参数password的值为&quot;+servletConfig.getInitParameter(&quot;password&quot;)); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;helloservlet2 dopost&quot;); &#125;&#125; 重写Servlet程序的init方法的时候一定要就是调用它父类的init方法 123456789public class HelloServlet2 extends HttpServlet &#123; //重写init程序的时候必须有这个super.init(config) @Override public void init(ServletConfig config) throws ServletException &#123; super.init(config);//调用父类的init方法才能让this.config获值 System.out.println(&quot;重写了init初始化方法，做了一些工作&quot;); &#125; /* ServletContext类1.ServletContext是一个接口，它表示servlet上下文对象 2.一个web工程只有一个ServletConText对象实例，不管调用getServletContext()几次，得到的都是一个ServletContext对象 3.ServletContext对象是一个域对象 4.ServletContext是在web工程部署启动的时候创建，在web工程停止的时候销毁 重新部署或者重启服务器之后，存储的数据就会消失 什么是域对象 域对象是可以象Map一样存储数据的对象，叫域对象 这里的域指的是存储数据的操作范围，整个web工程 ​ 存数据 取数据 删除数据 Map put() get() remove() 域对象 setAttribute() getAttribute() removeAttribute() ServletContext对象能向ServletContext域中存储对象 ServletContext类的四个作用 1.获取web.xml中配置的上下文参数context.param 2.获取当前的工程路径，格式:&#x2F;工程路径 3.获取工程部署后在服务器硬盘上的绝对路径 4.像Map一样存储数据 当正常在网址栏输入网址访问基本都是get请求 以下路径是IDEA整合Tomcat之后，Tomcat被拷贝的一些副本内容 C:\\Users#赵梓皓&amp;\\AppData\\Local\\JetBrains\\IntelliJIdea2020.3\\tomcat\\cc813db2-dbda-4294-89c0-505f477c0964 1D:\\IDEAjava工程\\javaweb\\out\\artifacts\\servlet_war_exploded\\ 这个就是项目部署之后在磁盘中的位置 servlet:war exploded就是一个文件夹，里面是项目中的web文件夹中的内容 前三个功能 1234567891011121314151617181920212223242526272829package com.atguigu.servlet;import javax.servlet.ServletConfig;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class ContextServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.获取web.xml中配置的上下文参数context.param ServletContext context= getServletConfig().getServletContext(); String username=context.getInitParameter(&quot;username&quot;); System.out.println(&quot;context-param参数username是&quot;+username); System.out.println(&quot;context-param参数password是&quot;+context.getInitParameter(&quot;password&quot;)); //2.获取当前的工程路径，格式:/工程路径System.out.println(&quot;当前工程的路径&quot;+context.getContextPath()); //3.获取工程部署后在服务器硬盘上的绝对路径 // 斜杠 被服务器解析地址为http://ip:port/工程名/ 映射到IDEA代码的web目录 //就是得到的这个地址访问之后就是web目录下的东西 System.out.println(&quot;工程部书之后的路径&quot;+context.getRealPath(&quot;/&quot;)); //获取web目录下的其他文件的绝对路径 System.out.println(&quot;工程下css目录的绝对路径是&quot;+context.getRealPath(&quot;/css&quot;)); System.out.println(&quot;工程目录下imgs目录1.jpg的绝对路径是&quot;+context.getRealPath(&quot;/imgs/1.jpg&quot;)); &#125;&#125; 第四个功能.像Map一样存储数据， ContextServlet1和ContextServlet2只要有一个存了key1的值，另一个也能获取key1的值，但重新部署或者重启服务器数据就消失了 ContextServlet1 1234567891011121314151617181920212223242526272829package com.atguigu.servlet;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class ContextServlet1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取ServletContext对象 ServletContext context = getServletContext(); //打印context的地址看两个Servlet中的地址相不相同 System.out.println(context); System.out.println(&quot;保存之前：Context1获取key1的值是&quot;+context.getAttribute(&quot;key1&quot;)); context.setAttribute(&quot;key1&quot;,&quot;value&quot;); System.out.println(&quot;context1中获取域数据key1的值为&quot;+context.getAttribute(&quot;key1&quot;)); System.out.println(&quot;context1中获取域数据key1的值为&quot;+context.getAttribute(&quot;key1&quot;)); System.out.println(&quot;context1中获取域数据key1的值为&quot;+context.getAttribute(&quot;key1&quot;)); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; &#125;&#125; ContextServlet2 123456789101112131415161718package com.atguigu.servlet;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class ContextServlet2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException&#123; ServletContext context = getServletContext(); System.out.println(context); System.out.println(&quot;Context2中获取域数据key1的值是&quot;+context.getAttribute(&quot;key1&quot;)); &#125;&#125; 两个文件中context地址相同 org.apache.catalina.core.ApplicationContextFacade@467b6a76 org.apache.catalina.core.ApplicationContextFacade@467b6a76 HTTP协议请求的HTTP协议协议是指双方或者多方约定好，大家都需要遵守的规则，叫协议 所谓HTTP协议就是指，客户端和服务器之间通信时，发送的数据需要遵守的规则，叫http协议 HTTP 协议中的数据又叫报文。 客户端给服务器发送数据叫请求。 服务器给客户端回传数据叫响应。 请求又分为 GET 请求，和 POST 请求两种 GET 请求 getpost都会对url进行url编码 1、请求行(报文行) (1) 请求的方式 GET (2) 请求的资源路径[+?+请求参数] (3) 请求的协议的版本号 HTTP&#x2F;1.1 2、请求头(报文头) key : value 组成 不同的键值对，表示不同的含义 ii. POST 请求 1、请求行 (1)请求的方式 POST (2) 请求的资源路径[+?+请求参数] (3) 请求的协议的版本号 HTTP&#x2F;1.1 2、 2.请求头 key : value 不同的请求头，有不同的含义 空行(请求头和请求体之间有空行) 3、请求体 &#x3D;&#x3D;&#x3D;&gt;&gt;&gt; 就是发送给服务器的数据 iii. 常用请求头的说明 Accept: 表示客户端可以接收的数据类型 Accpet-Languege: 表示客户端可以接收的语言类型 User-Agent: 表示客户端浏览器的信息 Host： 表示请求时的服务器 ip 和端口 iv. 哪些是 GET 请求，哪些是 POST 请求 GET 请求有哪些： 1、form 标签 method&#x3D;get 2、a 标签 3、link 标签引入 css 4、Script 标签引入 js 文件 5、img 标签引入图片 6、iframe 引入 html 页面 7、在浏览器地址栏中输入地址后敲回车 POST 请求有哪些： 8、form 标签 method&#x3D;post 响应的 HTTP 协议格式1、响应行 (1) 响应的协议和版本号 HTTP&#x2F;1.1 ​ (2) 响应状态码 200 ​ (3) 响应状态描述符 2、响应头 (1) key : value 不同的响应头，有其不同含义 空行 3、响应体 —-&gt;&gt;&gt; 就是回传给客户端的数 常见的响应码 200 表示请求成功 302 表示请求重定向（明天讲） 404 表示请求服务器已经收到了，但是你要的数据不存在（请求地址错误） 500 表示服务器已经收到请求，但是服务器内部错误（代码错误） MIME 类型说明 MIME 是 HTTP 协议中数据类型。 MIME 的英文全称是”Multipurpose Internet Mail Extensions” 多功能 Internet 邮件扩充服务。MIME 类型的格式是“大类型&#x2F;小 类型”，并与某一种文件的扩展名相对应 ServletRequest每次只要有请求进入，tomcat服务器就会把请求过来的HTTP协议信息解析好封装到request对象中。 然后传递到service方法，也含有doget dopost方法中给我们使用。我们可以通过HttpServletRequest对象，获取到所有请求的信息 HttpServletRequest 类的常用方法i. getRequestURI() 获取请求的资源路径 ii. getRequestURL() 获取请求的统一资源定位符（绝对路径） iii. getRemoteHost() 获取客户端的 ip 地址 iv. getHeader() 获取请求头 v. getParameter() 获取请求的参数 vi. getParameterValues() 获取请求的参数（多个值的时候使用） vii. getMethod() 获取请求的方式 GET 或 POST viii. setAttribute(key, value); 设置域数据 ，ServletRequest能通过这个方法向request域中存储数据 ix. getAttribute(key); 获取域数据 x. getRequestDispatcher() 获取请求转发对象 1234567891011121314151617181920212223242526272829package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class RequestAPIServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // i. getRequestURI() 获取请求的资源路径System.out.println(&quot;url=&gt;&quot;+req.getRequestURI()); //ii. getRequestURL() 获取请求的统一资源定位符（绝对路径）System.out.println(&quot;ulr=&gt;&quot;+req.getRequestURL()); //iii. getRemoteHost() 获取客户端的 ip 地址System.out.println(&quot;客户端 ip 地址&quot;+req.getRemoteHost());/*在IDEA中，使用使用localhost访问时，得到的客户端ip地址是127.0.0.1在IDEA中，使用使用127.0.0.1访问时，得到的客户端ip地址是127.0.0.1在IDEA中，使用使用真实ip访问时，得到的客户端ip地址是真实ip */ //iv. getHeader() 获取请求头System.out.println(&quot;请求头&quot;+req.getHeader(&quot;User-Agent&quot;)); //vii. getMethod() 获取请求的方式 GET 或 POST System.out.println(&quot;请求的方式&quot;+req.getMethod()); &#125;&#125; Servlet获取请求的参数值用来发送参数的form表单 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://localhost:8086/servlet2/parameterServlet&quot; method=&quot;get&quot;&gt; 用户名 &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt; 密码 &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br/&gt; 兴趣爱好 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;cpp&quot;&gt;c++ &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;java&quot;&gt;java &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;javascript&quot;&gt;javascript&lt;br/&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Arrays;public class ParameterServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求的参数，用name属性的值来作为参数获取 System.out.println(req.getParameter(&quot;username&quot;)); System.out.println(req.getParameter(&quot;password&quot;));//获取有多个参数的请求String []hobby=req.getParameterValues(&quot;hobby&quot;);System.out.println(Arrays.toString(hobby)); &#125;&#125; 解决post请求中的中文乱码问题 req.setCharacterEncoding(“UTF-8”); 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://localhost:8086/servlet2/parameterServlet&quot; method=&quot;post&quot;&gt; 用户名 &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt; 密码 &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br/&gt; 兴趣爱好 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;cpp&quot;&gt;c++ &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;java&quot;&gt;java &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;javascript&quot;&gt;javascript&lt;br/&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Arrays;public class ParameterServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求的参数，用name属性的值来作为参数获取 System.out.println(req.getParameter(&quot;username&quot;)); System.out.println(req.getParameter(&quot;password&quot;));//获取有多个参数的请求String []hobby=req.getParameterValues(&quot;hobby&quot;);System.out.println(Arrays.toString(hobby)); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置请求体的字符集为UTF-8，从而解决post请求的中文乱码问题 //这个方法只有在所有获取请求参数方法之前调用才有效 req.setCharacterEncoding(&quot;UTF-8&quot;); System.out.println(&quot;=-----post----&quot;); //获取请求的参数，用name属性的值来作为参数获取 System.out.println(req.getParameter(&quot;username&quot;)); System.out.println(req.getParameter(&quot;password&quot;));//获取有多个参数的请求 String []hobby=req.getParameterValues(&quot;hobby&quot;); System.out.println(Arrays.toString(hobby)); &#125;&#125; 请求的转发什么是请求的转发? 请求转发是指，服务器收到请求后，从一次资源跳转到另一个资源的操作叫请求转发 请求转发的特点第四条 如果form.html在WEB-INF目录下无法通过http://localhost:8086/servlet2/WEB-INF/form.html访问 但可以通过请求转发访问 下面两种都可以，第一个是绝对路径，第二个是相对路径 1RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;/WEB-INF/form.html&quot;); 1RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;WEB-INF/form.html&quot;); 在web中 &#x2F;斜杠就代表http://ip:port/工程名/ 可以映射到web目录下，可以在后面直接加web目录中的资源访问，但不能直接访问 WEB-INF目录中的资源 这是实现图片中的请求转发的步骤 servlet1 1234567891011121314151617181920212223242526272829303132package com.atguigu.servlet;import javafx.scene.control.TextInputControl;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class servlet1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求参数，(办事的材料)查看 //这个参数也可以用get传参直接传 String username=req.getParameter(&quot;username&quot;); System.out.println(&quot;在servlet1柜台中查看参数(材料)&quot;+username); //给材料盖一个章，并传递到servlet2柜台二去查看 req.setAttribute(&quot;key&quot;,&quot;柜台1的章&quot;); /* 请求转发必须要以斜杠打头，斜杠表示地址为：http://ip:port/工程名/ ,映射到IDEA代码的web目录，然后在后面加这个servlet文件名即可 */ //问路servlet2(柜台二在哪) RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;/servlet2&quot;); //走向servlet2，柜台二 requestDispatcher.forward(req,resp); &#125;&#125; servlet2 1234567891011121314151617181920212223package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class servlet2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求参数，(办事的材料)查看 String username=req.getParameter(&quot;username&quot;); System.out.println(&quot;在servlet1柜台中查看参数(材料)&quot;+username); //查看柜台1 是否有盖章 Object key = req.getAttribute(&quot;key&quot;); System.out.println(&quot;柜台一是否有章&quot;+key); //处理自己的业务 System.out.println(&quot;servlet2处理自己的业务&quot;); &#125;&#125; 关于重定向以及javaweb的路径补充（getResourcAsStream）服务器对服务器(请求转发)发起请求：(也叫服务器对斜杠&#x2F;进行解析的时候 绝对路径：&#x2F; 斜杠代表的是项目根目录 也就是http://ip:port/工程名， 可以映射到web目录下，后面直接跟web目录下内容，除了WEB-INF 浏览器对服务器(重定向)发起请求：(也叫浏览器对斜杠&#x2F;进行解析的时候) 绝对路径：&#x2F; 斜杠代表的是tomcat根目录，也就是http://ip:port 需要自己去加工程名 当这种&#x2F;表示tomcat根目录的时候，绝对路径开头的 &#x2F;工程名 就是自己设置的那个 而不是文件名 不管是哪个相对路径都是看相对位置 这个就是规定了工程的目录 也就是http://ip:port/servlet2 请求转发路径解释： 这个是web.xml文件中规定的Servlet文件的访问路径 等于是在web文件夹中创立一个contextservlet2文件，这也为什么http://ip:port/servlet2/contextservlet2能访问到servlet文件的原因 请求转发 这个地方用servlet2是因为这可以用相对路径，他们访问路径都在web目录下 也可以用&#x2F;servlet2 这是绝对路径，因为servlet2访问路径在web目录下 如果是web文件下有这个form.html文件也可以就是通过请求转发访问 下面两种都可以 1RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;form.html&quot;); 1RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;/form.html&quot;); 12345getResourceAsStream中的路径只有两种写法最前面是&#x27;/&#x27; 说明是工程目录下可以映射到web目录下最前面没有&#x27;/&#x27; 说明是默认从src目录开始 base标签的作用即使文件加上了base标签，也可以使用绝对路径 错误演示 c.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;这是a下的b下的c.html页面&lt;a href=&quot;/servlet2/index.html&quot;&gt;跳回首页&lt;/a&gt;&lt;a href=&quot;../../index.html&quot;&gt;跳回首页&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 这两个a标签中的地址都是index.html的地址一个是相对路径一个是绝对路径 这里因为是浏览器向服务器发起请求所以这里的绝对路径 &#x2F; 斜杠代表的是http://ip:port/ 访问到工程名默认的是访问web文件下的名为index的html或者js的文件 index.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;这是web下的index.html&lt;a href=&quot;a/b/c.html&quot;&gt;a/b/c.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://localhost:8086/servlet2/ForwardC&quot;&gt; 请求转发&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 第二个a标签利用请求转发跳转，是无法在c.html回到首页的 正确版本 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--base标签设置页面相对路径工作时参照的地址 href 属性就是参数的地址值 --&gt;&lt;/head&gt;&lt;body&gt;这是a下的b下的c.html页面&lt;a href=&quot;/servlet2/index.html&quot;&gt;跳回首页&lt;/a&gt;&lt;a href=&quot;../../index.html&quot;&gt;跳回首页&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; http://localhost:8080/servlet2/a/b/c.html就是这个文件中的所有相对路径的地址都是参照这个路径的 HttpServletResponse作用 HttpServletResponse 类和 HttpServletRequest 类一样。每次请求进来，Tomcat 服务器都会创建一个 Response 对象传递给 Servlet 程序去使用。 HttpServletRequest 表示请求过来的信息，HttpServletResponse 表示所有响应的信息， 我们如果需要设置返回给客户端的信息，都可以通过 HttpServletResponse 两个输出流说明字节流 getOutputStream() 常用于下载，传递二进制数据 字符流 getWriter() 常用于回传字符串(常用) 两个流同时只能使用一个，使用了字节流，就不能再使用字符流，否则就会报错 如何往客户端回传数据（乱码解决）要求：往客户端回传字符串数据以及中文乱码的解决方案（将服务器和浏览器统一编码） 1234567891011121314151617181920212223242526package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class ResponseIOServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //查看相应的字符集 默认ISO-8859-1 System.out.println(resp.getCharacterEncoding()); //设置服务器字符集为UTF-8 resp.setCharacterEncoding(&quot;UTF-8&quot;); //同时要自己去改变浏览器的字符集，改为UTF-8 resp.setHeader(&quot;Content-Type&quot;,&quot;text/html;charset=UTF-8&quot;); //要求：往客户端回传字符串数据 PrintWriter writer=resp.getWriter(); writer.write(&quot;我很帅&quot;); &#125;&#125; 第二种解决中文乱码的方案 123456789101112131415161718192021package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class ResponseIOServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //它会同时设置服务器和客户端都使用UTF-8字符集，还设置了响应头 //此方法一定要在获取流之前时使用才有效 resp.setContentType(&quot;text/html; charset=UTF-8&quot;); System.out.println(resp.getCharacterEncoding()); //要求：往客户端回传字符串数据 PrintWriter writer=resp.getWriter(); writer.write(&quot;我很帅&quot;); &#125;&#125; Servlet请求重定向请求重定向，是指客户端给服务器发请求，然后服务器告诉客户端说。我给你一些地址。你去新地址访问。叫请求 重定向（因为之前的地址可能已经被废弃） 重点：两个servlet之间不共享Request域中的数据 其实就是当用HttpServletResponse的setAttribute()方法是不能把把存储的数据给多个Servlet获取的，但ServletContext可以 response1重定向到response2的解析 response1 1234567891011121314151617181920package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class response1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;曾到此一游 Response1&quot;); req.setAttribute(&quot;key&quot;,&quot;value1&quot;); //设置响应状态码，表示重定向(已搬迁) resp.setStatus(302); //设置响应头，说明新的地址在哪里 resp.setHeader(&quot;Location&quot;,&quot;http://localhost:8086/servlet2/response2&quot;); &#125;&#125; response2 123456789101112131415package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class response2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(req.getAttribute(&quot;key&quot;)); resp.getWriter().write(&quot;response2 result&quot;); &#125;&#125; response1重定向到form.html的解析 错误案例：不能够重定向到WEB-INF下的form.html文件 因为重定向也就是第二次的地址是用来浏览器向服务器发起请求，WEB-INF中的文件受保护所以不行 1234567891011121314151617181920package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class response1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;曾到此一游 Response1&quot;); req.setAttribute(&quot;key&quot;,&quot;value1&quot;); //设置响应状态码，表示重定向(已搬迁) resp.setStatus(302); //设置响应头，说明新的地址在哪里 resp.setHeader(&quot;Location&quot;,&quot;http://localhost:8086/WEB-INF/form.html&quot;); &#125;&#125; 正确案例：访问web目录下的form.html 新地址使用绝对路径的方法，下面两个都是绝对路径 1234567891011121314151617181920package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class response1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;曾到此一游 Response1&quot;); req.setAttribute(&quot;key&quot;,&quot;value1&quot;); //设置响应状态码，表示重定向(已搬迁) resp.setStatus(302); //设置响应头，说明新的地址在哪里 resp.setHeader(&quot;Location&quot;,&quot;http://localhost:8086/servlet2/form.html&quot;); &#125;&#125; 1234567891011121314151617181920package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class response1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;曾到此一游 Response1&quot;); req.setAttribute(&quot;key&quot;,&quot;value1&quot;); //设置响应状态码，表示重定向(已搬迁) resp.setStatus(302); //设置响应头，说明新的地址在哪里 resp.setHeader(&quot;Location&quot;,&quot;/servlet2/form.html&quot;); &#125;&#125; 相对路径 1234567891011121314151617181920package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class response1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;曾到此一游 Response1&quot;); req.setAttribute(&quot;key&quot;,&quot;value1&quot;); //设置响应状态码，表示重定向(已搬迁) resp.setStatus(302); //设置响应头，说明新的地址在哪里 resp.setHeader(&quot;Location&quot;,&quot;form.html&quot;); &#125;&#125; 因为这里的重定向的地址是浏览器会向服务器发起的请求，所以绝对路径的 &#x2F;表示的是tomcat根目录下的内容 重定向也可以访问外部地址，只要把location换成一个网站的网址就可以 第二种请求重定向的方法第二种方法 123456789101112131415package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class response1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.sendRedirect(&quot;/servlet2/response2&quot;); &#125;&#125; 书城项目的第二个阶段用户的注册和登录 javaEE项目的三层架构 分层的目的是为了解耦。解耦就是为了降低代码的耦合度。方便项目后期的维护和升级 下面的斜杠是或者的意思 web 层 com.atguigu.web&#x2F;servlet&#x2F;controller service 层 com.atguigu.service Service 接口包 ​ com.atguigu.service.impl Service 接口实现类 dao 持久层 com.atguigu.dao Dao 接口包 ​ com.atguigu.dao.impl Dao 接口实现类 实体 bean 对象 com.atguigu.pojo&#x2F;entity&#x2F;domain&#x2F;bean JavaBean 类 测试包 com.atguigu.test&#x2F;junit 工具类 com.atguigu.utils 创建数据库和User用户表一般创建一个表都需要有一个id这样自增的主键 1234567891011121314create database book;use book;create table t_user(id int PRIMARY KEY auto_increment,username varchar(20) not null unique,password varchar(20) not null,email varchar(200));insert into t_user(username,password,email) values(&#x27;admin&#x27;,&#x27;admin&#x27;,&#x27;admin@guigu.com&#x27;);select *from t_user; 编写数据库表对应的javaBean对象所谓的javaBean对象就是一个和数据库中储存数据一样类型的java类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.atguigu.pojo;public class User &#123; private Integer id; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &quot;, email=&#x27;&quot; + email + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public User(Integer id, String username, String password, String email) &#123; this.id = id; this.username = username; this.password = password; this.email = email; &#125; public User() &#123; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; private String username; private String password; private String email; &#125; 编写工具类JDBCUtils 导入这两个包才能用@test JdbcUtils类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.atguigu.utils;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.pool.DruidDataSourceFactory;import java.io.InputStream;import java.sql.Connection;import java.sql.SQLException;import java.util.Properties;public class JdbcUtils &#123; private static DruidDataSource dataSource;static &#123; try&#123; Properties properties=new Properties(); //奇怪的是这个地方不能用绝对路径 InputStream inputStream=JdbcUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); properties.load(inputStream); dataSource= (DruidDataSource) DruidDataSourceFactory.createDataSource(properties); System.out.println(dataSource.getConnection()); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125;&#125;//获取数据库连接池中的连接，如果返回null就是获取失败，有值就是获取成功public static Connection getConnection()&#123; Connection conn=null; try &#123; conn=dataSource.getConnection(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return conn;&#125;//关闭连接 public static void close(Connection conn)&#123; if(conn!=null)&#123; try&#123; conn.close(); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 测试类 123456789101112131415161718package com.atguigu.test;import com.atguigu.utils.JdbcUtils;import org.junit.Test;import java.sql.Connection;public class JdbcUtilsTest &#123; @Testpublic void testJdbcUtils()&#123; for (int i = 0; i &lt;100 ; i++) &#123; Connection conn=JdbcUtils.getConnection(); System.out.println(conn); JdbcUtils.close(conn); &#125; &#125;&#125; 因为数据库连接池配置文件中有最大连接数为规定数，所以只有每次都释放才能获取连接 BaseDao在使用queryForList和queryForOne来获得javaBean对象的时候，这个javaBean类中属性的名字必须和select后面的列名相同，或者是起名让他相同 封装了增删改和查询方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.atguigu.dao.impl;import com.atguigu.utils.JdbcUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.apache.commons.dbutils.handlers.ScalarHandler;import java.sql.Connection;import java.sql.SQLException;import java.util.List;public class BaseDao &#123; //使用DbUtils操作数据库private QueryRunner queryRunner=new QueryRunner();/*update()方法用来执行：insert update delete语句如果返回-1说明执行失败， 否则返回其他表示影响的行数 */ public int update(String sql,Object...args)&#123; Connection conn= JdbcUtils.getConnection(); try &#123; return queryRunner.update(conn, sql, args); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; return -1; &#125; /* 查询返回一个javaBean的sql语句 type为返回对象类型，args是sql对应的参数值，sql是执行的sql语句 &lt;T&gt;返回的类型和泛型 */ public &lt;T&gt; T queryForOne(Class&lt;T&gt; type,String sql,Object...args) &#123; Connection con=JdbcUtils.getConnection(); try &#123; return queryRunner.query(con,sql,new BeanHandler&lt;T&gt;(type),args); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; finally&#123; JdbcUtils.close(con); &#125; return null; &#125; /* 查询返回多个javaBean的sql语句 */ public &lt;T&gt; List&lt;T&gt; queryForList(Class&lt;T&gt; type,String sql,Object...args)&#123; Connection con=JdbcUtils.getConnection(); try &#123; return queryRunner.query(con,sql,new BeanListHandler&lt;T&gt;(type),args); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; finally&#123; JdbcUtils.close(con); &#125; return null; &#125; /* 执行返回一个单元格的sql */ public Object queryForSingleValue(String sql,Object...args)&#123; Connection conn=JdbcUtils.getConnection(); try &#123; return queryRunner.query(conn, sql,new ScalarHandler(), args); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; finally&#123; JdbcUtils.close(conn); &#125; return null; &#125;&#125; 编写UserDao和测试其实这个Dao可以设计为一个泛型接口，用哪个类时再传递泛型参数，这样就是设计了一个不同数据库类的通用Dao 根据你所需要的方法来设计 UserDao 可以在空白处按ctrl和shift和t得到这个接口的测试 将Destination package换成你想要的位置，勾选好下面三个方法 123456789101112131415161718192021222324252627282930313233package com.atguigu.dao;import com.atguigu.pojo.User;public interface UserDao &#123; /* 根据用户名查询用户信息 username 用户名 如果返回null则说明没有这个用户，返之亦然 */ public User queryByUsername(String username); /** * 保存用户信息 * @param user * @return 返回-1表示操作失败，其他是sql语句影响的行数 */ public int saveUser(User user); /** * 根据用户名和密码查询用户信息 * @param username * @param password * @return 如果返回null则说明用户名或密码错误，返之亦然 */ public User queryUserByUsernameAndPassword(String username,String password);&#125; UserDaoImpl 12345678910111213141516171819202122232425package com.atguigu.dao.impl;import com.atguigu.dao.UserDao;import com.atguigu.pojo.User;public class UserDaoImpl extends BaseDao implements UserDao &#123; @Override public User queryByUsername(String username) &#123; String sql=&quot;select id,username,password,email from t_user where username=?&quot;; return queryForOne(User.class,sql,username); &#125; @Override public int saveUser(User user) &#123; String sql=&quot;insert into t_user(username,password,email) values(?,?,?)&quot;; return update(sql,user.getUsername(),user.getPassword(),user.getEmail()); &#125; @Override public User queryUserByUsernameAndPassword(String username, String password) &#123; String sql=&quot;select id,username,password,email from t_user where username=? and password=?&quot;; return queryForOne(User.class,sql,username,password); &#125;&#125; UserDaoTest 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.atguigu.test;import com.atguigu.dao.UserDao;import com.atguigu.dao.impl.UserDaoImpl;import com.atguigu.pojo.User;import org.junit.Test;import static org.junit.Assert.*;public class UserDaoTest &#123; UserDao userDao=new UserDaoImpl(); @Test public void queryByUsername() &#123; if(userDao.queryByUsername(&quot;admin123&quot;)==null) &#123; System.out.println(&quot;用户名可用&quot;); &#125; else &#123; System.out.println(&quot;用户名已存在&quot;); &#125; &#125; @Test public void saveUser() &#123; if(userDao.queryUserByUsernameAndPassword(&quot;admin&quot;,&quot;admin&quot;)==null)&#123; System.out.println(&quot;用户名或密码错误登陆错误&quot;); &#125; else &#123; System.out.println(&quot;登陆成功&quot;); &#125; &#125; @Test public void queryUserByUsernameAndPassword() &#123; System.out.println(userDao.saveUser(new User(null,&quot;admin&quot;,&quot;123456&quot;,&quot;wzg168@qq.com&quot;))); &#125;&#125; 编写UserService和测试可以在空白处按ctrl和shift和t得到这个接口的测试 将Destination package换成你想要的位置，勾选好下面三个方法 实现业务 UserService 123456789101112131415161718192021222324252627package com.atguigu.service;import com.atguigu.pojo.User;public interface UserService &#123; /** * 注册用户 * @param user */ public void registerUser(User user); /** * 登录 * @param user * @return 如果返回null，说明登录失败，返回有值，是登录成功 */ public User login(User user); /** * 检查用户名是否可用 * @param username * @return 返回true表示用户名已存在，返回false表示用户名可用 */ public boolean existsUsername(String username);&#125; UserServiceImpl 1234567891011121314151617181920212223242526272829package com.atguigu.service.impl;import com.atguigu.dao.UserDao;import com.atguigu.dao.impl.UserDaoImpl;import com.atguigu.pojo.User;import com.atguigu.service.UserService;public class UserServiceImpl implements UserService &#123; private UserDao userDao=new UserDaoImpl(); @Override public void registerUser(User user) &#123; userDao.saveUser(user); &#125; @Override public User login(User user) &#123; return userDao.queryUserByUsernameAndPassword(user.getUsername(),user.getPassword()); &#125; @Override public boolean existsUsername(String username) &#123; if(userDao.queryByUsername(username)==null)&#123; //等于null说明没查到，没查到表示可用 return false; &#125; return true; &#125;&#125; UserServiceTest 123456789101112131415161718192021222324252627282930313233package com.atguigu.test;import com.atguigu.pojo.User;import com.atguigu.service.UserService;import com.atguigu.service.impl.UserServiceImpl;import org.junit.Test;import static org.junit.Assert.*;public class UserServiceTest &#123; UserService userService=new UserServiceImpl(); @Test public void registerUser() &#123; userService.registerUser(new User(null,&quot;bbj168&quot;,&quot;666666&quot;,&quot;6668@qq.com&quot;)); &#125; @Test public void login() &#123; System.out.println(userService.login(new User(null,&quot;bbj168&quot;,&quot;666666&quot;,null))); &#125; @Test public void existsUsername() &#123; if(userService.existsUsername(&quot;bbj168&quot;))&#123; System.out.println(&quot;用户名已存在&quot;); &#125; else &#123; System.out.println(&quot;用户名可用&quot;); &#125; &#125;&#125; 实现用户注册的功能 javaweb阶段用base设定相对路径跳转 框架阶段用绝对路径 在title下面加上base标签，然后改变文件中所有的路径，因为现在的相对路径是以base这个路径为开头的 改变的文件既有register.html也有register_success.html 1&lt;base href=&quot;http://localhost:8087/book2/&quot;&gt; xml文件中配置servlet 把html文件中的表单，action设置为servlet的路径，method改为post 1&lt;form action=&quot;registServlet&quot; method=&quot;post&quot;&gt; 编写RegistServlet程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.atguigu.web;import com.atguigu.pojo.User;import com.atguigu.service.UserService;import com.atguigu.service.impl.UserServiceImpl;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class RegisterServlet extends HttpServlet &#123; //web层和service层交互 UserService userService=new UserServiceImpl(); @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.获取请求的参数 String username=req.getParameter(&quot;username&quot;); String password=req.getParameter(&quot;password&quot;); String email=req.getParameter(&quot;email&quot;); String code=req.getParameter(&quot;code&quot;); //2.检查 验证码是否正确,先把验证码写死，要求为abcde if(&quot;abcde&quot;.equalsIgnoreCase(code))&#123; //验证码正确 //检查用户名是否可用 if(userService.existsUsername(username))&#123; System.out.println(&quot;用户名&quot;+username+&quot;已存在&quot;); //跳回到注册页面 req.getRequestDispatcher(&quot;/pages/user/regist.html&quot;).forward(req,resp); &#125; else &#123; //可用 //调用Sercice保存到数据库 userService.registerUser(new User(null,username,password,email)); //注册成功后，跳转到注册成功页面 req.getRequestDispatcher(&quot;/pages/user/regist_success.html&quot;).forward(req,resp); &#125; &#125;else&#123; System.out.println(&quot;验证码&quot;+code+&quot;错误&quot;); //验证码不正确 //跳回注册页面，因为还是申请服务器中文件所以/还是工程目录下的 req.getRequestDispatcher(&quot;/pages/user/regist.html&quot;).forward(req,resp); &#125; &#125;&#125; IDEA中的Debug调试看pdf文件即可 用户登录功能的实现 操作步骤和用户注册功能差不多 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.atguigu.web;import com.atguigu.pojo.User;import com.atguigu.service.UserService;import com.atguigu.service.impl.UserServiceImpl;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class RegisterServlet extends HttpServlet &#123; //web层和service层交互 UserService userService=new UserServiceImpl(); @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.获取请求的参数 //这个getParameter方法是通过那个属性的name得到的 String username=req.getParameter(&quot;username&quot;); String password=req.getParameter(&quot;password&quot;); String email=req.getParameter(&quot;email&quot;); String code=req.getParameter(&quot;code&quot;); //2.检查 验证码是否正确,先把验证码写死，要求为abcde if(&quot;abcde&quot;.equalsIgnoreCase(code))&#123; //验证码正确 //检查用户名是否可用 if(userService.existsUsername(username))&#123; System.out.println(&quot;用户名&quot;+username+&quot;已存在&quot;); //跳回到注册页面 req.getRequestDispatcher(&quot;/pages/user/regist.html&quot;).forward(req,resp); &#125; else &#123; //可用 //调用Sercice保存到数据库 userService.registerUser(new User(null,username,password,email)); //注册成功后，跳转到注册成功页面 req.getRequestDispatcher(&quot;/pages/user/regist_success.html&quot;).forward(req,resp); &#125; &#125;else&#123; System.out.println(&quot;验证码&quot;+code+&quot;错误&quot;); //验证码不正确 //跳回注册页面，因为还是申请服务器中文件所以/还是工程目录下的 req.getRequestDispatcher(&quot;/pages/user/regist.html&quot;).forward(req,resp); &#125; &#125;&#125; JSP的内容jsp就是既能写java又能写html的文件 jsp 的全换是 java server pages。 Java 的服务器页面。 jsp 的主要作用是代替 Servlet 程序回传 html 页面的数据。 因为 Servlet 程序回传 html 页面数据是一件非常繁锁的事情。开发成本和维护成本都极高。 用servlet回传数据示例 12345678910111213141516171819202122232425262728package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class pringHtml extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 通过响应的回传流回传 html 页面数据 resp.setContentType(&quot;text/html; charset=UTF-8&quot;); PrintWriter writer = resp.getWriter(); writer.write(&quot;&lt;!DOCTYPE html&gt;\\r\\n&quot;); writer.write(&quot; &lt;html lang=\\&quot;en\\&quot;&gt;\\r\\n&quot;); writer.write(&quot; &lt;head&gt;\\r\\n&quot;); writer.write(&quot; &lt;meta charset=\\&quot;UTF-8\\&quot;&gt;\\r\\n&quot;); writer.write(&quot; &lt;title&gt;Title&lt;/title&gt;\\r\\n&quot;); writer.write(&quot; &lt;/head&gt;\\r\\n&quot;); writer.write(&quot; &lt;body&gt;\\r\\n&quot;); writer.write(&quot; 这是 html 页面数据 \\r\\n&quot;); writer.write(&quot; &lt;/body&gt;\\r\\n&quot;); writer.write(&quot;&lt;/html&gt;\\r\\n&quot;); writer.write(&quot;\\r\\n&quot;); &#125;&#125; 一个简单的jsp代码 123456789101112131415161718&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/1 Time: 10:28 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;这是html页面数据&lt;/body&gt;&lt;/html&gt; 2、jsp 如何访问： jsp 页面和 html 页面一样，都是存放在 web 目录下。访问也跟访问 html 页面一样 在 web 目录下有如下的文件： web 目录 a.html 页面 访问地址是 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&gt;&gt;&gt;&gt;&gt; http://ip:port/工程路径/ a.html b.jsp 页面 访问地址是 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&gt;&gt;&gt;&gt;&gt; http://ip:port/工程路径/b.js jsp页面的本质jsp 页面本质上是一个 Servlet 程序 当我们第一次访问 jsp 页面的时候。Tomcat 服务器会帮我们把 jsp 页面翻译成为一个 java 源文件。并且对它进行编译成 为.class 字节码程序。我们打开 java 源文件不难发现其里面的内容是 找java源文件的路径 12C:\\Users\\#赵梓皓&amp;\\AppData\\Local\\JetBrains\\IntelliJIdea2020.3\\tomcat\\a918c083-a48c-4fed-a7cf-4186b397852c\\work\\Catalina\\localhost\\jsp\\org\\apache\\jsp 我们跟踪原代码发现，HttpJspBase 类。它直接地继承了 HttpServlet 类。也就是说。jsp 翻译出来的 java 类，它间接了继 承了 HttpServlet 类。也就是说，翻译出来的是一个 Servlet 程序 总结：通过翻译的 java 源代码我们就可以得到结果：jsp 就是 Servlet 程序。 大家也可以去观察翻译出来的 Servlet 程序的源代码，不难发现。其底层实现，也是通过输出流。把 html 页面数据回传 给客户端 jsp 的三种语法jsp 头部的 page 指令jsp 的 page 指令可以修改 jsp 页面中一些重要的属性，或者行为 1&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; i. language 属性 表示 jsp 翻译后是什么语言文件。暂时只支持 java。 ii. contentType 属性 表示 jsp 返回的数据类型是什么。也是源码中 response.setContentType()参数值 iii. pageEncoding 属性 表示当前 jsp 页面文件本身的字符集。 iv. import 属性 跟 java 源代码中一样。用于导包，导类。 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;两个属性是给 out 输出流使用&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; v. autoFlush 属性 设置当 out 输出流缓冲区满了之后，是否自动刷新冲级区。默认值是 true。 vi. buffer 属性 设置 out 缓冲区的大小。默认是 8kb 如果将autoFlush设为false buffer改为比较小的2kb 然后jsp中页面又很多就会出现这种情况 pageEncoding属性改变的就是这个界面的编码 vii. errorPage 属性 设置当 jsp 页面运行时出错，自动跳转去的错误页面路径。 1errorPage=&quot;/error500.jsp&quot; viii. isErrorPage 属性 设置当前 jsp 页面是否是错误信息页面。默认是 false。如果是 true 可以 获取异常信息。 ix. session 属性 设置访问当前 jsp 页面，是否会创建 HttpSession 对象。默认是 true。 x. extends 属性 设置 jsp 翻译出来的java 类默认继承谁。 12345678910111213141516171819202122232425&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/1 Time: 10:28 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; pageEncoding=&quot;utf-8&quot; import=&quot;java.util.Map&quot; autoFlush=&quot;true&quot; buffer=&quot;8kb&quot; errorPage=&quot;/error500.jsp&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;a.jsp页面&lt;% int i=12/0;%&gt;&lt;/body&gt;&lt;/html&gt; 脚本声明脚本（少用）声明脚本的格式是： &lt;%! 声明 java 代码 % 作用：可以给 jsp 翻译出来的 java 类定义属性和方法甚至是静态代码块。内部类等 这是jsp的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/1 Time: 10:28 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; pageEncoding=&quot;utf-8&quot; import=&quot;java.util.Map&quot; autoFlush=&quot;true&quot; buffer=&quot;8kb&quot; errorPage=&quot;/error500.jsp&quot; language=&quot;java&quot; %&gt;&lt;%@ page import=&quot;java.util.HashMap&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1.声明类属性--&gt;&lt;%! private Integer id; private String name; private static Map&lt;String,Object&gt; map;%&gt;&lt;!--2.定义静态代码块--&gt;&lt;%! static &#123; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;key1&quot;, &quot;value1&quot;); map.put(&quot;key2&quot;, &quot;value2&quot;); map.put(&quot;key3&quot;, &quot;value3&quot;); &#125;%&gt;&lt;!--声明类的方法--&gt;&lt;%! public int abc()&#123; return 12; &#125;%&gt;&lt;!--生成内部类--&gt;&lt;%! public static class A&#123; private Integer id; private String abc=&quot;abc&quot;; &#125;%&gt;&lt;/body&gt;&lt;/html&gt; 上面这个图片是对应的jsp程序在a_jsp.java文件中生成的方法属性和静态代码块的样子 表达式脚本（常用）表达式脚本的格式是：&lt;%&#x3D;表达式%&gt; 表达式脚本的作用是：的 jsp 页面上输出数据。 表达式脚本的特点： 1、所有的表达式脚本都会被翻译到_jspService() 方法中 2、表达式脚本都会被翻译成为 out.print()输出到页面上 _3、由于表达式脚本翻译的内容都在_jspService() 方法中,所以_jspService()方法中的对象都可以直接使用。 4、表达式脚本中的表达式不能以分号结束。 这个就是jspService方法 out就是jsp专用的一个输入输出流 这个_jspService方法中的对象都可以使用 这个是表达式脚本的翻译演示 123456&lt;%=12%&gt;&lt;br/&gt;&lt;%=12.12%&gt;&lt;br/&gt;&lt;%=&quot;我是字符串&quot;%&gt;&lt;br/&gt;&lt;%=map%&gt;&lt;!--使用_jspService方法中的对象--&gt;&lt;%=request.getParameter(&quot;username&quot;)%&gt; 在页面输出12等等 代码脚本代码脚本中用System.out.println输出的都是在控制台中输出的 代码脚本的格式是： &lt;% java 语句 %&gt; 代码脚本的作用是：可以在 jsp 页面中，编写我们自己需要的功能（写的是 java 语句） 代码脚本的特点是： 1、代码脚本翻译之后都在_jspService 方法中 _ _2、代码脚本由于翻译到_jspService()方法中，所以在_jspService()方法中的现有对象都可以直接使用。 3、还可以由多个代码脚本块组合完成一个完整的 java 语句。 4、代码脚本还可以和表达式脚本一起组合使用，在 jsp 页面上输出数 正常的System只能输出在控制台，只有和表达式脚本结合才能输出页面 12345678910111213141516171819202122232425262728293031323334353637&lt;!--代码脚本和表达式脚本组合在一起用--&gt;&lt;% int i=13; if(i==12)&#123;%&gt;&lt;h1&gt;我是赵梓皓&lt;/h1&gt; &lt;% &#125; else &#123;%&gt;&lt;h1&gt;我是张几名&lt;/h1&gt; &lt;% &#125; %&gt;&lt;!--两个代码脚本合成一个，即使会报错，但是运行之后还是可以输出的--&gt;&lt;!--代码脚本还可以和表达式脚本一起组合输出--&gt;&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;% for(int j=0;j&lt;10;j++)&#123; %&gt; &lt;tr&gt; &lt;td&gt;&lt;%=j%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% &#125;%&gt;&lt;/table&gt;&lt;!--用jspService中的对象--&gt;&lt;% String username=request.getParameter(&quot;username&quot;); System.out.println(&quot;用户名的请求参数是&quot;+username);%&gt; jsp中的三种注释i. html 注释 html 注释会被翻译到 java 源代码中。在_jspService 方法里，以 out.writer 输出到客户端。 ii. java 注释 1&lt;% // 单行 java 注释 /* 多行 java 注释 */ %&gt; java 注释会被翻译到 java 源代码中。 iii. jsp 注释 &lt;%– 这是 jsp 注释 –%&gt; jsp 注释可以注掉，jsp 页面中所有代码 jsp九大内置对象 这个第九个内置对象只有 isErrorPage为true的时候才会在java文件中显示出来 java四个域对象的演示这四个域和Servlet中的域是一样的，所以Servlet在request域中存储的数据，其实在jsp中是可以获取的 四个域对象分别是： pageContext (PageContextImpl 类) 当前 jsp 页面范围内有效 request (HttpServletRequest 类)、 一次请求内有效 ，请求转发是一次请求 session (HttpSession 类)、 一个会话范围内有效（打开浏览器访问服务器，直到关闭浏览器） application (ServletContext 类) 整个 web 工程范围内都有效（只要 web 工程不停止，数据都在） 域对象是可以像 Map 一样存取数据的对象。四个域对象功能一样。不同的是它们对数据的存取范围 虽然四个域对象都可以存取数据。在使用上它们是有优先顺序的。 四个域在使用的时候，优先顺序分别是，他们从小到大的范围的顺序。 pageContext &#x3D;&#x3D;&#x3D;&#x3D;&gt;&gt;&gt; request &#x3D;&#x3D;&#x3D;&#x3D;&gt;&gt;&gt; session &#x3D;&#x3D;&#x3D;&#x3D;&gt;&gt;&gt;application score.jsp 123456789101112131415161718192021222324252627282930&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/1 Time: 14:58 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;score.jsp页面&lt;/h1&gt; &lt;% //往四个域中都分别保存了数据 pageContext.setAttribute(&quot;key&quot;,&quot;pageContext&quot;); request.setAttribute(&quot;key&quot;,&quot;request&quot;); session.setAttribute(&quot;key&quot;,&quot;session&quot;); application.setAttribute(&quot;key&quot;,&quot;application&quot;); %&gt; pageContext域是否有值：&lt;%=pageContext.getAttribute(&quot;key&quot;)%&gt; &lt;br&gt; request域是否有值：&lt;%=request.getAttribute(&quot;key&quot;)%&gt; &lt;br&gt; session域是否有值：&lt;%=session.getAttribute(&quot;key&quot;)%&gt; &lt;br&gt; application域是否有值：&lt;%=application.getAttribute(&quot;key&quot;)%&gt; &lt;br&gt;&lt;% request.getRequestDispatcher(&quot;/score2.jsp&quot;).forward(request,response);%&gt;&lt;/body&gt;&lt;/html&gt; score2.jsp 1234567891011121314151617181920&lt;%-- Created by IntelliJ IDEA. User: Administrator Date: 2020/2/23 Time: 21:23 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;scope2.jsp页面&lt;/h1&gt; pageContext域是否有值：&lt;%=pageContext.getAttribute(&quot;key&quot;)%&gt; &lt;br&gt; request域是否有值：&lt;%=request.getAttribute(&quot;key&quot;)%&gt; &lt;br&gt; session域是否有值：&lt;%=session.getAttribute(&quot;key&quot;)%&gt; &lt;br&gt; application域是否有值：&lt;%=application.getAttribute(&quot;key&quot;)%&gt; &lt;br&gt;&lt;/body&gt;&lt;/html&gt; 这种情况pageContext是null，因为请求转发就变了一个jsp页面了，但是依然是一次请求所以request是有的 1如果再专门请求一次score2 http://localhost:8088/jsp/score2.jsp 就可以让request也变成null 如果关闭浏览器，这里指的是关闭浏览器而不是只关闭浏览器的那个页面，然后再访问一次http://localhost:8088/jsp/score2.jsp 这样session就会消失了 重启或者重新部署服务器就会让application变为null jsp中out和response.getWriter输出的区别response 中表示响应，我们经常用于设置返回给客户端的内容（输出） out 也是给用户做输出使用的。 由于 jsp 翻译之后，底层源代码都是使用 out 来进行输出，所以一般情况下。我们在 jsp 页面中统一使用 out 来进行输出。避 免打乱页面输出内容的顺序 out.write() 输出字符串没有问题 out.print() 输出任意数据都没有问题（都转换成为字符串后调用的 write 输出 深入源码，浅出结论：在 jsp 页面中，可以统一使用 out.print()来进行输 这个就是out输出一 out输出二 response输出1 response输出2 12345678&lt;% out.write(&quot;out输出一&quot;); out.write(&quot;out输出二&quot;); out.flush(); response.getWriter().write(&quot;respose输出1&quot;); response.getWriter().write(&quot;response输出2&quot;);%&gt; 下面的这个规则对out的print方法依然适用 就是两个对象的write方法都能把自己分别写入自己的缓冲区 有out.flush方法就把out缓冲区中的追加到response缓冲区，就算没有out.flush，在页面代码执行完成（也就是response write的都写进了response缓冲区）自动把out缓冲区中的追加到response缓冲区 然后执行response刷新，把全部数据给客户端 jsp常用标签jsp静态包含示例说明： &lt;%@ include file&#x3D;””%&gt; 就是静态包含 file 属性指定你要包含的 jsp 页面的路径 地址中第一个斜杠 &#x2F; 表示为 http://ip:port/工程路径/ 映射到代码的 web 目录 1&lt;%@ include file=&quot;/include/foot.jsp&quot;%&gt; 在main.jsp中包含foot.jsp文件 这样访问main.jsp的时候也可以看到foot.jsp中的内容 静态包含的特点： ​ 1、静态包含不会翻译被包含的 jsp 页面。 ​ 2、静态包含其实是把被包含的 jsp 页面的代码拷贝到包含的位置执行输出 jsp动态包含 这是动态包含 1&lt;jsp:include page=&quot;&quot;&gt;&lt;/jsp:include&gt; page 属性是指定你要包含的 jsp 页面的路径 动态包含也可以像静态包含一样。把被包含的内容执行输出到包含位置 动态包含的特点： 1、动态包含会把包含的 jsp 页面也翻译成为 java 代码 2、动态包含底层代码使用如下代码去调用被包含的 jsp 页面执行输出。 ​ JspRuntimeLibrary.include(request, response, “&#x2F;include&#x2F;footer.jsp”, out, false); 3、动态包含，还可以传递参数 动态包含的原理是：main.jsp把自己的对象都传递给了footer.jsp页面，所以而这用的是一个out对象 main.jsp 12345678910111213141516171819202122232425262728&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 13:01 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;头部信息&lt;br/&gt;主体信息&lt;br/&gt;//静态包含&lt;%@ include file=&quot;/include/foot.jsp&quot;%&gt;//动态包含&lt;%--可以向foot.jsp传递参数，在foot.jsp页面中获取，因为都是用的一个request对象--%&gt;&lt;jsp:include page=&quot;/include/foot.jsp&quot;&gt; &lt;jsp:param name=&quot;username&quot; value=&quot;admin&quot;/&gt; &lt;jsp:param name=&quot;password&quot; value=&quot;admin&quot;/&gt;&lt;/jsp:include&gt;&lt;/body&gt;&lt;/html&gt; foot.jsp 1234567891011121314151617181920&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 13:04 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;页脚信息&lt;br/&gt;//获取main.jsp传来的参数&lt;%=request.getParameter(&quot;username&quot;)%&gt;&lt;%=request.getParameter(&quot;password&quot;)%&gt;&lt;/body&gt;&lt;/html&gt; 请求转发1&lt;jsp:forward page=&quot;&quot;&gt;&lt;/jsp:forward&gt; 是请求转发标签，它的功能就是请求转发 page 属性设置请求转发的路径 12&lt;%--请求转发--%&gt;&lt;jsp:forward page=&quot;/score2.jsp&quot;&gt;&lt;/jsp:forward&gt; 跳转到访问score2.jsp，显示score2.jsp内容 jsp练习题总结： &lt;% %&gt;代码脚本中 不要有表达式脚本或者声明脚本，也不要有html标签 html标签中可以有表达式脚本或者代码脚本 而且 到可以是看作一行，就是用来换行的标志 jsp页面中输出九九乘法表123456789101112131415161718192021222324252627282930313233343536&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 13:36 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; table&#123; width:600px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 align=&quot;center&quot;&gt;九九乘法口诀表&lt;/h1&gt;&lt;table border=&quot;1&quot;&gt;&lt;%for(int i=1;i&lt;=9;i++)&#123; %&gt;&lt;tr&gt;&lt;%for(int j=1;j&lt;=i;j++)&#123;%&gt; &lt;td&gt;&lt;%=i+&quot;*&quot;+j+&quot;=&quot;+i*j%&gt;&lt;/td&gt;&lt;%&#125;%&gt; &lt;tr/&gt;&lt;%&#125;%&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 遍历输出10个学生信息到表格中Student类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.atguigu.pojo;public class Student &#123; private Integer id; private String name; private Integer age; private String phone; public Student() &#123; &#125; public Student(Integer id, String name, Integer age, String phone) &#123; this.id = id; this.name = name; this.age = age; this.phone = phone; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, phone=&#x27;&quot; + phone + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;%@ page import=&quot;com.atguigu.pojo.Student&quot; %&gt;&lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt;&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 13:56 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; table&#123; border:1px black solid; width:600px; border-collapse: collapse; &#125; td,th&#123; border:1px black solid; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;% ArrayList&lt;Student&gt; studentArrayList = new ArrayList&lt;Student&gt;(); for(int i=0;i&lt;10;i++)&#123; int t=i+1; studentArrayList.add(new Student(t,&quot;name&quot;,18+t,&quot;phone&quot;+t)); &#125;%&gt;&lt;table border=&quot;1px&quot;&gt; &lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;手机号&lt;/td&gt; &lt;/tr&gt; &lt;%for(int i=0;i&lt;10;i++)&#123; int id=studentArrayList.get(i).getId(); String name=studentArrayList.get(i).getName(); int age=studentArrayList.get(i).getAge(); String phone=studentArrayList.get(i).getPhone(); %&gt; &lt;tr&gt; &lt;td&gt;&lt;%=id%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=name%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=age%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=phone%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;%&#125;%&gt;&lt;/table&gt;&lt;%%&gt;&lt;/body&gt;&lt;/html&gt; 请求转发的使用说明（第二个练习的优化）Servlet不太适合将查到的学生信息回传到客户端，所以改用jsp SearchStudentServlet程序 12345678910111213141516171819202122232425262728package com.atguigu.servlet;import com.atguigu.pojo.Student;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.ArrayList;public class SearchStudentServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求的参数 //发sql语句查询学生的信息 //使用for循环代替前面两步 ArrayList&lt;Student&gt; studentArrayList = new ArrayList&lt;Student&gt;(); for(int i=0;i&lt;10;i++)&#123; int t=i+1; studentArrayList.add(new Student(t,&quot;name&quot;,18+t,&quot;phone&quot;+t)); &#125; //保存查询到的结果到request域中 req.setAttribute(&quot;stuList&quot;,studentArrayList); //请求转发到showStudent.jsp页面 req.getRequestDispatcher(&quot;/test/test2.jsp&quot;).forward(req,resp); &#125;&#125; test2.jsp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;%@ page import=&quot;com.atguigu.pojo.Student&quot; %&gt;&lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt;&lt;%@ page import=&quot;java.util.List&quot; %&gt;&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 13:56 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; table&#123; border:1px black solid; width:600px; border-collapse: collapse; &#125; td,th&#123; border:1px black solid; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;% List&lt;Student&gt; studentList=(List&lt;Student&gt;)request.getAttribute(&quot;stuList&quot;);%&gt;&lt;table border=&quot;1px&quot;&gt; &lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;手机号&lt;/td&gt; &lt;/tr&gt; &lt;%for(int i=0;i&lt;10;i++)&#123; int id=studentList.get(i).getId(); String name=studentList.get(i).getName(); int age=studentList.get(i).getAge(); String phone=studentList.get(i).getPhone(); %&gt; &lt;tr&gt; &lt;td&gt;&lt;%=id%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=name%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=age%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=phone%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;%&#125;%&gt;&lt;/table&gt;&lt;%%&gt;&lt;/body&gt;&lt;/html&gt; Listener监听器1、Listener 监听器它是 JavaWeb 的三大组件之一。JavaWeb 的三大组件分别是：Servlet 程序、Filter 过滤器、Listener 监 听器。 2、Listener 它是 JavaEE 的规范，就是接口 3、监听器的作用是，监听某种事物的变化。然后通过回调函数，反馈给客户（程序）去做一些相应的处理。 ServletContextListener监听器ServletContextListener 它可以监听 ServletContext 对象的创建和销毁 ServletContext 对象在 web 工程启动的时候创建，在 web 工程停止的时候销毁。 监听到创建和销毁之后都会分别调用 两个方法分别是： 1234567891011121314151617181920//// Source code recreated from a .class file by IntelliJ IDEA// (powered by FernFlower decompiler)//package javax.servlet;import java.util.EventListener;public interface ServletContextListener extends EventListener &#123;/*这个方法在ServletContext对象创建之后调用，做初始化*/ void contextInitialized(ServletContextEvent var1);/*这个方法在ServletContext对象销毁之后调用*/ void contextDestroyed(ServletContextEvent var1);&#125; 如何使用 ServletContextListener 监听器监听 ServletContext 对象。 使用步骤如下： ​ 1、编写一个类去实现 ServletContextListener ​ 2、实现其两个回调方法 ​ 3、到 web.xml 中去配置监听器 EL表达式EL 表达式的全称是：Expression Language。是表达式语言。 EL 表达式的什么作用：EL 表达式主要是代替 jsp 页面中的表达式脚本在 jsp 页面中进行数据的输出。 因为 EL 表达式在输出数据的时候，要比 jsp 的表达式脚本要简洁很多 1234567891011121314151617181920212223&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 15:08 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;jsp的用法&lt;% request.setAttribute(&quot;key&quot;,&quot;值&quot;);%&gt;表达式输出key的值是&lt;%=request.getAttribute(&quot;key1&quot;)%&gt;EL表达式输出key的值$&#123;key1&#125;&lt;/body&gt;&lt;/html&gt; EL 表达式的格式是：${表达式} EL 表达式在输出 null 值的时候，输出的是空串。jsp 表达式脚本输出 null 值的时候，输出的是 null 字符串。 EL表达式搜索域数据的顺序EL 表达式主要是在 jsp 页面中输出数据。 主要是输出域对象中的数据。 当四个域中都有相同的 key 的数据的时候，EL 表达式会按照四个域的从小到大的顺序去进行搜索，找到就输出。 pageContext&#x3D;&#x3D;》requst&#x3D;&#x3D;》session&#x3D;&#x3D;》application 123456789101112131415161718192021222324&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 15:17 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% //往四个域中都保存了相同的key的数据 request.setAttribute(&quot;key&quot;,&quot;request&quot;); session.setAttribute(&quot;key&quot;,&quot;session&quot;); application.setAttribute(&quot;key&quot;,&quot;application&quot;); pageContext.setAttribute(&quot;key&quot;,&quot;pageContext&quot;);%&gt;$&#123;key&#125;&lt;/body&gt;&lt;/html&gt; EL 表达式输出 Bean 的普通属性，数组属性。List 集 合属性，map 集合属性i. 需求——输出 Person 类中普通属性，数组属性。list 集合属性和 map Person类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.atguigu.pojo;import java.util.Arrays;import java.util.List;import java.util.Map;public class Person &#123; private int age=18; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String[] getPhones() &#123; return phones; &#125; public void setPhones(String[] phones) &#123; this.phones = phones; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&quot; + name + &quot;, phones=&quot; + Arrays.toString(phones) + &quot;, cities=&quot; + cities + &quot;, map=&quot; + map + &#x27;&#125;&#x27;; &#125; public List&lt;String&gt; getCities() &#123; return cities; &#125; public void setCities(List&lt;String&gt; cities) &#123; this.cities = cities; &#125; public Map&lt;String, Object&gt; getMap() &#123; return map; &#125; public void setMap(Map&lt;String, Object&gt; map) &#123; this.map = map; &#125; private String name; public Person(String name, String[] phones, List&lt;String&gt; cities, Map&lt;String, Object&gt; map) &#123; this.name = name; this.phones = phones; this.cities = cities; this.map = map; &#125; public Person() &#123; &#125; private String[] phones; private List&lt;String&gt; cities; private Map&lt;String,Object&gt; map;&#125; c.jsp文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;%@ page import=&quot;com.atguigu.pojo.Person&quot; %&gt;&lt;%@ page import=&quot;java.util.List&quot; %&gt;&lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt;&lt;%@ page import=&quot;java.util.HashMap&quot; %&gt;&lt;%@ page import=&quot;java.util.Map&quot; %&gt;&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 15:29 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% Person person = new Person(); person.setName(&quot;国哥好帅！&quot;); person.setPhones(new String[]&#123;&quot;18610541354&quot;,&quot;18688886666&quot;,&quot;18699998888&quot;&#125;); List&lt;String&gt; cities = new ArrayList&lt;String&gt;(); cities.add(&quot;北京&quot;); cities.add(&quot;上海&quot;); cities.add(&quot;深圳&quot;); person.setCities(cities); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;key1&quot;,&quot;value1&quot;); map.put(&quot;key2&quot;,&quot;value2&quot;); map.put(&quot;key3&quot;,&quot;value3&quot;); person.setMap(map); pageContext.setAttribute(&quot;p&quot;,person);%&gt;输出 Person $&#123;p&#125;&lt;br/&gt;输出 Person 的 name 属性：$&#123;p.name&#125; &lt;br&gt;输出 Person 的 phones 数组属性值：$&#123;p.phones[2]&#125; &lt;br&gt;输出 Person 的 cities 集合中的元素值：$&#123;p.cities&#125; &lt;br&gt;输出 Person 的 List 集合中个别元素值：$&#123;p.cities[2]&#125; &lt;br&gt;输出 Person 的 Map 集合: $&#123;p.map&#125;&lt;br&gt;输出 Person 的 Map 集合中某个 key 的值: $&#123;p.map.key1&#125; &lt;br&gt;输出 Person 的 age 属性： $&#123;p.age&#125;&lt;br&gt; 输出Person的Map集合中所有的值 :$&#123;p.map.values()&#125;&lt;/body&gt;&lt;/html&gt; EL表达式在查找属性的时候其实是通过get方法来查找，所以即使你没有age属性，只要有getAge()方法就可以了 EL表达式运算关系运算 123456789101112131415161718192021222324252627282930313233&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 15:56 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;12==12&#125;&lt;br/&gt;或$&#123;12 eq 12&#125;&lt;br/&gt;$&#123;12!=12&#125;&lt;br/&gt;$&#123;12 ne 12&#125;&lt;br/&gt;$&#123;12&lt;12&#125;&lt;br/&gt;$&#123;12 lt 12&#125;&lt;br/&gt;$&#123;12&gt;12&#125;&lt;br/&gt;$&#123;12 gt 12&#125;&lt;br/&gt;$&#123;12&gt;=12&#125;&lt;br/&gt;$&#123;12 ge 12&#125;&lt;br/&gt;$&#123;12&lt;=12&#125;&lt;br/&gt;$&#123;12 le 12&#125;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 逻辑运算 1234$&#123;12==12&amp;&amp;12&gt;11&#125;&lt;br/&gt;$&#123;12==12 and 12&gt;11&#125;&lt;br/&gt;$&#123;! true&#125;&lt;br/&gt;$&#123;not true&#125;&lt;br/&gt; 算数运算 empty运算empty 运算可以判断一个数据是否为空，如果为空，则输出 true,不为空输出 false。 以下几种情况为空： 1、值为 null 值的时候，为空 2、值为空串的时候，为空 3、值是 Object 类型数组，长度为零的时候 4、list 集合，元素个数为零 5、map 集合，元素个数为零 12345678910111213141516171819202122232425262728293031323334353637&lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt;&lt;%@ page import=&quot;java.util.List&quot; %&gt;&lt;%@ page import=&quot;java.util.HashMap&quot; %&gt;&lt;%@ page import=&quot;java.util.Map&quot; %&gt;&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 16:52 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% //1、值为 null 值的时候，为空request.setAttribute(&quot;emptyNull&quot;,null); //2、值为空串的时候，为空 request.setAttribute(&quot;emptyStr&quot;,&quot;&quot;); //3、值是 Object 类型数组，长度为零的时候 request.setAttribute(&quot;emptyArr&quot;,new Object[]&#123;&#125;); //4、list 集合，元素个数为零List&lt;String&gt; list=new ArrayList&lt;String&gt;();list.add(&quot;abc&quot;); request.setAttribute(&quot;emptyList&quot;,list); //5、map 集合，元素个数为零 Map&lt;String,Object&gt; map=new HashMap&lt;String,Object&gt;();%&gt;$&#123;empty emptyNull&#125;&lt;br/&gt;$&#123;empty emptyStr&#125;&lt;br/&gt;$&#123;empty emptyArr&#125;&lt;br/&gt;$&#123;empty emptyList&#125;&lt;br/&gt;$&#123;empty emptyMap&#125;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 三元运算表达式 1？表达式 2：表达式 3 如果表达式 1 的值为真，返回表达式 2 的值，如果表达式 1 的值为假，返回表达式 3 的值 实例 1$&#123; 12 != 12 ? &quot;国哥帅呆&quot;:&quot;国哥又骗人啦&quot; &#125; “.”点运算 和 [] 中括号运算.点运算，可以输出 Bean 对象中某个属性的值。 []中括号运算，可以输出有序集合中某个元素的值。 并且[]中括号运算，还可以输出 map 集合中 key 里含有特殊字符的 key 的值。 1234567891011121314151617181920212223242526&lt;%@ page import=&quot;java.util.HashMap&quot; %&gt;&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 17:03 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;a.a.a&quot;,&quot;aaaValue&quot;); map.put(&quot;b+b+b&quot;,&quot;bbbValue&quot;); map.put(&quot;c-c-c&quot;,&quot;cccValue&quot;); request.setAttribute(&quot;map&quot;,map);%&gt;$&#123;map[&quot;a.a.a&quot;]&#125;&lt;br/&gt;$&#123;map[&quot;b+b+b&quot;]&#125;&lt;br/&gt;$&#123;map[&quot;c-c-c&quot;]&#125;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 这两个前面用到过一次输出bean普通属性时 但如果map的key中有.这种特殊字符，就不能用map.key 可以用map[“key”] EL表达式中的11个隐含对象EL 个达式中 11 个隐含对象，是 EL 表达式中自己定义的，可以直接使用 initParam Map&lt;String,String&gt; 它可以获取在 web.xml 中配置的上下文参数 EL获取四个特定域中的属性pageScope &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; pageContext域 requestScope &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; request域 sessionScope &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; session域 applicationScope &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ServletContext域 12345678910111213141516171819202122232425262728293031&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 17:22 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% pageContext.setAttribute(&quot;key1&quot;,&quot;pageContext1&quot;); pageContext.setAttribute(&quot;key2&quot;,&quot;pageContext2&quot;); request.setAttribute(&quot;key2&quot;,&quot;request&quot;); session.setAttribute(&quot;key2&quot;,&quot;session&quot;); application.setAttribute(&quot;key2&quot;,&quot;application&quot;);%&gt;&lt;%--输出pageContext域中的属性--%&gt;&lt;%--如果多个域中只有一个key1，可以直接$&#123;key1&#125; 但是如果两个域中都由key1属性，就可以通过$&#123;内置对象.key1&#125;来调用你想要的--%&gt;$&#123;pageScope.key1&#125;&lt;br/&gt;$&#123;pageScope.key2&#125;&lt;br/&gt;$&#123;requestScope.key2&#125;&lt;br/&gt;$&#123;sessionScope.key2&#125;&lt;br/&gt;$&#123;applicationScope.key2&#125;;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; pageContext演示可以获取jsp中的九大内置对象 协议： 服务器 ip： 服务器端口： 获取工程路径： 获取请求方法： 获取客户端 ip 地址： 获取会话的 id 编号 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 17:35 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--jsp中的内置对象request.getScheme()它可以获取请求的协议--%&gt;&lt;%--request.getScheme() 它可以获取请求的协议request.getServerName() 获取请求的服务器 ip 或域名request.getServerPort() 获取请求的服务器端口号request.getContextPath() 获取当前工程路径request.getMethod() 获取请求的方式（GET 或 POST）request.getRemoteHost() 获取客户端的 ip 地址session.getId() 获取会话的唯一标识--%&gt;&lt;%=request.getScheme()%&gt;&lt;%--用pageContext.request.scheme其实就和调用getScheme方法是一样的--%&gt;1. 协议：$&#123;pageContext.request.scheme&#125;&lt;br/&gt;2. 服务器 ip：$&#123;pageContext.request.serverName&#125;&lt;br/&gt;3. 服务器端口：$&#123;pageContext.request.serverPort&#125;&lt;br/&gt;4. 获取工程路径：$&#123;pageContext.request.contextPath&#125;&lt;br/&gt;5. 获取请求方法：$&#123;pageContext.request.method&#125;&lt;br/&gt;6. 获取客户端 ip 地址： $&#123;pageContext.request.remoteHost&#125;&lt;br/&gt;7. 获取会话的 id 编号 $&#123;pageContext.session.id&#125; &lt;br/&gt;&lt;%--简洁的写法--%&gt;&lt;% pageContext.setAttribute(&quot;req&quot;,request);%&gt;&lt;%--获取协议--%&gt;$&#123;req.scheme&#125;&lt;/body&gt;&lt;/html&gt; 其他EL隐含对象的事例param Map 它可以获取请求参数的值 Map&lt;String,String&gt; paramValues Map&lt;String,String[]&gt; 它也可以获取请求参数的值，获取多个值的时候使用 请求地址 1http://localhost:8084/eljstl/other.jsp?username=1&amp;password=2&amp;hobby=1&amp;hobby=2 123456789101112131415161718192021&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 18:30 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;param.username&#125;&lt;br/&gt;$&#123;param.password&#125;&lt;br/&gt;$&#123;paramValues.username[0]&#125;&lt;br/&gt;$&#123;paramValues.password[0]&#125;&lt;br/&gt;$&#123;paramValues.hobby[0]&#125;&lt;br/&gt;$&#123;paramValues.hobby[1]&#125;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; header Map 它可以获取请求头的信息 headerValues Map 它可以获取请求头的信息，它可以获取多个值的情况 12345678910111213141516171819&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 18:30 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--因为User-Agent的- 是特殊字符--%&gt;$&#123;header[&#x27;User-Agent&#x27;]&#125;&lt;br/&gt;$&#123;header.Connection&#125;&lt;br/&gt;$&#123;headerValues[&#x27;User-Agent&#x27;][0]&#125;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; cookie Map &lt;String,Cookie&gt; 它可以获取当前请求的 Cookie 信息 1234567891011121314151617&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/2 Time: 18:30 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;获取cookie的名称:$&#123;cookie.JSESSIONID.name&#125;&lt;br/&gt;获取Cookie的值：$&#123;cookie.JSESSIONID.value&#125;&lt;/body&gt;&lt;/html&gt; initParam Map&lt;String,String&gt; 它可以获取在web.xml中配置的上下文参数 在web.xml文件中添加这个 修改配置web.xml这种文件需要重新部署才能生效 1234&lt;context-param&gt; &lt;param-name&gt;url&lt;/param-name&gt; &lt;param-value&gt;jdbc:mysql://test&lt;/param-value&gt;&lt;/context-param&gt; 12345678910111213&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;initParam&#125;输出&amp;lt;Context-param&amp;gt;username的值：$&#123;initParam.username&#125;输出&amp;lt;Context-param&amp;gt;url的值：$&#123;initParam.url&#125;&lt;/body&gt;&lt;/html&gt; JSTL标签库JSTL 标签库 全称是指 JSP Standard Tag Library JSP 标准标签库。是一个不断完善的开放源代码的 JSP 标 签库。 EL 表达式主要是为了替换 jsp 中的表达式脚本，而标签库则是为了替换代码脚本。这样使得整个 jsp 页面 变得更佳简洁 JSTL标签库的使用步骤先导入jstl的jar包 1、先导入 jstl 标签库的 jar 包。 taglibs-standard-impl-1.2.1.jar taglibs-standard-spec-1.2.1.jar 2、第二步，使用 taglib 1&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 用自动补全代码的时候，这个会自动导入进来 core核心库的使用i. &lt;c:set &#x2F;&gt;（使用很少） 作用：set 标签可以往域中保存数据 12345678910111213141516171819202122232425262728293031323334&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/3 Time: 15:30 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--i.&lt;c:set /&gt;作用：set 标签可以往域中保存数据以前保存域数据域对象.setAttribute(key,value);scope 属性设置保存到哪个域page 表示 PageContext 域（默认值）request 表示 Request 域session 表示 Session 域application 表示 ServletContext 域var 属性设置 key 是多少value 属性设置值--%&gt;保存之前:$&#123;requestScope.abc&#125;&lt;br/&gt;&lt;c:set scope=&quot;request&quot; var=&quot;abc&quot; value=&quot;abcValue&quot;/&gt;保存之后:$&#123;requestScope.abc&#125;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; ii .&lt;c:if &#x2F;&gt; if 标签用来做 if 判断。 12345678910111213141516ii.&lt;c:if /&gt;if 标签用来做 if 判断。test 属性表示判断的条件（使用 EL 表达式输出）--%&gt;&lt;c:if test=&quot;$&#123;12==12&#125;&quot;&gt; &lt;h1&gt;无敌&lt;/h1&gt;&lt;/c:if&gt;&lt;c:if test=&quot;$&#123;12!=12&#125;&quot;&gt; &lt;h1&gt;无敌&lt;/h1&gt;&lt;/c:if&gt; iii.&lt;c:choose&gt; &lt;c:when&gt; &lt;c:otherwise&gt;标签 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/3 Time: 15:30 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--i.&lt;c:set /&gt;作用：set 标签可以往域中保存数据以前保存域数据域对象.setAttribute(key,value);scope 属性设置保存到哪个域page 表示 PageContext 域（默认值）request 表示 Request 域session 表示 Session 域application 表示 ServletContext 域var 属性设置 key 是多少value 属性设置值--%&gt;保存之前:$&#123;requestScope.abc&#125;&lt;br/&gt;&lt;c:set scope=&quot;request&quot; var=&quot;abc&quot; value=&quot;abcValue&quot;/&gt;保存之后:$&#123;requestScope.abc&#125;&lt;br/&gt;&lt;%--ii.&lt;c:if /&gt;if 标签用来做 if 判断。test 属性表示判断的条件（使用 EL 表达式输出）--%&gt;&lt;c:if test=&quot;$&#123;12==12&#125;&quot;&gt; &lt;h1&gt;无敌&lt;/h1&gt;&lt;/c:if&gt;&lt;c:if test=&quot;$&#123;12!=12&#125;&quot;&gt; &lt;h1&gt;无敌&lt;/h1&gt;&lt;/c:if&gt;&lt;%--iii.&lt;c:choose&gt; &lt;c:when&gt; &lt;c:otherwise&gt;标签作用：多路判断。跟 switch ... case .... default 非常接近choose 标签开始选择判断when 标签表示每一种判断情况test 属性表示当前这种判断情况的值otherwise 标签表示剩下的情况&lt;hr/&gt;&lt;c:choose&gt; &lt;c:when&gt; &lt;c:otherwise&gt;标签使用时需要注意的点：1、标签里不能使用 html 注释，要使用 jsp 注释2、when 标签的父标签一定要是 choose 标签--%&gt;&lt;% request.setAttribute(&quot;height&quot;,178);%&gt;&lt;c:choose&gt; &lt;c:when test=&quot;$&#123;requestScope.height&gt;190&#125;&quot;&gt; &lt;h1&gt;是巨人&lt;/h1&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;requestScope.height&gt;180&#125;&quot;&gt; &lt;h1&gt;小巨人&lt;/h1&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;requestScope.height&gt;170&#125;&quot;&gt; &lt;h1&gt;还行&lt;/h1&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;requestScope.height&gt;160&#125;&quot;&gt; &lt;h1&gt;有点矮&lt;/h1&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;c:choose&gt; &lt;c:when test=&quot;$&#123;requestScope.height&gt;150&#125;&quot;&gt; &lt;h1&gt;xiaoren&lt;/h1&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;requestScope.height&gt;140&#125;&quot;&gt; &lt;h1&gt;xiaoren2&lt;/h1&gt; &lt;/c:when&gt; &lt;/c:choose&gt; &lt;/c:otherwise&gt;&lt;/c:choose&gt;&lt;/body&gt;&lt;/html&gt; test中是要判断的条件，otherwise是这些都不符合之后执行的，这些when标签和otherwise标签执行一个，其他的就不能执行 如果想要在otherwise标签中再使用when标签就要加上choose c：foreach 标签 遍历1到10 12345678910111213&lt;%--1.遍历 1 到 10，输出begin 属性设置开始的索引end 属性设置结束的索引var 属性表示循环的变量(也是当前正在遍历到的数据)for (int i = 1; i &lt; 10; i++)--%&gt;&lt;table border=&quot;1&quot;&gt;&lt;c:forEach begin=&quot;1&quot; end=&quot;100&quot; var=&quot;i&quot;&gt; &lt;tr&gt; &lt;td&gt;第$&#123;i&#125;行&lt;td/&gt; &lt;tr/&gt; &lt;/c:forEach&gt;&lt;/table&gt; 遍历Object类型的数组 1234567891011&lt;%-- 2.遍历 Object 数组for (Object item: arr)items 表示遍历的数据源（遍历的集合）var 表示当前遍历到的数据--%&gt;&lt;% request.setAttribute(&quot;arr&quot;,new String[]&#123;&quot;18888&quot;,&quot;166666&quot;&#125;);%&gt;&lt;c:forEach items=&quot;$&#123;requestScope.arr&#125;&quot; var=&quot;item&quot;&gt; $&#123;item&#125;&lt;br/&gt;&lt;/c:forEach&gt; 遍历Map集合 1234567891011121314&lt;% Map&lt;String,Object&gt; map=new HashMap&lt;String,Object&gt;(); map.put(&quot;key1&quot;,&quot;value1&quot;); map.put(&quot;key2&quot;,&quot;value2&quot;); map.put(&quot;key3&quot;,&quot;value3&quot;); // for ( Map.Entry&lt;String,Object&gt; entry : map.entrySet()) &#123;// &#125; request.setAttribute(&quot;map&quot;,map);%&gt;&lt;c:forEach items=&quot;$&#123;requestScope.map&#125;&quot; var=&quot;entry&quot;&gt; &lt;h1&gt;$&#123;entry&#125;&lt;/h1&gt; &lt;h1&gt;$&#123;entry.key&#125;&lt;/h1&gt; &lt;h2&gt;$&#123;entry.value&#125;&lt;/h2&gt;&lt;/c:forEach&gt; entry是map中的一个元素 entry.key是map中一个元素的key值 entry.value是map中一个元素的value值 遍历List集合–list 中存放 Student 类，有属性：编号，用户名，密码，年龄， 电话信息 1234567891011121314151617181920212223242526272829303132333435&lt;%--4.遍历 List 集合---list 中存放 Student 类，有属性：编号，用户名，密码，年龄，电话信息--%&gt;&lt;% List&lt;Student&gt; studentArraylist = new ArrayList&lt;Student&gt;(); for(int i=0;i&lt;10;i++) studentArraylist.add(new Student(i,i+&quot;username&quot;,i+&quot;password&quot;,i+18,i+&quot;1&quot;)); request.setAttribute(&quot;list&quot;,studentArraylist);%&gt;&lt;table&gt;&lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;username&lt;/td&gt; &lt;td&gt;password&lt;/td&gt; &lt;td&gt;age&lt;/td&gt; &lt;td&gt;phone&lt;/td&gt; &lt;td&gt;step&lt;/td&gt;&lt;/tr&gt; &lt;%--items 表示遍历的集合var 表示遍历到的数据--%&gt;&lt;c:forEach items=&quot;$&#123;requestScope.list&#125;&quot; var=&quot;stu&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;stu.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.username&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.password&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.phone&#125;&lt;/td&gt; &lt;td&gt;删除修改&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt;&lt;/table&gt; foreach标签组合使用 上面的图片是status可以获取到的东西 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;%@ page import=&quot;java.util.HashMap&quot; %&gt;&lt;%@ page import=&quot;java.util.Map&quot; %&gt;&lt;%@ page import=&quot;com.atguigu.pojo.Student&quot; %&gt;&lt;%@ page import=&quot;java.util.List&quot; %&gt;&lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/3 Time: 16:11 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--4.遍历 List 集合---list 中存放 Student 类，有属性：编号，用户名，密码，年龄，电话信息--%&gt;&lt;% List&lt;Student&gt; studentArraylist = new ArrayList&lt;Student&gt;(); for(int i=0;i&lt;10;i++) studentArraylist.add(new Student(i,i+&quot;username&quot;,i+&quot;password&quot;,i+18,i+&quot;1&quot;)); request.setAttribute(&quot;list&quot;,studentArraylist);%&gt;&lt;table&gt;&lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;username&lt;/td&gt; &lt;td&gt;password&lt;/td&gt; &lt;td&gt;age&lt;/td&gt; &lt;td&gt;phone&lt;/td&gt; &lt;td&gt;step&lt;/td&gt;&lt;/tr&gt; &lt;%-- items 表示遍历的集合 var 表示遍历到的数据 begin 表示遍历的开始索引值 end 表示结束的索引值 step 属性表示遍历的步长值 varStatus 属性表示当前遍历到的数据的状态 for（int i = 1; i &lt; 10; i+=2） --%&gt;&lt;c:forEach begin=&quot;2&quot; end=&quot;7&quot; step=&quot;2&quot; varStatus=&quot;status&quot; items=&quot;$&#123;requestScope.list&#125;&quot; var=&quot;stu&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;stu.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.username&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.password&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.phone&#125;&lt;/td&gt; &lt;td&gt;$&#123;status.current&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; varStatus 属性表示当前遍历到的数据的状态 这个是status能够获得的状态 status.current status.first status.end 这样去用 文件的上传和下载文件的上传和下载，是非常常见的功能。 很多的系统中，或者软件中都经常使用文件的上传和下载。 比如：QQ 头像，就使用了上传。 邮箱中也有附件的上传和下载功能。 OA 系统中审批有附件材料的上传。 文件上传的介绍1、要有一个 form 标签，method&#x3D;post 请求 因为get请求有长度限制，所以使用post请求 2、form 标签的 encType 属性值必须为 multipart&#x2F;form-data 值 3、在 form 标签中使用 input type&#x3D;file 添加上传的文件 4、编写服务器代码（Servlet 程序）接收，处理上传的数据。 encType&#x3D;multipart&#x2F;form-data 表示提交的数据，以多段（每一个表单项一个数据段）的形式进行拼 接，然后以二进制流的形式发送给服务器 上传文件的表单 123456789101112131415161718192021&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/3 Time: 20:56 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt; 头像 &lt;input type=&quot;file&quot; name=&quot;photo&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; username是用户名，就是表单中提交的东西，如果还提交了密码或者别的，都会在请求体中以分段的形式出现 请求体中每一个数据段都是一个表单中的项 &#x3D; 要用下面这种流的格式来获取post传的值，基本就是请求体的内容 123456789101112131415161718192021222324252627package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class UploadServlet extends HttpServlet &#123; /** * 用来处理文件上传 * @param req * @param resp * @throws ServletException * @throws IOException */ @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;文件上传&quot;); ServletInputStream inputStream = req.getInputStream(); byte[] buffer=new byte[1024000]; int read=inputStream.read(buffer); System.out.println(new String(buffer,0,read)); &#125;&#125; 文件上传中获取其他表单项也都不能用getParameter的方法 文件上传用到的类和方法commons-fileupload.jar 常用 API 介绍说明 commons-fileupload.jar 需要依赖 commons-io.jar 这个包，所以两个包我们都要引入。 第一步，就是需要导入两个 jar 包： commons-fileupload-1.2.1.jar commons-io-1.4.jar commons-fileupload.jar 和 commons-io.jar 包中，我们常用的类有哪些？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.IOException;import java.util.List;import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.FileItemFactory;import org.apache.commons.fileupload.FileUploadException;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;public class UploadServlet extends HttpServlet &#123; /** * 用来处理文件上传 * @param req * @param resp * @throws ServletException * @throws IOException */ @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.先判断上传的数据是否是多段数据，只有是多端的数据才可能是文件上传的 if(ServletFileUpload.isMultipartContent(req))&#123; //创建FileItemFactory工厂实现类 FileItemFactory fileItemFactory=new DiskFileItemFactory(); //创建用于解析上传数据的工具类ServletFileUpload ServletFileUpload servletFileUpload=new ServletFileUpload(fileItemFactory); try &#123; //解析上传的数据，得到一个表单项FileItem List&lt;FileItem&gt; list=servletFileUpload.parseRequest(req); //循环判断每一个表单项是上传的文件还是普通类型 for(FileItem fileItem:list)&#123; if(fileItem.isFormField())&#123; //普通表单项 System.out.println(&quot;表单项的name属性值&quot;+fileItem.getFieldName()); //UTF-8是为了防止出现乱码 System.out.println(&quot;表单项的value属性&quot;+fileItem.getString(&quot;UTF-8&quot;)); &#125; else &#123; //上传的文件 System.out.println(&quot;表单项的name属性值&quot;+fileItem.getFieldName()); System.out.println(&quot;表单项的value属性&quot;+fileItem.getName()); //将上传的文件写入e盘 fileItem.write(new File(&quot;e:\\\\&quot;+fileItem.getName())); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 文件下载getResourceAsStream中的路径只有两种写法 最前面是’&#x2F;‘ 说明是工程目录下可以映射到web目录下 最前面没有’&#x2F;‘ 说明是默认从src目录开始 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.atguigu.servlet;import org.apache.commons.io.IOUtils;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;public class Download extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.获取要下载的文件名 String downloadFilename=&quot;1.jpg&quot;; //2.读取要下载的文件内容（通过ServletContext对象可以读取） ServletContext servletContext=getServletContext(); // 获取要下载的文件类型 String mimeType = servletContext.getMimeType(&quot;/File/&quot; + downloadFilename); System.out.println(&quot;下载的文件类型&quot;+mimeType); //4.在回传前，通过响应头告诉客户端返回的数据类型 resp.setContentType(mimeType); //5.还要告诉客户端收到的数据是用于下载使用(还是使用响应头) //Content-Disposition响应头，表示收到的数据怎么处理 //attachment表示附件，表示下载使用 //filename=表示指定下载的文件名 //这个filename不一定是源文件名，用自己起的也行 resp.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot;+downloadFilename); InputStream resourceAsStream=servletContext.getResourceAsStream(&quot;/File/&quot;+downloadFilename); //获取响应的输出流 OutputStream outputStream=resp.getOutputStream(); //3.把下载的文件内容回传给客户端 //读取输入流中全部的数据，赋值给输出流，输出给客户端 IOUtils.copy(resourceAsStream,outputStream); &#125;&#125; 火狐浏览器base64编码 因为火狐浏览器有点问题，所以要单独把他拿出来 书城项目第三阶段页面jsp动态化1.在html页面添加page指令 2.修改文件后缀名为.jsp 再次打开服务器访问时，需要先去除浏览器缓存，ctrl+shift+delete 3、使用 IDEA 搜索替换.html 为.jsp(快捷键：Ctrl+Shift+R 用.jsp替换文件中的.html 抽取所有jsp页面中的公共内容将下面的内容放在一个jsp文件中然后使用静态包含，引用到利用它的地方 123456&lt;div&gt; &lt;span&gt;欢迎&lt;span class=&quot;um_span&quot;&gt;韩总&lt;/span&gt;光临尚硅谷书城&lt;/span&gt; &lt;a href=&quot;order/order.jsp&quot;&gt;我的订单&lt;/a&gt; &lt;a href=&quot;index.jsp&quot;&gt;注销&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;index.jsp&quot;&gt;返回&lt;/a&gt;&lt;/div&gt; 静态包含 12 &lt;!--静态包含jsp文件--&gt;&lt;%@ include file=&quot;/pages/common/login_success_menu.jsp&quot;%&gt; 这个也是每一个文件公有的，引入css样式，jQuery库和base标签 1234 &lt;!--写base标签，永远固定相对路径的跳转结果--&gt; &lt;base href=&quot;http://localhost:8087/book2/&quot;&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;static/css/style.css&quot; &gt; &lt;script src=&quot;static/script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; 静态包含 12&lt;!--使用静态包含引入css样式jQuery和base标签--&gt; &lt;%@ include file=&quot;/pages/common/head.jsp&quot;%&gt; 页脚也是完全一样的 12&lt;!--静态包含页脚的代码--&gt;&lt;%@include file=&quot;/pages/common/footer.jsp&quot; %&gt; manager中的下面的也是一样的 12345&lt;div&gt; &lt;a href=&quot;book_manager.jsp&quot;&gt;图书管理&lt;/a&gt; &lt;a href=&quot;order_manager.jsp&quot;&gt;订单管理&lt;/a&gt; &lt;a href=&quot;../../index.jsp&quot;&gt;返回商城&lt;/a&gt;&lt;/div&gt; 动态的base标签值就是让文件的路径根据我们的输入的网址来进行改变 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;!--写base标签，永远固定相对路径的跳转结果--&gt;&lt;% String basePath=request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+request.getContextPath()+&quot;/&quot;;%&gt;&lt;%--这个最后的/是一定不能省去的--%&gt;&lt;%--这写个方法的意思写在PageContext演示标题下--%&gt;&lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt; 登录，注册错误提示，及表单回显在LoginServlet中将信息保存到request域中，方便当用户输入错误时，在jsp页面保留输入的用户名以及出现错误提示 123//把错误信息，和回显的表单项信息，保存到request域中req.setAttribute(&quot;msg&quot;,&quot;用户名或者密码错误&quot;);req.setAttribute(&quot;username&quot;,username); 这个value是为了第一次进入页面没有提交过信息的时候，那个username那一栏是空的 12&lt;input class=&quot;itxt&quot; type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; autocomplete=&quot;off&quot; tabindex=&quot;1&quot; name=&quot;username&quot;value=&quot;&lt;%=request.getAttribute(&quot;username&quot;)==null?&quot;&quot;:request.getAttribute(&quot;username&quot;)%&gt;&quot;/&gt; 这是对报错信息的修改，就是为了刚进去是请输入用户密码和用户名，如果提交信息的错误则输出报错信息 1&lt;span class=&quot;errorMsg&quot;&gt;&lt;%=request.getAttribute(&quot;msg&quot;)==null?&quot;请输入用户密码和用户名&quot;:request.getAttribute(&quot;msg&quot;)%&gt;&lt;/span&gt; 这是对登录页面的修改，在注册页面中也对username email 以及报错信息进行了类似的修改 合并LoginServlet和RegistServlet为UserServlet在实际的项目开发中，一个模块，一般只使用一个 Servlet 程序。 就是在两个jsp页面的表单中添加hidden的表单项，根据Servlet程序获取的表单项的值不同，可以判断是login还是regist继而执行对应的程序，同时两个表单的action属性改为UserServlet 12&lt;form action=&quot;UserServlet&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;login&quot;/&gt; 12&lt;form action=&quot;UserServlet&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;regist&quot;/&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.atguigu.web;import com.atguigu.pojo.User;import com.atguigu.service.UserService;import com.atguigu.service.impl.UserServiceImpl;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class UserServlet extends HttpServlet &#123; private UserService userService=new UserServiceImpl(); protected void login(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;//获取用户名和密码参数 String username=req.getParameter(&quot;username&quot;); String password=req.getParameter(&quot;password&quot;); //如果用户名或密码错误 if(userService.login(new User(null,username,password,null))==null)&#123; //把错误信息，和回显的表单项信息，保存到request域中 req.setAttribute(&quot;msg&quot;,&quot;用户名或者密码错误&quot;); req.setAttribute(&quot;username&quot;,username); req.getRequestDispatcher(&quot;/pages/user/login.jsp&quot;).forward(req,resp); &#125; //如果用户名和密码正确 else &#123; req.getRequestDispatcher(&quot;/pages/user/login_success.jsp&quot;).forward(req,resp); &#125; &#125; protected void regist(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.获取请求的参数 //这个getParameter方法是通过那个属性的name得到的 String username=req.getParameter(&quot;username&quot;); String password=req.getParameter(&quot;password&quot;); String email=req.getParameter(&quot;email&quot;); String code=req.getParameter(&quot;code&quot;); //2.检查 验证码是否正确,先把验证码写死，要求为abcde if(&quot;abcde&quot;.equalsIgnoreCase(code))&#123; //验证码正确 //检查用户名是否可用 if(userService.existsUsername(username))&#123; System.out.println(&quot;用户名&quot;+username+&quot;已存在&quot;); req.setAttribute(&quot;msg&quot;,&quot;用户名已存在&quot;); req.setAttribute(&quot;username&quot;,username); req.setAttribute(&quot;email&quot;,email); //跳回到注册页面 req.getRequestDispatcher(&quot;/pages/user/regist.jsp&quot;).forward(req,resp); &#125; else &#123; //可用 //调用Sercice保存到数据库 userService.registerUser(new User(null,username,password,email)); //注册成功后，跳转到注册成功页面 req.getRequestDispatcher(&quot;/pages/user/regist_success.jsp&quot;).forward(req,resp); &#125; &#125;else&#123; //把回显信息保存到request域中 req.setAttribute(&quot;msg&quot;,&quot;用户验证码错误&quot;); req.setAttribute(&quot;username&quot;,username); req.setAttribute(&quot;email&quot;,email); System.out.println(&quot;验证码&quot;+code+&quot;错误&quot;); //验证码不正确 //跳回注册页面，因为还是申请服务器中文件所以/还是工程目录下的 req.getRequestDispatcher(&quot;/pages/user/regist.jsp&quot;).forward(req,resp); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String parameter=req.getParameter(&quot;action&quot;); if(parameter.equals(&quot;login&quot;))&#123; login(req,resp); &#125; else if(parameter.equals(&quot;regist&quot;))&#123; regist(req,resp); &#125; &#125;&#125; 使用反射优化大量else if代码用户模块的功能，除了登录和注册，还有其他比如：添加用户，修改用户信息，修改密码，绑定手机号，绑定邮箱，注销用户 ….等等这样在UserServlet终究会出现特别多的else if 语句 12345678910111213141516@Overrideprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String parameter=req.getParameter(&quot;action&quot;); try &#123; //通过反射获取对应的方法，因为设定获取的action的参数值和调用方法的名字相同 Method parameter1 = this.getClass().getDeclaredMethod(parameter,HttpServletRequest.class,HttpServletResponse.class); //执行目标业务方法 parameter1.invoke(this,req,resp); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 这个是因为获取的hidden的action参数值是和要调用的业务方法是相同的，所以用反射获取要调用的业务方法然后调用 抽取BaseServlet程序 12345678910111213141516171819202122232425262728293031323334353637package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.Method;public abstract class BaseServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req,resp); &#125; protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(&quot;text/html;charset=UTF-8&quot;); //解决响应乱码问题 String parameter=req.getParameter(&quot;action&quot;); try &#123; //通过反射获取对应的方法，因为设定获取的action的参数值和调用方法的名字相同 //this是指调用该post方法的对象 Method parameter1 = this.getClass().getDeclaredMethod(parameter,HttpServletRequest.class,HttpServletResponse.class); //执行目标业务方法 parameter1.invoke(this,req,resp); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 因为Servlet程序还有好多有UserServlet有BookServlet等等他们上面那些代码都是一致的，所以拿出来形成一个BaseServlet BaseServlet继承HttpServlet ，其他的都继承BaseServlet就可以了 post访问时会自动调用UserServlet中继承的doPost方法 BeanUtils工具的使用BeanUtils 工具类，它可以一次性的把所有请求的参数注入到 JavaBean 中 BeanUtils 工具类，经常用于把 Map 中的值注入到 JavaBean 中，或者是对象属性值的拷贝操作。 BeanUtils 它不是 Jdk 的类。而是第三方的工具类。所以需要导包。 1、导入需要的 jar 包： commons-beanutils-1.8.0.jar commons-logging-1.1.1.jar 2.BeanUtils的使用 12345678User user=new User();try &#123; //将所有请求参数导入user对象，getParameterMap方法是获得Map类型的参数 BeanUtils.populate(user,req.getParameterMap());&#125; catch (Exception e) &#123; e.printStackTrace();&#125;userService.registerUser(user); 这个的使用原理就是 找属性username然后变成setUsername对这个属性进行赋值，然后再对其他每个属性进行这个操作 所以如果这个属性没有对应的正确的set方法是无法注入值的 所以还有一个要求是获取的参数的name一定要和java类中的属性的名字相同 webUtils类 对这个BeanUtils类中的方法使用进行一个封装 1234567891011121314151617181920212223242526272829package com.atguigu.utils;import com.atguigu.pojo.User;import org.apache.commons.beanutils.BeanUtils;import javax.servlet.http.HttpServletRequest;import java.util.Map;public class WebUtils &#123; /** * 把 Map 中的值注入到对应的 JavaBean 属性中。 * @param value * @param bean */ public static&lt;T&gt; T copyParamToBean(Map value, T bean)&#123; /* 将所有的请求参数一次性注入到user对象中 */ try &#123; System.out.println(&quot;注入之前:&quot;+bean); //将所有请求参数导入user对象，getParameterMap方法是获得Map类型的参数 BeanUtils.populate(bean,value); System.out.println(&quot;注入之后&quot;+bean); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return bean; &#125;&#125; webUtils的使用 1234 //可用 //调用Sercice保存到数据库Map map=req.getParameterMap();User user=WebUtils.copyParamToBean(map,new User()); 书城项目第四阶段使用EL修改表单回显这是login.jsp的 将用jsp表达式脚本转变为EL表达式 1234&lt;span class=&quot;errorMsg&quot;&gt; &lt;%--&lt;%=request.getAttribute(&quot;msg&quot;)==null?&quot;请输入用户密码和用户名&quot;:request.getAttribute(&quot;msg&quot;)%&gt;--%&gt; $&#123;empty requestScope.msg?&quot;请输入用户密码和用户名&quot;:requestScope.msg&#125;&lt;/span&gt; 12345&lt;!--省去判断是因为即使是空那么返回的也是空字符串--&gt;&lt;input class=&quot;itxt&quot; type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; autocomplete=&quot;off&quot; tabindex=&quot;1&quot; name=&quot;username&quot;&lt;%--value=&quot;&lt;%=request.getAttribute(&quot;username&quot;)==null?&quot;&quot;:request.getAttribute(&quot;username&quot;)%&gt;&quot;--%&gt; value=&quot;$&#123;requestScope.username&#125;&quot;/&gt; regist.jsp中同样有这种的 ，username ，email 和报错信息 书城项目的第五阶段MVC概念MVC 全称：Model 模型、 View 视图、 Controller 控制器。 MVC 最早出现在 JavaEE 三层中的 Web 层，它可以有效的指导 Web 层的代码如何有效分离，单独工作 View 视图：只负责数据和界面的显示，不接受任何与显示数据无关的代码，便于程序员和美工的分工合作—— JSP&#x2F;HTML Controller 控制器：只负责接收请求，调用业务层的代码处理请求，然后派发页面，是一个“调度者”的角色——Servlet。 转到某个页面。或者是重定向到某个页面。 Model 模型：将与业务逻辑相关的数据封装为具体的 JavaBean 类，其中不掺杂任何与数据处理相关的代码—— JavaBean&#x2F;domain&#x2F;entity&#x2F;pojo。 MVC 是一种思想 MVC 的理念是将软件代码拆分成为组件，单独开发，组合使用（目的还是为了降低耦合度）。 创建图书模块的数据库表123456789create table t_book(id int primary key auto_increment,name varchar(100),price decimal(11,2),author varchar(100),sales int,stock int,img_path varchar(200)); 然后在里面插入数据 123use book;select *from t_book;查询一下里面插入的数据 编写图书模块的JavaBean1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.atguigu.pojo;import java.math.BigDecimal;public class Book &#123; private Integer id; private String name; private String author; private BigDecimal price; private Integer sales; private Integer stock; private String imgPath=&quot;static/img/default.jpg&quot;;//图书的封面 public Book() &#123; &#125; public Book(Integer id, String name, String author, BigDecimal price, Integer sales, Integer stock, String imgPath) &#123; this.id = id; this.name = name; this.author = author; this.price = price; this.sales = sales; this.stock = stock; this.imgPath = imgPath; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Book&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, author=&#x27;&quot; + author + &#x27;\\&#x27;&#x27; + &quot;, price=&quot; + price + &quot;, sales=&quot; + sales + &quot;, stock=&quot; + stock + &quot;, imgPath=&#x27;&quot; + imgPath + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; public BigDecimal getPrice() &#123; return price; &#125; public void setPrice(BigDecimal price) &#123; this.price = price; &#125; public Integer getSales() &#123; return sales; &#125; public void setSales(Integer sales) &#123; this.sales = sales; &#125; public Integer getStock() &#123; return stock; &#125; public void setStock(Integer stock) &#123; this.stock = stock; &#125; public String getImgPath() &#123; return imgPath; &#125; public void setImgPath(String imgPath) &#123; this.imgPath = imgPath; &#125;&#125; 编写图书模块的Dao和测试DaoBookDao 123456789101112131415package com.atguigu.dao;import com.atguigu.pojo.Book;import java.util.List;public interface BookDao &#123; public int addBook(Book book); public int deleteBookById(Integer id); public int updateBook(Book book); public Book queryBookById(Integer id); public List&lt;Book&gt; queryBooks();&#125; BookDaoImpl 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.atguigu.dao.impl;import com.atguigu.dao.BookDao;import com.atguigu.pojo.Book;import java.util.List;public class BookDaoImpl extends BaseDao implements BookDao &#123; @Override public int addBook(Book book) &#123; String sql=&quot;insert into t_book (name,author,price,sales,stock,img_path) values(?,?,?,?,?,?)&quot;; return update(sql,book.getName(),book.getAuthor(),book.getPrice(),book.getSales(),book.getStock(),book.getImgPath()); &#125; @Override public int deleteBookById(Integer id) &#123; String sql=&quot;delete from t_book where id=?&quot;; return update(sql,id); &#125; @Override public int updateBook(Book book) &#123; String sql=&quot;update t_book set name=?,author=?,price=?,sales=?,stock=?,img_path=? where id=?&quot;; return update(sql,book.getName(),book.getAuthor(),book.getPrice(),book.getSales(),book.getStock(),book.getImgPath(),book.getId()); &#125; @Override public Book queryBookById(Integer id) &#123; String sql=&quot;select * from t_book where id=?&quot;; return queryForOne(Book.class,sql,id); &#125; @Override public List&lt;Book&gt; queryBooks() &#123; String sql=&quot;select * from t_book&quot;; return queryForList(Book.class,sql); &#125;&#125; BookDaoTest 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.atguigu.test;import com.atguigu.dao.BookDao;import com.atguigu.dao.impl.BookDaoImpl;import com.atguigu.pojo.Book;import org.junit.Test;import java.math.BigDecimal;public class BookDaoTest &#123;private BookDao bookDao=new BookDaoImpl(); @Test public void addBook() &#123; bookDao.addBook(new Book(null,&quot;国哥为什么这么帅！&quot;, &quot;191125&quot;, new BigDecimal(9999),1100000,0,null )); &#125; @Test public void deleteBookById() &#123; bookDao.deleteBookById(1); &#125; @Test public void updateBook() &#123; bookDao.updateBook(new Book(21,&quot;国哥&quot;, &quot;191125&quot;, new BigDecimal(9999),1100000,0,null )); &#125; @Test public void queryBookById() &#123; System.out.println(bookDao.queryBookById(21)); &#125; @Test public void queryBooks() &#123; for (Book queryBook : bookDao.queryBooks()) &#123; System.out.println(queryBook); &#125; &#125;&#125; 编写图书模块的Service和测试ServiceBookSevice 12345678910111213package com.atguigu.service;import com.atguigu.pojo.Book;import java.util.List;public interface BookService &#123; public void addBook(Book book); public void deleteBookById(Integer id); public void updateBook(Book book); public Book queryBookById(Integer id); public List&lt;Book&gt; queryBooks();&#125; BookService的实现是基于BookDao的 BookServiceImpl 123456789101112131415161718192021222324252627282930313233343536package com.atguigu.service.impl;import com.atguigu.dao.BookDao;import com.atguigu.dao.impl.BookDaoImpl;import com.atguigu.pojo.Book;import com.atguigu.service.BookService;import java.util.List;public class BookServiceImpl implements BookService &#123; private BookDao bookDao=new BookDaoImpl(); @Override public void addBook(Book book) &#123; bookDao.addBook(book); &#125; @Override public void deleteBookById(Integer id) &#123;bookDao.deleteBookById(id); &#125; @Override public void updateBook(Book book) &#123;bookDao.updateBook(book); &#125; @Override public Book queryBookById(Integer id) &#123; return bookDao.queryBookById(id); &#125; @Override public List&lt;Book&gt; queryBooks() &#123; return bookDao.queryBooks(); &#125;&#125; BookServiceImplTest测试 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.atguigu.test;import com.atguigu.pojo.Book;import com.atguigu.service.BookService;import com.atguigu.service.impl.BookServiceImpl;import org.junit.Test;import java.math.BigDecimal;import static org.junit.Assert.*;public class BookServiceImplTest &#123; private BookService bookService=new BookServiceImpl(); @Test public void addBook() &#123; bookService.addBook(new Book(1,&quot;java从入门到放弃&quot;,&quot;国歌&quot;,new BigDecimal(80),9999,9,&quot;static/img/default.jpg&quot;)); &#125; @Test public void deleteBookById() &#123; bookService.deleteBookById(21); &#125; @Test public void updateBook() &#123; bookService.updateBook(new Book(22,&quot;黑涩会国歌&quot;,&quot;122&quot;,new BigDecimal(100000),100000,0,null)); &#125; @Test public void queryBookById() &#123; System.out.println(bookService.queryBookById(22)); &#125; @Test public void queryBooks() &#123; for (Book queryBook : bookService.queryBooks()) &#123; System.out.println(queryBook); &#125; &#125;&#125; 编写图书模块的web层，和页面联调测试流程 这个是manager.jsp页面 点一下这个是进入book_manager.jsp是 步骤 在bookServlet中添加这个方法 123456789protected void list(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.通过BookService查询全部图书 List&lt;Book&gt; books = bookService.queryBooks(); //2.把全部图书保存到request域中 req.setAttribute(&quot;books&quot;,books); System.out.println(1); //3.请求转发到/pages/manager/book_manager.jsp req.getRequestDispatcher(&quot;/pages/manager/book_manager.jsp&quot;).forward(req,resp);&#125; 在book_manager.jsp中进行图书信息遍历输出 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;图书管理&lt;/title&gt; &lt;!--使用静态包含引入css样式jQuery和base标签--&gt; &lt;%@ include file=&quot;/pages/common/head.jsp&quot;%&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;header&quot;&gt; &lt;img class=&quot;logo_img&quot; alt=&quot;&quot; src=&quot;static/img/logo.gif&quot; &gt; &lt;span class=&quot;wel_word&quot;&gt;图书管理系统&lt;/span&gt; &lt;!--引入manager_menu.jsp内容--&gt; &lt;%@include file=&quot;/pages/common/manager_menu.jsp&quot;%&gt; &lt;/div&gt; &lt;div id=&quot;main&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;名称&lt;/td&gt; &lt;td&gt;价格&lt;/td&gt; &lt;td&gt;作者&lt;/td&gt; &lt;td&gt;销量&lt;/td&gt; &lt;td&gt;库存&lt;/td&gt; &lt;td colspan=&quot;2&quot;&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach items=&quot;$&#123;requestScope.books&#125;&quot; var=&quot;book&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;book.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.price&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.author&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.sales&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.stock&#125;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;book_edit.jsp&quot;&gt;修改&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;#&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;book_edit.jsp&quot;&gt;添加图书&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;!--静态包含页脚的代码--&gt; &lt;%@include file=&quot;/pages/common/footer.jsp&quot; %&gt;&lt;/body&gt;&lt;/html&gt; 还有一个改动 在BaseServlet添加doGet方法并在其中调用doPost方法 因为 1&lt;a href=&quot;manager/BookServlet?action=list&quot;&gt;图书管理&lt;/a&gt; 进行的是get传参，来调用list方法，所以得有一个doGet方法来调用doPost 123456789101112131415161718192021222324252627282930313233package com.atguigu.web;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.Method;public abstract class BaseServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req,resp); &#125; protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String parameter=req.getParameter(&quot;action&quot;); try &#123; //通过反射获取对应的方法，因为设定获取的action的参数值和调用方法的名字相同 Method parameter1 = this.getClass().getDeclaredMethod(parameter,HttpServletRequest.class,HttpServletResponse.class); //执行目标业务方法 parameter1.invoke(this,req,resp); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 前后端的简单介绍 添加图书功能的实现 book_edit是这个界面，用来添加图书的 1&lt;td&gt;&lt;a href=&quot;pages/manager/book_edit.jsp&quot;&gt;添加图书&lt;/a&gt;&lt;/td&gt; 党点击添加图书跳转到book_edit界面 先修改book_edit界面的表单，表单项中的name属性一定要和javabean类中的属性名一样，否则不能用BeanUtils注入 将action改为manager&#x2F;BookServlet，添加了一个表单项value为add来调用add方法 123456789101112131415161718192021&lt;form action=&quot;manager/BookServlet&quot; method=&quot;get&quot;&gt; &lt;table&gt; &lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;add&quot;/&gt; &lt;tr&gt; &lt;td&gt;名称&lt;/td&gt; &lt;td&gt;价格&lt;/td&gt; &lt;td&gt;作者&lt;/td&gt; &lt;td&gt;销量&lt;/td&gt; &lt;td&gt;库存&lt;/td&gt; &lt;td colspan=&quot;2&quot;&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input name=&quot;name&quot; type=&quot;text&quot; value=&quot;时间简史&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;price&quot; type=&quot;text&quot; value=&quot;30.00&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;author&quot; type=&quot;text&quot; value=&quot;霍金&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;sales&quot; type=&quot;text&quot; value=&quot;200&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;stock&quot; type=&quot;text&quot; value=&quot;300&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt; 修改BookServlet 1234567891011121314151617protected void add(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //使用BeanUtils生成Book对象 Map parameterMap = req.getParameterMap(); Book book= WebUtils.copyParamToBean(parameterMap,new Book()); //保存图书 bookService.addBook(book); //使用这个方法是有bug的 //造成表单的重复提交，当用户提交完请求，浏览器会记录下最后一次请求的全部信息，当用户按下功能键f5，就会发起浏览器记录的最后一次请求 // req.getRequestDispatcher(&quot;/manager/BookServlet?action=list&quot;).forward(req,resp); //这里要使用重定向resp.sendRedirect(req.getContextPath()+&quot;/manager/BookServlet?action=list&quot;); &#125; 造成表单的重复提交，当用户提交完请求，浏览器会记录下最后一次请求的全部信息，当用户按下功能键f5，就会发起浏览器记录的最后一次请求 请求转发是一次请求，重定向是两次请求，就是如果请求转发则从提交表单开始到最后都是一次请求，但重定向则是两次，第二次是请求那个jsp页面，所以对于重定向来讲，浏览器存储的最后一次请求就是请求那个jsp页面，便不会重复添加 删除图书功能的实现 修改book_editmanager中的 1&lt;td&gt;&lt;a class=&quot;deleteClass&quot; href=&quot;manager/BookServlet?action=delete&amp;id=$&#123;book.id&#125;&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; 在book_editmanager中加一个点击事件，来获取要删除的书的名字，来提醒用户是否删错 1234567891011121314151617181920&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; $(&quot;a.deleteClass&quot;).click(function()&#123; /* confirm是确认提示框函数 参数是他的提示内容 它有两个按扭，一个确认，一个是取消。 返回true表示点击了确认，返回false表示点击了取消 */ //在事件的function函数总有一个this对象是当前正在响应事件的dom对象 //将dom转换为jQuery对象获得父标签的父标签tr再得到子标签td中的第一个里面的文本内容 return confirm(&quot;你确定要删除[&quot;+$(this).parent().parent().find(&quot;td:first&quot;).text()+&quot;]?&quot;); /* return false会阻止元素的默认行为，不提交请求 */ &#125;); &#125;);&lt;/script&gt; 在WebUtils中增加的字符串转数字的方法 123456789101112/** * 将字符串转换成为int类型的数据 * @param strInt 这个是要转换为数字的字符串 * @param defaultValue 如果没有转换成功返回默认值 * @return */public static int parseInt(String strInt,int defaultValue)&#123; if(strInt!=null) return Integer.parseInt(strInt); return defaultValue;&#125; 在BookServlet中增加的delete方法 12345678910 protected void delete(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 1、获取请求的参数 id，图书编程 int id=WebUtils.parseInt(req.getParameter(&quot;id&quot;),0);// 2、调用 bookService.deleteBookById();删除图书 bookService.deleteBookById(id);// 3、重定向回图书列表管理页面// /book/manager/bookServlet?action=list resp.sendRedirect(req.getContextPath() + &quot;/manager/BookServlet?action=list&quot;); &#125; 修改图书功能的实现让修改界面变成要修改的书的信息改变 修改选项的请求信息 1&lt;td&gt;&lt;a href=&quot;manager/BookServlet?action=getBook&amp;id=$&#123;book.id&#125;&quot;&gt;修改&lt;/a&gt;&lt;/td&gt; 在BookServlet中添加了一个getBook的方法 这里使用请求转发，是因为请求是在页面显示要修改的book的内容，即使用户按了f5再次请求也无伤大雅 1234567891011protected void getBook(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取图书编号 int id=WebUtils.parseInt(req.getParameter(&quot;id&quot;),0); //调用BookService中的方法查找到这个book的信息 Book book = bookService.queryBookById(id); //把图书保存到request域中 req.setAttribute(&quot;book&quot;,book); //请求转发 req.getRequestDispatcher(&quot;/pages/manager/book_edit.jsp&quot;).forward(req,resp);&#125; 在book_edit页面中修改显示的信息 12345678&lt;tr&gt; &lt;td&gt;&lt;input name=&quot;name&quot; type=&quot;text&quot; value=&quot;$&#123;requestScope.book.name&#125;&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;price&quot; type=&quot;text&quot; value=&quot;$&#123;requestScope.book.price&#125;&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;author&quot; type=&quot;text&quot; value=&quot;$&#123;requestScope.book.author&#125;&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;sales&quot; type=&quot;text&quot; value=&quot;$&#123;requestScope.book.sales&#125;&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;stock&quot; type=&quot;text&quot; value=&quot;$&#123;requestScope.book.stock&#125;&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/td&gt;&lt;/tr&gt; 提交给服务器保存修改 在BookServlet中添加update方法 12345678910protected void update(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //请求参数，封装为Book对象 Map parameterMap = req.getParameterMap(); Book book=WebUtils.copyParamToBean(parameterMap,new Book()); //调用BookService的方法修改图书 bookService.updateBook(book); //将信息重定向到book_edit页面 resp.sendRedirect(req.getContextPath()+&quot;/manager/BookServlet?action=list&quot;);&#125; 这里使用重定向是因为如果使用请求转发，客户端按下f5则会修改两次 改变修改按钮的指向地址，这是为了点击修改之后book_edit页面中能显示要修改的book的信息 1&lt;td&gt;&lt;a href=&quot;manager/BookServlet?action=getBook&amp;id=$&#123;book.id&#125;&quot;&gt;修改&lt;/a&gt;&lt;/td&gt; 解决book_edit页面既要实现add又要实现update的问题 123&lt;!--通过判断是否存在参数id来绝顶value是add还是update--&gt;&lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;$&#123;empty param.id?&quot;add&quot;:&quot;update&quot;&#125;&quot;/&gt;&lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;$&#123;requestScope.book.id&#125;&quot;/&gt; 第二行代码是因为修改book需要id 图书分页的分析 分页模型page的抽取1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.atguigu.pojo;import java.util.List;/*Page是分页的模型对象&lt;T&gt;是具体的模块的javaBean类 */public class Page &lt;T&gt;&#123; public static final Integer PAGE_SIZE=4; public Integer getPageNo() &#123; return pageNo; &#125; public void setPageNo(Integer pageNo) &#123; this.pageNo = pageNo; &#125; public Integer getPageTotal() &#123; return pageTotal; &#125; @Override public String toString() &#123; return &quot;Page&#123;&quot; + &quot;pageNo=&quot; + pageNo + &quot;, pageTotal=&quot; + pageTotal + &quot;, pageSize=&quot; + pageSize + &quot;, pageTotalCount=&quot; + pageTotalCount + &quot;, items=&quot; + items + &#x27;&#125;&#x27;; &#125; public void setPageTotal(Integer pageTotal) &#123; this.pageTotal = pageTotal; &#125; public Integer getPageSize() &#123; return pageSize; &#125; public void setPageSize(Integer pageSize) &#123; this.pageSize = pageSize; &#125; public Integer getPageTotalCount() &#123; return pageTotalCount; &#125; public void setPageTotalCount(Integer pageTotalCount) &#123; this.pageTotalCount = pageTotalCount; &#125; public List&lt;T&gt; getItems() &#123; return items; &#125; public void setItems(List&lt;T&gt; items) &#123; this.items = items; &#125; //当前页码 private Integer pageNo; //总页码 private Integer pageTotal; //当前页的显示数量 private Integer pageSize=PAGE_SIZE; //总记录数 private Integer pageTotalCount; //当前页数据 private List&lt;T&gt; items; public Page(Integer pageNo, Integer pageTotal, Integer pageSize, Integer pageTotalCount, List&lt;T&gt; items) &#123; this.pageNo = pageNo; this.pageTotal = pageTotal; this.pageSize = pageSize; this.pageTotalCount = pageTotalCount; this.items = items; &#125; public Page() &#123; &#125;&#125; 分页的初步实现图书管理这个地方改成分页操作 1&lt;a href=&quot;manager/BookServlet?action=page&quot;&gt;图书管理&lt;/a&gt; BookServlet 在其中添加了分页功能，利用了bookService的page方法 就是生成页面对象的方法，页面对象包括页面的数据条数，多少页等等 12345678910111213141516/*处理分页功能 */protected void page(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1。获取请求的参数，pageNo和pageSize //用户没有点击第几页，就默认显示第一页，所以第二个参数是1 int pageNo=WebUtils.parseInt(req.getParameter(&quot;pageNo&quot;),1); int pageSize=WebUtils.parseInt(req.getParameter(&quot;pageSize&quot;), Page.PAGE_SIZE); //2。调用BookService.page(pageNo,pageSize):Page对象 Page&lt;Book&gt; page=bookService.page(pageNo,pageSize); //3.保存Page对象到request域中 req.setAttribute(&quot;page&quot;,page); //4.请求转发到pages/manager/book_manager.jsp req.getRequestDispatcher(&quot;/pages/manager/book_manager.jsp&quot;).forward(req,resp);&#125; BookService 在BookService中添加了page方法，生成page对象，用到了BookDao的queryForPageTotalCount()方法和queryFotPageItems()方法 为了得到总记录数和当前页数据 123456789101112131415161718192021222324252627@Overridepublic Page&lt;Book&gt; page(int pageNo, int pageSize) &#123; Page&lt;Book&gt; page=new Page&lt;&gt;(); //设置page对象的当前页 page.setPageNo(pageNo); //设置每页显示的数量 page.setPageSize(pageSize); //求总记录数 Integer pageTotalCount=bookDao.queryForPageTotalCount(); //设置总记录数 page.setPageTotalCount(pageTotalCount); //求总页码 Integer pageTotal=pageTotalCount/pageSize; if(pageTotalCount%pageSize&gt;0)&#123; pageTotal+=1; &#125; //设置总页码 page.setPageTotal(pageTotal); //求当前页面开始的索引 int begin=(page.getPageNo()-1)*pageSize; //求当前页数据 List&lt;Book&gt; items=bookDao.queryForPageItems(begin,pageSize); //设置当前页数据 page.setItems(items); return page;&#125; BookDao 在BookDao中增加了queryForPageItems和queryForPageTotalCount方法 为了得到总记录数和当前页数据 123456789101112@Overridepublic Integer queryForPageTotalCount() &#123; String sql=&quot;select count(*) from t_book&quot;; Number count=(Number)queryForSingleValue(sql); return count.intValue();&#125;@Overridepublic List&lt;Book&gt; queryForPageItems(int begin, int pageSize) &#123; String sql=&quot;select id,name,author,price,sales,stock,img_path from t_book limit ?,? &quot;; return queryForList(Book.class,sql,begin,pageSize);&#125; 1234ScalarHandler用来获得聚合函数的值,返回类型是Object,用Number来接收比较好Number num=qr.query(cntSql.append(whereSql).toString(),new ScalarHandler&lt;&gt;(),params.toArray());然后调用intValue()方法int tr=num.intValue()即可! book_manager.jsp中增加了换页框 1234567891011&lt;div id=&quot;page_nav&quot;&gt; &lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;上一页&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;3&lt;/a&gt; 【$&#123;requestScope.page.pageNo&#125;】 &lt;a href=&quot;#&quot;&gt;5&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;下一页&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;末页&lt;/a&gt; 共$&#123;requestScope.page.pageTotal&#125;页，$&#123;requestScope.page.pageTotalCount&#125;条记录 到第&lt;input value=&quot;4&quot; name=&quot;pn&quot; id=&quot;pn_input&quot;/&gt;页 &lt;input type=&quot;button&quot; value=&quot;确定&quot;&gt;&lt;/div&gt; book_manager.jsp中还改变了遍历的数据项requestScope.page.items 1234567891011&lt;c:forEach items=&quot;$&#123;requestScope.page.items&#125;&quot; var=&quot;book&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;book.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.price&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.author&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.sales&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.stock&#125;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;manager/BookServlet?action=getBook&amp;id=$&#123;book.id&#125;&quot;&gt;修改&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a class=&quot;deleteClass&quot; href=&quot;manager/BookServlet?action=delete&amp;id=$&#123;book.id&#125;&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; 首页上一页，下一页，末页的实现1234567891011121314151617&lt;div id=&quot;page_nav&quot;&gt; &lt;%--大于首页才显示上一页按钮--%&gt; &lt;c:if test=&quot;$&#123;requestScope.page.pageNo&gt;1&#125;&quot;&gt; &lt;a href=&quot;manager/BookServlet?action=page&amp;pageNo=1&quot;&gt;首页&lt;/a&gt; &lt;a href=&quot;manager/BookServlet?action=page&amp;pageNo=$&#123;requestScope.page.pageNo-1&#125;&quot;&gt;上一页&lt;/a&gt; &lt;/c:if&gt; &lt;a href=&quot;manager/BookServlet?action=page&amp;pageNo=$&#123;requestScope.page.pageNo-1&#125;&quot;&gt;$&#123;requestScope.page.pageNo-1&#125;&lt;/a&gt; 【$&#123;requestScope.page.pageNo&#125;】 &lt;a href=&quot;manager/BookServlet?action=page&amp;pageNo=$&#123;requestScope.page.pageNo+1&#125;&quot;&gt;$&#123;requestScope.page.pageNo+1&#125;&lt;/a&gt; &lt;%--如果已经是最后一页则不显示下一页和末页--%&gt; &lt;c:if test=&quot;$&#123;requestScope.page.pageNo&lt;requestScope.page.pageTotal&#125;&quot;&gt; &lt;a href=&quot;manager/BookServlet?action=page&amp;pageNo=$&#123;requestScope.page.pageNo+1&#125;&quot;&gt;下一页&lt;/a&gt; &lt;a href=&quot;manager/BookServlet?action=page&amp;pageNo=$&#123;requestScope.page.pageTotal&#125;&quot;&gt;末页&lt;/a&gt; &lt;/c:if&gt; 共$&#123;requestScope.page.pageTotal&#125;页，$&#123;requestScope.page.pageTotalCount&#125;条记录 到第&lt;input value=&quot;$&#123;requestScope.page.pageNo&#125;&quot; name=&quot;pn&quot; id=&quot;pn_input&quot;/&gt;页 &lt;input type=&quot;button&quot; value=&quot;确定&quot;&gt;&lt;/div&gt; 分页模块中跳转到指定页数功能实现这个是head.jsp文件，把路径保存在pageContext域中，方便在book_manager.jsp文件中获取 1234&lt;% String basePath=request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+request.getContextPath()+&quot;/&quot;; pageContext.setAttribute(&quot;basePath&quot;,basePath);%&gt; 给确定键按钮加了一个点击事件 1234567891011121314151617共$&#123;requestScope.page.pageTotal&#125;页，$&#123;requestScope.page.pageTotalCount&#125;条记录 到第&lt;input value=&quot;$&#123;requestScope.page.pageNo&#125;&quot; name=&quot;pn&quot; id=&quot;pn_input&quot;/&gt;页 &lt;input type=&quot;button&quot; id=&quot;searchPageBtn&quot; value=&quot;确定&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; $(&quot;#searchPageBtn&quot;).click(function()&#123; var pageNo=$(&quot;#pn_input&quot;).val(); //javascript语言中提供了一个location地址栏 //他有一个属性叫href，它可以获取浏览器地址栏中的地址 //href属性可读可写 location.href=&quot;$&#123;pageScope.basePath&#125;manager/BookServlet?action=page&amp;pageNo=&quot;+pageNo; &#125;); &#125;); &lt;/script&gt; 数据有效边境检查前端jsp,加了一个前端的校验，如果当前要转的页码大于最大页码或者小于零就返回false，阻止事件发生 123456789101112131415161718192021&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; $(&quot;#searchPageBtn&quot;).click(function()&#123; var pageNo=$(&quot;#pn_input&quot;).val(); var pageTotal=$&#123;requestScope.page.pageTotal&#125;; if(pageNo&gt;pageTotal||pageNo&lt;=0)&#123; return false; &#125; //javascript语言中提供了一个location地址栏 //他有一个属性叫href，它可以获取浏览器地址栏中的地址 //href属性可读可写 location.href=&quot;$&#123;pageScope.basePath&#125;manager/BookServlet?action=page&amp;pageNo=&quot;+pageNo; &#125;); &#125;);&lt;/script&gt; 服务器端检查数据边界，因为在地址栏中使用get传参可以跳过前端验证 直接在setPageNo的方法中设置，只要pageNo不合法，直接替换 1234567891011public void setPageNo(Integer pageNo) &#123; //设置数据的边界值 if(pageNo&lt;1)&#123; pageNo=1; &#125; if(pageNo&gt;pageTotal)&#123; pageNo=pageTotal; &#125; this.pageNo = pageNo;&#125; 分页条形码的输出分页模块中，页码 1,2,【3】,4,5 的显示，要显示 5 个页 码，并且页码可以点击跳转。 需求：显示 5 个连续的页码，而且当前页码在中间。除了当前页码之外，每个页码都可以点击跳到指定页。 如果总页码 优化后 123456789101112131415161718192021222324252627282930313233343536373839&lt;%--页码输出的开始--%&gt;&lt;c:choose&gt; &lt;%--情况 1：如果总页码小于等于 5 的情况，页码的范围是：1-总页码--%&gt; &lt;c:when test=&quot;$&#123; requestScope.page.pageTotal &lt;= 5 &#125;&quot;&gt; &lt;c:set var=&quot;begin&quot; value=&quot;1&quot;/&gt; &lt;c:set var=&quot;end&quot; value=&quot;$&#123;requestScope.page.pageTotal&#125;&quot;/&gt; &lt;/c:when&gt; &lt;%--情况 2：总页码大于 5 的情况--%&gt; &lt;c:when test=&quot;$&#123;requestScope.page.pageTotal &gt; 5&#125;&quot;&gt; &lt;c:choose&gt; &lt;%--小情况 1：当前页码为前面 3 个：1，2，3 的情况，页码范围是：1-5.--%&gt; &lt;c:when test=&quot;$&#123;requestScope.page.pageNo &lt;= 3&#125;&quot;&gt; &lt;%--记录begin和end--%&gt; &lt;c:set var=&quot;begin&quot; value=&quot;1&quot;/&gt; &lt;c:set var=&quot;end&quot; value=&quot;5&quot;/&gt; &lt;/c:when&gt; &lt;%--小情况 2：当前页码为最后 3 个，8，9，10，页码范围是：总页码减 4 - 总页码--%&gt; &lt;c:when test=&quot;$&#123;requestScope.page.pageNo &gt; requestScope.page.pageTotal-3&#125;&quot;&gt; &lt;%--记录begin和end--%&gt; &lt;c:set var=&quot;begin&quot; value=&quot;$&#123;requestScope.page.pageTotal-4&#125;&quot;/&gt; &lt;c:set var=&quot;end&quot; value=&quot;$&#123;requestScope.page.pageTotal&#125;&quot;/&gt; &lt;/c:when&gt; &lt;%--小情况 3：4，5，6，7，页码范围是：当前页码减 2 - 当前页码加 2--%&gt; &lt;c:otherwise&gt; &lt;c:set var=&quot;begin&quot; value=&quot;$&#123;requestScope.page.pageNo-2&#125;&quot;/&gt; &lt;c:set var=&quot;end&quot; value=&quot;$&#123;requestScope.page.pageNo+2&#125;&quot;/&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/c:when&gt;&lt;/c:choose&gt;&lt;c:forEach begin=&quot;$&#123;begin&#125;&quot; end=&quot;$&#123;end&#125;&quot; var=&quot;i&quot;&gt; &lt;c:if test=&quot;$&#123;i == requestScope.page.pageNo&#125;&quot;&gt; 【$&#123;i&#125;】 &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;i != requestScope.page.pageNo&#125;&quot;&gt; &lt;a href=&quot;manager/BookServlet?action=page&amp;pageNo=$&#123;i&#125;&quot;&gt;$&#123;i&#125;&lt;/a&gt; &lt;/c:if&gt;&lt;/c:forEach&gt;&lt;%--页码输出的结束--%&gt; &lt;c:set var=&quot;begin&quot; value=&quot;1&quot;/&gt; &lt;c:set var=&quot;end&quot; value=&quot;$&#123;requestScope.page.pageTotal&#125;&quot;/&gt; 这个是设置begin和end的value值 然后等到&lt;c:choose&gt;执行完之后再执行forEach 12345678&lt;c:forEach begin=&quot;$&#123;begin&#125;&quot; end=&quot;$&#123;end&#125;&quot; var=&quot;i&quot;&gt; &lt;c:if test=&quot;$&#123;i == requestScope.page.pageNo&#125;&quot;&gt; 【$&#123;i&#125;】 &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;i != requestScope.page.pageNo&#125;&quot;&gt; &lt;a href=&quot;manager/BookServlet?action=page&amp;pageNo=$&#123;i&#125;&quot;&gt;$&#123;i&#125;&lt;/a&gt; &lt;/c:if&gt;&lt;/c:forEach&gt; 修改分页对原来增删改的影响这个是把BookServlet中原本action&#x3D;list都改为action&#x3D;page 1resp.sendRedirect(req.getContextPath()+&quot;/manager/BookServlet?action=page&quot;); 添加图书的影响 book_manager 添加图书的时候带着pageTotal 1&lt;td&gt;&lt;a href=&quot;pages/manager/book_edit.jsp?pageNo=$&#123;requestScope.page.pageTotal&#125;&quot;&gt;添加图书&lt;/a&gt;&lt;/td&gt; book_edit 1加了这一行，来传接收到的pageNo参数 1&lt;input type=&quot;hidden&quot; name=&quot;pageNo&quot; value=&quot;$&#123;param.pageNo&#125;&quot;/&gt;; 123456&lt;form action=&quot;manager/BookServlet&quot; method=&quot;get&quot;&gt; &lt;!--通过判断是否存在参数id来绝顶value是add还是update--&gt; &lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;$&#123;empty param.id?&quot;add&quot;:&quot;update&quot;&#125;&quot;/&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;$&#123;requestScope.book.id&#125;&quot;/&gt; &lt;input type=&quot;hidden&quot; name=&quot;pageNo&quot; value=&quot;$&#123;param.pageNo&#125;&quot;/&gt;; BookServlet中的add方法 12345678910111213141516171819 protected void add(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; int pageNo=WebUtils.parseInt(req.getParameter(&quot;pageNo&quot;),0); pageNo+=1; //使用BeanUtils生成Book对象 Map parameterMap = req.getParameterMap(); Book book= WebUtils.copyParamToBean(parameterMap,new Book()); //保存图书 bookService.addBook(book); //使用这个方法是有bug的 //造成表单的重复提交，当用户提交完请求，浏览器会记录下最后一次请求的全部信息，当用户按下功能键f5，就会发起浏览器记录的最后一次请求 // req.getRequestDispatcher(&quot;/manager/BookServlet?action=list&quot;).forward(req,resp); //这里要使用重定向resp.sendRedirect(req.getContextPath()+&quot;/manager/BookServlet?action=page&amp;pageNo=&quot;+pageNo); &#125; int pageNo=WebUtils.parseInt(req.getParameter(&quot;pageNo&quot;),0); pageNo+=1; 让pageNo为最后一页的下一页（因为永远不会越界，前面有所设定） 然后重定向 1resp.sendRedirect(req.getContextPath()+&quot;/manager/BookServlet?action=page&amp;pageNo=&quot;+pageNo); 删除的影响 book_manager.jsp 带着pageNo参数 1&lt;td&gt;&lt;a class=&quot;deleteClass&quot; href=&quot;manager/BookServlet?action=delete&amp;id=$&#123;book.id&#125;&amp;pageNo=$&#123;requestScope.page.pageNo&#125;&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; BookServlet中的delete方法 带着pageNo请求BookServlet的page方法，来显示删除之后的界面 1resp.sendRedirect(req.getContextPath() + &quot;/manager/BookServlet?action=page&amp;pageNo=&quot;+req.getParameter(&quot;pageNo&quot;)); 修改的影响 修改的影响和删除的影响相同 前台分页的初步实现 所以先将index.jsp的内容复制到client下的index.jsp然后，web下的index.jsp只做一件事就是请求转发Servlet 注意这个jsp:forward和必须是在一行上，要不会报错 123&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%--只负责请求转发--%&gt;&lt;jsp:forward page=&quot;/client/ClientBookServlet?action=page&quot;&gt;&lt;/jsp:forward&gt; 然后是ClientBookServlet，请求转发到client下的index.jsp 12345678910111213141516171819202122232425262728293031package com.atguigu.web;import com.atguigu.pojo.Book;import com.atguigu.pojo.Page;import com.atguigu.service.BookService;import com.atguigu.service.impl.BookServiceImpl;import com.atguigu.utils.WebUtils;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class ClientBookServlet extends BaseServlet&#123; BookService bookService=new BookServiceImpl(); protected void page(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1。获取请求的参数，pageNo和pageSize //用户没有点击第几页，就默认显示第一页，所以第二个参数是1 System.out.println(&quot;经过了前台的Servlet程序&quot;); int pageNo= WebUtils.parseInt(req.getParameter(&quot;pageNo&quot;),1); int pageSize=WebUtils.parseInt(req.getParameter(&quot;pageSize&quot;), Page.PAGE_SIZE); //2。调用BookService.page(pageNo,pageSize):Page对象 Page&lt;Book&gt; page=bookService.page(pageNo,pageSize); //3.保存Page对象到request域中 req.setAttribute(&quot;page&quot;,page); //4.请求转发到pages/manager/book_manager.jsp req.getRequestDispatcher(&quot;/pages/client/index.jsp&quot;).forward(req,resp); &#125;&#125; client下的index.jsp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;书城首页&lt;/title&gt; &lt;!--使用静态包含引入css样式jQuery和base标签--&gt; &lt;%@ include file=&quot;/pages/common/head.jsp&quot;%&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;header&quot;&gt; &lt;img class=&quot;logo_img&quot; alt=&quot;&quot; src=&quot;/img/logo.gif&quot; &gt; &lt;span class=&quot;wel_word&quot;&gt;网上书城&lt;/span&gt; &lt;div&gt; &lt;a href=&quot;pages/user/login.jsp&quot;&gt;登录&lt;/a&gt; | &lt;a href=&quot;pages/user/regist.jsp&quot;&gt;注册&lt;/a&gt; &amp;nbsp;&amp;nbsp; &lt;a href=&quot;pages/cart/cart.jsp&quot;&gt;购物车&lt;/a&gt; &lt;a href=&quot;pages/manager/manager.jsp&quot;&gt;后台管理&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;main&quot;&gt; &lt;div id=&quot;book&quot;&gt; &lt;div class=&quot;book_cond&quot;&gt; &lt;form action=&quot;&quot; method=&quot;get&quot;&gt; 价格：&lt;input id=&quot;min&quot; type=&quot;text&quot; name=&quot;min&quot; value=&quot;&quot;&gt; 元 - &lt;input id=&quot;max&quot; type=&quot;text&quot; name=&quot;max&quot; value=&quot;&quot;&gt; 元 &lt;input type=&quot;submit&quot; value=&quot;查询&quot; /&gt; &lt;/form&gt; &lt;/div&gt; &lt;div style=&quot;text-align: center&quot;&gt; &lt;span&gt;您的购物车中有3件商品&lt;/span&gt; &lt;div&gt; 您刚刚将&lt;span style=&quot;color: red&quot;&gt;时间简史&lt;/span&gt;加入到了购物车中 &lt;/div&gt; &lt;/div&gt; &lt;c:forEach items=&quot;$&#123;requestScope.page.items&#125;&quot; var=&quot;book&quot;&gt; &lt;div class=&quot;b_list&quot;&gt; &lt;div class=&quot;img_div&quot;&gt; &lt;img class=&quot;book_img&quot; alt=&quot;&quot; src=&quot;$&#123;book.imgPath&#125;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;book_info&quot;&gt; &lt;div class=&quot;book_name&quot;&gt; &lt;span class=&quot;sp1&quot;&gt;书名:&lt;/span&gt; &lt;span class=&quot;sp2&quot;&gt;$&#123;book.name&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;book_author&quot;&gt; &lt;span class=&quot;sp1&quot;&gt;作者:&lt;/span&gt; &lt;span class=&quot;sp2&quot;&gt;$&#123;book.author&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;book_price&quot;&gt; &lt;span class=&quot;sp1&quot;&gt;价格:&lt;/span&gt; &lt;span class=&quot;sp2&quot;&gt;$&#123;book.price&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;book_sales&quot;&gt; &lt;span class=&quot;sp1&quot;&gt;销量:&lt;/span&gt; &lt;span class=&quot;sp2&quot;&gt;$&#123;book.sales&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;book_amount&quot;&gt; &lt;span class=&quot;sp1&quot;&gt;库存:&lt;/span&gt; &lt;span class=&quot;sp2&quot;&gt;$&#123;book.stock&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;book_add&quot;&gt; &lt;button&gt;加入购物车&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/c:forEach&gt; &lt;div id=&quot;page_nav&quot;&gt; &lt;%--大于首页才显示上一页按钮--%&gt; &lt;c:if test=&quot;$&#123;requestScope.page.pageNo&gt;1&#125;&quot;&gt; &lt;a href=&quot;client/ClientBookServlet?action=page&amp;pageNo=1&quot;&gt;首页&lt;/a&gt; &lt;a href=&quot;client/ClientBookServlet?action=page&amp;pageNo=$&#123;requestScope.page.pageNo-1&#125;&quot;&gt;上一页&lt;/a&gt; &lt;/c:if&gt; &lt;%--页码输出的开始--%&gt; &lt;c:choose&gt; &lt;%--情况 1：如果总页码小于等于 5 的情况，页码的范围是：1-总页码--%&gt; &lt;c:when test=&quot;$&#123; requestScope.page.pageTotal &lt;= 5 &#125;&quot;&gt; &lt;c:set var=&quot;begin&quot; value=&quot;1&quot;/&gt; &lt;c:set var=&quot;end&quot; value=&quot;$&#123;requestScope.page.pageTotal&#125;&quot;/&gt; &lt;/c:when&gt; &lt;%--情况 2：总页码大于 5 的情况--%&gt; &lt;c:when test=&quot;$&#123;requestScope.page.pageTotal &gt; 5&#125;&quot;&gt; &lt;c:choose&gt; &lt;%--小情况 1：当前页码为前面 3 个：1，2，3 的情况，页码范围是：1-5.--%&gt; &lt;c:when test=&quot;$&#123;requestScope.page.pageNo &lt;= 3&#125;&quot;&gt; &lt;%--记录begin和end--%&gt; &lt;c:set var=&quot;begin&quot; value=&quot;1&quot;/&gt; &lt;c:set var=&quot;end&quot; value=&quot;5&quot;/&gt; &lt;/c:when&gt; &lt;%--小情况 2：当前页码为最后 3 个，8，9，10，页码范围是：总页码减 4 - 总页码--%&gt; &lt;c:when test=&quot;$&#123;requestScope.page.pageNo &gt; requestScope.page.pageTotal-3&#125;&quot;&gt; &lt;%--记录begin和end--%&gt; &lt;c:set var=&quot;begin&quot; value=&quot;$&#123;requestScope.page.pageTotal-4&#125;&quot;/&gt; &lt;c:set var=&quot;end&quot; value=&quot;$&#123;requestScope.page.pageTotal&#125;&quot;/&gt; &lt;/c:when&gt; &lt;%--小情况 3：4，5，6，7，页码范围是：当前页码减 2 - 当前页码加 2--%&gt; &lt;c:otherwise&gt; &lt;c:set var=&quot;begin&quot; value=&quot;$&#123;requestScope.page.pageNo-2&#125;&quot;/&gt; &lt;c:set var=&quot;end&quot; value=&quot;$&#123;requestScope.page.pageNo+2&#125;&quot;/&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/c:when&gt; &lt;/c:choose&gt; &lt;c:forEach begin=&quot;$&#123;begin&#125;&quot; end=&quot;$&#123;end&#125;&quot; var=&quot;i&quot;&gt; &lt;c:if test=&quot;$&#123;i == requestScope.page.pageNo&#125;&quot;&gt; 【$&#123;i&#125;】 &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;i != requestScope.page.pageNo&#125;&quot;&gt; &lt;a href=&quot;client/ClientBookServlet?action=page&amp;pageNo=$&#123;i&#125;&quot;&gt;$&#123;i&#125;&lt;/a&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;%--页码输出的结束--%&gt; &lt;%--如果已经是最后一页则不显示下一页和末页--%&gt; &lt;c:if test=&quot;$&#123;requestScope.page.pageNo&lt;requestScope.page.pageTotal&#125;&quot;&gt; &lt;a href=&quot;client/ClientBookServlet?action=page&amp;pageNo=$&#123;requestScope.page.pageNo+1&#125;&quot;&gt;下一页&lt;/a&gt; &lt;a href=&quot;client/ClientBookServlet?action=page&amp;pageNo=$&#123;requestScope.page.pageTotal&#125;&quot;&gt;末页&lt;/a&gt; &lt;/c:if&gt; 共$&#123;requestScope.page.pageTotal&#125;页，$&#123;requestScope.page.pageTotalCount&#125;条记录 到第&lt;input value=&quot;$&#123;requestScope.page.pageNo&#125;&quot; name=&quot;pn&quot; id=&quot;pn_input&quot;/&gt;页 &lt;input type=&quot;button&quot; value=&quot;确定&quot;&gt; 共$&#123;requestScope.page.pageTotal&#125;页，$&#123;requestScope.page.pageTotalCount&#125;条记录 到第&lt;input value=&quot;$&#123;requestScope.page.pageNo&#125;&quot; name=&quot;pn&quot; id=&quot;pn_input&quot;/&gt;页 &lt;input type=&quot;button&quot; id=&quot;searchPageBtn&quot; value=&quot;确定&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; $(&quot;#searchPageBtn&quot;).click(function()&#123; var pageNo=$(&quot;#pn_input&quot;).val(); //javascript语言中提供了一个location地址栏 //他有一个属性叫href，它可以获取浏览器地址栏中的地址 //href属性可读可写 location.href=&quot;$&#123;pageScope.basePath&#125;client/ClientBookServlet?action=page&amp;pageNo=&quot;+pageNo; &#125;); &#125;); &lt;/script&gt; &lt;/div&gt;&lt;/div&gt;&lt;!--静态包含页脚的代码--&gt;&lt;%@include file=&quot;/pages/common/footer.jsp&quot; %&gt;&lt;/body&gt;&lt;/html&gt; 在页面遍历内容 1234567891011121314151617181920212223242526272829303132&lt;c:forEach items=&quot;$&#123;requestScope.page.items&#125;&quot; var=&quot;book&quot;&gt; &lt;div class=&quot;b_list&quot;&gt; &lt;div class=&quot;img_div&quot;&gt; &lt;img class=&quot;book_img&quot; alt=&quot;&quot; src=&quot;$&#123;book.imgPath&#125;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;book_info&quot;&gt; &lt;div class=&quot;book_name&quot;&gt; &lt;span class=&quot;sp1&quot;&gt;书名:&lt;/span&gt; &lt;span class=&quot;sp2&quot;&gt;$&#123;book.name&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;book_author&quot;&gt; &lt;span class=&quot;sp1&quot;&gt;作者:&lt;/span&gt; &lt;span class=&quot;sp2&quot;&gt;$&#123;book.author&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;book_price&quot;&gt; &lt;span class=&quot;sp1&quot;&gt;价格:&lt;/span&gt; &lt;span class=&quot;sp2&quot;&gt;$&#123;book.price&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;book_sales&quot;&gt; &lt;span class=&quot;sp1&quot;&gt;销量:&lt;/span&gt; &lt;span class=&quot;sp2&quot;&gt;$&#123;book.sales&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;book_amount&quot;&gt; &lt;span class=&quot;sp1&quot;&gt;库存:&lt;/span&gt; &lt;span class=&quot;sp2&quot;&gt;$&#123;book.stock&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;book_add&quot;&gt; &lt;button&gt;加入购物车&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/c:forEach&gt; 同时把后台的那个分页条复制到这个文件中，然后还要改一下路径 1client/ClientBookServlet?action=page&amp;pageNo=$&#123;i&#125; 分页条抽取在Page中直接添加一个url属性，代表分页条的跳转 然后在client的index.jsp中做一个替换 1&lt;a href=&quot;$&#123;requestScope.page.url&#125;&amp;pageNo=$&#123;requestScope.page.pageNo+1&#125;&quot;&gt;下一页&lt;/a&gt; BookServlet的page方法中加这是后台的分页条跳转 1page.setUrl(&quot;manager/BookServlet?action=page&quot;); ClientBookServlet中page加 这是首页的分页条跳转 1page.setUrl(&quot;client/ClientBookServlet?action=page&quot;); 这种改变之后，首页和后台的分页条都差不多可以抽取到page_nv.jsp 然后静态引入 1&lt;%@include file=&quot;/pages/common/page_nav.jsp&quot;%&gt; 价格区间搜索这个操作和前面的设置分页类似s 先对client中的index.jsp的表单进行了修改 改了提交地址，和value设置为pageByPrice 123456&lt;form action=&quot;client/ClientBookServlet&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;pageByPrice&quot;/&gt; 价格：&lt;input id=&quot;min&quot; type=&quot;text&quot; name=&quot;min&quot; value=&quot;&quot;&gt; 元 - &lt;input id=&quot;max&quot; type=&quot;text&quot; name=&quot;max&quot; value=&quot;&quot;&gt; 元 &lt;input type=&quot;submit&quot; value=&quot;查询&quot; /&gt;&lt;/form&gt; 在ClientBookServlet中创建pageByPrice方法，用了bookService的pageByPrice方法 12345678910111213141516protected void pageByPrice(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1。获取请求的参数，pageNo和pageSize //用户没有点击第几页，就默认显示第一页，所以第二个参数是1 System.out.println(100); int pageNo= WebUtils.parseInt(req.getParameter(&quot;pageNo&quot;),1); int pageSize=WebUtils.parseInt(req.getParameter(&quot;pageSize&quot;), Page.PAGE_SIZE); //获取最小价格min和最大价格max两个参数 int min=WebUtils.parseInt(req.getParameter(&quot;min&quot;),1); int max=WebUtils.parseInt(req.getParameter(&quot;max&quot;),100); Page&lt;Book&gt; page=bookService.pageByPrice(pageNo,pageSize,min,max); req.setAttribute(&quot;page&quot;,page); page.setUrl(&quot;client/ClientBookServlet?action=pageByPrice&quot;); req.getRequestDispatcher(&quot;/pages/client/index.jsp&quot;).forward(req,resp);&#125; BookService 123456789101112131415161718192021222324252627@Overridepublic Page&lt;Book&gt; pageByPrice(int pageNo, int pageSize, int min, int max) &#123; Page&lt;Book&gt; page=new Page&lt;&gt;(); //设置每页显示的数量 page.setPageSize(pageSize); //求总记录数 Integer pageTotalCount=bookDao.queryForPageTotalCountByPrice(min,max); //设置总记录数 page.setPageTotalCount(pageTotalCount); //求总页码 Integer pageTotal=pageTotalCount/pageSize; if(pageTotalCount%pageSize&gt;0)&#123; pageTotal+=1; &#125; //设置总页码 page.setPageTotal(pageTotal); //设置page对象的当前页 page.setPageNo(pageNo); //求当前页面开始的索引 int begin=(page.getPageNo()-1)*pageSize; //求当前页数据 List&lt;Book&gt; items=bookDao.queryForPageItemsByPrice(begin,pageSize,min,max); //设置当前页数据 page.setItems(items); return page;&#125; 用了BookDao中的queryForPageItemsByPrice和queryForPageTotalCountByPrice 123456789101112@Overridepublic Integer queryForPageTotalCountByPrice(int min, int max) &#123; String sql=&quot;select count(*) from t_book where price between ? and ?&quot;; Number count=(Number)queryForSingleValue(sql,min,max); return count.intValue();&#125;@Overridepublic List&lt;Book&gt; queryForPageItemsByPrice(int begin, int pageSize, int min, int max) &#123; String sql=&quot;select id,name,author,price,sales,stock,img_path imgPath from t_book where price between ? and ? limit ?,? &quot;; return queryForList(Book.class,sql,min,max,begin,pageSize);&#125; 搜索完成后显示区间范围12价格：&lt;input id=&quot;min&quot; type=&quot;text&quot; name=&quot;min&quot; value=&quot;$&#123;param.min&#125;&quot;&gt; 元 -&lt;input id=&quot;max&quot; type=&quot;text&quot; name=&quot;max&quot; value=&quot;$&#123;param.max&#125;&quot;&gt; 元 点了提交之后一直是一次请求，因为中间用的是请求转发，所以提交的min和max参数可以通过param获取 实现每个页面都能显示搜索区间 12345678StringBuilder sb=new StringBuilder(&quot;client/ClientBookServlet?action=pageByPrice&quot;);if(req.getParameter(&quot;min&quot;)!=null)&#123; sb.append(&quot;&amp;min=&quot;).append(req.getParameter(&quot;min&quot;));&#125;if(req.getParameter(&quot;max&quot;)!=null)&#123; sb.append(&quot;&amp;max=&quot;).append(req.getParameter(&quot;max&quot;));&#125;page.setUrl(sb.toString()); Cookie&amp;Session什么是Cookie 1、Cookie 翻译过来是饼干的意思。 2、Cookie 是服务器通知客户端保存键值对的一种技术。 3、客户端有了 Cookie 后，每次请求都发送给服务器。 4、每个 Cookie 大小不能超过4kb cookie的创建创建是服务器创建cookie发送给客户端 给cookie.html加上base标签 1&lt;base href=&quot;http://localhost:8079/cookie/&quot;&gt; 1&lt;li&gt;&lt;a href=&quot;CookieServlet?action=createCookie&quot; target=&quot;target&quot;&gt;Cookie的创建&lt;/a&gt;&lt;/li&gt; 给cookie创建的连接修改 CookieServlet程序 可以一次性创建多个cookie 12345678910111213141516171819202122232425package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class CookieServlet extends BaseServlet&#123; protected void createCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.创建cookie对象 Cookie cookie=new Cookie(&quot;key1&quot;,&quot;value1&quot;); //2.通知客户端保存cookie resp.addCookie(cookie); //1.创建cookie对象 Cookie cookie1=new Cookie(&quot;key2&quot;,&quot;value2&quot;); //2.通知客户端保存cookie resp.addCookie(cookie1); resp.getWriter().write(&quot;Cookie创建成功&quot;); &#125;&#125; BaseServlet 在BaseServlet的最开头加上这句代码能避免响应的中文乱码 12345//解决post请求中文乱码问题//一定要在获取请求参数之前调用才有效//req.setCharacterEncoding(&quot;UTF-8&quot;);//解决响应的中文乱码问题resp.setContentType(&quot;text/html;charset=UTF-8&quot;); 可以在下面图片中的位置看到cookie 服务器获取Cookie服务器获取客户端的 Cookie 只需要一行代码：req.getCookies():Cookie[] cookie.html 1&lt;li&gt;&lt;a href=&quot;CookieServlet?action=getCookie&quot; target=&quot;target&quot;&gt;Cookie的获取&lt;/a&gt;&lt;/li&gt; 查看请求头中的cookie 获取全部cookie的方法 12345678910111213141516171819202122232425262728 protected void getCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; Cookie[] cookies = req.getCookies(); for (Cookie cookie : cookies) &#123; //getName方法返回cookie的名称 resp.getWriter().write(&quot;Cookie[&quot;+cookie.getName()+&quot;=&quot;+cookie.getValue()+&quot;]&lt;br/&gt;&quot;); &#125;Cookie iWantCookie= CookieUtils.findCookie(&quot;key1&quot;,cookies); if(iWantCookie!=null)&#123; resp.getWriter().write(&quot;找到了需要的cookie&quot;); &#125; // for (Cookie cookie : cookies) &#123; //getName方法返回cookie的名称 // resp.getWriter().write(&quot;Cookie[&quot;+cookie.getName()+&quot;=&quot;+cookie.getValue()+&quot;]&lt;br/&gt;&quot;); // if(&quot;key1&quot;.equals(cookie.getName()))&#123; // iWantCookie=cookie; // break; // &#125; //&#125; //如果不等于null,说明附过值，也就是找到了需要的cookie // if(iWantCookie!=null)&#123; // resp.getWriter().write(&quot;找到了需要的cookie&quot;); //&#125; &#125; 封装的获取指定cookie的方法 传入要找到的cookie的名字，和全部的cookie就可以 1234567891011121314151617181920package com.atguigu.util;import javax.servlet.http.Cookie;/*查找指定名称的cookie对象 */public class CookieUtils &#123; public static Cookie findCookie(String name,Cookie[] cookies)&#123; if(name==null||cookies==null||cookies.length==0)&#123; return null; &#125; for (Cookie cookie : cookies) &#123; if(name.equals(cookie.getName()))&#123; return cookie; &#125; &#125; return null; &#125;&#125; Cookie值的修改方案一：1、先创建一个要修改的同名（指的就是 key）的 Cookie 对象 ​ 2、在构造器，同时赋于新的 Cookie 值。 ​ 3、调用 response.addCookie( Cookie ); 123456789protected void updateCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 1、先创建一个要修改的同名（指的就是 key）的 Cookie 对象 //2、在构造器，同时赋于新的 Cookie 值。 Cookie cookie=new Cookie(&quot;key1&quot;,&quot;newvalue1&quot;); // 3、调用 response.addCookie( Cookie ); resp.addCookie(cookie); resp.getWriter().write(&quot;key1的值已经修改好了&quot;);&#125; 方案二： 1、先查找到需要修改的 Cookie 对象 ​ 2、调用 setValue()方法赋于新的 Cookie 值。 ​ 3、调用 response.addCookie()通知客户端保存修改 12345678protected void updateCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1、先查找到需要修改的 Cookie 对象 Cookie cookie=CookieUtils.findCookie(&quot;key1&quot;,req.getCookies()); //2、调用 setValue()方法赋于新的 Cookie 值。 cookie.setValue(&quot;new1Value&quot;); //3、调用 response.addCookie()通知客户端保存修改 resp.addCookie(cookie);&#125; 这个value的值是不支持中文的 各种浏览器查看cookie Cookie生命周期Cookie 的生命控制指的是如何管理 Cookie 什么时候被销毁（删除） setMaxAge() 正数，表示在指定的秒数后过期 负数，表示浏览器一关，Cookie 就会被删除（默认值是-1） 零，表示马上删除 Cooki 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 默认级别的cookie会话，设置为-1是浏览器关闭才消失 * @param req * @param resp * @throws ServletException * @throws IOException */protected void defaultLife(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; Cookie cookie=new Cookie(&quot;defaultLife&quot;,&quot;defaultLife&quot;); cookie.setMaxAge(-1);//设置存活时间 resp.addCookie(cookie);&#125;/*立即删除 */protected void deleteNow(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;//先找到你要删除的cookie对象 Cookie cookie=CookieUtils.findCookie(&quot;key1&quot;,req.getCookies());//调用setMaxAge(0); if(cookie!=null)&#123; //马上删除 cookie.setMaxAge(0); &#125; //response.addCookie(cookie); resp.addCookie(cookie); resp.getWriter().write(&quot;key1的cookie已经被删除&quot;);&#125;/*指定cookie再存货一段时间 */protected void life3600(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; Cookie cookie=new Cookie(&quot;life3600&quot;,&quot;life3600&quot;); cookie.setMaxAge(60*60); resp.addCookie(cookie); resp.getWriter().write(&quot;已经创建了一个存货一小时的cookie&quot;);&#125; Cookie的Path设置Cookie 的 path 属性可以有效的过滤哪些 Cookie 可以发送给服务器。哪些不发。 path 属性是通过请求的地址来进行有效的过滤 只要能匹配cookie路径的请求地址都是可以发送的，就是cookie路径是请求地址的子串 · 1234567891011/*带路径的cookie的测试 */protected void testPath(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; Cookie cookie=new Cookie(&quot;path&quot;,&quot;path&quot;); //getContextPath()==&gt;&gt;得到工程路径 cookie.setPath(req.getContextPath()+&quot;/abc&quot;); System.out.println(req.getContextPath()+&quot;/abc&quot;); resp.addCookie(cookie); resp.getWriter().write(&quot;创建了一个带有Path路径的cookie&quot;);&#125; 访问它是不会给你pathcookie的 1http://localhost:8079/cookie/cookie.html 访问它可以给你cookie 1http://localhost:8079/cookie/abc/cookie.html 免输入用户名登录 login.jsp 1234567891011121314151617181920&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/8 Time: 16:08 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://localhost:8079/cookie/LoginServlet&quot; method=&quot;get&quot;&gt; 用户名: &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;$&#123;cookie.username.value&#125;&quot;&gt;&lt;br&gt; 密码: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234&lt;body&gt;获取cookie的名称:$&#123;cookie.JSESSIONID.name&#125;&lt;br/&gt;获取Cookie的值：$&#123;cookie.JSESSIONID.value&#125;&lt;/body&gt; JESSIONID是一个cookie的名字 LoginServlet 12345678910111213141516171819202122232425262728package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class LoginServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String username=req.getParameter(&quot;username&quot;); String password=req.getParameter(&quot;password&quot;); if(&quot;zzh&quot;.equals(username)&amp;&amp;&quot;123456&quot;.equals(password))&#123; //登陆成功 Cookie cookie=new Cookie(&quot;username&quot;,username); cookie.setMaxAge(60*60*24*7); resp.addCookie(cookie); System.out.println(&quot;登录成功&quot;); &#125; else &#123; //登陆失败 System.out.println(&quot;登陆失败&quot;); &#125; &#125;&#125; 第一次登陆成功之后 服务器发送了一个响应头中有cookie的值，cookie中保存了username 但是此时浏览器的cookie中还没有zzh&#x3D;username 第二次发起请求的时候 用户名上就有用户名 第二次请求的时候 请求头中就有cookie为username&#x3D;zzh，所以这时就是浏览器有cookie请求服务器时就会带着cookie一起 Session的创建什么是 Session 会话? 1、Session 就一个接口（HttpSession）。 2、Session 就是会话。它是用来维护一个客户端和服务器之间关联的一种技术。 3、每个客户端都有自己的一个 Session 会话。 4、Session 会话中，我们经常用来保存用户登录之后的信息。 Session是保存在服务器上 123456789101112public class SessionServlet extends BaseServlet&#123; protected void createorGetSession(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //创建和获取Session会话对象 HttpSession session=req.getSession(); //判断当前session会话，是否是新创建出来的 boolean isNew=session.isNew(); //获取Session会话的唯一标识 String id=session.getId(); resp.getWriter().write(&quot;得到的Session的id是&quot;+id+&quot;&lt;br/&gt;&quot;); resp.getWriter().write(&quot;这个Session是否是新创建的&quot;+isNew+&quot;&lt;br/&gt;&quot;); &#125; 1&lt;li&gt;&lt;a href=&quot;http://localhost:8079/cookie/SessionServlet?action=createorGetSession&quot; target=&quot;target&quot;&gt;Session的创建和获取（id号、是否为新创建）&lt;/a&gt;&lt;/li&gt; Session域中数据的存储在SessionServlet中增加的方法 12345678910111213141516/*往session域中存储数据 */protected void setAttribute(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.getSession().setAttribute(&quot;key1&quot;,&quot;value1&quot;); resp.getWriter().write(&quot;已经往session中保存了数据&quot;);&#125;/*从session域中获取数据 */protected void getAttribute(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; Object attribute=req.getSession().getAttribute(&quot;key1&quot;); resp.getWriter().write(&quot;从session域中获取的key1的值是&quot;+attribute);&#125; Session的生命周期的控制public void setMaxInactiveInterval(int interval) 设置 Session 的超时时间（以秒为单位），超过指定的时长，Session 就会被销毁。 session是基于cookie的，关闭浏览器cookie没了，session自然也就消失了 停服务器之后session也会没 值为正数的时候，设定 Session 的超时时长。 负数表示永不超时（极少使用） public int getMaxInactiveInterval()获取 Session 的超时时间 public void invalidate() 让当前 Session 会话马上超时无效。 Session 默认的超时时长是多少！ Session 默认的超时时间长为 30 分钟。 因为在 Tomcat 服务器的配置文件 web.xml中默认有以下的配置，它就表示配置了当前 Tomcat 服务器下所有的 Session 超时配置默认时长为：30 分钟 123 &lt;session-config&gt;&lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; 如果你想只修改个别 Session 的超时时长。就可以使用上面的 API。setMaxInactiveInterval(int interval)来进行单独的设 置。 session.setMaxInactiveInterval(int interval)单独设置超时时长。 当你间隔一秒二秒访问的时候这个timeout又会被重置为3 在SessionServlet中 12345678910111213141516171819202122232425262728293031 /* 获取Session的默认存在时长 */ protected void defaultLife(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取了Session的默认的超时时长 int maxInactiveInterval = req.getSession().getMaxInactiveInterval(); // resp.getWriter().write(&quot;Session的默认超时时长为&quot;+maxInactiveInterval+&quot;秒&quot;); &#125; /* 规定Session3秒之后超时 */ protected void life3(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //先获取session HttpSession session=req.getSession(); //设置当前session3秒之后消失 session.setMaxInactiveInterval(3); resp.getWriter().write(&quot;当前Session已经被设置3秒之后超时&quot;); &#125;/*让当前Session立即超时 */ protected void deleteNow(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //先获取session HttpSession session=req.getSession(); //设置当前session3秒之后消失 session.invalidate(); resp.getWriter().write(&quot;当前Session已经被设置为无效&quot;); &#125; 在Session.html中 123&lt;li&gt;&lt;a href=&quot;http://localhost:8079/cookie/SessionServlet?action=defaultLife&quot; target=&quot;target&quot;&gt;Session的默认超时及配置&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://localhost:8079/cookie/SessionServlet?action=life3&quot; target=&quot;target&quot;&gt;Session3秒超时销毁&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://localhost:8079/cookie/SessionServlet?action=deleteNow&quot; target=&quot;target&quot;&gt;Session马上销毁&lt;/a&gt;&lt;/li&gt; 浏览器合Session之间关联的内幕Session 技术，底层其实是基于 Cookie 技术来实现的。 书城项目第六阶段显示登陆的用户名UserServlet 中在sesseion中保存了用户信息 123456789//如果用户名和密码正确else&#123; //保存用户的登录信息 //因为每一个登陆成功页面都会显示名字，所以不能用request，request只有在一次请求中有效，再请求别的页面就无效了 //所以用Session req.getSession().setAttribute(&quot;user&quot;,loginUser); req.getRequestDispatcher(&quot;/pages/user/login_success.jsp&quot;).forward(req,resp);&#125; 在login_success_menu页面显示，出我登陆之后的用户名 123456&lt;div&gt; &lt;span&gt;欢迎&lt;span class=&quot;um_span&quot;&gt;$&#123;sessionScope.user.username&#125;&lt;/span&gt;光临尚硅谷书城&lt;/span&gt; &lt;a href=&quot;pages/order/order.jsp&quot;&gt;我的订单&lt;/a&gt; &lt;a href=&quot;index.jsp&quot;&gt;注销&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a href=&quot;index.jsp&quot;&gt;返回&lt;/a&gt;&lt;/div&gt; client下的index.jsp，分为登录和没登陆两种显示 12345678910111213141516171819202122232425 &lt;div&gt; &lt;%--如果用户没有注册--%&gt; &lt;c:if test=&quot;$&#123;empty sessionScope.user&#125;&quot;&gt; &lt;a href=&quot;pages/user/login.jsp&quot;&gt;登录&lt;/a&gt; | &lt;a href=&quot;pages/user/regist.jsp&quot;&gt;注册&lt;/a&gt; &lt;/c:if&gt;&amp;nbsp;&amp;nbsp; &lt;c:if test=&quot;$&#123;not empty sessionScope.user&#125;&quot;&gt; &lt;span&gt;欢迎&lt;span class=&quot;um_span&quot;&gt;$&#123;sessionScope.user.username&#125;&lt;/span&gt;光临尚硅谷书城&lt;/span&gt; &lt;a href=&quot;pages/order/order.jsp&quot;&gt;我的订单&lt;/a&gt; &lt;a href=&quot;index.jsp&quot;&gt;注销&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;/c:if&gt; &lt;a href=&quot;pages/cart/cart.jsp&quot;&gt;购物车&lt;/a&gt; &lt;a href=&quot;pages/manager/manager.jsp&quot;&gt;后台管理&lt;/a&gt; &lt;/div&gt; 注销登录1、销毁 Session 中用户登录的信息（或者销毁 Session） 2、重定向到首页（或登录页面）。 在UserServlet中添加方法 123456protected void logout(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //销毁session中的用户登录信息（或者销毁session） req.getSession().invalidate(); //重定向到首页 resp.sendRedirect(req.getContextPath());&#125; 将client的index.jsp和login_success_menu.jsp的注销都换成 1&lt;a href=&quot;UserServlet?action=logout&quot;&gt;注销&lt;/a&gt;&amp;nbsp; 表单重复提交之验证码表单重复提交有三种常见的情况： ‘ 一：提交完表单。服务器使用请求转来进行页面跳转。这个时候，用户按下功能键 F5，就会发起最后一次的请求。 造成表单重复提交问题。 解决方法：使用重定向来进行跳转 二：用户正常提交服务器，但是由于网络延迟等原因，迟迟未收到服务器的响应，这个时候，用户以为提交失败， 就会着急，然后多点了几次提交操作，也会造成表单重复提交。 三：用户正常提交服务器。服务器也没有延迟，但是提交完成后，用户回退浏览器。重新提交。也会造成表单重复 提交 RegistServlet中1.是获取Session中验证码，并删除Session的验证码 就是第一次访问regist.jsp的时候，服务器给一个验证码，保存到session域中，然后用户提交表单之后，保存Session中验证码之后，将Session域中验证码删除，然后将它和用户提交的验证码进行比较，第一次如果相同则运许，重复提交则会阻止 谷歌验证码的使用谷歌验证码 kaptcha 使用步骤如下： 1、导入谷歌验证码的 jar 包 ​ kaptcha-2.3.2.jar 2、在 web.xml 中去配置用于生成验证码的 Servlet 程序 12345678&lt;servlet&gt; &lt;servlet-name&gt;KaptchaServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.google.code.kaptcha.servlet.KaptchaServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;KaptchaServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/kaptcha.jpg&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 3、在表单中使用 img 标签去显示验证码图片并使用 123456&lt;form action=&quot;http://localhost:8080/tmp/registServlet&quot; method=&quot;get&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; &gt; &lt;br&gt; 验证码：&lt;input type=&quot;text&quot; style=&quot;width: 60px;&quot; name=&quot;code&quot;&gt; &lt;img src=&quot;http://localhost:8080/tmp/kaptcha.jpg&quot; alt=&quot;&quot; style=&quot;width: 100px; height: 28px;&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/form&gt; 4、在服务器获取谷歌生成的验证码和客户端发送过来的验证码比较使用 123456789101112131415161718192021222324252627282930313233package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import static com.google.code.kaptcha.Constants.KAPTCHA_SESSION_KEY;public class RegistServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 获取Session中的验证码 String token = (String) req.getSession().getAttribute(KAPTCHA_SESSION_KEY); // 删除 Session中的验证码 req.getSession().removeAttribute(KAPTCHA_SESSION_KEY); String code = req.getParameter(&quot;code&quot;); // 获取用户名 String username = req.getParameter(&quot;username&quot;); if (token != null &amp;&amp; token.equalsIgnoreCase(code)) &#123; System.out.println(&quot;保存到数据库：&quot; + username); resp.sendRedirect(req.getContextPath() + &quot;/ok.jsp&quot;); &#125; else &#123; System.out.println(&quot;请不要重复提交表单&quot;); &#125; &#125;&#125; 在书城中用验证码1、导入谷歌验证码的 jar 包 ​ kaptcha-2.3.2.jar 2、在 web.xml 中去配置用于生成验证码的 Servlet 程序 12345678&lt;servlet&gt; &lt;servlet-name&gt;KaptchaServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.google.code.kaptcha.servlet.KaptchaServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;KaptchaServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/kaptcha.jpg&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 3、在表单中使用 img 标签去显示验证码图片并使用 123&lt;label&gt;验证码：&lt;/label&gt;&lt;input class=&quot;itxt&quot; type=&quot;text&quot; name=&quot;code&quot; style=&quot;width: 100px;&quot; id=&quot;code&quot;/&gt;&lt;img alt=&quot;&quot; src=&quot;kaptcha.jpg&quot; style=&quot;float: right; margin-right: 40px;width:100px;height:28px &quot;&gt; 4.在服务器获取谷歌生成的验证码和客户端发送过来的验证码比较使用 修改的UserServlet中的regist方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950protected void regist(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 获取Session中的验证码 String token = (String) req.getSession().getAttribute(KAPTCHA_SESSION_KEY); // 删除 Session中的验证码 req.getSession().removeAttribute(KAPTCHA_SESSION_KEY); //1.获取请求的参数 //这个getParameter方法是通过那个属性的name得到的 String username=req.getParameter(&quot;username&quot;); String password=req.getParameter(&quot;password&quot;); String email=req.getParameter(&quot;email&quot;); String code=req.getParameter(&quot;code&quot;); //2.检查 验证码是否正确,先把验证码写死，要求为abcde if(token.equalsIgnoreCase(code)&amp;&amp;token!=null)&#123; //验证码正确 //检查用户名是否可用 if(userService.existsUsername(username))&#123; System.out.println(&quot;用户名&quot;+username+&quot;已存在&quot;); req.setAttribute(&quot;msg&quot;,&quot;用户名已存在&quot;); req.setAttribute(&quot;username&quot;,username); req.setAttribute(&quot;email&quot;,email); //跳回到注册页面 req.getRequestDispatcher(&quot;/pages/user/regist.jsp&quot;).forward(req,resp); &#125; else &#123; //可用 //调用Sercice保存到数据库 Map map=req.getParameterMap(); User user= WebUtils.copyParamToBean(map,new User()); userService.registerUser(user); //注册成功后，跳转到注册成功页面 req.getRequestDispatcher(&quot;/pages/user/regist_success.jsp&quot;).forward(req,resp); &#125; &#125;else&#123; //把回显信息保存到request域中 req.setAttribute(&quot;msg&quot;,&quot;用户验证码错误&quot;); req.setAttribute(&quot;username&quot;,username); req.setAttribute(&quot;email&quot;,email); System.out.println(&quot;验证码&quot;+code+&quot;错误&quot;); //验证码不正确 //跳回注册页面，因为还是申请服务器中文件所以/还是工程目录下的 req.getRequestDispatcher(&quot;/pages/user/regist.jsp&quot;).forward(req,resp); &#125;&#125; 验证码的切换切换指的是点击验证码，会切换一个图片 给图片添加一个单击事件，这种方法在ie和火狐浏览器只能重新生成一个 1234567891011$(function()&#123; /* 给验证码的图片绑定单击事件 */ $(&quot;#codeimg&quot;).click(function()&#123; //在事件响应的function函数中有一个this对象，是当前正在响应事件的dom对象 //src属性表示验证码img标签的 图片路径，它可读，它可写 //下面给它赋值之后，就会自动再生成一个图片 this.src=&quot;$&#123;basePath&#125;&quot;+&quot;/kaptcha.jpg&quot;; &#125;); 在重新生成验证码的路径后面加一个get传参，然后这个参数每次都不一样，所以拿时间戳作为参数是最好的选择 1234567891011$(function()&#123; /* 给验证码的图片绑定单击事件 */ $(&quot;#codeimg&quot;).click(function()&#123; //在事件响应的function函数中有一个this对象，是当前正在响应事件的dom对象 //src属性表示验证码img标签的 图片路径，它可读，它可写 //下面给它赋值之后，就会自动再生成一个图片 this.src=&quot;$&#123;basePath&#125;kaptcha.jpg?d=&quot;+new Date(); &#125;); 购物车模块 点击添加至购物车时（带着图书的id），就是先调用CartServlet中的方法（将图书转换为商品项），然后CartServlt中的方法调用Cart对象中的功能方法，然后再把Cart购物车展示 购物车商品项 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.atguigu.pojo;import java.math.BigDecimal;/*购物车的商品项 */public class CartItem &#123; private Integer id; private String name; private Integer count; public Integer getId() &#123; return id; &#125; @Override public String toString() &#123; return &quot;CartItem&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, count=&quot; + count + &quot;, price=&quot; + price + &quot;, totalPrice=&quot; + totalPrice + &#x27;&#125;&#x27;; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getCount() &#123; return count; &#125; public void setCount(Integer count) &#123; this.count = count; &#125; public BigDecimal getPrice() &#123; return price; &#125; public void setPrice(BigDecimal price) &#123; this.price = price; &#125; public BigDecimal getTotalPrice() &#123; return totalPrice; &#125; public void setTotalPrice(BigDecimal totalPrice) &#123; this.totalPrice = totalPrice; &#125; public CartItem(Integer id, String name, Integer count, BigDecimal price, BigDecimal totalPrice) &#123; this.id = id; this.name = name; this.count = count; this.price = price; this.totalPrice = totalPrice; &#125; private BigDecimal price; private BigDecimal totalPrice; public CartItem() &#123; &#125;&#125; 购物车对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.atguigu.pojo;import java.math.BigDecimal;import java.util.ArrayList;import java.util.List;public class Cart &#123; public Integer getTotalCount() &#123; return totalCount; &#125; @Override public String toString() &#123; return &quot;Cart&#123;&quot; + &quot;totalCount=&quot; + totalCount + &quot;, totalPrice=&quot; + totalPrice + &quot;, items=&quot; + items + &#x27;&#125;&#x27;; &#125; public void setTotalCount(Integer totalCount) &#123; this.totalCount = totalCount; &#125; public BigDecimal getTotalPrice() &#123; return totalPrice; &#125; public void setTotalPrice(BigDecimal totalPrice) &#123; this.totalPrice = totalPrice; &#125; public List&lt;CartItem&gt; getItems() &#123; return items; &#125; public void setItems(List&lt;CartItem&gt; items) &#123; this.items = items; &#125; private Integer totalCount; private BigDecimal totalPrice; private List&lt;CartItem&gt; items=new ArrayList&lt;CartItem&gt;(); &#125; 购物车的功能方法Cart 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package com.atguigu.pojo;import com.sun.javafx.collections.MappingChange;import java.math.BigDecimal;import java.util.ArrayList;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;public class Cart &#123; private Integer totalCount; private BigDecimal totalPrice; public Integer getTotalCount() &#123; totalCount=0; for(Map.Entry&lt;Integer,CartItem&gt; entry : items.entrySet())&#123; totalCount+=entry.getValue().getCount(); &#125; return totalCount; &#125; @Override public String toString() &#123; return &quot;Cart&#123;&quot; + &quot;totalCount=&quot; + getTotalCount() + &quot;, totalPrice=&quot; + getTotalPrice() + &quot;, items=&quot; + items + &#x27;&#125;&#x27;; &#125; public BigDecimal getTotalPrice() &#123; totalPrice=new BigDecimal(0); for(Map.Entry&lt;Integer,CartItem&gt; entry : items.entrySet())&#123; totalPrice=totalPrice.add(entry.getValue().getTotalPrice()); &#125; return totalPrice; &#125; public Map&lt;Integer, CartItem&gt; getItems() &#123; return items; &#125; public void setItems(Map&lt;Integer, CartItem&gt; items) &#123; this.items = items; &#125; /* Map类型，key是商品编号，value是商品信息 */ private Map&lt;Integer,CartItem&gt; items=new LinkedHashMap&lt;Integer,CartItem&gt;(); /* 添加商品项 */ public void addItem(CartItem carItem)&#123; //先看商品中是否已经添加过此商品，如果已经添加，则数量累加，总金额更新，如果没有添加过，直接放到集合中即可 CartItem item = items.get(carItem.getId()); if(item==null)&#123; //如果之前没有添加过,则直接添加 items.put(carItem.getId(),carItem); &#125; else &#123; //之前添加过 //数量累加 item.setCount(item.getCount()+1); //两个BigDecimal之间才能相乘，所以把count改为BigDecimal类型的 item.setTotalPrice(item.getPrice().multiply(new BigDecimal(item.getCount()))); &#125; &#125; /* 删除商品项 */ public void deleteItem(Integer id)&#123; items.remove(id); &#125; /* 清空购物车 */ public void clear()&#123;items.clear(); &#125; /* 修改商品数量 */ public void updateCount(Integer id,Integer count)&#123; //先查看购物车中是否有此商品，如果有，就修改商品数量，更新总金额 CartItem item=items.get(id); if(item!=null)&#123; item.setCount(count); item.setTotalPrice(item.getPrice().multiply(new BigDecimal(item.getCount()))); &#125; &#125;&#125; 添加商品到购物车使用请求转发是在request域中存储东西的时候用的 CartServlet中加一个方法 1234567891011121314151617181920212223242526272829303132private BookService bookService=new BookServiceImpl();/*加入购物车 */protected void addItem(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求的参数，商品编号 int id= WebUtils.parseInt(req.getParameter(&quot;id&quot;),0); //调用bookService.queryBookById(id):得到Book的信息 Book book = bookService.queryBookById(id); //把图书信息转化成为CartItem商品项 CartItem cartItem=new CartItem(book.getId(),book.getName(),1,book.getPrice(),book.getPrice()); /* 用session存储cart信息 */ Cart cart = (Cart) req.getSession().getAttribute(&quot;cart&quot;); if(cart==null)&#123; cart=new Cart(); req.getSession().setAttribute(&quot;cart&quot;,cart); &#125; //调用Cart.addItem(CartItem)添加商品项 cart.addItem(cartItem); System.out.println(cart); //重定向回商品列表页面 /* req.getHeader(&quot;Referer&quot;)获取请求服务器的地址，然后下面再跳回到这个地址 */ resp.sendRedirect(req.getHeader(&quot;Referer&quot;));&#125; client中的index.jsp 1&lt;button bookId=$&#123;book.id&#125; class=&quot;addToCart&quot;&gt;加入购物车&lt;/button&gt; 给加入购物车加一个bookId属性，用来保存要加入购物车的书的id 那加入购物车的点击的事件 12345678910111213141516171819&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; $(&quot;button.addToCart&quot;).click(function()&#123; /** * 在事件响应的function函数中有一个this对象，就是是当前正在响应事件的dom对象，就是那个标签的dom对象， * @type &#123;*|jQuery&#125; */ /* 先把this改为jQery对象然后获取属性值 */ var bookId=$(this).attr(&quot;bookId&quot;); //跳转到 location.href=&quot;http://localhost:8087/book2/CartServlet?action=addItem&amp;id=&quot;+bookId; &#125;); &#125;);&lt;/script&gt; 这个图意思就是点击加入购物车的时候，返回的地址是不一样的 但是可以通过Referer获取请求发起时，浏览器地址栏中的地址发给服务器，然后获取这个地址之后，再跳转回去 1req.getHeader(&quot;Referer&quot;) 购物车展示cart.jsp是购物车界面 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;购物车&lt;/title&gt; &lt;!--使用静态包含引入css样式jQuery和base标签--&gt; &lt;%@ include file=&quot;/pages/common/head.jsp&quot;%&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;header&quot;&gt; &lt;img class=&quot;logo_img&quot; alt=&quot;&quot; src=&quot;static/img/logo.gif&quot; &gt; &lt;span class=&quot;wel_word&quot;&gt;购物车&lt;/span&gt; &lt;!--静态包含jsp文件--&gt; &lt;%@ include file=&quot;/pages/common/login_success_menu.jsp&quot;%&gt; &lt;/div&gt; &lt;div id=&quot;main&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td&gt;数量&lt;/td&gt; &lt;td&gt;单价&lt;/td&gt; &lt;td&gt;金额&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;%--空的时候输出--%&gt; &lt;c:if test=&quot;$&#123;empty sessionScope.cart.items&#125;&quot;&gt; &lt;tr&gt; &lt;td colspan=&quot;5&quot;&gt;&lt;a href=&quot;index.jsp&quot;&gt;亲，当前购物车为空快去浏览商品吧&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:if&gt; &lt;%--非空的时候输出--%&gt; &lt;c:if test=&quot;$&#123;not empty sessionScope.cart.items&#125;&quot;&gt; &lt;c:forEach items=&quot;$&#123;sessionScope.cart.items&#125;&quot; var=&quot;entry&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;entry.value.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;entry.value.count&#125;&lt;/td&gt; &lt;td&gt;$&#123;entry.value.price&#125;&lt;/td&gt; &lt;td&gt;$&#123;entry.value.totalPrice&#125;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;#&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/c:if&gt; &lt;/table&gt; &lt;%--如果购物车是非空才输出下面的内容--%&gt; &lt;c:if test=&quot;$&#123;not empty sessionScope.cart.items&#125;&quot;&gt; &lt;div class=&quot;cart_info&quot;&gt; &lt;span class=&quot;cart_span&quot;&gt;购物车中共有&lt;span class=&quot;b_count&quot;&gt;$&#123;sessionScope.cart.totalCount&#125;&lt;/span&gt;件商品&lt;/span&gt; &lt;span class=&quot;cart_span&quot;&gt;总金额&lt;span class=&quot;b_price&quot;&gt;$&#123;sessionScope.cart.totalPrice&#125;&lt;/span&gt;元&lt;/span&gt; &lt;span class=&quot;cart_span&quot;&gt;&lt;a href=&quot;#&quot;&gt;清空购物车&lt;/a&gt;&lt;/span&gt; &lt;span class=&quot;cart_span&quot;&gt;&lt;a href=&quot;pages/cart/checkout.jsp&quot;&gt;去结账&lt;/a&gt;&lt;/span&gt; &lt;/div&gt; &lt;/c:if&gt; &lt;/div&gt; &lt;!--静态包含页脚的代码--&gt; &lt;%@include file=&quot;/pages/common/footer.jsp&quot; %&gt;&lt;/body&gt;&lt;/html&gt; 1$&#123;entry.value.name&#125; 这个entry应该是Map.Entry对象，所以可以用entry.value取得value的值 删除购物车中的商品改删除的这个链接 1&lt;td&gt;&lt;a href=&quot;CartServlet?action=deleteItem&amp;id=$&#123;entry.value.id&#125;&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; 给链接加一个单击事件 1234567891011&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; //给删除绑定一个单击事件 $(&quot;a.deleteItem&quot;).click(function()&#123; //返回true是单击事件发生，返回false是单击事件不发生 return confirm(&quot;你确定要删除&quot;+$(this).parent().parent().find(&quot;td:first&quot;).text()+&quot;】吗&quot;); &#125;); &#125;);&lt;/script&gt; 给a标签绑定单击事件，如果返回false就不会跳转了 confirm是崩出一个确认的弹框，有true和false两个选项，点true就返回true，点false就返回false 在js中return false的作用一般是用来取消默认动作的。比如你单击一个链接除了触发你（指定的）的onclick事件以外还要触发一个默认事件就是执行页面的跳转。所以如果你想取消对象的默认动作就可以return false。 比如表单的提交，如果有一个单击事件返回false，那么会阻止表单提交 CartServlet中添加一个方法 123456789101112protected void deleteItem(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求的参数，商品编号 int id= WebUtils.parseInt(req.getParameter(&quot;id&quot;),0); Cart cart = (Cart) req.getSession().getAttribute(&quot;cart&quot;); if(cart!=null)&#123; //删除 了购物车商品项 cart.deleteItem(id); &#125; //重定向到请求的那个地址 resp.sendRedirect(req.getHeader(&quot;Referer&quot;));&#125; 清空购物车的实现CartServlet中加一个clear()方法 123456789protected void clear(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.获取购物车对象 Cart cart = (Cart)req.getSession().getAttribute(&quot;cart&quot;); if(cart!=null)&#123; cart.clear(); //重定向会原来购物车展示的页面 resp.sendRedirect(req.getHeader(&quot;Referer&quot;)); &#125;&#125; 清空购物车选项改一下链接 1&lt;span class=&quot;cart_span&quot;&gt;&lt;a class=&quot;deleteAll&quot; href=&quot;CartServlet?action=clear&quot;&gt;清空购物车&lt;/a&gt;&lt;/span&gt; 给清空购物车定义一个单击事件，用来确认是否全部删除 1234567891011121314151617&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; //给删除绑定一个单击事件 $(&quot;a.deleteItem&quot;).click(function()&#123; //返回true是单击事件发生，返回false是单击事件不发生 return confirm(&quot;你确定要删除&quot;+$(this).parent().parent().find(&quot;td:first&quot;).text()+&quot;】吗&quot;); &#125;); //给清空购物车邦单击事件 $(&quot;a.deleteAll&quot;).click(function()&#123; return confirm(&quot;你确定要删除全部的图书么&quot;); &#125;); &#125;);&lt;/script&gt; 修改购物车商品数量CartServlet中添加一个方法 1234567891011121314protected void updateCount(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求的参数，商品编号，商品数量 int id=WebUtils.parseInt(req.getParameter(&quot;id&quot;),0); int count=WebUtils.parseInt(req.getParameter(&quot;count&quot;),1); //获取购物车对象 Cart cart=(Cart)req.getSession().getAttribute(&quot;cart&quot;); //修改商品数量 if(cart!=null) &#123; cart.updateCount(id, count); //重定向会原来购物车展示的页面 resp.sendRedirect(req.getHeader(&quot;Referer&quot;)); &#125;&#125; cart.jsp中给输入框加一个内容改变事件 获得count是图书数量要改变成得值，num是书的名字，id是那本书的id，然后带着count和id访问CartServlet 1234567891011121314$(&quot;.updateCount&quot;).change(function()&#123; var num=$(this).parent().parent().find(&quot;td:first&quot;).text(); var count=this.value; var id=$(this).attr(&#x27;bookId&#x27;); if( confirm(&quot;你确定要将这本【&quot;+num+&quot;】的数量改编为【&quot;+count+&quot;】&quot;))&#123; //发起请求给服务器保存修改 location.href=&quot;http://localhost:8087/book2/CartServlet? action=updateCount&amp;count=&quot;+count+&quot;&amp;id=&quot;+id; &#125; else &#123; //this.defaultValue它是表单项dom对象的属性，它表示默认的value属性值 this.value=this.defaultValue; &#125;&#125;); 把书的数量那里变一个输入框 bookId记录要改得书的id，value是书的数量要改成的值 12345678910111213&lt;c:forEach items=&quot;$&#123;sessionScope.cart.items&#125;&quot; var=&quot;entry&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;entry.value.name&#125;&lt;/td&gt; &lt;td&gt; &lt;input class=&quot;updateCount&quot; style=&quot;width: 80px;&quot; bookId=&quot;$&#123;entry.value.id&#125;&quot; type=&quot;text&quot; value=&quot;$&#123;entry.value.count&#125;&quot;&gt; &lt;/td&gt; &lt;td&gt;$&#123;entry.value.price&#125;&lt;/td&gt; &lt;td&gt;$&#123;entry.value.totalPrice&#125;&lt;/td&gt; &lt;td&gt;&lt;a class=&quot;deleteItem&quot; href=&quot;CartServlet?action=deleteItem&amp;id=$&#123;entry.value.id&#125;&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; 首页购物车数据展示再CartServlet中的addItem方法添加这一行，来存储最新的加入购物车书的名称 1req.getSession().setAttribute(&quot;lastName&quot;,cartItem.getName()); 分为购物车为空和购物车不为空 123456789101112131415161718&lt;c:if test=&quot;$&#123;empty sessionScope.cart.items&#125;&quot;&gt; &lt;%--购物车为空的输出--%&gt; &lt;span&gt;&lt;/span&gt; &lt;div&gt; &lt;span style=&quot;color: red&quot;&gt;当前购物车为空&lt;/span&gt; &lt;/div&gt;&lt;/c:if&gt;&lt;c:if test=&quot;$&#123;not empty sessionScope.cart.items&#125;&quot;&gt; &lt;%--购物车不为空的输出--%&gt; &lt;span&gt;您的购物车中有$&#123;sessionScope.cart.totalCount&#125;件商品&lt;/span&gt; &lt;div&gt; &lt;%--这是用来获取session中存储的最后添加的书的名字--%&gt; 您刚刚将&lt;span style=&quot;color: red&quot;&gt;$&#123;sessionScope.lastName&#125;&lt;/span&gt;加入到了购物车中 &lt;/div&gt;&lt;/c:if&gt; 书城项目第七阶段订单模块的分析 订单项是订单的物品的详细信息，一个购物车属于是一个订单 创建数据库表123456789101112131415161718 use book; create table t_order(`order_id` varchar(50) primary key,`create_time` datetime, `price` decimal(11,2),`status` int, `user_id` int, foreign key(`user_id`) references t_user(`id`) ); create table t_order_item(`id` int primary key auto_increment,`name` varchar(100),`count` int, `price` decimal(11,2),`total_price` decimal(11,2),`order_id` varchar(50), foreign key(`order_id`) references t_order(`order_id`) ); foreign key(order_id) references t_order(order_id)建立外键 编写订单两个模块的数据模型Order 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.atguigu.pojo;import java.math.BigDecimal;import java.util.Date;public class Order &#123; private String orderId; private Date createTime; public String getOrderId() &#123; return orderId; &#125; public void setOrderId(String orderId) &#123; this.orderId = orderId; &#125; @Override public String toString() &#123; return &quot;Order&#123;&quot; + &quot;orderId=&#x27;&quot; + orderId + &#x27;\\&#x27;&#x27; + &quot;, createTime=&quot; + createTime + &quot;, price=&quot; + price + &quot;, status=&quot; + status + &quot;, userId=&quot; + userId + &#x27;&#125;&#x27;; &#125; public Order() &#123; &#125; public Date getCreateTime() &#123; return createTime; &#125; public void setCreateTime(Date createTime) &#123; this.createTime = createTime; &#125; public BigDecimal getPrice() &#123; return price; &#125; public void setPrice(BigDecimal price) &#123; this.price = price; &#125; public Integer getStatus() &#123; return status; &#125; public void setStatus(Integer status) &#123; this.status = status; &#125; public Integer getUserId() &#123; return userId; &#125; public void setUserId(Integer userId) &#123; this.userId = userId; &#125; private BigDecimal price; //0未发货，1已发货，2表示以签收 private Integer status=0; private Integer userId;&#125; OrderItem 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.atguigu.pojo;import java.math.BigDecimal;public class OrderItem &#123;private Integer id;private String name; public OrderItem() &#123; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getCount() &#123; return count; &#125; public void setCount(Integer count) &#123; this.count = count; &#125; public BigDecimal getPrice() &#123; return price; &#125; public void setPrice(BigDecimal price) &#123; this.price = price; &#125; public String getOrderId() &#123; return orderId; &#125; public void setOrderId(String orderId) &#123; this.orderId = orderId; &#125; @Override public String toString() &#123; return &quot;OrderItem&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, count=&quot; + count + &quot;, price=&quot; + price + &quot;, orderId=&#x27;&quot; + orderId + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public OrderItem(Integer id, String name, Integer count, BigDecimal price, String orderId) &#123; this.id = id; this.name = name; this.count = count; this.price = price; this.orderId = orderId; &#125; private Integer count;private BigDecimal price;private String orderId;&#125; 编写DaoOrderDao 12345678910111213141516package com.atguigu.dao;import com.atguigu.pojo.Order;import java.util.List;public interface OrderDao &#123; //保存订单 public int saveOrder(Order order); //查询全部订单 public List&lt;Order&gt; queryOrders(); //改变订单状态 public int changeStatus(int orderId, int status); //根据用户id查找订单 public List&lt;Order&gt; queryOrdersByUserId(int userId);&#125; OrderDaoImpl 12345678910111213141516171819202122232425262728293031323334353637package com.atguigu.dao.impl;import com.atguigu.dao.OrderDao;import com.atguigu.pojo.Order;import java.util.List;public class OrderDaoImpl extends BaseDao implements OrderDao &#123; @Override public int saveOrder(Order order) &#123; String sql=&quot;insert into t_order(order_id,create_time,price,status,user_id) values(?,?,?,?,?)&quot;; return update(sql,order.getOrderId(),order.getCreateTime(),order.getPrice(),order.getStatus(),order.getUserId()); &#125; @Override public List&lt;Order&gt; queryOrders() &#123; String sql=&quot;select order_id orderId,create_time createTime,price,status,user_Id userId from t_order&quot;; return queryForList(Order.class,sql); &#125; @Override public int changeStatus(int orderId, int status) &#123; String sql=&quot;update t_order set status=? where order_id=?&quot;; return update(sql,status,orderId); &#125; @Override public List&lt;Order&gt; queryOrdersByUserId(int userId) &#123; String sql=&quot;select order_id orderId,create_time createTime,price,status,user_id userId from t_order where user_id=?&quot;; return queryForList(Order.class,sql,userId); &#125;&#125; 在使用queryForList和queryForOne来获得javaBean对象的时候，这个javaBean类中属性的名字必须和select后面的列名相同，或者是起名让他相同 sql的update语句完全可以只改变一两个属性 OrderItemDao 1234567891011121314package com.atguigu.dao;import com.atguigu.pojo.OrderItem;public interface OrderItemDao &#123; /* 保存订单项 */ public int saveOrderItem(OrderItem orderItem); /* 根据订单号查询订单明细 */ public OrderItem queryOrderItemsByOrderId(int orderId);&#125; OrderItemDaoImpl 12345678910111213141516171819202122package com.atguigu.dao.impl;import com.atguigu.dao.OrderItemDao;import com.atguigu.pojo.OrderItem;public class OrderItemDaoImpl extends BaseDao implements OrderItemDao &#123; @Override public int saveOrderItem(OrderItem orderItem) &#123; String sql=&quot;insert into t_order_item(name,count,price,total_price,order_id) values(?,?,?,?,?)&quot;; return update(sql,orderItem.getName(),orderItem.getCount(),orderItem.getPrice(),orderItem.getTotalPrice(),orderItem.getOrderId()); &#125; @Override public OrderItem queryOrderItemsByOrderId(int orderId) &#123; String sql=&quot;select id,name,count,price,total_price totalPrice,order_id orderId from t_order_item where order_id=?&quot;; return queryForOne(OrderItem.class,sql,orderId); &#125;&#125; Service的编写OrderService 123456789101112package com.atguigu.service;import com.atguigu.pojo.Cart;public interface OrderService &#123; public String createOrder(Cart cart, int userId); public void showAllOrders(); public void sendOrder(int orderId); public void showOrderDetail(int orderId); public void showMyOrders(int userId); public void receiveOrder(int orderId);&#125; OrderServiceImpl 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.atguigu.service.impl;import com.atguigu.dao.impl.OrderDaoImpl;import com.atguigu.dao.impl.OrderItemDaoImpl;import com.atguigu.pojo.Cart;import com.atguigu.pojo.CartItem;import com.atguigu.pojo.Order;import com.atguigu.pojo.OrderItem;import com.atguigu.service.OrderService;import java.util.List;import java.util.Map;import java.util.Date;public class OrderServiceImpl implements OrderService &#123; private OrderDaoImpl orderDao=new OrderDaoImpl(); private OrderItemDaoImpl orderItemDao=new OrderItemDaoImpl(); @Override public String createOrder(Cart cart, int userId) &#123; //订单号，唯一性 用时间戳加userId保证唯一性 String orderId=System.currentTimeMillis()+&quot;&quot;+userId; //创建一个订单对象 Order order=new Order(orderId,new Date(),cart.getTotalPrice(),0,userId); //保存订单 orderDao.saveOrder(order); //遍历购物车中每一个商品转换成为订单项保存到数据库 for(Map.Entry&lt;Integer, CartItem&gt;entry:cart.getItems().entrySet())&#123; //获取每一个购物车中的商品项 CartItem cartItem=entry.getValue(); //然后转化为每一个订单项 OrderItem orderItem=new OrderItem(null,cartItem.getName(),cartItem.getTotalPrice(),cart.getTotalCount(),cartItem.getPrice(),orderId); //保存到数据库 orderItemDao.saveOrderItem(orderItem); &#125; //清空购物车 cart.clear(); return orderId; &#125; @Override public void showAllOrders() &#123; List&lt;Order&gt; orders = orderDao.queryOrders(); for (Order order : orders) &#123; System.out.println(order); &#125; &#125; @Override public void sendOrder(int orderId) &#123;orderDao.changeStatus(orderId,1); &#125; @Override public void showOrderDetail(int orderId) &#123; OrderItem orderItem = orderItemDao.queryOrderItemsByOrderId(orderId); System.out.println(orderItem); &#125; @Override public void showMyOrders(int userId) &#123; List&lt;Order&gt; orders = orderDao.queryOrdersByUserId(userId); for (Order order : orders) &#123; System.out.println(order); &#125; &#125; @Override public void receiveOrder(int orderId) &#123;orderDao.changeStatus(orderId,2); &#125;&#125; 结账功能实现改一下Service中的createOrder方法 实现结账后同时更新库存和销量 123456789101112131415161718192021222324252627@Overridepublic String createOrder(Cart cart, int userId) &#123; //订单号，唯一性 用时间戳加userId保证唯一性 String orderId=System.currentTimeMillis()+&quot;&quot;+userId; //创建一个订单对象 Order order=new Order(orderId,new Date(),cart.getTotalPrice(),0,userId); //保存订单 orderDao.saveOrder(order); //遍历购物车中每一个商品转换成为订单项保存到数据库 for(Map.Entry&lt;Integer, CartItem&gt;entry:cart.getItems().entrySet())&#123; //获取每一个购物车中的商品项 CartItem cartItem=entry.getValue(); //然后转化为每一个订单项 OrderItem orderItem=new OrderItem(null,cartItem.getName(),cartItem.getTotalPrice(),cart.getTotalCount(),cartItem.getPrice(),orderId); //保存到数据库 orderItemDao.saveOrderItem(orderItem); //更新库存和销量 Book book=bookDao.queryBookById(cartItem.getId()); book.setSales(book.getSales()+cartItem.getCount()); book.setStock(book.getStock()-cartItem.getCount()); &#125; //清空购物车 cart.clear(); return orderId;&#125; OrderServlet 123456789101112131415161718192021222324252627282930313233343536373839package com.atguigu.web;import com.atguigu.pojo.Cart;import com.atguigu.pojo.User;import com.atguigu.service.OrderService;import com.atguigu.service.impl.OrderServiceImpl;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class OrderServlet extends BaseServlet&#123; private OrderService orderService=new OrderServiceImpl(); /* 生成订单 */ protected void createOrder(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //先获取Cart购物车对象 Cart cart=(Cart)req.getSession().getAttribute(&quot;cart&quot;); //获取Userid User loginUser=(User)req.getSession().getAttribute(&quot;user&quot;); //如果没有注册就去注册一下 if(loginUser==null)&#123; req.getRequestDispatcher(&quot;/pages/user/login.jsp&quot;).forward(req,resp); &#125; Integer userId=loginUser.getId(); //调用orderService.createOrder(Cart,Userid) //得到获得的订单号 String orderId=orderService.createOrder(cart,userId); //将订单号保存在session域中 req.getSession().setAttribute(&quot;orderId&quot;,orderId); //请求转发 resp.sendRedirect(req.getContextPath()+&quot;/pages/cart/checkout.jsp&quot;); return; &#125;&#125; checkout.jsp 显示订单的号 1&lt;h1&gt;你的订单已结算，订单号为$&#123;sessionScope.orderId&#125;&lt;/h1&gt; cart.jsp 改去结账的链接 1&lt;span class=&quot;cart_span&quot;&gt;&lt;a href=&quot;OrderServlet?action=createOrder&quot;&gt;去结账&lt;/a&gt;&lt;/span&gt; 一开始一直不行，经过我的不断测试发现其实userId是空的，然后看到UserServlet中的保存user的时候，保存的是没有id的 于是对这个保存id的操作修改，用userDao从数据库中找到了有id的user，保存到session域中 12//用Dao找到那个有id的User而不是用loginUser这个没id的User User user=userDao.queryByUsername(username); UserServlet 1234567891011121314151617181920212223242526 private UserService userService=new UserServiceImpl(); private UserDao userDao=new UserDaoImpl(); protected void login(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;//获取用户名和密码参数 String username=req.getParameter(&quot;username&quot;); String password=req.getParameter(&quot;password&quot;); User loginUser=new User(null,username,password,null); //如果用户名或密码错误 if(userService.login(loginUser)==null)&#123; //把错误信息，和回显的表单项信息，保存到request域中 req.setAttribute(&quot;msg&quot;,&quot;用户名或者密码错误&quot;); req.setAttribute(&quot;username&quot;,username); req.getRequestDispatcher(&quot;/pages/user/login.jsp&quot;).forward(req,resp); &#125; //如果用户名和密码正确 else &#123; //用Dao找到那个有id的User而不是用loginUser这个没id的User User user=userDao.queryByUsername(username); //保存用户的登录信息 //因为每一个登陆成功页面都会显示名字，所以不能用request，request只有在一次请求中有效，再请求别的页面就无效了 //所以用Session req.getSession().setAttribute(&quot;user&quot;,user); req.getRequestDispatcher(&quot;/pages/user/login_success.jsp&quot;).forward(req,resp); &#125; &#125; Filter过滤器1、Filter 过滤器它是 JavaWeb 的三大组件之一。三大组件分别是：Servlet 程序、Listener 监听器、Filter 过滤器 2、Filter 过滤器它是 JavaEE 的规范。也就是接口 3、Filter 过滤器它的作用是：拦截请求，过滤响应。 拦截请求常见的应用场景有： 1、权限检查 2、日记操作 3、事务管理 ……等等 Filter初体验要求：在你的 web 工程下，有一个 admin 目录。这个 admin 目录下的所有资源（html 页面、jpg 图片、jsp 文件、等等）都必 须是用户登录之后才允许访问。 思考：根据之前我们学过内容。我们知道，用户登录之后都会把用户登录的信息保存到 Session 域中。所以要检查用户是否 登录，可以判断 Session 中否包含有用户登录的信息即可！！！ 实现一 如果用户没有用户名，也就是没登录，跳转到登录页面 局限：只有jsp文件才有 12345678&lt;% Object user=session.getAttribute(&quot;user&quot;); //如果等于null，说明还没有登陆 if(user==null)&#123; request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request,response); return; &#125;%&gt; 用Filter实现这个功能 AdminFilter实现Filter 1234567891011121314151617181920212223242526272829303132333435363738394041package com.atguigu.filter;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;import java.io.IOException;public class AdminFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; /* doFilter方法，专门用于拦截请求，可以做权限检查 */ @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;foFilter&quot;); //获取Session HttpServletRequest httpServletRequest=(HttpServletRequest) servletRequest; HttpSession session=httpServletRequest.getSession(); Object user=session.getAttribute(&quot;user&quot;); //如果等于null，说明还没有登陆 if(user==null)&#123; servletRequest.getRequestDispatcher(&quot;/login.jsp&quot;).forward(servletRequest,servletResponse); return; &#125; else &#123; //让程序继续往下访问用户的目标资源 filterChain.doFilter(servletRequest,servletResponse); &#125; &#125; @Override public void destroy() &#123; &#125;&#125; web.xml 123456789101112131415161718192021222324 &lt;!--filter标签用于配置一个Filter过滤器--&gt; &lt;filter&gt; &lt;!--给filter起一个别名--&gt; &lt;filter-name&gt; AdminFilter &lt;/filter-name&gt; &lt;!--配置filter全类名--&gt; &lt;filter-class&gt; com.atguigu.filter.AdminFilter &lt;/filter-class&gt; &lt;/filter&gt; &lt;!--filter-mapping配置Filter过滤器的拦截路径--&gt; &lt;filter-mapping&gt; &lt;!--filter-name表示当前的拦截路径给哪个filter使用--&gt; &lt;filter-name&gt;AdminFilter &lt;/filter-name&gt; &lt;!--url-pattern配置拦截路径 /admin/* 表示请求地址为web目录下admin下的全部 --&gt; &lt;url-pattern&gt; /admin/* &lt;/url-pattern&gt; &lt;/filter-mapping&gt; a.sjp 123456789101112131415161718192021222324&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/10 Time: 19:58 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% System.out.println(&quot;a.jsp页面执行了&quot;); Object user=session.getAttribute(&quot;user&quot;); //如果等于null，说明还没有登陆 if(user==null)&#123; request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request,response); return; &#125;%&gt;&lt;/body&gt;&lt;/html&gt; 12[Title](http://localhost:8080/Filter/admin/a.jsp)访问这个的时候会访问不到，被Filter拦截，跳到login.jsp 完整的用户登录和权限检查Filter 过滤器的使用步骤： 1、编写一个类去实现 Filter 接口 2、实现过滤方法 doFilter() 3、到 web.xml 中去配置 Filter 的拦截路径 login.jsp 123456789101112131415161718192021&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/10 Time: 20:08 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://localhost:8080/Filter/loginServlet&quot; method=&quot;get&quot;&gt; 用户名 &lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br&gt; 密码 &lt;input tyep=&quot;password&quot; name=&quot;password&quot;/&gt;&lt;br&gt; &lt;input type=&quot;submit&quot;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; LoginServlet 123456789101112131415161718192021222324252627package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class LoginServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //解决相应乱码问题 resp.setContentType(&quot;text/html;charset=UTF-8&quot;); String username=req.getParameter(&quot;username&quot;); String password=req.getParameter(&quot;password&quot;); if(&quot;wzg168&quot;.equals(username)&amp;&amp;&quot;123456&quot;.equals(password))&#123; req.getSession().setAttribute(&quot;user&quot;,username); resp.getWriter().write(&quot;登陆成功&quot;); &#125; else &#123; req.getRequestDispatcher(&quot;/login.jsp&quot;).forward(req,resp); &#125; &#125;&#125; 登录之后就可以访问admin下面的内容了 Filter的生命周期 FilterConfig类FilterConfig 类见名知义，它是 Filter 过滤器的配置文件类。 Tomcat 每次创建 Filter 的时候，也会同时创建一个 FilterConfig 类，这里包含了 Filter 配置文件的配置信息 FilterConfig 类的作用是获取 filter 过滤器的配置内容 1、获取 Filter 的名称 filter-name 的内容 2、获取在 Filter 中配置的 init-param 初始化参数 3、获取 ServletContext 对象 测试FilterConfig类 1234567891011 @Override public void init(FilterConfig filterConfig) throws ServletException &#123; // 1、获取 Filter 的名称 filter-name 的内容System.out.println(&quot;2.Filter的init(FilterConfig filterConfig)初始化&quot;);System.out.println(&quot;filter-name的值&quot;+filterConfig.getFilterName()); //2、获取在 web,xml Filter 中配置的 init-param 初始化参数System.out.println(&quot;初始化参数username的值&quot;+filterConfig.getInitParameter(&quot;username&quot;));System.out.println(&quot;初始化参数url的值&quot;+filterConfig.getInitParameter(&quot;url&quot;)); //3、获取 ServletContext 对象 System.out.println(filterConfig.getServletContext()); &#125; web.xml文件中加上init-param参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445 &lt;!--filter标签用于配置一个Filter过滤器--&gt; &lt;filter&gt; &lt;!--给filter起一个别名--&gt; &lt;filter-name&gt; AdminFilter &lt;/filter-name&gt; &lt;!--配置filter全类名--&gt; &lt;filter-class&gt; com.atguigu.filter.AdminFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;root&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;url&lt;/param-name&gt; &lt;param-value&gt;jdbc:mysql:localhost3306/test&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!--filter-mapping配置Filter过滤器的拦截路径--&gt; &lt;filter-mapping&gt; &lt;!--filter-name表示当前的拦截路径给哪个filter使用--&gt; &lt;filter-name&gt;AdminFilter &lt;/filter-name&gt; &lt;!--url-pattern配置拦截路径 /admin/* 表示请求地址为web目录下admin下的全部 --&gt; &lt;url-pattern&gt; /admin/* &lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt; LoginServlet &lt;/servlet-name&gt; &lt;servlet-class&gt; com.atguigu.servlet.LoginServlet &lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/loginServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; FilterChain过滤链是doFilter方法的第三个参数FilterChain filterChain 前两个参数是request和response Filter 过滤器 Chain 链，链 条 FilterChain 就是过滤器链（多个过滤器如何一起工作） 如果通过了两个doFilter方法的guolv 代码执行就是 Filter1前置代码 Filter2前置代码 目标资源被访问啦 Filter2后置代码 Filter1后置代码 如果Filter2过滤不通过 代码执行是 FilTer1前置代码 Filter2 前置代码 Filter1后置代码 如果Filter2过滤不通过 Filter1前置代码 Thread.getCurrentThread().getName()得到当前线程的名字 Filter过滤器的三种拦截路径路径后面加参数都是可以匹配的 —精确匹配 1/target.jsp 以上配置的路径，表示请求地址必须为：http://ip:port/工程路径/target.jsp 后面可以加参数都是无所谓的 –目录匹配 1/admin/* 以上配置的路径，表示请求地址必须为：http://ip:port/工程路径/admin/* –后缀名匹配 书城项目第八阶段1.使用 Filter 过滤器拦截&#x2F;pages&#x2F;manager&#x2F;所有内容，实 现权限检查 加一个过滤器 12345678910111213141516171819202122232425262728293031323334package com.atguigu.filter;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;import java.io.IOException;public class ManagerFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; //获得session HttpServletRequest servletRequest1 = (HttpServletRequest) servletRequest; HttpSession session = servletRequest1.getSession(); Object user = session.getAttribute(&quot;user&quot;); if(user==null)&#123; servletRequest1.getRequestDispatcher(&quot;/pages/user/login.jsp&quot;).forward(servletRequest,servletResponse); &#125;else &#123; filterChain.doFilter(servletRequest,servletResponse); &#125; &#125; @Override public void destroy() &#123; &#125;&#125; 在web.xml中加上一个filter的过滤器 两个路径，因为通过&#x2F;manager&#x2F;BookServlet?action&#x3D;page也可以访问后台，所以两个都要过滤掉 123456789&lt;filter&gt; &lt;filter-name&gt;ManagetFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.atguigu.filter.ManagerFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;ManagetFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/pages/manager/*&lt;/url-pattern&gt; &lt;url-pattern&gt;/manager/BookServlet&lt;/url-pattern&gt;&lt;/filter-mapping&gt; ThreadLocal使用介绍ThreadLocal 的作用，它可以解决多线程的数据安全问题。 ThreadLocal 它可以给当前线程关联一个数据（可以是普通变量，可以是对象，也可以是数组，集合） ThreadLocal 的特点： 1、ThreadLocal 可以为当前线程关联一个数据。（它可以像 Map 一样存取数据，key 为当前线程） 2、每一个 ThreadLocal 对象，只能为当前线程关联一个数据，如果要为当前线程关联多个数据，就需要使用多个 ThreadLocal 对象实例。 3、每个 ThreadLocal 对象实例定义的时候，一般都是 static 类型 4、ThreadLocal 中保存数据，在线程销毁后。会由 JVM 虚拟自动释放 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.atguigu.test;import java.util.Random;class OrderService &#123; public void createOrder()&#123; String name = Thread.currentThread().getName(); System.out.println(&quot;OrderService 当前线程[&quot; + name + &quot;]中保存的数据是：&quot; + ThreadLocalTest.threadLocal.get()); new OrderDao().saveOrder(); &#125;&#125; class OrderDao &#123; public void saveOrder()&#123; String name = Thread.currentThread().getName(); System.out.println(&quot;OrderDao 当前线程[&quot; + name + &quot;]中保存的数据是：&quot; + ThreadLocalTest.threadLocal.get()); &#125;&#125;public class ThreadLocalTest &#123; // public static Map&lt;String,Object&gt; data = new Hashtable&lt;String,Object&gt;(); public static ThreadLocal&lt;Object&gt; threadLocal = new ThreadLocal&lt;Object&gt;(); private static Random random = new Random(); public static class Task implements Runnable &#123; @Override public void run() &#123;// 在 Run 方法中，随机生成一个变量（线程要关联的数据），然后以当前线程名为 key 保存到 map 中 Integer i = random.nextInt(1000);// 获取当前线程名 String name = Thread.currentThread().getName(); System.out.println(&quot;线程[&quot;+name+&quot;]生成的随机数是：&quot; + i);// data.put(name,i); threadLocal.set(i); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //这个也是为验证取出的同一线程相关联的数都是相同的 new OrderService().createOrder();// 在 Run 方法结束之前，以当前线程名获取出数据并打印。查看是否可以取出操作// Object o = data.get(name); Object o = threadLocal.get(); System.out.println(&quot;在线程[&quot;+name+&quot;]快结束时取出关联的数据是：&quot; + o); &#125; &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 3; i++)&#123; new Thread(new Task()).start(); &#125; &#125;&#125; 使用 Filter 和 ThreadLocal 组合管理事务查询时不需要提交事务的 保存订单和保存订单项还有更新销量要么都成功，要么都失败 可以用到事务 JDBCUtils 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package com.atguigu.utils;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.pool.DruidDataSourceFactory;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.SQLException;import java.util.Properties;public class JdbcUtils &#123; private static DruidDataSource dataSource; //用ThreadLocal保存conn链接 private static ThreadLocal&lt;Connection&gt; conns=new ThreadLocal&lt;Connection&gt;();static &#123; try&#123; Properties properties=new Properties(); InputStream inputStream=JdbcUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); properties.load(inputStream); dataSource= (DruidDataSource) DruidDataSourceFactory.createDataSource(properties); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125;&#125;//获取数据库连接池中的连接，如果返回null就是获取失败，有值就是获取成功public static Connection getConnection()&#123;Connection conn=conns.get();if(conn==null)&#123; try &#123; conn=dataSource.getConnection();//从数据库连接池中获取链接 conns.set(conn);//保存到ThreadLocal对象中，供后面的jdbc操作使用 conn.setAutoCommit(false);//设置为手动管理事务 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125;return conn;&#125;/*提交事务，并释放连接 */public static void commitAndColose() &#123; Connection connection = conns.get(); if(connection!=null)&#123; //如果不等于null，说明之前使用过链接操作过数据库 try &#123; connection.commit();//提交事务 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally&#123; //关闭链接 try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //一定要执行remove操作，否则就会出错，因为Tomcat服务器底层用了线程池技术 conns.remove();&#125;/*回滚事务，关闭连接 */public static void rollbackAndColose() &#123; Connection connection = conns.get(); if(connection!=null)&#123; //如果不等于null，说明之前使用过链接操作过数据库 try &#123; connection.rollback();//提交事务 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally&#123; //关闭链接 try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //一定要执行remove操作，否则就会出错，因为Tomcat服务器底层用了线程池技术 conns.remove();&#125;//关闭连接 /*public static void close(Connection conn)&#123; if(conn!=null)&#123; try&#123; conn.close(); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;*/ public static void main(String[] args) &#123; &#125;&#125; BaseDao 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.atguigu.dao.impl;import com.atguigu.utils.JdbcUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.apache.commons.dbutils.handlers.ScalarHandler;import java.sql.Connection;import java.sql.SQLException;import java.util.List;public class BaseDao &#123; //使用DbUtils操作数据库private QueryRunner queryRunner=new QueryRunner();/*update()方法用来执行：insert update delete语句如果返回-1说明执行失败， 否则返回其他表示影响的行数 */ public int update(String sql,Object...args)&#123; Connection conn= JdbcUtils.getConnection(); try &#123; return queryRunner.update(conn, sql, args); &#125; catch(Exception e)&#123; e.printStackTrace(); //将异常都抛出去 throw new RuntimeException(e); &#125; &#125; /* 查询返回一个javaBean的sql语句 type为返回对象类型，args是sql对应的参数值，sql是执行的sql语句 &lt;T&gt;返回的类型和泛型 */ public &lt;T&gt; T queryForOne(Class&lt;T&gt; type,String sql,Object...args) &#123; Connection con=JdbcUtils.getConnection(); try &#123; return queryRunner.query(con,sql,new BeanHandler&lt;T&gt;(type),args); &#125;catch(SQLException e)&#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125; /* 查询返回多个javaBean的sql语句 */ public &lt;T&gt; List&lt;T&gt; queryForList(Class&lt;T&gt; type,String sql,Object...args)&#123; Connection con=JdbcUtils.getConnection(); try &#123; return queryRunner.query(con,sql,new BeanListHandler&lt;T&gt;(type),args); &#125;catch(SQLException e)&#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125; /* 执行返回一个单元格的sql */ public Object queryForSingleValue(String sql,Object...args)&#123; Connection conn=JdbcUtils.getConnection(); try &#123; return queryRunner.query(conn, sql,new ScalarHandler(), args); &#125; catch(SQLException e)&#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125;&#125; OrderServlet 12345678try &#123; orderId = orderService.createOrder(cart, userId); JdbcUtils.commitAndColose();//提交事务&#125;catch(Exception e)&#123; JdbcUtils.rollbackAndColose();//回滚事务 e.printStackTrace();&#125; 一开始一直不成功，将表的引擎改为Innodb就可以了，以及把mysql默认引擎改为innodb mylsam引擎是不支持事务操作的 右键表的设计表选项 使用Filter统一给所有的Service方法都加上try-catch 就是doFilter有除了filterChain.doFilter()方法之外还有前置代码和后置代码，只要给这个工程的所有访问路径加上这个过滤器，然后再在 filterChain.foFilter后面加上提交事务，和catch 回滚事务，这样访问资源回来之后，可以执行后置代码，这个后置代码就是提交事务，或者捕捉错误之后回滚事务 TranscationFilter类的代码 123456789101112131415161718192021222324252627282930313233package com.atguigu.filter;import com.atguigu.utils.JdbcUtils;import javax.servlet.*;import java.io.IOException;public class TranscationServlet implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; try &#123; filterChain.doFilter(servletRequest, servletResponse); //提交事务 JdbcUtils.commitAndColose(); &#125; catch(Exception e) &#123;//回滚事务 JdbcUtils.rollbackAndColose(); e.printStackTrace(); &#125; &#125; @Override public void destroy() &#123; &#125;&#125; web.xml 123456789&lt;filter&gt; &lt;filter-name&gt;TranscationServlet&lt;/filter-name&gt; &lt;filter-class&gt;com.atguigu.filter.TranscationServlet&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;TranscationServlet&lt;/filter-name&gt; &lt;!--表示当前工程下的所有请求--&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; BaseServlet 把BaseServlet中的异常抛出 就是过程中的异常都应该抛出，如果异常没被Filter捕获就不能回滚事务了 1234567891011121314151617181920212223242526272829303132333435package com.atguigu.web;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.Method;public abstract class BaseServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req,resp); &#125; protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(&quot;text/html;charset=UTF-8&quot;); String parameter=req.getParameter(&quot;action&quot;); try &#123; //通过反射获取对应的方法，因为设定获取的action的参数值和调用方法的名字相同 //this是指调用该post方法的对象 Method parameter1 = this.getClass().getDeclaredMethod(parameter,HttpServletRequest.class,HttpServletResponse.class); //执行目标业务方法 parameter1.invoke(this,req,resp); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException();//把异常抛给Filter过滤器 &#125; &#125;&#125; 使用Tomcat统一管理，展示友好的错误页面在 web.xml 中我们可以通过错误页面配置来进行管理 1234567891011121314&lt;!--error-page 标签配置，服务器出错之后，自动跳转的页面--&gt;&lt;error-page&gt; &lt;!--error-code 是错误类型--&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;!--location 标签表示。要跳转去的页面路径--&gt; &lt;location&gt;/pages/error/error500.jsp&lt;/location&gt;&lt;/error-page&gt;&lt;!--error-page 标签配置，服务器出错之后，自动跳转的页面--&gt;&lt;error-page&gt; &lt;!--error-code 是错误类型--&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;!--location 标签表示。要跳转去的页面路径--&gt; &lt;location&gt;/pages/error/error404.jsp&lt;/location&gt;&lt;/error-page&gt; error500.jsp 1234567891011121314151617&lt;%-- Created by IntelliJ IDEA. User: #赵梓皓&amp; Date: 2022/10/13 Time: 15:18 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;这是错误页面&lt;a href=&quot;index.jsp&quot;&gt;返回首页&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; TranscationServlet 12345678 catch(Exception e) &#123;//回滚事务 JdbcUtils.rollbackAndColose(); e.printStackTrace(); throw new RuntimeException();//继续抛异常，让tomcat服务器收到异常 &#125;&#125; 回滚事务之后还是抛出异常，让tomcat服务器接收异常 Json和AjaxJsonJSON (JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON 采用完全独立于语言的文本格式，而且很多语言都提供了对 json 的支持（包括 C, C++, C#, Java, JavaScript, Perl, Python 等）。 这样就使得 JSON 成为理想的数据交换格式 json 是一种轻量级的数据交换格式。 轻量级指的是跟 xml 做比较 数据交换指的是客户端和服务器之间业务数据的传递格式 Json在javascript的使用json定义 json 是由键值对组成，并且由花括号（大括号）包围。每个键由引号引起来，键和值之间使用冒号进行分隔， 多组键值对之间进行逗号进行分隔。 1234567891011121314// json的定义//vlaue可以使字符串，数组，布尔，数字，json对象，有json对象的数组var jsonobj=&#123; &quot;key1&quot;:12, &quot;key2&quot;:&quot;abc&quot;, &quot;key3&quot;:true, &quot;key4&quot;:[11,&quot;arr&quot;,false], &quot;key5&quot;:&#123; &quot;key5_1&quot;:12, &quot;key5_2&quot;:&quot;value&quot; &#125;, &quot;key6&quot;:[&#123;&quot;key1&quot;:&quot;12&quot;&#125;,&#123;&quot;key1&quot;:123&#125;] &#125;; json的访问 json 本身是一个对象。 json 中的 key 我们可以理解为是对象中的一个属性。 json 中的 key 访问就跟访问对象的属性一样： json 1234567891011121314151617181920212223242526272829// json的定义//vlaue可以使字符串，数组，布尔，数字，json对象，有json对象的数组var jsonobj=&#123; &quot;key1&quot;:12, &quot;key2&quot;:&quot;abc&quot;, &quot;key3&quot;:true, &quot;key4&quot;:[11,&quot;arr&quot;,false], &quot;key5&quot;:&#123; &quot;key5_1&quot;:12, &quot;key5_2&quot;:&quot;value&quot; &#125;, &quot;key6&quot;:[&#123;&quot;key1&quot;:&quot;12&quot;&#125;,&#123;&quot;key1&quot;:123&#125;]&#125;;//json就是一个对象alert(typeof(jsonobj))// json的访问 alert(jsonobj.key1);alert(jsonobj.key2);alert(jsonobj.key3);//数组遍历for(var i=0;i&lt;jsonobj.key4.length;i++)&#123; alert(jsonobj.key4[i]);&#125;alert(jsonobj.key5.key5_1);alert(jsonobj.key5.key5_2);alert(jsonobj.key6);//key6存储的就是json对象的数组，所以变量json被赋了个json对象var json=jsonobj.key6[0]; json两个常用方法 json 的存在有两种形式。 一种是：对象的形式存在，我们叫它 json 对象。 一种是：字符串的形式存在，我们叫它 json 字符串。 一般我们要操作 json 中的数据的时候，需要 json 对象的格式。 一般我们要在客户端和服务器之间进行数据交换的时候，使用 json 字符串。 123456// json对象转字符串var jsonstring=JSON.stringify(jsonobj);//特别象java中对象的toString方法alert(jsonstring)// json字符串转json对象var json2=JSON.parse(jsonstring);alert(typeof(json2)); json在java中使用json和javaBean的互转 12345678910111213141516 //javaBean和json互相转化 @Test public void test1()&#123;Person person=new Person(1,&quot;好帅&quot;);//创建Gson对象实例Gson gson=new Gson();///toJson方法可以把java对象转换成为json字符串 String personJsonString = gson.toJson(person); System.out.println(personJsonString); //fromJson把json字符串转换为java对象 //第一个参数是json字符串，第二个参数是转换回去的java对象类型 //看好是哪个方法选择第一个参数是字符串的fromJson方法 Person person1 = gson.fromJson(personJsonString, Person.class); System.out.println(person1); &#125; List 和 json互转 1234567891011121314151617//list集合和json转换@Testpublic void test2()&#123; ArrayList&lt;Person&gt; personList = new ArrayList&lt;&gt;(); personList.add(new Person(1,&quot;哥&quot;)); personList.add(new Person(2,&quot;第&quot;)); Gson gson=new Gson(); //把List转换为Json字符串 String personListJsonString = gson.toJson(personList); System.out.println(personListJsonString);//[&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;哥&quot;&#125;,&#123;&quot;id&quot;:2,&quot;name&quot;:&quot;第&quot;&#125;] //第二个参数不能是personList.getClass(),这样得到的集合里面存储的是map对象不能转换为Person对象，所以用这个方法 ArrayList&lt;Person&gt; arrayList = gson.fromJson(personListJsonString, new PersonListType().getType()); Person person = arrayList.get(0); System.out.println(person);&#125; 12345678910package com.atguigu.json;import com.atguigu.pojo.Person;import com.google.gson.reflect.TypeToken;import java.util.ArrayList;public class PersonListType extends TypeToken&lt;ArrayList&lt;Person&gt;&gt; &#123;&#125; json和Map集合相互转换 123456789101112131415161718//map和json的互转@Testpublic void test3()&#123; Map&lt;Integer,Person&gt; personMap=new HashMap&lt;&gt;(); personMap.put(1,new Person(1,&quot;国歌&quot;)); personMap.put(2,new Person(2,&quot;康师傅&quot;)); Gson gson=new Gson(); String personMapJsonString = gson.toJson(personMap); System.out.println(personMapJsonString);//&#123;&quot;1&quot;:&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;国歌&quot;&#125;,&quot;2&quot;:&#123;&quot;id&quot;:2,&quot;name&quot;:&quot;康师傅&quot;&#125;&#125; Map&lt;Integer,Person&gt; personMap1 = gson.fromJson(personMapJsonString, new PersonMapType().getType()); //使用匿名内部类的方式，这样就不用多创建java的class TypeToken泛型中是你要返回的类型 // Map&lt;Integer,Person&gt; personMap1 = gson.fromJson(personMapJsonString, new TypeToken&lt;HashMap&lt;Integer,Person&gt;&gt;()&#123;&#125;.getType()); System.out.println(personMap1); Person p=personMap1.get(1); System.out.println(p);&#125; 如果Map的value存储的是一个实体类对象，那么json对象.key取出的也就是一个json对象 ​ 如果是一个正常的12，字符串或者布尔，可以直接取出， Map的key就是json对象的key Ajaxajax是单线程异步的 AJAX 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发 技术。 ajax 是一种浏览器通过 js 异步发起请求，局部更新页面的技术（地址栏不发生变化，页面局部更新，其他地方不变） 同步是指你调了一个什么方法，这个线程就一直在这等着，这个方法调用完往下走，异步是指接着往下走先调用下面的代码，等那个方法服务器返回再执行 异步就是等服务器回应的时候，接着执行下面的代码 Ajax 请求的局部更新，浏览器地址栏不会发生变化 局部更新不会舍弃原来页面的内容 原生Ajax请求实例BaseServlet 1234567891011121314151617181920212223242526272829303132333435package com.atguigu.web;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.Method;public abstract class BaseServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req,resp); &#125; protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //解决返回中文时的乱码问题 resp.setContentType(&quot;text/html;charset=UTF-8&quot;); String parameter=req.getParameter(&quot;action&quot;); try &#123; //通过反射获取对应的方法，因为设定获取的action的参数值和调用方法的名字相同 //this是指调用该post方法的对象 Method parameter1 = this.getClass().getDeclaredMethod(parameter,HttpServletRequest.class,HttpServletResponse.class); //执行目标业务方法 parameter1.invoke(this,req,resp); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; AjaxServlet 123456789101112131415161718192021package com.atguigu.servlet;import com.atguigu.pojo.Person;import com.google.gson.Gson;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class AjaxServlet extends BaseServlet&#123; protected void javascriptAjax(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;Ajax请求过来啦&quot;); Person person=new Person(1,&quot;国歌&quot;); //json格式的字符串 Gson gson=new Gson(); //服务器响应一个person对象，用json字符串传送 String personJsonString = gson.toJson(person); resp.getWriter().write(personJsonString); &#125;&#125; ajax.html 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot; /&gt; &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot; /&gt; &lt;meta http-equiv=&quot;Expires&quot; content=&quot;0&quot; /&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; //在这里使用javascript语言发起Ajax请求，访问服务器AjaxServlet中javascriptAjax function ajaxRequest() &#123;// 1、我们首先要创建XMLHttpRequest var xmlhttpreqest =new XMLHttpRequest();// 2、调用open方法设置请求参数 //第一个参数是请求的方法，第二个参数是请求的地址，第三个参数是请求是否是异步 xmlhttpreqest.open(&quot;GET&quot;,&quot;http://localhost:8080/jsonajax/AjaxServlet?action=javascriptAjax&quot;,true);// 3、调用send方法发送请求 xmlhttpreqest.send();// 4、在send方法前绑定onreadystatechange事件，处理请求完成后的操作。 //这个事件是响应值做好被处理准备之后调用 xmlhttpreqest.onreadystatechange=function()&#123; //满足这两个条件，才能用responseText if(xmlhttpreqest.readyState==4&amp;&amp;xmlhttpreqest.status==200)&#123; //转成json对象 var jsonobj = JSON.parse(xmlhttpreqest.responseText); document.getElementById(&quot;div01&quot;).innerHTML=&quot;编号&quot;+jsonobj.id+&quot;，姓名&quot;+jsonobj.name; &#125; &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;ajaxRequest()&quot;&gt;ajax request&lt;/button&gt; &lt;div id=&quot;div01&quot;&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; Ajax请求的特点说明jQuery中的ajax方法 回调函数的参数获取服务器返回的数据 这是$.ajax演示 1234567891011121314151617// ajax请求$(&quot;#ajaxBtn&quot;).click(function()&#123; $.ajax(&#123; url:&quot;http://localhost:8080/jsonajax/AjaxServlet&quot;, data:&#123;action:&quot;jQueryAjax&quot;&#125;, //data:&quot;action=jQueryAjax&quot;, type:&quot;Get&quot;, success:function(msg)&#123;//参数获取服务器返回的数据 //先转成json对象 var jsonobj=JSON.parse(msg); $(&quot;#msg&quot;).html(&quot;编号&quot;+jsonobj.id+&quot;，姓名&quot;+jsonobj.name); &#125;, dataType:&quot;text&quot; &#125;);&#125;); 在AjaxServlet中加方法 1234567891011protected void jQueryAjax(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;jQueryAjax===方法调用了&quot;); Person person=new Person(1,&quot;国歌&quot;); //json格式的字符串 Gson gson=new Gson(); //服务器响应一个person对象，用json字符串传送 String personJsonString = gson.toJson(person); //往客户端返回Json字符串 resp.getWriter().write(personJsonString);&#125; jQuery中的get和post方法 1234567891011121314151617// ajax--get请求$(&quot;#getBtn&quot;).click(function()&#123; $.get(&quot;http://localhost:8080/jsonajax/AjaxServlet&quot;,&quot;action=jQueryGet&quot;,function(data)&#123;//参数获取服务器返回的数据 //这里不用把data转为json对象，是因为服务器返回数据本来就设置为json对象 $(&quot;#msg&quot;).html(&quot;get编号&quot;+data.id+&quot;,姓名&quot;+data.name); &#125;,&quot;json&quot;); &#125;);// ajax--post请求$(&quot;#postBtn&quot;).click(function()&#123; $.post(&quot;http://localhost:8080/jsonajax/AjaxServlet&quot;,&quot;action=jQueryPost&quot;,function(data)&#123; $(&quot;#msg&quot;).html(&quot;post编号&quot;+data.id+&quot;,姓名&quot;+data.name); &#125;,&quot;json&quot;); &#125;); Servlet中加的方法 12345678910111213141516171819protected void jQueryGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;jQueryget===方法调用了&quot;); Person person = new Person(1, &quot;国歌&quot;); //json格式的字符串 Gson gson = new Gson(); //服务器响应一个person对象，用json字符串传送 String personJsonString = gson.toJson(person); resp.getWriter().write(personJsonString);&#125;protected void jQueryPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;jQuerypost===方法调用了&quot;); Person person = new Person(1, &quot;国歌&quot;); //json格式的字符串 Gson gson = new Gson(); //服务器响应一个person对象，用json字符串传送 String personJsonString = gson.toJson(person); resp.getWriter().write(personJsonString);&#125; jQuery的getJson方法$.getJSON 方法 getJSON的返回值都是json对象 url 请求的 url 地址 data 发送给服务器的数据 callback 成功的回调函数 1234567// ajax--getJson请求$(&quot;#getJSONBtn&quot;).click(function()&#123;$.getJSON(&quot;http://localhost:8080/jsonajax/AjaxServlet&quot;,&quot;action=jQueryGetJson&quot;,function(data)&#123; $(&quot;#msg&quot;).html(&quot;getJson编号&quot;+data.id+&quot;,姓名&quot;+data.name);&#125;);&#125;); Servlet中增加的方法 123456789protected void jQueryGetJson(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;jQuerygetJson===方法调用了&quot;); Person person = new Person(1, &quot;国歌&quot;); //json格式的字符串 Gson gson = new Gson(); //服务器响应一个person对象，用json字符串传送 String personJsonString = gson.toJson(person); resp.getWriter().write(personJsonString);&#125; jQuery中的serialize()方法serialize()可以把表单中所有表单项的内容都获取到，并以 name&#x3D;value&amp;name&#x3D;value “action&#x3D;jQuerySerialize&amp;”+$(“#form01”).serialize() 获取表单的所有项再和自己传的参数拼接 123456// ajax请求$(&quot;#submit&quot;).click(function()&#123; $.getJSON(&quot;http://localhost:8080/jsonajax/AjaxServlet&quot;,&quot;action=jQuerySerialize&amp;&quot;+$(&quot;#form01&quot;).serialize(),function(data)&#123; $(&quot;#msg&quot;).html(&quot;getJson编号&quot;+data.id+&quot;,姓名&quot;+data.name); &#125;);&#125;); Servlet中加方法 12345678910111213protected void jQuerySerialize(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;jQuerySeialize===方法调用了&quot;); //获取serialize从表单中得到的用户名 System.out.println(&quot;用户名&quot;+req.getParameter(&quot;username&quot;)); //获取serialize从表单中或得到的密码 System.out.println(&quot;密码&quot;+req.getParameter(&quot;password&quot;)); Person person = new Person(1, &quot;国歌&quot;); //json格式的字符串 Gson gson = new Gson(); //服务器响应一个person对象，用json字符串传送 String personJsonString = gson.toJson(person); resp.getWriter().write(personJsonString);&#125; 书城项目第九阶段使用 AJAX请求验证用户名是否可用 123456789101112131415161718$(function()&#123; //给用户名绑定失去焦点事件 $(&quot;#username&quot;).blur(function()&#123; //1.获取用户名 var username=this.value; //获得JSON，并得到json对象 $.getJSON(&quot;http://localhost:8087/book2/UserServlet&quot;,&quot;action=ajaxExistUsername&amp;username=&quot;+username,function(data)&#123; if(data.existsUsername)&#123; $(&quot;span.errorMsg&quot;).text(&quot;用户名已存在&quot;); &#125; else &#123; $(&quot;span.errorMsg&quot;).text(&quot;用户名可用&quot;); &#125; &#125;); &#125;); 上面这个是regisr.jsp 这个是UserServlet加了一个方法 1234567891011121314protected void ajaxExistUsername(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求的参数 String username=req.getParameter(&quot;username&quot;); //调用userService.exsitsUsername() boolean b = userService.existsUsername(username); //把返回的结果封装成为Map对象 Map&lt;String,Object&gt; resultMap=new HashMap&lt;String,Object&gt;(); resultMap.put(&quot;existsUsername&quot;,b); //将Map转成json字符串 Gson gson=new Gson(); String s = gson.toJson(resultMap); //回传给客户端resp.getWriter().write(s);&#125; 使用Ajax修改把商品添加到购物车 index.jsp 把原本的添加到购物车的按钮的点击事件给改了 12345678910111213141516171819202122232425&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; $(&quot;button.addToCart&quot;).click(function()&#123; /** * 在事件响应的function函数中有一个this对象，就是是当前正在响应事件的dom对象，就是那个标签的dom对象， * @type &#123;*|jQuery&#125; */ /* 先把this改为jQery对象然后获取属性值 */ var bookId=$(this).attr(&quot;bookId&quot;); //跳转到 /* location.href=&quot;http://localhost:8087/book2/CartServlet?action=addItem&amp;id=&quot;+bookId;*/ $.getJSON(&quot;http://localhost:8087/book2/CartServlet&quot;,&quot;action=ajaxAddItem&amp;id=&quot;+bookId,function(data)&#123; //法Ajax请求，添加商品到购物车 $(&quot;#cartTotalCount&quot;).text(&quot;您的购物车中有&quot;+data.totalCount+&quot;件商品&quot;); $(&quot;#cartLastName&quot;).text(data.lastName); &#125;); &#125;); &#125;);&lt;/script&gt; CartServlet 12345678910111213141516171819202122232425262728293031323334353637protected void ajaxAddItem(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求的参数，商品编号 int id= WebUtils.parseInt(req.getParameter(&quot;id&quot;),0); //调用bookService.queryBookById(id):得到Book的信息 Book book = bookService.queryBookById(id); //把图书信息转化成为CartItem商品项 CartItem cartItem=new CartItem(book.getId(),book.getName(),1,book.getPrice(),book.getPrice()); /* 用session存储cart信息 */ Cart cart = (Cart) req.getSession().getAttribute(&quot;cart&quot;); if(cart==null)&#123; cart=new Cart(); req.getSession().setAttribute(&quot;cart&quot;,cart); &#125; //调用Cart.addItem(CartItem)添加商品项 cart.addItem(cartItem); System.out.println(cart); //重定向回商品列表页面 /* req.getHeader(&quot;Referer&quot;)获取请求服务器的地址，然后下面再跳回到这个地址 */ req.getSession().setAttribute(&quot;lastName&quot;,cartItem.getName()); //返回购物车总的商品数量和最后一个添加的商品 HashMap&lt;String, Object&gt; resultMap = new HashMap&lt;&gt;(); resultMap.put(&quot;totalCount&quot;,cart.getTotalCount()); resultMap.put(&quot;lastName&quot;,cartItem.getName()); Gson gson=new Gson(); String resultMapJsonString = gson.toJson(resultMap); resp.getWriter().write(resultMapJsonString);&#125; index.jsp中的html代码 1234567891011121314151617&lt;c:if test=&quot;$&#123;empty sessionScope.cart.items&#125;&quot;&gt; &lt;%--购物车为空的输出--%&gt; &lt;span id=&quot;cartTotalCount&quot;&gt;&lt;/span&gt; &lt;div&gt; &lt;span id=&quot;cartLastName&quot; style=&quot;color: red&quot;&gt;当前购物车为空&lt;/span&gt; &lt;/div&gt;&lt;/c:if&gt;&lt;c:if test=&quot;$&#123;not empty sessionScope.cart.items&#125;&quot;&gt; &lt;%--购物车为空的输出--%&gt; &lt;span id=&quot;cartTotalCount&quot;&gt;您的购物车中有$&#123;sessionScope.cart.totalCount&#125;件商品&lt;/span&gt; &lt;div&gt; 您刚刚将&lt;span id=&quot;cartLastName&quot; style=&quot;color: red&quot;&gt;$&#123;sessionScope.lastName&#125;&lt;/span&gt;加入到了购物车中 &lt;/div&gt;&lt;/c:if&gt; 给标签加上了id cartTotalCount cartLastName","categories":[],"tags":[]},{"title":"java","slug":"java","date":"2022-09-29T09:56:50.000Z","updated":"2022-10-01T03:44:57.280Z","comments":true,"path":"2022/09/29/java/","link":"","permalink":"http://example.com/2022/09/29/java/","excerpt":"","text":"变量在Java中，静态变量和实例变量可以统称为成员变量。首先，明白什么是静态变量，什么是实例变量，他们定义的形式。静态变量也叫做类变量，独立于方法之外的变量，有static修饰。实例变量同样独立也是独立于方法之外 的变量，但没有static修饰。 运算符&lt;&lt;：是逻辑左移，右边补0，符号位和其他位一样要移动。 数学意义：在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以2的1次方，左移n位就相当于乘以2的n次方。 计算：3 &lt;&lt; 2 3 &lt;&lt; 2，则是将数字3左移2位 1、首先把3转换为二进制数字0000 0000 0000 0000 0000 0000 0000 0011 2、然后把该数字高位（左侧）的两个零移出，其他的数字都朝左平移2位，最后在低位（右侧）的两个空位补零。 3、则得到的最终结果是0000 0000 0000 0000 0000 0000 0000 1100，则转换为十进制是12。 （右移运算符） 位运算符 凡位运算符都是把值先转换成二进制再进行后续的处理，5的二进制位是0000 0101，右移两位就是把101左移后为0000 0001，正数左边第一位补0，负数补1，等于除于2的n次方，结果为1 ，只保留了结果的整数部分 &amp;（按位与） 位运算符 &amp;按位与的运算规则是将两边的数转换为二进制位，然后运算最终值，运算规则即(两个为真才为真)1&amp;1&#x3D;1 , 1&amp;0&#x3D;0 , 0&amp;1&#x3D;0 , 0&amp;0&#x3D;0 3的二进制位是0000 0011 ， 5的二进制位是0000 0101 ， 那么就是011 &amp; 101，由按位与运算规则得知，001 &amp; 101等于0000 0001，最终值为1 7的二进制位是0000 0111，那就是111 &amp; 101等于101，也就是0000 0101，故值为5 |（按位或） 位运算符 |按位或和&amp;按位与计算方式都是转换二进制再计算，不同的是运算规则(一个为真即为真)1|0 &#x3D; 1 , 1|1 &#x3D; 1 , 0|0 &#x3D; 0 , 0|1 &#x3D; 1 6的二进制位0000 0110 , 2的二进制位0000 0010 , 110|010为110，最终值0000 0110，故6|2等于6 ^（异或运算符） 位运算符 ^异或运算符顾名思义，异就是不同，其运算规则为1^0 &#x3D; 1 , 1^1 &#x3D; 0 , 0^1 &#x3D; 1 , 0^0 &#x3D; 0 5的二进制位是0000 0101 ， 9的二进制位是0000 1001，也就是0101 ^ 1001,结果为1100 , 00001100的十进制位是12 ~（取反运算符） 位运算符 取反就是1为0,0为1,5的二进制位是0000 0101，取反后为1111 1010，值为-6 （无符号右移运算符） 正数无符号右移 无符号右移运算符和右移运算符的主要区别在于负数的计算，因为无符号右移是高位补0，移多少位补多少个0。 15的二进制位是0000 1111 ， 右移2位0000 0011，结果为3 负数无符号右移 -6的二进制是6的二进制取反再加1,6的二进制也就是0000 0000 0000 0000 0000 0000 0000 0110，取反后加1为1111 1111 1111 1111 1111 1111 1111 1010，右移三位0001 1111 1111 1111 1111 1111 1111 1111 二进制正值转负值 a.最高位改成1 b.除了最高位，其他位取反 c.结果+1 d.得到的结果就是对应的负值 java.lang包java.lang包是java语言的核心，它提供了java中的基础类。包括基本Object类、Class类、String类、基本类型的包装类、基本的数学类等等最基本的类。我们介绍一下Java 8中的java.lang包。主要类如下图： 类 由 域(变量) 方法 组成 常量叫做直接量 数据类型基本数据类型:整形:短整型，整形，长整型，字节型空数组引用数据类型:类，接口，数组 字符’ ‘字符串” “ 一个字节八比特，一个byte八位 byte 1字节 short2字节 int 4字节 long 8字节 float 4字节 double 8字节 char 2字节 boolean 1位 类方法与实例方法的区别定义：类方法：static修饰的方法实例方法：由类创建实例调用 对象变量:指类中不加static的成员变量 区别： 类方法中不能引用对象变量；实例方法可以引用对象变量，也可以引用类变量。 类方法不能直接调用实例方法；实例方法可以直接调用类方法 类方法中不能使用super、this关键字；实例方法可以使用。 类方法不能被覆盖。 5.实例方法不能通过类名调用，当类的字节码文件被加载到内存时，类的实例方法不会被分配入口地址，当该类创建对象后，类中的实例方法才分配入口地址，从而实例方法可以被类创建的任何对象调用执行。 6.类方法可以通过类名调用，类方法在该类被加载到内存时，就分配了相应的入口地址。从而类方法不仅可以被类创建的任何对象调用执行，也可以直接通过类名调用。类方法的入口地址直到程序退出时才被取消。 类名.方法名() 子类中出现和父类相同的方法，就是覆盖，子类的对象就无法访问父类的那个被覆盖的方法，覆盖方法和被覆盖的方法要么都是类方法，要么都是实例方法，不能一个是类方法，一个是实例方法 private方法不支持重写 如果父类方法是private，即使子类中定义一个与父类private方法相同的方法名，相同的参数列表依然不是重写，只是在子类里重新定义了一个新的方法 标识符标识符命名规则：1，只能由字母数字，_或$2.必须以字母，_或$开头3.大小写敏感，无长度限制4，不能是java的关键字和保留字 标识符规则标识符常量用大写字母，变量用小写字母开始，类以大写字母开始标识符不能与关键字同名标识符最好见名知义 super关键字在子类方法中调用父类中被覆盖的方法，则可以使用super（被覆盖的是实例方法），或者父类类名来调用父类中被覆盖的函数（被覆盖的是类方法） 继承和多态12345678910111213141516171819202122232425262728293031323334353637383940414243package Hello;public class Hello &#123; public String s; public int a; public Hello() &#123; &#125; public Hello(String s,int a) &#123; this.s=s; this.a=a; &#125; public void print() &#123; System.out.println(&quot;123&quot;); &#125; public void print2() &#123; System.out.println(&quot;1234&quot;); &#125; public static void main(String[] args) &#123; Hello a=new Hello(); Hello b=new Hello(&quot;as&quot;,1); System.out.print(b.s); System.out.print(a.s); Hello c=new Hello(); Hello d=new Hell(); c.print(); d.print(); d.print2(); ((Hell)d).print3(); &#125;&#125;class Hell extends Hello&#123; public void print() &#123; System.out.print(&quot;234&quot;); &#125; public void print3() &#123; System.out.println(&quot;12345&quot;); &#125; &#125; 静态初始化块，和初始化块 12345678910111213141516171819202122232425262728293031323334package Hello;public class Hello &#123; static int a; int b; static&#123; System.out.println(&quot;静态初始化块&quot;); a=6; // b=2;这个地方会报错 &#125; &#123; int b=6; if (b&gt;4) &#123; System.out.println(&quot;lss&quot;); &#125; System.out.println(a); &#125; &#123; System.out.println(&quot;第二个构造器&quot;); &#125; public Hello() &#123; System.out.println(&quot;构造器&quot;); &#125; public static void main(String[] args) &#123; Hello a=new Hello(); &#125;&#125; 数字转字符串 String b&#x3D;5+””; equals和&#x3D;&#x3D;的使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package Hello;class Person&#123; private String name; public Person(String name) &#123; this.name=name; &#125;&#125;public class Hello &#123;public static void main(String[] args) &#123; Person p=new Person (&quot;123&quot;); System.out.println(p.toString()); System.out.println(p); System.out.println(p+&quot;123&quot;); int it =65; float fl=65.0f; char ch=&#x27;A&#x27;; if(it==fl) &#123; System.out.print(&quot;相等&quot;); &#125; if(ch==it) &#123; System.out.println(&quot;相等&quot;); &#125; Hello a=new Hello(); Hello b=new Hello(); if(a==b) &#123; System.out.println(&quot;相等&quot;); &#125; else &#123; System.out.println(&quot;不相等&quot;); &#125; if(a.equals(b)) &#123; System.out.println(&quot;相等&quot;); &#125; else &#123; System.out.println(&quot;不相等&quot;); &#125; String H=&quot;123&quot;; String G=&quot;345&quot;; String I=&quot;123345&quot;; String T=H+G; String R=new String(&quot;123&quot;); if(H==R) &#123; System.out.println(&quot;相等1&quot;); &#125; if(T==I) &#123; System.out.println(&quot;相等2&quot;); &#125; if(H.equals(R)) &#123; System.out.println(&quot;相等1&quot;); &#125; if(T.equals(I)) &#123; System.out.println(&quot;相等2&quot;); &#125; &#125;&#125; 1O:12:&quot;Road_is_Long&quot;:2:&#123;s:6:&quot;string&quot;;O:13:&quot;Make_a_Change&quot;:1:&#123;s:6:&quot;effort&quot;;O:13:&quot;Try_Work_Hard&quot;:1:&#123;s:3:&quot;var&quot;;s:52:&quot;php://filter/convert.base64-encode/resource=flag.php&quot;;&#125;&#125;s:4:&quot;page&quot;;O:12:&quot;Road_is_Long&quot;:2:&#123;s:6:&quot;string&quot;;N;s:4:&quot;page&quot;;N;&#125;&#125; 1O:12:&quot;Road_is_Long&quot;:2:&#123;s:6:&quot;string&quot;;N;s:4:&quot;page&quot;;O:12:&quot;Road_is_Long&quot;:2:&#123;s:6:&quot;string&quot;;O:13:&quot;Make_a_Change&quot;:1:&#123;s:6:&quot;effort&quot;;O:13:&quot;Try_Work_Hard&quot;:1:&#123;s:3:&quot;var&quot;;s:52:&quot;php://filter/convert.base64-encode/resource=flag.php&quot;;&#125;&#125;s:4:&quot;page&quot;;s:3:&quot;aaa&quot;;&#125;&#125; final的使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package Hello;class Person&#123; private String name; public static int a=1; public int c=1; final static int d; static&#123; a=2; //b=2; d=1; &#125; public Person(String name) &#123; this.name=name; &#125; public void print() &#123; final int h=1; //public int y=1; int x=1; &#125; public static void print1(final int i) &#123; final int a=1; //i=1; &#125;&#125;public class Hello &#123; public final void test()&#123; &#125; public final void test(String name) &#123; &#125;public static void main(String[] args) &#123; Person b=new Person(&quot;1&quot;); System.out.println(b.a); System.out.println(Person.a); final int[] iArr= &#123;5,6,12,9&#125;; iArr[2]=10; //iArr=null; final Person p=new Person(&quot;1&quot;); p.a=123; String str2=&quot;java&quot;; String str3=&quot;com&quot;; final String str=&quot;java&quot;; final String str1=&quot;com&quot;; String s1=&quot;javacom&quot;; System.out.println(str+str1==s1); System.out.println(str2+str3==s1); &#125;&#125; 有关强制类型转换基本类型之间的转换只能在数值类型之间间进行，这里所说的数值类型包括整数型，字符型和浮点型，但数值类型和字符串类型和布尔类型是不能进行类型转换的 总结：父类引用可以指向子类对象，子类引用不能指向父类对象。把子类对象直接赋给父类引用叫做向上转型，向上转型不用强制转型，如Father f1&#x3D;new Son()，把指向子类对象的父类引用赋给子类引用叫做向下转型，要强制转型，如Son s1 &#x3D; (Son)f1。向上转型会丢失子类特有的方法，但是子类overriding父类的方法，子类方法有效。 将一种类型的数据赋给另外一种类型变量时，满足下列两种要求将执行自动类型转换：1.两种类型是兼容的；2.目的类型的范围比来源类型大。 数据值类型按照范围从小到大为：byte，short，char，int，long，float，double 例如int类型比所有byte合法类型大，因此不要求显式强制类型转换。对于数字类型，整型和浮点型都是彼此兼容的，但是数字类型和字符类型和布尔类型是不兼容的，字符类型和布尔类型也不是互相兼容的。 自动类型转换不能满足所有的转换需求，比如int型变量赋值给byte型变量，这种转换不会自动进行，因为byte型比int型范围小。为了完成两种不兼容类型转换，需要用到强制类型转换。 目标类型指定了要转换成为的类型。例如果将int型转为byte型，int型取值范围大于byte型，它的值将堆byte型范围进行取模。而把浮点型赋值给整数型，就会出现截断，截取掉小数部分。从其他数值类型转换为char类型时，必须进行强制转换。将char类型转换为其他数值类型时，除了byte、short必须强制转换之外，int、long、float、double都不用强制转换。 类型转换都是小范围向大范围转换的，大范围往小范围转化需要用到强制转换，转换后的值会有所损失。 String 与其他数据类型的转换String to int int i&#x3D;Integer.parseInt(str); int to String String s&#x3D;String.valueOf(i); String to Array char []a&#x3D;str.toCharArray(); char []a&#x3D;str.getChars(0,str.length,anArray,0); Array toString String str&#x3D;new String(anArray); char to String 123 char b=&#x27;2&#x27;;String a=String.valueOf(b); System.out.println(a); String to char charAt()和toCharArray() java的Big数字类java的BigDecimal类方法声明public BigDecimal add (BigDecinal value) 加法运算 public BigDecimal subtract (BigDecimal value)减法运算 public BigDecimal multiply(BigDecimal value)乘法运算 public BigDecimal divide (BigDecimal value)除法运算 精确的计算小数之间的加减乘除 1234567891011121314151617import java.math.BigDecimal;import java.util.Scanner;public class Main&#123; public static void main(String []args)&#123; Scanner in=new Scanner(System.in); while(in.hasNext())&#123; String a=in.next(); String b=in.next(); BigDecimal a1=new BigDecimal(a); BigDecimal a2=new BigDecimal(b); System.out.println(a2.add(a1));//求两个相加 System.out.println(a2.multiply(a1));//求两个的乘积 &#125; &#125;&#125; java的BigInteger类12345678910111213141516171819202122import java.math.BigInteger;import java.util.Arrays;import java.util.Scanner;public class Main&#123; public static void main(String []args)&#123; BigInteger a=new BigInteger(&quot;0&quot;); Scanner in=new Scanner(System.in); while(in.hasNext()) &#123; String key=in.nextLine(); if(key.equalsIgnoreCase(&quot;e&quot;)) &#123; break; &#125; a=a.add(new BigInteger(key));//求相加&#125; System.out.println(a);&#125;&#125; 一.BigInteger简介 BigInteger类所在的包 java中可以使用BigInteger操作大整数，也可以转换进制。如果在操作的时候一个整型数据已经超过了整数的最大类型长度long的话，则此数据就无法装入，所以，此时要使用BigInteger类进行操作。这些大数都会以字符串的形式传入。 二.BigInteger类常用方法 1.BigInteger(String value)：构造方法，将value字符串变成BigInteger类型数据。 2.BigInteger add(BigInteger value)：加法，求两个BigInteger类型数据的和。 3.BigInteger subtract(BigInteger value)：减法，求两个BigInteger类型数据的差。 4.BigInteger multiply(BigInteger value)：乘法，求两个BigInteger类型数据的积。 5.BigInteger divide(BigInteger divisor)：除法，求两个BigInteger类型数据的商。 6.BigInteger modInverse(BigInteger m)：求模，求BigInteger类型数据对m求模。 7.BigInteger remainder(BigInteger divisor)：求余数，求BigInteger类型数据除以divisor的余数。 8.BigInteger max(BigInteger value)：最大数，求两个BigInteger类型数据的最大值。 9.BigInteger min(BigInteger value)：最小数，求两个BigInteger类型数据的最小值。 10.BigInteger gcd(BigInteger value)：最大公约数，求两个BigInteger类型数据的最大公约数。 11.BigInteger abs()：绝对值，求BigInteger类型数据的绝对值。 12.BigInteger negate()：相反数，求BigInteger类型数据的相反数。 123456789101112131415161718192021222324252627282930 BigInteger a = new BigInteger(&quot;15&quot;);BigInteger b = new BigInteger(&quot;10&quot;);BigInteger c = new BigInteger(&quot;-10&quot;);BigInteger d = new BigInteger(&quot;2&quot;);BigInteger add_result = a.add(b);BigInteger subtract_result = a.subtract(b);BigInteger multiply_result = a.multiply(b);BigInteger divide_result = a.divide(b);BigInteger modinverse_result = a.modInverse(d);BigInteger remainder_result = a.remainder(b);BigInteger max_result = a.max(b);BigInteger min_result = a.min(b);BigInteger gcd_result = a.gcd(b);BigInteger abs_result = c.abs();BigInteger negate_result = a.negate();Log.d(&quot;TAG&quot;, &quot;15+10=&quot; + add_result);Log.d(&quot;TAG&quot;, &quot;15-10=&quot; + subtract_result);Log.d(&quot;TAG&quot;, &quot;15*10=&quot; + multiply_result);Log.d(&quot;TAG&quot;, &quot;15/10=&quot; + divide_result);Log.d(&quot;TAG&quot;, &quot;15对2求模=&quot; + modinverse_result);Log.d(&quot;TAG&quot;, &quot;15/10余数=&quot; + remainder_result);Log.d(&quot;TAG&quot;, &quot;15和10最大数=&quot; + max_result);Log.d(&quot;TAG&quot;, &quot;15和10最小数=&quot; + min_result);Log.d(&quot;TAG&quot;, &quot;15和10最大公约数=：&quot; + gcd_result);Log.d(&quot;TAG&quot;, &quot;-10的绝对值=&quot; + abs_result);Log.d(&quot;TAG&quot;, &quot;15的相反数=&quot; + negate_result); Java String类总序java中的字符串分为两类，字符串常量和字符串变量 字符串常量：包括直接字符串常量和String类的对象；字符串常量的值一旦创建不会再改动 字符串变量：指的是StringBuffer类的对象，创建之后允许对其进行修改 字符串文本 1234567String str1=&quot;java&quot;; 相当于 char cstr[]= &#123;&#x27;J&#x27;,&#x27;a&#x27;,&#x27;v&#x27;,&#x27;a&#x27;&#125;; String str=new String(cstr); System.out.println(str);把字符数组转变为字符串的一个方法 2.String str1&#x3D;new String(“hello”); 3.使用数组方式 char str[]&#x3D;{‘h’,’e’,’l’,’l’,’0’}; String str[]&#x3D;{“hello”,”word”,”!”} String类的构造方法 例子 n在String类提供的构造方法中，可以由字符数组、字节数组以及字符串缓冲区来构成字符串，如下面的代码所示。 char cDeomo[]&#x3D; {‘2’,’3’,’4’,’5’}; char cDeomo1[]&#x3D; {‘1’,’2’,’3’,’4’,’5’}; String strDemo1&#x3D;new String(cDeomo); String strDemo2&#x3D;new String(cDeomo1,1,4);&#x2F;&#x2F;从cDeomo1的下标1元素到下标为4的元素 System.out.println(strDemo1); System.out.println(strDemo2); 利用上面的两个构造方法生成的字符串实例的内容均为“2345”。 n下面例子说明如何利用字节数组生成字符串： byte cDemo[]&#x3D; {66,67,68};byte cDemo1[]&#x3D; {65,66,67,68};String strDemo1&#x3D;new String(cDemo);String strDemo2&#x3D;new String(cDemo1,1,3);&#x2F;&#x2F;从下标1到下标3 都包括刚开始第一个下标的那个字符System.out.println(strDemo1);System.out.println(strDemo2);&#x2F;&#x2F;会把数字转换为unicode编码的字符 利用上面的两个构造方法生成的字符串实例的内容均为”BCD” length方法1234String str=&quot;java&quot;;System.out.println(str.length());获取字符串长度 getChars方法public void getChars(int start,int end,char c[],int offset) ​ 该方法的作用是将当前字符串从start到end-1位置上的字符复制到字符数组c中，并从c的offset处开始存放 就是将字符串从下标为start到下标为end-1的字符从c字符数组的offset下标处开始存放 String str&#x3D;”java”;char dstch[]&#x3D;new char[20];int n&#x3D;str.length();str.getChars(0, n, dstch, 0);System.out.println(dstch); 都包括第一个下标开始的那个字符 compareTo方法String类是默认实现的comparable接口的compareTo方法 用于字符串比较 int compareTo(String str) 例如:字符串A和字符串B进行比较,如果A大于B,返回大于0的值;如果A等于B,返回0; 如果A小于B,返回小于0的值。 ​ A.compareTo(B); 即参与比较的两个字符串如果首字符相同，则比较下一个字符，直到有不同的为止，返回该不同的字符的ASCII码差值； 是A字符串字符的ascii编码减去B字符串字符的ascii编码 如果两个字符串不一样长，可以参与比较的字符又完全一样，则返回两个字符串的长度差值 String str&#x3D;”abcde”;System.out.println(str.compareTo(“boy”));System.out.println(str.compareTo(“aba”));System.out.println(str.compareTo(“abcdefghi”)); 运行结果 -12-4 使用例子 12345678public int compareTo(Student o1) &#123; if(o1.getScore()==this.getScore()) &#123; return this.id.compareTo(o1.id); &#125; else &#123; return o1.getScore()-this.getScore(); &#125;&#125; 先按成绩降序排序，当成绩相同的时候按照id来自然排序 concat方法n将调用该方法的字符串与指定字符串连接，返回新的字符串。 String str1&#x3D;”java”;String str2&#x3D;”world”;String str3;str3&#x3D;str1.concat(str2);System.out.println(str3);&#x2F;&#x2F;javaworld substring方法n用于提取调用方法的字符串中的子串。 String substring (int begin, int end)； 提取从begin到end-1处的字符。就是第二个参数是下标减一 String str1&#x3D;”java”,str2&#x3D;”world”,str3;str3&#x3D;str1.concat(str2);System.out.println(str3.substring(0,3)+” “+str3.substring(4,9)); 运行结果：jav world 当substring方法只有一个参数的时候 它是此字符串的一个子字符串。该子字符串从指定索引处的字符开始，直到此字符串末尾。 String str1&#x3D;”java”,str2&#x3D;”world”,str3;str3&#x3D;str1.concat(str2);System.out.println(str3.substring(2)); 运行结果：vaworld 包括这个第一个下标开始的那个字符 replace方法返回一个新字符串 n用于替换调用方法在字符串中的某个字符，返回替换后的新字符串。 String replace(char oldChar, char newChar)； String str1&#x3D;”java world”,str3;str3&#x3D;str1.replace(‘a’,’b’);System.out.println(str3); 运行结果： jbvb world trim方法返回一个新字符串 npublic String trim() 一个字符串s 通过调用方法trim()得到一个字符串对象,该字符串对象是s去掉前后空格后的字符串。 如下面的代码所示： String s&#x3D;”I mist theep “;String temp&#x3D;s.replace(‘t’, ‘s’);String a&#x3D;” i am a student “;String tema&#x3D;s.trim();System.out.println(temp);System.out.println(tema); indexOf方法indexOf, lastIndexOf: 这两个方法用于对字符串建立索引，返回字符串的位置； int indexOf(String str)；&#x2F;&#x2F;这个是返回第一个遇到的索引，两个都是返回匹配的字符串的第一个字符的索引值 int lastIndexOf(String str);&#x2F;&#x2F;这个是返回从最后开始遇到的索引 String str1&#x3D;”java world or”;String str2&#x3D;”or”;int v1&#x3D;str1.indexOf(str2);int v2&#x3D;str1.lastIndexOf(str2);System.out.println(v1+” “+v2); 运行结果：6 11 equals方法在String类中equals()定义如下： public boolean equals(String s) 该方法用来比较当前字符串对象的实体是否与参数指定的字符串s的实体是否相同。例如 String tom&#x3D;new String( “we are students”); String boy&#x3D;new String( “We are students”); String jerry&#x3D; new String(“we are students”); tom.equals(boy)的值是false，tom.equals(jerry)的值是true 而且字符串之间进行比较不能够用&#x3D;&#x3D;，因为&#x3D;&#x3D;是比较两个字符串的地址是否相同，而equals是比较两个字符串的内容是否是相等的 &#x3D;&#x3D;比较引用，equals 比较值 1、java中字符串的比较：&#x3D;&#x3D; 我们经常习惯性的写上if(str1&#x3D;&#x3D;str2)，这种写法在java中可能会带来问题 example1: 1String a=&quot;abc&quot;;String b=&quot;abc&quot; 那么a&#x3D;&#x3D;b将返回true。因为在java中字符串的值是不可改变的，相同的字符串在内存中只会存 一份，所以a和b指向的是同一个对象； example2： 1String a=new String(&quot;abc&quot;); String b=new String(&quot;abc&quot;); 那么a&#x3D;&#x3D;b将返回false，此时a和b指向不同的对象。 2、用equals方法比较的是字符串的内容是否相同， example： 123String a=new String(&quot;abc&quot;); String b=new String(&quot;abc&quot;); a.equals(b); 将返回true。 equalsIgnoreCase()方法n在String类中equalsIgnoreCase ()定义如下： public boolean equalsIgnoreCase(String s) 字符串对象调用比较当前字符串对象是否与参数指定的字符串s 相同,比较时忽略大小写。例如： String tom&#x3D;new String(“ABC”);String Jerry&#x3D;new String(“abc”);System.out.println(tom.equals(Jerry)); tom.equalsIgnoreCase(Jerry)的值是true。 split方法1public String[] split(String regex, int limit) 根据第一个参数的字符串将字符串分割为第二个参数的份数变成字符串数组 第一个参数一定是一个字符串用双引号 String [] c&#x3D;b[i].split(“：”);用冒号将字符串分割为字符串数组afd Integer.parseInt将字符串转换为数字 startsWith方法 prefix – 前缀。 toffset – 字符串中开始查找的位置。 12345public boolean startsWith(String prefix, int toffset)或public boolean startsWith(String prefix) toUpperCase()String cc &#x3D; “aBc123”.toUpperCase(); 结果就是：ABC123 Java中StringBuffer类构造方法StringBuffer中提供了三种构造方法 public StringBuffer() 构造一个不包含字符的字符串缓冲区，其初始的容量设为 16 个字符。 public StringBuffer(int) 构造一个不包含字符的字符串缓冲区，其初始容量由参数设定。 public StringBuffer(String) 构造一个字符串缓冲区，来表示和字符串参数相同的字符序列。 字符串缓冲区的初始容量为16加上字符串参数的长度。 capacity方法n用来计算StringBuffer的容量，返回容量大小的整型值。 StringBuffer sb&#x3D;new StringBuffer(100);int x&#x3D;sb.capacity();System.out.println(x); 运算结果：100 容量是一开始那个有的那个，而不是有内容的，可以是空的默认值 append方法n将指定的字符串的内容连接到StringBuffer对象中内容的后边，并返回连接后的的StringBuffer对象。 StringBuffer append(String str); StringBuffer sb1&#x3D;new StringBuffer(“Hello”);StringBuffer sb2&#x3D;new StringBuffer(“all”);String str&#x3D;”_good”;sb2&#x3D;sb1.append(str);System.out.println(sb2); 运行结果：Hello_good insert方法n将指定的字符ch插入到StringBuffer对象的offset处，并返回修改后的StringBuffer对象。 StringBuffer insert（int offset, char ch） StringBuffer sb1=new StringBuffer(&quot;Hello&quot;); char c=&#39;2&#39;; StringBuffer sb2=new StringBuffer(100); sb2=sb1.insert(1,c); System.out.println(sb2); insert的第一个参数是要插入的字符的下标 delete方法n将StringBuffer对象中的一部分内容删掉，并将删除后的StringBuffer对象返回。 StringBuffer delete(int start, int end); 从start 删除到 end-1； StringBuffer sb1&#x3D;new StringBuffer(“Hello”);StringBuffer sb2&#x3D;new StringBuffer(100);sb2&#x3D;sb1.delete(1, 3);System.out.println(sb2); 运行结果：Hlo reverse方法n将StringBuffer中的内容颠倒过来； StringBuffer reverse(); StringBuffer sb1&#x3D;new StringBuffer(“Hello”);sb1&#x3D;sb1.reverse();System.out.println(sb1); 结果为：olleH java中数组数组的声明需要提供数组元素的类型和数组的维数。 例如： int[] k; &#x2F;&#x2F;int型一维数组 ​ String s[]; 数组声明注意test 123456789101112131415161718package Main;import java.util.Scanner;class Main&#123; public static void main(String []args)&#123; int arr[]= &#123;1,3,2,4,5,6,7&#125;; int arr2[]= &#123;1,2,3,4&#125;; arr=arr2;//arr 也变成1,2,3,4 for(int i=0;i&lt;arr.length;i++) &#123; System.out.println(arr[i]); &#125; arr[0]=100; System.out.println(arr2[0]);//说明arr=arr2之后两个数组指向同一个内存地址 &#125;&#125; 创建数组对象使用关键字new； 例如：new int [5]; ​ new String [6][5]; &#x2F;&#x2F;创建String 型二维数组 创建后，需要将相应类型的数组引用指向该对象，才能对数组对象进行操作。 例如：int[] k; &#x2F;&#x2F;int型一维数组 ​ String[][] s; ​ k&#x3D;new int [5]; ​ s&#x3D;new String[6][5]; 枚举初始化例子：TestArray.java 循环初始化：TestArray.java 枚举初始化： 例如： int[] i&#x3D;{1,3,5,7,9}; ​ int[] i&#x3D;new int[]{1,3,5,7,9}; 数组排序整个数组排序 public static void sort (int[] a)； 对指定的数组区间进行排序 public static void sort (int[] a, int fromIndex, int toIndex)；这个第二个参数是最后一个下标减一 int a[]&#x3D; {1,2,3,5,4};Arrays.sort(a);for(int i:a){ System.out.println(i);} } 查找指定元素nJava中也提供binarySearch方法来帮助开发人员进行查找操作，该方法格式如下所示。 public static int binarySearch(int[ ] a,int key)； 方法的object[]参数是要查找的数组，key参数为要查找的key值。 方法的返回值有几种： 1.找到的情况下：如果key在数组中，则返回搜索值的索引。 2.找不到的情况下： [1] 搜索值不是数组元素，且在数组范围内，从1开始计数，得“ - 插入点索引值”； [2] 搜索值是数组元素，从0开始计数，得搜索值的索引值； [3] 搜索值不是数组元素，且大于数组内元素，索引值为 – (length + 1); [4] 搜索值不是数组元素，且小于数组内元素，索引值为 – 1。 这个binarySearch方法必须是按照从小到大的顺序排的元素才能够算是key在数组中，如果有小的数跟在最后面就是找不到的情况下的第一种情况 123456 int a[] = new int[] &#123;1, 3, 4, 6, 8, 9&#125;; int x1 = Arrays.binarySearch(a, 5); int x2 = Arrays.binarySearch(a, 4); int x3 = Arrays.binarySearch(a, 0); int x4 = Arrays.binarySearch(a, 10);x1=-4 x2=2 x3=-1 x4=-7结果 数组利用比较器排序注意点：这个数组必须是Integer这种对象类型的而不是int基本类型 同时自己设计的比较器需要实现Comparator接口，当下面例子这种形式的时候是从小到大排序 将第一个if返回值变为-1 第二个elseif返回值变为1就可以实现从大到小排序 1234567891011121314151617181920212223242526272829303132package Main;import java.util.Arrays;import java.util.Comparator;import java.util.Scanner;class compare implements Comparator&lt;Integer&gt;&#123; @Override public int compare(Integer o1, Integer o2) &#123; if(o1&gt;o2) &#123; return 1; &#125; else if(o1&lt;o2) &#123; return -1; &#125; else &#123; return 0; &#125; &#125;&#125;class Main&#123; public static void main(String []args) &#123; Integer []a= &#123;1,3,4,2,5&#125;;//这里必须使用Integer Comparator c=new compare(); Arrays.sort(a,c);for(int i:a) &#123; System.out.println(i);&#125; &#125;&#125; Java Character类中的方法Character类在java.lang包下所以不需要自己去导入 isLower(Upper)Case和to(Upper)Case方法作用：是转大小写或者判断是否是大写或者小写 char cstr[]&#x3D; {‘j’,’a’,’v’,’a’};System.out.println(Character.isUpperCase(cstr[0]));System.out.println(Character.isLowerCase(cstr[0]));cstr[1]&#x3D;Character.toUpperCase(cstr[1]);System.out.println(cstr[1]);cstr[1]&#x3D;Character.toLowerCase(cstr[1]);System.out.println(cstr[1]); java.lang包下的类是默认自动导入的，character类就是在java.lang包下，以及java.lang包下的自包还是不可以被默认导入，如果用到里面的类需要自己手动导入 转大小写的时候不会把原来的字符变为大写或小写，但可以重新赋值 isDigit方法确定指定字符是否为数字 Character a=&#39;2&#39;; System.out.println(Character.isDigit(a)); 输出的结果是true isLetter方法 确定指定字符是否为字母。 1234Character a=&#x27;a&#x27;; System.out.println(Character.isLetter(a)); 输出结果为true equals方法 Character a=&#39;a&#39;; Character b=&#39;b&#39;; System.out.println(a.equals(b)); 输出结果为faulse 两个基本类型字符（用char定义的，或者char数组中的）之间可以直接进行&#x3D;&#x3D;，!&#x3D;之间的比较，两个Character对象字符之间不能够用&#x3D;&#x3D; !&#x3D;得用equals 123456Character a=new Character(&#x27;a&#x27;);Character b=new Character(&#x27;a&#x27;);System.out.println(a==b);System.out.println(a.equals(b));结果：false true 123456789101112Character a=&#x27;a&#x27;;Character b=&#x27;a&#x27;;char c=&#x27;a&#x27;;char d=&#x27;a&#x27;;System.out.println(a==b);System.out.println(a.equals(b));System.out.println(c==d);//System.out.println(c.equals(d));结果：基本类型不能调用很多方法，可以用Character引用变量去指向基本类型truetruetrue 字符数组String str&#x3D;”java”;char dstch[]&#x3D;new char[20];int n&#x3D;str.length();str.getChars(0, n, dstch, 0);System.out.println(dstch); 结果：java java random类的使用random类不在java.lang包下，所以需要自己去导入 import java.util.Random; Random类的构造方法Random类包含两个构造方法，下面依次进行介绍：（1）public Random()该构造方法使用一个和当前系统时间对应的相对时间有关的数字作为种子数，然后使用这个种子数构造Random对象。（2）public Random(long seed)该构造方法可以通过制定一个种子数进行创建。示例代码：Random r &#x3D; new Random();Random r1 &#x3D; new Random(10);再次强调：种子数只是随机算法的起源数字，和生成的随机数字的区间无关。 Random有两种构造方法：1.Random()，用于创建一个伪随机数生成器，无参构造，每次生成的随机数是不同的。程序示例： 12345678Random r=new Random();//随机生成10个[0,100)之间的数for(int i=0;i&lt;10;i++)&#123;System.out.println(r.nextInt(100));&#125; 每次运行生成的随机数都是不同的 2.Random(long seed)，使用一个long型的seed种子创建伪随机数生成器 ，有参构造，每次生成的随机数相同。 12345678Random r=new Random(13); //创建对象时传入种子//随机生成10个[0,100)之间的数for(int i=0;i&lt;10;i++)&#123;System.out.println(r.nextInt(100));&#125; 每次运行生成的随机数都是相同的 nextBoolan方法该方法的作用是生成一个随机的boolean值，生成true和false的值几率相等，也就是都是50%的几率。 Random a=new Random(); System.out.println(a.nextBoolean()); nextDouble方法该方法的作用是生成一个随机的double值，数值介于[0,1.0)之间。 Random a=new Random(); System.out.println(a.nextDouble()); 也可以自己指定范围生成 1234567（2）生成[0,5.0)区间的小数double d2 = r.nextDouble() * 5;因为nextDouble方法生成的数字区间是[0,1.0)，将该区间扩大5倍即是要求的区间。同理，生成[0,d)区间的随机小数，d为任意正的小数，则只需要将nextDouble方法的返回值乘以d即可。（3）生成[1,2.5)区间的小数double d3 = r.nextDouble() * 1.5 + 1;生成[1,2.5)区间的随机小数，则只需要首先生成[0,1.5)区间的随机数字，然后将生成的随机数区间加1即可。同理，生成任意非从0开始的小数区间[d1,d2)范围的随机数字(其中d1不等于0)，则只需要首先生成[0,d2-d1)区间的随机数字，然后将生成的随机数字区间加上d1即可。 就是在原本的基础上乘以多少就可以变成原本的多少倍 nextInt方法该方法的作用是生成一个随机的int值，该值介于int的区间，也就是-231到231-1之间。 Random a=new Random(); System.out.println(a.nextInt()); 同时可以自己指定生成整数的范围 生成[0,10)区间的整数 Random a&#x3D;new Random(); System.out.println(a.nextInt(10)); 生成[0,10]区间的整数 Random a&#x3D;new Random(); System.out.println(a.nextInt(11)); 生成[-3,15)区间的整数 Random a&#x3D;new Random(); System.out.println(a.nextInt(18)-3); java中Math类不用导入包 静态常量Math 类中包含 E 和 PI 两个静态常量，正如它们名字所暗示的，它们的值分别等于 e（自然对数）和 π（圆周率）。 调用 Math 类的 E 和 PI 两个常量，并将结果输出。代码如下： 1System.out.println(&quot;E 常量的值：&quot; + Math.E);System.out.println(&quot;PI 常量的值：&quot; + Math.PI); 执行上述代码，输出结果如下： 12E 常量的值：2.718281828459045PI 常量的值：3.141592653589793 System.out.println(Math.E);System.out.println(Math.PI); 求最大值、最小值和绝对值在程序中常见的就是求最大值、最小值和绝对值问题，如果使用 Math 类提供的方法可以很容易实现。这些方法的说明如表 1 所示。 就是比较的时候两个数字的数字类型一定要相同，这些函数只能是在两个数之间进行比较 求 10 和 20 的较大值、15.6 和 15 的较小值、-12 的绝对值，代码如下： 12纯文本复制public class Test02 &#123; public static void main(String[] args) &#123; System.out.println(&quot;10 和 20 的较大值：&quot; + Math.max(10, 20)); System.out.println(&quot;15.6 和 15 的较小值：&quot; + Math.min(15.6, 15)); System.out.println(&quot;-12 的绝对值：&quot; + Math.abs(-12)); &#125;&#125; 该程序的运行结果如下： 12310和20的较大值：2015.6和15的较小值：15.0-12的绝对值：12 求整运算Math 类的求整方法有很多，详细说明如表 2 所示。 &#96;&#96;&#96;import java.util.Scanner;public class Test03 {public static void main(String[] args) { Scanner input &#x3D; new Scanner(System.in); System.outprintln(“请输入一个数字：”); double num &#x3D; input.nextDouble(); System.out.println(“大于或等于 “+ num +” 的最小整数：” + Math.ceil(num)); System.out.println(“小于或等于 “+ num +” 的最大整数：” + Math.floor(num)); System.out.println(“将 “+ num +” 加上 0.5 之后最接近的整数：” + Math.round(num)); System.out.println(“最接近 “+num+” 的整数：” + Math.rint(num)); }12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 Double a=1.0; System.out.println(Math.ceil(a)); System.out.println(Math.floor(a)); System.out.println(Math.rint(a)); System.out.println(Math.round(a));//当距离两个整数一样的时候取那个小的# Java Scanner 类2022-01-25 14:23 更新java.util.Scanner是Java5的新特征，我们可以通过 Scanner 类来获取用户的输入。下面是创建 Scanner 对象的基本语法： Scanner s &#x3D; new Scanner(System.in); 1234567接下来我们演示一个最简单的的数据输入，并通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据：### 使用 next 方法： import java.util.Scanner; public class ScannerDemo { public static void main(String[] args) { Scanner scan &#x3D; new Scanner(System.in); &#x2F;&#x2F; 从键盘接收数据 //next方式接收字符串 System.out.println(&quot;next方式接收：&quot;); // 判断是否还有输入 if(scan.hasNext())&#123; String str1 = scan.next(); System.out.println(&quot;输入的数据为：&quot;+str1); &#125; &#125; } 123执行以上程序输出结果为： $ javac ScannerDemo.java$ java ScannerDemonext方式接收：youj com输入的数据为：youj 12345可以看到 com 字符串并未输出，接下来我们看 nextLine。### 使用 nextLine 方法： import java.util.Scanner; public class ScannerDemo &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); // 从键盘接收数据 //nextLine方式接收字符串 System.out.println(&quot;nextLine方式接收：&quot;); // 判断是否还有输入 if(scan.hasNextLine())&#123; String str2 = scan.nextLine(); System.out.println(&quot;输入的数据为：&quot;+str2); &#125; &#125; &#125; 1 执行以上程序输出结果为：$ javac ScannerDemo.java $ java ScannerDemo nextLine方式接收： youj com 输入的数据为：youj com 可以看到 com 字符串输出。 12345678910111213141516171819### next()与nextLine()区别**next():**- 1、一定要读取到有效字符后才可以结束输入。- 2、对输入有效字符之前遇到的空白，next()方法会自动将其去掉。- 3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。- next()不能得到带有空格的字符串。**nextLine()：**- 1、以Enter为结束符,也就是说nextLine()方法返回的是输入回车之前的所有字符。- 2、可以获得空白。如果要输入int或float类型的数据，在Scanner类中也有支持，但是在输入之前最好先使用 hasNextXxx() 方法进行验证，再使用 nextXxx() 来读取： import java.util.Scanner; public class ScannerDemo { public static void main(String[] args) { Scanner scan &#x3D; new Scanner(System.in); &#x2F;&#x2F; 从键盘接收数据 int i &#x3D; 0 ; float f &#x3D; 0.0f ; System.out.print(“输入整数：”); if(scan.hasNextInt()){ &#x2F;&#x2F; 判断输入的是否是整数 i &#x3D; scan.nextInt() ; &#x2F;&#x2F; 接收整数 System.out.println(“整数数据：” + i) ; }else{ &#x2F;&#x2F; 输入错误的信息 System.out.println(“输入的不是整数！”) ; } System.out.print(“输入小数：”); if(scan.hasNextFloat()){ &#x2F;&#x2F; 判断输入的是否是小数 f &#x3D; scan.nextFloat() ; &#x2F;&#x2F; 接收小数 System.out.println(“小数数据：” + f) ; }else{ &#x2F;&#x2F; 输入错误的信息 System.out.println(“输入的不是小数！”) ; } }} 123执行以上程序输出结果为： $ javac ScannerDemo.java$ java ScannerDemo输入整数：12整数数据：12输入小数：1.2小数数据：1.2 12345678910111213一个字节八比特，一个byte八位## java SimpleDateFormat类**1、为什么要使用SimpleDateFormat？**在Java中，如果我们想获取当前时间，一般会使用Date类的无参构造函数，如下所示，我们获取到当前时间并输出： import java.util.Date; public class SimpleDateFormatDemo { public static void main(String[] args) { Date currentTime &#x3D; new` `Date(); System.out.println(currentTime); &#x2F;&#x2F; 输出：Mon Feb 18 10:24:30 CST 2019 }&#96;&#96;} 123456789101112131415161718192021此时我们会发现， 输出的格式并不是我们预期的格式，一般情况下，我们希望的格式都是类似于2019-02-18，2019-02-18 10:24:30，2019/02/18这样的，此时我们就需要用到java.text.SimpleDateFormat来自定义格式。**2.使用format()方法将日期转换为字符串**使用format()方法，我们可以将日期类型转换为自己自定义的字符串格式，如2019-02-18，2019/02/18，2019-02-18 10:24:30等，自定义格式如下表所示：| 格式 | 释义 | 举例 || ---- | -------------- | ------------ || yyyy | 年 | 2019 || MM | 月 | 02 || dd | 日 | 18 || HH | 小时(24小时制) | 13，下午一点 || mm | 分钟 | 53 || ss | 秒 | 42 || SSS | 毫秒 | 629 | package com.zwwhnly.springbootdemo; import java.text.SimpleDateFormat;import java.util.Date;` `public class SimpleDateFormatDemo &#123; public static void main(String[] args) &#123; Date currentTime = new Date(); System.out.println(currentTime); // Mon Feb 18 13:53:50 CST 2019` ` SimpleDateFormat simpleDateFormat1 &#x3D; new` `SimpleDateFormat(“yyyy-MM-dd HH:mm:ss.SSS”); SimpleDateFormat simpleDateFormat2 = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); SimpleDateFormat simpleDateFormat3 &#x3D; new` `SimpleDateFormat(“yyyy&#x2F;MM&#x2F;dd”);` ` System.out.println(simpleDateFormat1.format(currentTime)); // 输出2019-02-18 13:53:50.629 System.out.println(simpleDateFormat2.format(currentTime)); &#x2F;&#x2F; 输出2019-02-18 System.out.println(simpleDateFormat3.format(currentTime)); // 输出2019/02/18 &#125;} 1234567**3.使用parse()方法将字符串转换为日期**在实际开发过程中，我们经常需要将字符串转换为日期类型，以进行后续操作，此时可以使用parse()方法，但需要**注意：如果字符串与指定的格式不匹配，会报java.text.ParseException异常**。 package com.zwwhnly.springbootdemo; import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date; public class SimpleDateFormatDemo { public static void main(String[] args) { try` `&#123; SimpleDateFormat simpleDateFormat1 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;); String strDate1 = “2019-02-18 13:58”; String strDate2 = “2019-02-18”;` ` Date date1 &#x3D; simpleDateFormat1.parse(strDate1); System.out.println(date1); Date date2 &#x3D; simpleDateFormat1.parse(strDate2); System.out.println(date2); } catch` `(ParseException e) &#123; e.printStackTrace(); &#125; &#125;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455运行结果如下图所示：![img](https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291918082.png)由此我们可以看到，strDate1格式匹配能正常转换为Date类型，而strDate2由于格式不匹配，抛出java.text.ParseException，正是因为如此，以上的代码才必须包括在try,catch语句中，否则IDEA会提示错误，代码也编译不通过，如下图所示：![img](https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291918064.png)## 抽象类和接口package Shape;public abstract class Shape &#123; &#123; System.out.println(&quot;执行Shapes初始化块..&quot;); &#125; private String color; public abstract double calPerimeter(); public abstract String getType(); public Shape() &#123;&#125; public Shape(String color) &#123; System.out.println(&quot;执行Shape的构造器&quot;); this.color=color; &#125;​ public interface Output&#123; int MAX_CACHE_LINE=50; void out(); void getData(String msg); default void print(String...msgs) &#123; for (String msg :msgs) &#123; System.out.println(&quot;默认的test()方法&quot;); &#125; &#125; default void test() &#123; System.out.println(&quot;test方法&quot;); &#125; static String staticTest() &#123; return &quot;接口里的类方法&quot;; &#125; &#125;&#125;多入参方式 public static void main(String[] args) { System.out.println(“test1:”); test(“a”,”b”,”c”); System.out.println(“test2:”); test(new String[] {“a”, “b”, “c”}); } /** * 测试方法 * @param params 参数 * */ public static void test(String... params)&#123; //遍历参数内容 for(String temp : params)&#123; System.out.println(temp); &#125; System.out.println(); 123定义这种类型的入参必须放到最后一个才可以，也就是说int入参需要放到可变入参的前面，同时再test1处增加一个String进行测试，看一下代码。 public static void main(String[] args) { System.out.println(“test1:”); test(1,”a”,”b”,”c”,”d”); System.out.println(“test2:”); test(2,new String[] {“a”, “b”, “c”}); } 12345678910111213141516171819202122​ /** * 测试方法 * @param params 参数 * */​ public static void test(int intParam,String... params)&#123;​ System.out.println(&quot;int:&quot;+intParam);​ //遍历参数内容​ for(String temp : params)&#123;​ System.out.println(temp);​ &#125;​ System.out.println();​ &#125;# java的内部类## 非静态内部类 package Shape; public class Shape{ private String prop&#x3D;”外部类的实例变量”; private class InClass{ private String prop&#x3D;”内部类的实例变量”; public void info() { String prop&#x3D;”局部变量”; System.out.println(Shape.this.prop); System.out.println(this.prop); System.out.println(prop); } } public void test() { InClass a&#x3D;new InClass(); a.info(); } public static void main(String[] args) { new Shape().test(); } } 123## 静态内部类 package Shape; public class Shape{ private int a&#x3D;1; private static int b&#x3D;2; static class show{ 123456789101112131415161718 private static int age=1; public int c=3; public void accessOuterProp() &#123; //System.out.println(a); System.out.println(b); &#125; &#125; public static void main(String[] args) &#123; System.out.println(show.age); System.out.println(new show().c); &#125; &#125;## 在外部类以外使用非静态内部类 package Shape; class Out{ class In{ public In(String msg){ System.out.println(msg); } }}public class Shape{ public static void main(String[] args) { Out.In in&#x3D;new Out().new In(“测试信息”); &#125; } 123## 在外部类以外使用静态内部类 package Shape; class StaticOut{ static class StaticIn{ public StaticIn() { System.out.println(“静态类内部的构造器”); } }}public class Shape{ public static void main(String[] args) { StaticOut.StaticIn in&#x3D;new StaticOut.StaticIn(); &#125; } 1234567891011121314151617181920212223242526272829## 使用静态内部类注意事项```javapackage Shape;class StaticOut&#123; private int a=1; private static int h=2; static class StaticIn&#123; public StaticIn() &#123; System.out.println(&quot;静态类内部的构造器&quot;); //System.out.println(a); StaticOut b= new StaticOut(); System.out.println(b.a); System.out.println(h); &#125; &#125;&#125;public class Shape&#123; public static void main(String[] args) &#123; StaticOut.StaticIn in=new StaticOut.StaticIn(); &#125;&#125; 匿名内部类1234567891011121314151617181920212223242526272829303132package Shape;interface Product&#123; public double getPrice(); public String getName();&#125;public class Shape&#123; private static int age=1; public void test(Product P) &#123; System.out.println(&quot;购买了一个&quot;+P.getName()+&quot;,花掉了&quot;+P.getPrice()); &#125; public static void main(String[] args) &#123; Shape a=new Shape(); a.test(new Product() &#123; public double getPrice() &#123; System.out.println(age); return 567.8; &#125; public String getName() &#123; return &quot;Agp显卡&quot;; &#125; &#125;); &#125;&#125; 12345678910111213141516171819 可以替代上面的匿名内部类 class product1 implements Product&#123;public double getPrice()&#123;return 56.7;&#125;public String getName()&#123;return &quot;agp显卡&quot;;&#125;&#125;a.test(new product1()); lambda表达式1234567891011121314151617181920212223242526272829303132333435363738394041package Shape;interface Eatable&#123;void taste(); &#125;interface Flyable&#123; void fly(String weather);&#125;interface Addable&#123; int add(int a,int b);&#125;public class Shape&#123; public void eat(Eatable e) &#123; System.out.println(e); e.taste(); &#125; public void drive(Flyable f) &#123; System.out.println(&quot;我正在驾驶&quot;+f); &#125; public void test(Addable add) &#123; System.out.println(&quot;5域3的和位&quot;+add.add(5,3)); &#125; public static void main(String[] args) &#123; Shape lq=new Shape(); lq.eat(()-&gt;System.out.println(&quot;okok&quot;)); lq.drive(weather-&gt;&#123;System.out.println(&quot;今天的天气是&quot;+weather);&#125;); lq.test((a,b)-&gt;a+b); &#125;&#125; 123456789101112package hello;interface like&#123; void print();&#125;public class Hello&#123; public static void main(String []args) &#123; like l=()-&gt;&#123; System.out.println(&quot;1&quot;); &#125;; &#125;&#125; 引用类方法1234567891011121314package Shape;@FunctionalInterfaceinterface Converter&#123; Integer convert(String from);&#125;public class Shape&#123;public static void main(String[] args) &#123;Converter converter1=from-&gt;Integer.valueOf(from);Converter converter2=Integer::valueOf;&#125;&#125; 引用特定对象的实例方法1234567891011121314package Shape;@FunctionalInterfaceinterface Converter&#123; Integer convert(String from);&#125;public class Shape&#123; Converter converter2=from-&gt;&quot;fkit.org&quot;.indexOf(from); Converter converter1=&quot;fkit.org&quot;::indexOf; int value=converter1.convert(&quot;1&quot;); void print() &#123; System.out.println(value); &#125; } 引用某类对象的实例方法12345678910111213141516171819202122package Shape;@FunctionalInterfaceinterface Mytest&#123; String test(String a,int b ,int c);&#125;public class Shape&#123;Mytest mt =(a,b,c)-&gt;a.substring(b,c);Mytest mt1=String::substring;void print() &#123; String str=mt.test(&quot;java i love you&quot;,3,9); System.out.println(str);&#125;public static void main(String[] args)&#123; Shape a=new Shape(); a.print(); &#125;&#125; 引用构造器12345678910111213141516171819202122package Shape;@FunctionalInterfaceinterface YourTest&#123; JFrame win(String title);&#125;public class Shape&#123;YourTest yt=(String a)-&gt;new JFrame(a);YourTest yt1=JFrame::new;void print() &#123; JFrame jf=yt.win(&quot;我的窗口&quot;); System.out.println(jf);&#125;public static void main(String[] args)&#123; Shape a=new Shape(); a.print(); &#125;&#125; 12345678package Shape;public class JFrame &#123;public JFrame(String a)&#123; System.out.println(&quot;a&quot;); &#125;&#125; 枚举类1234567891011121314151617181920212223242526272829303132333435363738394041package Shape;enum SeasonEnum&#123; SPRING,SUMMER,FALL,WINTER;&#125;public class Shape&#123;public void judge(SeasonEnum s)&#123; switch (s) &#123; case SPRING: System.out.println(&quot;春天&quot;); break; case SUMMER: System.out.println(&quot;夏天&quot;); break; case FALL: System.out.println(&quot;秋天&quot;); break; case WINTER: System.out.println(&quot;冬天&quot;); break; &#125;&#125;public static void main(String[] args)&#123; for (SeasonEnum s:SeasonEnum.values()) &#123; System.out.println(s); &#125; new Shape().judge(SeasonEnum.SPRING); &#125;&#125; 更合理的枚举类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package Shape;enum Gender&#123; MALE,FEMALE; private String name; public void setName(String name) &#123; switch (this) &#123; case MALE: if(name.equals(&quot;男&quot;)) &#123; this.name=name; &#125; else &#123; System.out.println(&quot;参数错误&quot;); &#125; break; case FEMALE: if(name.equals(&quot;女&quot;)) &#123; this.name=name; &#125; else &#123; System.out.println(&quot;参数错误&quot;); &#125; break; &#125; &#125; public String getName() &#123; return this.name; &#125;&#125;public class Shape&#123;public static void main(String[] args)&#123; Gender g=Gender.valueOf(&quot;FEMALE&quot;); g.setName(&quot;女&quot;); System.out.println(g+&quot;代表&quot;+g.getName()); //g.setName(&quot;男&quot;); &#125;&#125; 用构造器做的枚举类，更合理12345678910111213141516171819202122232425package Shape;enum Gender&#123; MALE(&quot;男&quot;),FEMALE(&quot;女&quot;); private final String name; private Gender(String name) &#123; this.name=name; &#125; public String getName() &#123; return this.name; &#125;&#125;public class Shape&#123;public static void main(String[] args)&#123; Gender g=Gender.valueOf(&quot;FEMALE&quot;); System.out.println(g.getName()); &#125; &#125; 实现接口的枚举类，不同的枚举值重写的函数还不一样1234567891011121314151617181920212223242526272829303132333435package Shape;interface GenderDesc&#123; void info(); &#125;enum Gender implements GenderDesc&#123;MALE(&quot;男&quot;)&#123;public void info()&#123;System.out.println(&quot;这个枚举值代表男性&quot;); &#125;&#125;,FEMALE(&quot;女&quot;)&#123; public void info() &#123; System.out.println(&quot;这个枚举值代表女性&quot;); &#125;&#125;; private final String name;private Gender(String name) &#123; this.name=name;&#125;&#125;public class Shape&#123;public static void main(String[] args)&#123; Gender g=Gender.valueOf(&quot;FEMALE&quot;); g.info(); &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051这个是包含抽象方法的枚举类在对枚举值实例化的时候也是进行了一个方法的重写，类似于匿名内部类，创建了一个Gender子类的实例package Shape;enum Gender&#123;PLUS&#123;public double eval(double x, double y)&#123; return x+y;&#125;&#125;,MINUS&#123;public double eval(double x,double y) &#123;return x-y; &#125;&#125;,TIMES&#123;public double eval(double x,double y)&#123;return x*y; &#125;&#125;,DEVIDE&#123; public double eval(double x,double y) &#123; return x/y; &#125;&#125;;public abstract double eval(double x,double y);public static void main(String []args) &#123; System.out.println(Gender.PLUS.eval(5,4)); System.out.println(Gender.PLUS.eval(5,4)); System.out.println(Gender.PLUS.eval(5,4)); System.out.println(Gender.PLUS.eval(5,4));&#125; } java中的集合Collection这是一个接口，只能new 实现类 Collection常用方法 12345678910111213141516171819202122int size();boolean isEmpty();boolean contains(Object o);//调用o的equals方法和集合中元素比较来判断是否存在Iterator&lt;E&gt; iterator();Object[] toArray ();boolean add(E o);boolean remove(Object o);boolean containsAll (Collection&lt;?&gt; c);//检查集合c是否在集合里面出现boolean addAll (Collection&lt;? extends E&gt; c);boolean removeAll (Collection&lt;?&gt; c);//boolean retainAll (Collection&lt;?&gt; c);//保留两个集合交集void clear();boolean equals(Object o); 常用方法的使用 12345678910111213141516171819202122232425package Shape;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;public class Shape&#123;public static void main(String []args) &#123; Collection c =new ArrayList(); c.add(&quot;寻悟空&quot;); c.add(6); c.remove(6); System.out.println(c.contains(&quot;寻悟空&quot;)); c.add(&quot;java&quot;); Collection books=new HashSet(); books.add(&quot;轻量级javaee企业实战&quot;); books.add(&quot;疯狂java将以&quot;); books.add(&quot;寻悟空&quot;); c.removeAll(books);//移除c中和books相同的元素 c.clear();//清除所有元素 books.retainAll(c);//移除books中和c不相同的元素 System.out.println(books);&#125;&#125; 使用lambda表达式遍历集合 12345678910111213141516package Shape;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;public class Shape&#123;public static void main(String []args) &#123; Collection books=new HashSet(); books.add(&quot;轻量级javaee企业实战&quot;); books.add(&quot;疯狂java讲义&quot;); books.add(&quot;疯狂安定&quot;); books.forEach(obj-&gt;System.out.println(&quot;迭代元素集合&quot;+obj));&#125;&#125; Iterator 遍历集合元素 例一 12345678910111213141516171819202122232425262728293031323334package Shape;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;import java.util.Iterator;public class Shape&#123;public static void main(String []args) &#123; Collection books=new HashSet(); books.add(&quot;轻量级javaee企业实战&quot;); books.add(&quot;疯狂java讲义&quot;); books.add(&quot;疯狂安定&quot;); Iterator it =books.iterator(); while(it.hasNext()) &#123; String book=(String)it.next(); System.out.println(book); if(books.equals(&quot;疯狂java讲义&quot;)) &#123; it.remove();//从集合中删除上一次next()方法返回的元素 //books.remove();迭代过程中不能使用这个，只有Iterator来remove才行 &#125; book=&quot;测试字符串&quot;;//对book变量赋值，不会改变集合元素本身的 System.out.println(books); it.forEachRemaining(obj-&gt;System.out.println(&quot;可迭代的元素&quot;+obj)); &#125;&#125;&#125; 例二 12345678910111213141516public static void main(String []args) &#123;Collection c=new HashSet();c.add(new Student(1,&quot;Tom&quot;,60));c.add(new Student(2,&quot;Peter&quot;,70));c.add(new Student(3,&quot;Bob&quot;,80));Iterator i=c.iterator();while(i.hasNext()) &#123; Student s=(Student)i.next();//将得到的元素强制转换为（Student）类然后就可以正常使用了 //如果这里上面的Iterator规定泛型是&lt;Student&gt;就不需要转换了 //其实其他集合也是一样，因为java无法知道集合中是什么类 System.out.println(s.getName());&#125; &#125; jdk1.5用foreach循环遍历集合 1234567891011121314151617181920212223242526package Shape;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;public class Shape&#123;public static void main(String []args) &#123; Collection books=new HashSet(); books.add(&quot;轻量级javaee企业实战&quot;); books.add(&quot;疯狂java讲义&quot;); books.add(&quot;疯狂安定&quot;); for(Object obj:books) &#123; String book=(String)obj; System.out.println(&quot;book&quot;); if(book.equals(&quot;疯狂java讲义&quot;)) &#123; books.remove(book); &#125; &#125; System.out.println(books); &#125;&#125; Predicate操作集合 1234567891011121314151617181920package Shape;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;public class Shape&#123;public static void main(String []args) &#123; Collection books=new HashSet(); books.add(&quot;轻量级javaee企业实战&quot;); books.add(&quot;疯狂java讲义&quot;); books.add(&quot;疯狂安定&quot;); books.add(&quot;疯狂ios讲义&quot;); books.add(&quot;疯狂ajax讲义&quot;); books.add(&quot;疯狂andriod将以&quot;); books.removeIf(ele-&gt;((String)ele).length()&lt;10); System.out.println(books);&#125;&#125; 123456789101112131415161718192021222324252627282930package Shape;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;import java.util.function.Predicate;public class Shape&#123;public static void main(String []args) &#123; Collection books=new HashSet(); books.add(&quot;疯狂java&quot;); books.add(&quot;疯狂javajavajavajvaa&quot;); System.out.println(calAll(books,ele-&gt;((String)ele).contains(&quot;疯狂&quot;)));&#125;public static int calAll(Collection books,Predicate p)&#123; int total=0; for(Object obj:books) &#123; if(p.test(obj)) &#123; total++; &#125; &#125; return total;&#125;&#125; List集合是一个集合，需要new实现类 特点：实现该接口的类中的元素**有顺序，可以重复 List容器中的元素都有一个对应的整数型的序号，用以记录元素在容器中的位置，可以根据序号取元素。** 主要实现类：ArrayList，LinkedList 列表：按照一定次序（对象进入的顺序）排列的·对象集，对象之间有次序关系，对象可以重复 Object get(int index); Object set(int index, Object element); void add(int index,Object element); Object remove(int index); int indexOf (Object o); int lastIndexOf(Object o); 常用方法的使用 123456789101112131415161718192021222324package Hello;import java.util.ArrayList;import java.util.List;import java.util.Scanner;public class Hello&#123; public static void main(String[] args) &#123;List books=new ArrayList();books.add(new String(&quot;轻量级javaee企业应用实战&quot;));books.add(new String (&quot;疯狂java讲义&quot;));books.add(new String(&quot;疯狂狂andriod讲义&quot;));System.out.println(books);books.add(1,new String(&quot;java讲义&quot;));//将新字符串对象插入在第二个位置for(int i=0;i&lt;books.size();i++)&#123;System.out.println(books.get(i)); &#125;books.remove(2);//删除第三个元素System.out.println(books);System.out.println(books.indexOf(new String(&quot;java讲义&quot;)));//判断指定元素在List集合中的位置，输出1，表明位于第二位books.set(1,new String(&quot;疯狂java讲义&quot;));//将第二个元素替换成新的字符串对象System.out.println(books);System.out.println(books.subList(1,2));//将集合的第二个元素截取成子集合,就是第二个参数减一是结束下标 &#125; } addAll方法 1234567891011121314151617 public static void main(String []args) &#123;ArrayList&lt;String&gt; a=new ArrayList&lt;String&gt;();ArrayList&lt;String&gt; b=new ArrayList&lt;String&gt;();a.add(&quot;a&quot;);a.add(&quot;b&quot;);a.add(&quot;c&quot;);b.add(&quot;a&quot;);b.add(&quot;b&quot;);b.add(&quot;c&quot;);a.addAll(b);System.out.println(a); &#125;结果：[a, b, c, a, b, c] LIST集合是通过equals方法判断两个对象是否一样的 A类重写了equals方法 123456789101112131415161718192021222324package Hello;import java.util.ArrayList;import java.util.List;import java.util.Scanner;class A&#123; public boolean equals(Object obj) &#123; return true; &#125;&#125;public class Hello&#123; public static void main(String[] args) &#123;List books=new ArrayList();books.add(new String(&quot;轻量级javaee企业应用实战&quot;));books.add(new String (&quot;疯狂java讲义&quot;));books.add(new String(&quot;疯狂狂andriod讲义&quot;));books.remove(new A());//会删除第一个元素，因为它和任意元素都可以相等books.remove(new A());//再次删除第一个元素System.out.println(books); &#125;&#125; List两个新增方法sort和replacell()方法 sort需要一个Comparator对象来控制元素排序，程序可使用Lambda表达式作为参数 sort方法必须传入构造器 replaceAll()方法需要一个UnaryOperator来替换所有的集合元素，UnaryOperator是一个函数式接口，也可以使用Lambda作为参数 12345678910111213141516171819202122232425262728package Hello;import java.util.ArrayList;import java.util.List;import java.util.Scanner;class A&#123; public boolean equals(Object obj) &#123; return true; &#125;&#125;public class Hello&#123; public static void main(String[] args) &#123;List books=new ArrayList();books.add(new String(&quot;轻量级javaee企业应用实战&quot;));books.add(new String (&quot;疯狂java讲义&quot;));books.add(new String(&quot;疯狂狂andriod讲义&quot;)); //使用目标类型为Comparator的Lambda表达式对List集合排序books.sort((o1,o2)-&gt;((String)o1).length()-((String)o2).length());System.out.println(books); //使用目标类型为UnaryOperator的Lambda表达式来替换集合中的所有元素 //该Lambda表达式控制使用每个字符串的长度作为新的集合元素books.replaceAll(ele-&gt;((String)ele).length());System.out.println(books); &#125;&#125; 123456789101112131415161718192021222324252627class Compare implements Comparator&lt;Integer&gt;&#123; @Override public int compare(Integer o1, Integer o2) &#123; return o2-o1; &#125;&#125;public class Main&#123; public static void main(String []args) &#123;ArrayList&lt;Integer&gt; a=new ArrayList&lt;Integer&gt;();a.add(1);a.add(4);a.add(3);Compare b=new Compare();a.sort(b);System.out.println(a); &#125;&#125;结果：[4, 3, 1] Arrays.List方法 123456789101112131415161718192021222324package Hello;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.Scanner;class A&#123; public boolean equals(Object obj) &#123; return true; &#125;&#125;public class Hello&#123; public static void main(String[] args) &#123;List books=Arrays.asList(&quot;轻量级javaee企业应用实战&quot;,&quot;疯狂java讲义&quot;,&quot;疯狂狂andriod讲义&quot;);System.out.println(books.getClass());books.forEach(System.out::println);//books.add(&quot;疯狂java讲义&quot;);//books.add(&quot;疯狂java&quot;); &#125;&#125; 将集合转变为数组的方法 ** 123456789101112131415161718192021222324public** **static** **void** main(String[] args)&#123;​ *// 创建一个动态数组*​ ArrayList&lt;String&gt; sites = **new** ArrayList&lt;&gt;();​ ​ sites.add(&quot;Runoob&quot;);​ sites.add(&quot;Google&quot;);​ sites.add(&quot;Wiki&quot;);​ sites.add(&quot;Taobao&quot;);​ System.out.println(&quot;网站列表: &quot; + sites);​ *// 创建一个新的 String 类型的数组*​ *// 数组长度和 ArrayList 长度一样*​ String[] arr = **new** String[sites.size()];​ *// 将ArrayList对象转换成数组*​ sites.toArray(arr);​ *// 输出所有数组的元素*​ System.out.print(&quot;Array: &quot;);​ **for**(String item:arr) &#123;​ System.out.print(item+&quot;, &quot;);​ &#125; &#125; 子类ArrayListArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。 ArrayList 继承了 AbstractList ，并实现了 List 接口。 12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.Collections;class Main&#123;public static void main(String []args)&#123; ArrayList&lt;String&gt; sites=new ArrayList&lt;String&gt;(); sites.add(&quot;google&quot;);//向集合中添加 sites.add(&quot;runoob&quot;); sites.add(&quot;taobao&quot;); System.out.println(sites.get(1));//得到指定下标的元素 sites.set(2, &quot;Wiki&quot;);//在指定下标处插入 sites.remove(3);//移除下标为3的元素 System.out.println(sites.size()); for(int i=0;i&lt;sites.size();i++) &#123; System.out.println(sites.get(i)); &#125; for(String i:sites) &#123; System.out.println(i); &#125; ArrayList&lt;Integer&gt; myNumbers=new ArrayList&lt;Integer&gt;(); myNumbers.add(10); myNumbers.add(15); myNumbers.add(20); myNumbers.add(25); System.out.println(myNumbers.size());//得到数组中元素的数量 Collections.sort(sites);//排序 for(String i:sites) &#123; System.out.println(i); &#125;&#125;&#125; 一个ArrayList自己的排序方法 sort方法中的参数是一个比较器，下面这个例子是按照字母顺序进行排序 12345678910111213class Main&#123; public static void main(String []args) &#123; ArrayList&lt;String&gt; name=new ArrayList&lt;String&gt;(); name.add(&quot;a&quot;); name.add(&quot;c&quot;); name.add(&quot;b&quot;); name.sort(Comparator.naturalOrder()); System.out.println(name); &#125;&#125; ArrayList转数组 1234567891011121314151617181920public class Main &#123;public static void main(String []args) &#123; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.add(&quot;c&quot;); list.add(&quot;d&quot;); list.add(&quot;e&quot;); list.add(&quot;f&quot;); list.add(&quot;g&quot;); String[] array =new String[list.size()]; list.toArray(array); for(String x:list) &#123; System.out.println(x); &#125;&#125;&#125; VectorList接口的实现类。 特点：跟ArrayList一样，都是可变长的对象数组。 与ArrayList区别 ①Vector是线程安全的，是可以同步的，运行效率低； ②ArrayList不同步，适合于单线程环境中。 public Object elementAt(int index) public void addElement(Object obj) public void removeElementAt(int index) public void insertElementAt(E obj, int index) public boolean removeElement(Object obj) public void removeAllElements() Stack(栈)extends Vector 后进先出，就是一个底下有底的箱子，只能从上面拿所以是后进先出 常用方法 – public Object push(E item) – public Object pop() – public Object peek() – public boolean empty() – public int search(Object o) 1234567891011121314public static void main(String []args) &#123; Stack s=new Stack(); s.push(&quot;hello&quot;); s.push(new Date());//往箱子里面放东西 s.push(100); s.push(3.14); System.out.println(&quot;弹栈前size=&quot;+s.size()); System.out.println(s.pop());//弹出箱子中最顶上的元素 System.out.println(&quot;弹栈后size=&quot;+s.size()); System.out.println(s.peek());//获得箱子中最顶上的元素，但是不弹出 System.out.println(&quot;peek操作后&quot;+s.size()); while(!s.isEmpty()) &#123;//判断箱子中是否是空 System.out.println(s.pop()); &#125; 把Stack当作普通List用 失去了Stack所特有的性质 12345678910111213141516171819202122public static void main(String[] args) &#123;Stack&lt;String&gt; s = new Stack&lt;String&gt;();s.add(&quot;one&quot;);s.add(&quot;two&quot;);s.add(&quot;three&quot;);s.add(2, &quot;four&quot;);s.add(0,&quot;five&quot;);System.*out*.println(s);s.remove(&quot;two&quot;);System.*out*.println(s);&#125; Queue集合队列：一种先进先出（FIFO）的容器，从容器的一端放入对象，从另一端取出对象，并且放入和取出的顺序相同 常用方法 –offer()：（入队）如果可能，将指定的元素插入此队列。 –peek()，element()：在不移除的情况下返回队头。peek方法在队列为空时返回null，element方法在队列为空时抛出异常。 –poll()，remove()：移除并返回队头（出队）。poll方法在队列为空时返回null，remove方法在队头为空时抛出异常。 12345678910Queue queue=new LinkedList();queue.offer(&quot;hello&quot;);queue.offer(&quot;world&quot;);queue.offer(&quot;你好&quot;);System.out.println(queue.size());String str;System.out.println(queue.peek());//返回当前队头的元素while((str=(String)queue.poll())!=null) &#123;//移除并返回当前队头的元素 System.out.println(str);&#125; PriorityQueue实现类123456789101112131415161718192021222324package Hello;import java.util.PriorityQueue;class A&#123; public boolean equals(Object obj) &#123; return true; &#125;&#125;public class Hello&#123; public static void main(String[] args) &#123;PriorityQueue pq=new PriorityQueue();pq.offer(6);pq.offer(-3);pq.offer(20);pq.offer(18);System.out.println(pq);System.out.println(pq.poll()); &#125;&#125; Deque接口与ArrayDeque实现类1234567891011121314151617181920212223package Hello;import java.util.ArrayDeque;import java.util.PriorityQueue;class A&#123; public boolean equals(Object obj) &#123; return true; &#125;&#125;public class Hello&#123; public static void main(String[] args) &#123;ArrayDeque stack=new ArrayDeque();stack.push(&quot;疯狂java讲义&quot;);stack.push(&quot;轻量级java ee企业应用实战&quot;);System.out.println(stack.peek());System.out.println(stack.pop());System.out.println(stack); &#125;&#125; LinkedList实现类123456789101112131415161718192021222324252627282930313233package Hello;import java.util.ArrayDeque;import java.util.LinkedList;import java.util.PriorityQueue;class A&#123; public boolean equals(Object obj) &#123; return true; &#125;&#125;public class Hello&#123; public static void main(String[] args) &#123;LinkedList books=new LinkedList();books.offer(&quot;疯狂java讲义&quot;);books.push(&quot;轻量级java ee企业级应用实战&quot;);books.offerFirst(&quot;疯狂andriod讲义&quot;);for(int i=0;i&lt;books.size();i++)&#123;System.out.println(&quot;遍历中&quot;+books.get(i)); &#125;System.out.println(books.peekFirst());System.out.println(books.peekLast());System.out.println(books.pop());System.out.println(books);System.out.println(books.pollLast());System.out.println(books); &#125;&#125; Set对象唯一，不会重复，元素没有顺序 HashSet元素值可以使null HashSet判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode方法返回值也相等（重写两个方法的时候最好两者统一） 先判断hashCode是否相等，如果hashCode相等再去判断equals方法是否为true 只有用到Hashtable HashMap HashSet LinkedHashMap等时才要注意hashcode方法。 equals方法重写的方法1234567891011121314151617181920212223242526272829public boolean equals(Object obj) &#123;if (this == obj) return true;if (obj == null)//先看看参数是不是空 return false;if (getClass() != obj.getClass())//再看看参数是否是同一个类，getClass()是指获取这个类创建实例的类型，也就是获取当前类这个类型 return false;//getClass方法获得的不是引用变量的类型，而是真正的类型final Student other = (Student) obj;if (no != other.no) return false;return true;&#125;public String toString() &#123; return &quot;no is : &quot; + no;&#125; 重写equals方法 12345678910public boolean equals(Object obj) &#123; if(obj==null) &#123;//先判断是否为空 return false; &#125; if(obj instanceof Company) &#123;//判断能否向下转型 Company c=(Company)obj; return c.name.equals(name); &#125; return false; &#125; TreeSet实现了对Set的排序 自然排序 123456789public static void main(String []args) &#123;TreeSet ts=new TreeSet();ts.add(&quot;YaoMing&quot;);ts.add(&quot;Kobe&quot;);ts.add(&quot;McGrand&quot;);ts.add(&quot;Jordan&quot;);System.out.println(ts); &#125; 结果：[Jordan, Kobe, McGrand, YaoMing] 按照字典排序 定制排序 TreeSet(Comparator&lt;? super E&gt; comparator) 可以自己写一个构造器当作参数 LinkedSet就是按照插入的顺序排列元素 Mapjava中的Hash表Hash表介绍 哈希表：能够通过元素快速查获找到元素的存储位置，又称为散列表。 哈希表基本原理：通过哈希函数或散列函数将元素的关键字和元素的存储位置关联起来。由哈希函数计算出来的值称为哈希码(Hash Code)或散列索引。 哈希表的存储空间称为哈希表的容量(Capacity)。 hash表分为三类 java语言提供了java.util.Hashtable, java.util.HashMap, java.util.WeakHashMap三个类来提供哈希存储支持。这三者的元素都是主要由关键字和值两部分组成。 Hashtable元素的关键字和值都不允许null。HashMap和WeakHashMap的关键字和值都允许null。 Hashtable支持线程同步， HashMap和WeakHashMap不支持线程同步。 WeakHashMap会自动按一定规则检查各个元素是否常用，不常用的元素会被去除，从而被系统回收。（WeakHashMap是HashMap的子类） k-y相等判断方式判断两个value相等，两个对象通过equals方法比较返回true即可，判断两个key相等，那equals放回true hashcode值也相等 Map元素遍历Set keySet( )获取所有Key的集合 Collection values( ) 获取所有Value的集合 Set entrySet( ) 获取所有key-value对的集合 再用相应的Iterator或者for循环遍历 例一 12345678910HashMap&lt;String ,Integer&gt; a=new HashMap&lt;String,Integer&gt;();a.put(&quot;a&quot;,1);a.put(&quot;b&quot;,2);Set b=a.keySet();Iterator&lt;String&gt; i=b.iterator();while(i.hasNext()) &#123; String key=i.next(); Integer value=a.get(key); System.out.println(key+&quot;-&quot;+value+&quot; &quot;);&#125; 1234567891011 public static void main(String []args) &#123;HashMap &lt;String,Integer&gt;a=new HashMap&lt;String,Integer&gt;();a.put(&quot;a&quot;,1);a.put(&quot;b&quot;,2);a.put(&quot;c&quot;,3);Collection b=a.values();System.out.println(b);结果：[1, 2, 3]&#125; 例二 entrySet方法介绍 Map的entrySet()方法返回一个实现Map.Entry接口的对象集合。集合中每个对象都是底层Map中一个特定的键&#x2F;值对。通过这个集合的迭代器，获得每一个条目(唯一获取方式)的键或值并对值进行更改。Map.Entry中的常用方法如下所示： 123(1) Object getKey(): 返回条目的关键字 (2) Object getValue(): 返回条目的值 (3) Object setValue(Object value): 将相关映像中的值改为value，并且返回旧值 12345678910public static void main(String[]args) &#123; HashMap&lt;String ,Integer&gt; a=new HashMap&lt;String,Integer&gt;(); a.put(&quot;a&quot;,1); a.put(&quot;b&quot;,2); Set b=a.entrySet(); for(Object o:b) &#123; Map.Entry e=(Map.Entry)o; System.out.println(e.getKey()+&quot;-&quot;+e.getValue()+&quot; &quot;); &#125;&#125; 按照key或者value对map排序的方法Map会根据key的大小来自动排序 因为LinekedHashMap是按照顺序添加的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.*;class compare1 implements Comparator&lt;Map.Entry&gt;&#123; @Override public int compare(Map.Entry o1,Map.Entry o2) &#123; return (int)(o2.getValue())-(int)(o1.getValue());//注意这个地方的()缺一不可 &#125;&#125;class Main&#123; public static void main(String []args)&#123; Scanner in=new Scanner(System.in); String a=in.nextLine(); String b[]=a.split(&quot; &quot;); Hashtable&lt;String,Integer&gt; c=new Hashtable&lt;String,Integer&gt;(); int count =0; for(int i=0;i&lt;b.length;i++) &#123; if(c.containsKey(b[i])) &#123; c.put(b[i],c.get(b[i])+1); &#125; else &#123; c.put(b[i],1); &#125; &#125; List list=new LinkedList(c.entrySet()); compare1 q=new compare1(); Collections.sort(list,q); Map sortedMap=new LinkedHashMap();//这个地方必须使用LinkedHashMap for(Iterator it=list.iterator();it.hasNext();) &#123; Map.Entry entry=(Map.Entry)it.next();//这里的迭代器如果加泛型&lt;Iterator&gt;,就不用强制转换了 sortedMap.put(entry.getKey(), entry.getValue());&#125; Set h=sortedMap.keySet(); Iterator&lt;String&gt; r=h.iterator(); while(r.hasNext()) &#123; String i=r.next(); System.out.println(i+&quot;:&quot;+ sortedMap.get(i)); &#125; &#125;&#125; 用函数法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.*;import java.util.Map.Entry;class Compare implements Comparator&lt;Map.Entry&gt;&#123; @Override public int compare(Map.Entry o1,Map.Entry o2) &#123; return (int)(o2.getValue())-(int)(o1.getValue()); &#125;&#125;class Main&#123; public static Map getMap(Map unsortedMap) &#123; List a=new ArrayList(unsortedMap.entrySet()); Compare b=new Compare(); Collections.sort(a,b); Map sortedMap=new LinkedHashMap();//这里必须是LinkedHashMap for(Iterator it=a.iterator();it.hasNext();) &#123; Map.Entry entry=(Map.Entry)it.next(); sortedMap.put(entry.getKey(), entry.getValue()); &#125; return sortedMap; &#125; public static void main(String []args) &#123; Scanner in=new Scanner(System.in); String a=in.nextLine(); String b[]=a.split(&quot; &quot;); Hashtable&lt;String,Integer&gt; c=new Hashtable&lt;String,Integer&gt;(); int count =0; for(int i=0;i&lt;b.length;i++) &#123; if(c.containsKey(b[i])) &#123; c.put(b[i],c.get(b[i])+1); &#125; else &#123; c.put(b[i],1); &#125; &#125; Map n=getMap(c); Set i=n.keySet(); Iterator&lt;String&gt; e=i.iterator(); while(e.hasNext()) &#123; String t=e.next(); System.out.println(t+&quot;:&quot;+n.get(t)); &#125; &#125;&#125;就是java是向下兼容的，如果函数返回类型是Map其实是返回的只要是Map的子类的实例化对象都可以 如果函数的参数类型是Map类型，其实这个参数只要是Map子类的实例化对象都可以 ​ Hashtable集合不能保证顺序 Hashtable的构造方法 名称 描述 public Hashtable( ) 创建哈希表实例对象，容量为11，装填因子为0.75。 public Hashtable( int initialCapacity) 创建哈希表实例对象，容量为initialCapacity，装填因子为0.75。 public Hashtable( int initialCapacity, float loadFactor) 创建哈希表实例对象，容量为initialCapacity，装填因子为loadFactor。 Hashtable ht1&#x3D;new Hashtable&lt;String, Integer&gt; ( ); Hashtable ht2&#x3D;new Hashtable( );&#x2F;&#x2F;未指定关键字和键值类型，编译会警告 java.util.Hashtable的成员方法 名称 描述 public V put(K key, V value ) 添加关键字为****key, 值为value的元素 public V get(Object key) 获得由参数key指定的关键字所对应的元素值 public void Clear( ) 清空整个Hash表 public boolean containsKey(Object key) 判断表中是否存在关键字****key public boolean containsValue(Object value) 判断表中是否存在元素值****value public boolean contains(Object value) 判断表中是否存在元素值****value public boolean isEmpty( ) 判断Hash表是否为空 public V remove(Object key) 删除指定关键字key所对应的元素 public int size( ) 返回Hash表元素的个数 1234567891011121314151617例子 String []sa= &#123;&quot;Mary&quot;,&quot;Tom&quot;,&quot;John&quot;,&quot;James&quot;,&quot;Louis&quot;,&quot;Jim&quot;,&quot;Rose&quot;,&quot;Ann&quot;,&quot;Liza&quot;,&quot;Betty&quot;,&quot;Henry&quot;&#125;; Hashtable &lt;String ,Integer&gt; ht=new Hashtable&lt;String ,Integer&gt;(); for(int i=0;i&lt;sa.length;i++) &#123; ht.put(sa[i],new Integer(i) );//将这个key和value放入hash表中 &#125; String s=sa[5]; System.out.println(ht.get(s));//获得key为参数所对应的value值 System.out.println(ht.containsKey(sa[5])); System.out.println(ht.containsValue(1)); System.out.println(ht.contains(1)); System.out.println(ht.isEmpty()); System.out.println(ht.size()); ht.remove(sa[5]); System.out.println(ht.size()); 还有一个方法就是keySet() ，可以得到集合的key的一个集合** Set s &#x3D; ht.keySet();** Properties集合Properties是用来读取配置文件的（结尾为.properties的文件） Properties类表示一组持久的属性。 Properties可以保存到流中或从流中加载。 extends Hashtable&lt;k,v&gt; implements Map&lt;k,v&gt; Properties集合是一个唯一和IO相结合的集合 第一条的解释 可以使用Properties集合中的方法store，把集合中的临时数据，持久化写入到硬盘中存储 可以使用Properties集合中的load，把硬盘保存的文件（键值对），读取到集合中使用 属性列表中的每个键及其对应的值都是一个字符串。 解释： ​ Properties集合是一个双列集合，key和value默认都是字符串 Properties集合存储数据，遍历取出Properties集合中的数据 Properties结合是一个双列集合，key和value默认都是字符串 Properties集合有一些操作字符串的特有方法 ​ Object setProperty(String key,String value)其实就是调用Hashtable的方法put ​ String getProperty(String key) 通过key找到value值，相当于Map集合中的get方法 ​ Set stringPropertyNames() 返回此属性列表中的一组键，其中键及其对应的值为字符串，包括默认属性列表中的不同键，如果尚未从主属性列表中找到相同名称的键。相当于Map集合中的keySet方法 几个方法的基本使用 //创建Properties集合对象 Properties prop=new Properties(); prop.setProperty(&quot;a&quot;, &quot;1&quot;); prop.setProperty(&quot;b&quot;,&quot;2&quot;); prop.setProperty(&quot;c&quot;,&quot;3&quot;); //使用stringPropertyNames把Properties集合中的键取出，存储到一个Set集合中 Set&lt;String&gt; set=prop.stringPropertyNames(); for(String key:set) &#123; String value=prop.getProperty(key); System.out.println(key+&quot;-&quot;+value); Properties集合中的store方法 void store(OutputStream out,String comments) void store(Writer writer,String comments) 参数： ​ OutputStream out：字节输出流，不能写入中文 ​ Writer writer ：字符输出流，可以写中文 ​ String comments：注释，解释说明保存的文件是做什么用的 ​ 不能使用中文，会产生乱码，默认是Unicode编码，而系统默认编码是GBK 使用步骤： ​ 1.创建Properties集合对象，添加数据 ​ 2.创建字节输出流&#x2F;字符输出流对象，构造方法中绑定要输出的目的地 ​ 3.使用Properties集合中的方法store，把集合中的临时数据，持久化写入到硬盘中存储 ​ 4.释放资源 123456789101112131415161718192021222324public static void main(String []args) throws IOException &#123;show01();&#125;private static void show01() throws IOException &#123; //1.创建Properties集合对象，添加数据 Properties prop=new Properties(); prop.setProperty(&quot;a&quot;, &quot;1&quot;); prop.setProperty(&quot;b&quot;,&quot;2&quot;); prop.setProperty(&quot;c&quot;,&quot;3&quot;); //.创建字节输出流/字符输出流对象，构造方法中绑定要输出的目的地FileWriter fw=new FileWriter(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);// 3.使用Properties集合中的方法store，把集合中的临时数据，持久化写入到硬盘中存储prop.store(fw,&quot;sava data&quot;);//关闭资源fw.close();&#125;文件写入结果： #sava data#Fri Jul 01 10:34:48 CST 2022a=1b=2c=3上面的时间是自己加的 Properties集合的load方法 可以使用Properties集合中的方法load，把硬盘中保存的文件（键值对），读取到集合中使用 void load(InputStream inStream) void load(Reader reader) 参数： ​ InputStream inStream：不能读取含有中文的键值对 ​ Reader reader：字符输入流，能读取含有中文的键值对 使用步骤： ​ 1.创建Properties集合对象 ​ 2.使用Properites集合对象中的方法load读取到保存键值对的文件 ​ 3.遍历Properties集合 注意：1.存储键值对的文件中，键与值默认的连接符号可以使用-，空格（其他符号） ​ 2.存储键值对的文件中，可以使用井号进行注释，被注释的键值对不会再被读取 ​ 3.存键值对的文件中，键与值都默认是字符串，都不用再加引号 12345678public void test2() throws Exception &#123; Properties pros=new Properties(); FileInputStream fis=new FileInputStream(&quot;./jdbc.properties&quot;); pros.load(fis); String user=pros.getProperty(&quot;user&quot;); String password=pros.getProperty(&quot;password&quot;); System.out.println(&quot;user=&quot;+user+&quot;password=&quot;+password);&#125; HashMap集合不能保证顺序 12345678910111213141516171819202122232425262728293031323334package Hello;import java.util.HashMap;import java.util.Map;class A&#123; public boolean equals(Object obj) &#123; return true; &#125;&#125;public class Hello&#123; public static void main(String[] args) &#123;Map map=new HashMap();map.put(&quot;疯狂Java&quot;,109);map.put(&quot;疯狂python&quot;,10);map.put(&quot;疯狂ios&quot;,79);map.put(&quot;疯狂php&quot;,99);System.out.println(map.put(&quot;疯狂python&quot;,99));System.out.println(map);System.out.println(map.containsKey(&quot;疯狂python&quot;));System.out.println(map.containsValue(99));for(Object key:map.keySet())&#123;System.out.println(key+&quot;--&gt;&quot;+map.get(key));&#125;map.remove(&quot;疯狂python&quot;);System.out.println(map); &#125;&#125; LinkedHashMap实现类是一种按照map的添加顺序存储的实现类 12345678910111213141516171819202122package Hello;import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;class A&#123; public boolean equals(Object obj) &#123; return true; &#125;&#125;public class Hello&#123; public static void main(String[] args) &#123;LinkedHashMap scores=new LinkedHashMap();scores.put(&quot;语文&quot;,80);scores.put(&quot;英语&quot;,82);scores.put(&quot;数学&quot;,76);scores.forEach((key,value)-&gt;System.out.println(key+&quot;--&gt;&quot;+value)); &#125;&#125; 实用类Collections类提供了List容器操作的静态方法 void sort(List list);&#x2F;&#x2F;对List容器内元素排序，默认升序 void reverse(List list);&#x2F;&#x2F;对List容器内的对象进行逆序排列 void copy(List dest,List src); &#x2F;&#x2F;把src中List容器内容拷贝到dest List容器 int binarySearch(List list, Object key); &#x2F;&#x2F;对顺序的List容器，用折半查找方法查找指定对象，返回对应key元素的下标 void shuffle(List);&#x2F;&#x2F;对List容器内的对象进行随机排序 12345678910111213public static void main(String[]args) &#123; List list1=new LinkedList(); for(int i=0;i&lt;=9;i++) &#123; list1.add(&quot;a&quot;+i); &#125; System.out.println(list1); Collections.reverse(list1); System.out.println(list1); Collections.shuffle(list1); System.out.println(list1); Collections.sort(list1); System.out.println(Collections.binarySearch(list1,&quot;a2&quot;)); &#125; Collections.sort()方法public static void sort(List list, Comparator&lt;? super T&gt; c) List(接口)就是指List类型,那么也就是说只能对集合的具体类的Arraylist和LinkedList这两种类型进行排序,由于接口也能向上转型,光论排序的内容的话其它各种自建类型都行。 第一种方法 在日常开发中，很多时候都需要对一些数据进行排序的操作。然而那些数据一般都是放在一个集合中如：Map ，Set ，List 等集合中。他们都提共了一个排序方法 sort()，要对数据排序直接使用这个方法就行，但是要保证集合中的对象是 可比较的。 怎么让一个对象是 可比较的，那就需要该对象实现 Comparable 接口啦。然后重写里面的compareTo()方法 &#96;&#96;&#96;public interface Comparable123456789101112131415161718192021222324252627282930313233当实现Comparable类的时候也是不规定泛型就是Object，且下面的compareTo方法中的参数类型要和他一样```javapublic class Student implements Comparable&lt;Student&gt; &#123; private int id; private int age; private String name; public Student(int id, int age, String name) &#123; this.id = id; this.age = age; this.name = name; &#125; @Override public int compareTo(Student o) &#123; //降序 //return o.age - this.age; //升序 return this.age - o.age; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&quot; + id + &quot;, age=&quot; + age + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 调用compareTo方法后负数时，当前对象在前面，正数时当前对象在后面，0时位置不变 12345678public int compareTo(Student o1) &#123; if(o1.getScore()==this.getScore()) &#123; return this.id.compareTo(o1.id); &#125; else &#123; return o1.getScore()-this.getScore(); &#125;&#125; 先按照成绩降序排序，成绩相同按照学号升序排序 第二种方法 &#96;&#96;&#96;public interface Comparator1234567891011121314实现Comparator接口的时候，如果没有规定泛型默认是Object，同时T必须和下面compare方法中的参数类型一样自己搞一个构造器，重写compare方法当作Collections.sort(第二个参数)```javaclass compare implements Comparator&lt;Integer&gt;&#123; @Override public int compare(Integer o1, Integer o2) &#123; return o1-o2; &#125;&#125; 第三种直接倒叙的方法 Collection.sort的第二个参数 如果要降序呢?可以传入Collections.reverseOrder(), 返回一个倒叙的Comparator对象, Arrays类定义了多种数组操作的方法 12345678910Integer[]a= &#123;3,25,12,79,48&#125;; System.out.println(Arrays.toString(a));//输出数组 Arrays.sort(a);//对数组中元素进行排序 System.out.println(Arrays.toString(a));//输出数组以[3,25,12,79,48] int idx=Arrays.binarySearch(a,25);//返回25元素所对应的下标 System.out.println(idx); List list=Arrays.asList(3,4,5);//将其转换为List集合返回值是一个List//public static &lt;T&gt; List&lt;T&gt; asList(T... a) System.out.println(list); 其实Arrays.toString的本质是调用数组中所有对象的toString方法然后用逗号隔开然后用[ ]框起来 java异常机制的处理异常：指程序中出现的不期而至的各种状况，如文件找不到，网络连接失败，非法参数等等； java把异常当作对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类 在javaAPI中已经定一个许多异常类，这些异常分为两类，错误Error和异常Exception 这个图中只是举了例子 错误：一般指程序运行时遇到的硬件或操作系统的错误，如内存溢出、不能读取硬盘分区、 硬 件驱动错误等。这是致命的，将导致程序无法运行，同时也是程序本身不能处理 的。错误大都是jvm的问题 2.异常： 异常大都是语法问题； 运行异常和编译异常。 运行异常：顾名思义，是程序运行时才会出现的异常。运行异常是java.lang.RuntimeException类及其子类的统称。如NullPointerException（空指针异常）、IndexOutOfBoundsException（数组下标越界异常）等。运行异常一般是由程序逻辑错误导致的，可以通过捕获处理或向上抛出。运行异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现运行异常，也会被编译通过。编译异常：顾名思义，是程序编译时就会出现的异常。编译异常是java.lang.RuntimeException以外的异常。编译异常必须进行处理，如果不处理，程序就不能编译通过。 异常可以分为两类：1.运行时异常 RuntimeException 2.其他的异常都属于非运行时异常 异常处理机制例1 1234int a=1; int b=0; try &#123;//try监控区域 System.out.println(a/b); &#125; catch(ArithmeticException e)//这个地方的错误必须是和try中出现的错误类型相同，否则没什么用 &#123;//catch 捕获异常 System.out.println(&quot;程序出现异常，变量b不能为0&quot;); &#125; finally &#123;//处理善后工作，无论是否报错这个finally都是会执行的，无论怎样都会执行，报其他错也会执行 System.out.println(&quot;finally&quot;); //finally可以不要finally，假设IO时读取文件关闭资源关闭时可以用 &#125; 例2 123456public static void main(String args[])&#123; int a=1; int b=0; try &#123;//try监控区域 new Main().a();//这是一个栈溢出的异常 &#125; catch(Error e)//这个地方如果时Error和Throwable都可以，就是根据上面那个表格，cathch括号里错误类型的子类也可以被捕获 &#123;//catch 捕获异常 System.out.println(&quot;程序出现异常，变量b不能为0&quot;); &#125; finally &#123;//处理善后工作，无论是否报错这个finally都是会执行的，无论怎样都会执行，报其他错也会执行 System.out.println(&quot;finally&quot;); //finally可以不要finally，假设IO时读取文件关闭资源关闭时可以用 &#125; &#125; public void a() &#123; b(); &#125; public void b() &#123; a(); &#125; 例3 有多个catch的异常处理机制，只能执行一个catch，所以越往下catch括号里的错误类型越高层，从小到大去捕获 123try &#123;//try监控区域 new Main().a();//这是一个栈溢出的异常 &#125; catch(Error e)//这个地方的错误必须是和try中出现的错误类型相同，否则没什么用 &#123;//catch 捕获异常 System.out.println(&quot;程序出现异常，变量b不能为0&quot;); &#125; catch(Exception e) &#123; System.out.println(&quot;exception&quot;); &#125; catch(Throwable e) &#123; System.out.println(&quot;throwable&quot;); &#125; finally &#123;//处理善后工作，无论是否报错这个finally都是会执行的，无论怎样都会执行，报其他错也会执行 System.out.println(&quot;finally&quot;); //finally可以不要finally，假设IO时读取文件关闭资源关闭时可以用 &#125; 例四 throw和throws的用法，是用来主动抛出异常 public void test(int a,int b) throws ArithmeticException&#123;//有throws就是在调用这个方法的时候要对这个异常进行捕获，也就是下面使用这个trycatch /*if(b==0) &#123; throw new ArithmeticException();//主动的抛出异常，一般在方法中使用 &#125;*/ &#125; public static void main(String[] args) &#123; try &#123; new Hello().test(1,0); &#125; catch(ArithmeticException e)&#123; e.printStackTrace(); &#125; &#125; 不用throws的话就是要在throw那个地方去进行一个异常捕获 自定义异常exception类能被继承的常用方法： public void printStackTrace() public String toString() public String getMessage() 除内置的异常类可以描述大部分异常情况，除此之外，用户还可以自定义异常，用户自定义异常类，只需继承Exception类即可； 1.创建自定义异常类 2.在方法中通过throw关键字抛出异常对象 3.如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理；否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作 4.再出现异常方法的调用者捕获并处理异常 例子 自定义的异常类 12345678910111213141516package Main;class MyException extends Exception&#123;//传递数字大于10 private int detail; public MyException(int a) &#123; this.detail=a; &#125; @Override public String toString() &#123; return &quot;MyException&#123;&quot;+detail+&#x27;&#125;&#x27;; &#125;&#125; 测试 123456789101112131415161718192021class Test&#123;static void test(int a) throws MyException&#123; System.out.println(&quot;传递的参数为: &quot;+a); if(a&gt;10) &#123; throw new MyException(a)//抛出 &#125; System.out.println(&quot;ok&quot;);&#125;public static void main(String[] args)&#123;try &#123; test(11);&#125;catch(MyException e)&#123; System.out.println(&quot;MyException=&gt;&quot;+e);//这是调用e类中的toString方法&#125;&#125;&#125; 1234567891011121314### 自定义异常的常用格式public class MyException extends Exception&#123;public MyException()&#123;&#125;public MyException(String msg)&#123;super(msg);&#125;&#125; ATM 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package Main;import java.util.Scanner;class NoMoney extends Exception &#123; public NoMoney() &#123; &#125; public NoMoney(String msg) &#123; super(msg);//构造方法传报错信息 &#125; /* public String toString () &#123; return &quot;您的余额不足，您当前余额为&quot;+Main.money; &#125;*/&#125;class Main&#123; public static double money=0; public void deposit(double a) &#123; this.money+=a; System.out.println(&quot;您的当前余额为&quot;+this.money); &#125; public void query() &#123; System.out.println(&quot;您的当前余额为&quot;+this.money); &#125; public void withdraw(double a) throws NoMoney &#123; if(this.money&lt;a) &#123; throw new NoMoney(&quot;余额不足&quot;); &#125; &#125;public static void main(String []args) &#123; int index=0; while(true) &#123; if(index==0) &#123; System.out.println(&quot;您可以输入 查询余额,取款,存款,退出&quot;);&#125; index++; Scanner in=new Scanner(System.in); String str=in.nextLine(); String str1=&quot;查询余额&quot;; String str2=&quot;取款&quot;; String str3=&quot;存款&quot;; String str4=&quot;退出&quot;; Main discount =new Main(); if(str.equals(str1))&#123; discount.query(); &#125; else if(str.equals(str2))&#123; System.out.println(&quot;您要取出的金额是&quot;); double count =in.nextDouble(); try &#123; discount.withdraw(count); Main.money=Main.money-count; System.out.println(&quot;您当前的余额是&quot;+Main.money); &#125; catch(NoMoney e)&#123; //System.out.println(&quot;您当前的余额不足,您当前的余额是&quot;+Main.money); /*System.out.println(e.toString()); continue;*/ e.printStackTrace();//打印报错信息和堆栈信息 System.out.println(e.getMessage());//打印获得的报错信息 &#125; &#125; else if(str.equals(str3)) &#123; System.out.println(&quot;您要存入的金额是&quot;); double count=in.nextDouble(); discount.deposit(count); &#125; else if(str.equals(str4))&#123; break; &#125; else &#123; System.out.println(&quot;输入内容有问题&quot;); continue; &#125; &#125; &#125; &#125;# 异常语句的执行顺序分析12345678910111213141516public class Demo&#123; public int add(int a,int b)&#123; try&#123; return a+b; &#125;catch(Exception e)&#123; System.out.println(“catch 语句块”); &#125;finally&#123; System.out.println(“finally 语句块”); &#125; return 0; &#125; public static void main(String[] args)&#123; Demo demo = new Demo(); System.out.println(“和是：”+demo.add(9,34)); &#125;&#125; 执行结果： finally 语句块和是：43 调用add方法之后一直等到finally调用完才返回到主函数 java中的泛型泛型初体验 123456789101112131415161718192021//编译期间检查类型//减少了数据类型的转换ArrayList&lt;String&gt; strList=new ArrayList&lt;&gt;();strList.add(&quot;a&quot;);strList.add(&quot;b&quot;);strList.add(&quot;c&quot;);for(int i=0;i&lt;strList.size();i++)&#123; String s=strList.get(i); System.out.println(s);&#125;ArrayList&lt;Integer&gt; intList=new ArrayList&lt;&gt;();intList.add(100);intList.add(200);intList.add(300);for(int i=0;i&lt;intList.size();i++)&#123; int num=intList.get(i); System.out.println(num);&#125; 泛型类的创建12345678910111213141516171819202122232425/*泛型类的定义 * &lt;T&gt;泛型标识--类型形参 * T 创建对象的时候里指定具体的数据类型 */ public class Generic &lt;T&gt;&#123; //T，是由外部使用类的时候来指定 private T key; public Generic(T key) &#123; this.key=key; &#125; public T getKey() &#123; return key; &#125; public void setKey(T key) &#123; this.key=key; &#125; @Override public String toString() &#123; return &quot;Generic&#123;&quot;+&quot;key=&quot;+key+&#x27;&#125;&#x27;; &#125;&#125; 泛型类使用语法： 类名&lt;具体的数据类型&gt; 对象名&#x3D;new 类名&lt;具体的数据类型&gt;(); 或者 类名&lt;具体的数据类型&gt; 对象名&#x3D;new 类名&lt;&gt;(); 测试123456public static void main(String []args) &#123; //泛型类在创建对象的时候，来指定操作的具体的数据类型 Generic&lt;String&gt; strGeneric=new Generic&lt;&gt;(&quot;赵梓皓&quot;); String key1=strGeneric.getKey(); System.out.println(&quot;key1:&quot;+key1); Generic&lt;Integer&gt; intGeneric =new Generic&lt;&gt;(123); int key=intGeneric.getKey(); System.out.println(&quot;key:&quot;+key); //泛型类在创建对象的时候，没有指定类型，将按照Object类型来操作 Generic generic =new Generic(&quot;ABC&quot;); Object key3=generic.getKey(); System.out.println(&quot;key3:&quot;+key3); //泛型类不支持基本数据类型 // Generic &lt;int&gt; generic2=new Generic &lt;int&gt;(100); //同一泛型类，根据不同的数据类型创建的对象，本质上是同一类型，是Generic类型 System.out.println(intGeneric.getClass()); System.out.println(strGeneric.getClass()); System.out.println(intGeneric.getClass()==strGeneric.getClass()); &#125; 注意事项：泛型类，如果没有指定具体的数据类型，此时，操作类型是Object 2.泛型的类型参数只能是类类型，不能是基本数据类型 3.泛型类型在逻辑上可以看成是多个不同的类型，但实际上都是相同类型 泛型类的使用抽奖器泛型类 1234567891011121314151617import java.util.ArrayList;import java.util.Random;public class ProductGetter &lt;T&gt; &#123; Random random=new Random(); //奖品private T product;//奖品池ArrayList &lt;T&gt; list=new ArrayList&lt;T&gt;();public void addProduct(T t) &#123; list.add(t);&#125; //抽奖public T getProduct() &#123; return list.get(random.nextInt(list.size()));&#125;&#125; 抽奖器使用 1234567891011121314151617181920class Main&#123; public String b=&quot;100&quot;; public static void main(String []args) &#123; //创建抽奖器对象，指定数据类型 ProductGetter&lt;String&gt; stringProductGetter=new ProductGetter&lt;&gt;(); String[] strProducts= &#123;&quot;苹果手机&quot;,&quot;华为手机&quot;,&quot;扫地机器人&quot;,&quot;咖啡机&quot;&#125;; //给抽奖器中，填充奖品 for(int i=0;i&lt;strProducts.length;i++) &#123; stringProductGetter.addProduct(strProducts[i]); &#125; //抽奖 String product1=stringProductGetter.getProduct(); System.out.println(&quot;恭喜您，你抽中了&quot;+product1); &#125;&#125; 泛型类派生子类1.子类也是泛型类，子类和父类的泛型类型一致 class ChildGeneric extends Generic 2.子类不是泛型类，父类要明确泛型的数据类型 class ChildGeneric extends Generic 例一： 1234567891011父类public class Parent &lt;E&gt; &#123;private E value;public E getValue() &#123; return value;&#125;public void setValue(E value) &#123; this.value=value;&#125;&#125; 123456789子类 //子类中可以泛型扩展，但必须要有一个泛型和父类中的一样 //泛型类派生子类，子类也是泛型类的情况时，子类的泛型标识要和父类一致public class ChildFirst&lt;T&gt; extends Parent&lt;T&gt; &#123; @Override public T getValue() &#123; return super.getValue(); &#125;&#125; 1234567891011测试class Main&#123; public static void main(String []args) &#123; ChildFirst&lt;String&gt; childFirst=new ChildFirst&lt;String&gt;(); childFirst.setValue(&quot;abc&quot;); String value=childFirst.getValue(); System.out.println(value); &#125;&#125; 例二 &#96;&#96;&#96;java&#x2F;* 子类 当泛型类派生自类的时候，如果子类不是泛型类那么父类要明确数据类型*&#x2F;public class ChildFirst extends Parent { @Override public String getValue() { return super.getValue(); }}1 1234567891011 * 测试class Main&#123; public static void main(String []args) &#123; ChildFirst childfirst=new ChildFirst(); childfirst.setValue(&quot;abc&quot;); String value1=childfirst.getValue(); System.out.println(value1); &#125;&#125; 泛型接口 1.泛型接口的实现类不是泛型类，接口要明确数据类型 泛型接口 1234567* /* * 泛型接口 */ public interface Generator&lt;T&gt; &#123; T getKey(); &#125; 子类 1234567891011public class Apple implements Generator&lt;String&gt;&#123; /* * 实现泛型接口的类，不是泛型类，需要明确实现泛型接口的数据类型 */ @Override public String getKey() &#123; return &quot;hello generic&quot;; &#125;&#125; 测试 12345678class Main&#123; public static void main(String []args) &#123; Apple apple=new Apple(); String key=apple.getKey(); System.out.println(key); &#125;&#125; 2.实现类也是泛型类，实现类和接口的泛型类型要一致 /*子类 123456789101112131415161718192021* 泛型接口的实现类是一个泛型类，那么要保证实现接口的泛型类泛型标识包含泛型接口的泛型标识 */ //实现类的泛型标识必须和接口的一样 public class Apple&lt;T,E&gt; implements Generator&lt;T&gt;&#123; private T key; private E value; public Apple(T key,E value)&#123; this.key=key; this.value=value; &#125; @Override public T getKey() &#123; return key; &#125; public E getValue() &#123; return value; &#125; &#125; 123* ``` /*泛型类 泛型接口*&#x2F;public interface Generator {T getKey();} 12345678910111213141516 实现类```javaclass Main&#123; public static void main(String []args) &#123; Apple&lt;String,Integer&gt; apple=new Apple&lt;&gt;(&quot;abc&quot;,100); String a=apple.getKey(); int b=apple.getValue(); System.out.println(a+b); &#125;&#125; 泛型方法12345修饰符 &lt;T,E,...&gt; 返回值类型 方法名(形参列表) &#123;方法体&#125; 泛型类 &#96;&#96;&#96;javaimport java.util.ArrayList; import java.util.Random; 123456789101112131415161718192021222324public class ProductGetter &lt;T&gt; &#123; Random random=new Random(); //奖品private T product;//奖品池ArrayList &lt;T&gt; list=new ArrayList&lt;T&gt;();public void addProduct(T t) &#123; list.add(t);&#125; //抽奖public T getProduct() &#123;//这都不是泛型方法，是用泛型的成员方法 return list.get(random.nextInt(list.size()));&#125;/* * 定义泛型方法 * 这里定义的就是一个泛型方法，有了&lt;E&gt;泛型标识，方法里就可以用这个泛型标识，具体类型由调用方法的时候来指定 */ public &lt;E&gt; E getProduct(ArrayList&lt;E&gt; list) &#123;//这个泛型方法的类型是独立于泛型类的 return list.get(random.nextInt(list.size())); &#125; &#125; 测试 123456789101112class Main&#123; public static void main(String []args) &#123; ProductGetter&lt;Integer&gt; productGetter=new ProductGetter&lt;&gt;(); ArrayList&lt;String&gt; strList=new ArrayList&lt;&gt;(); strList.add(&quot;笔记本&quot;); strList.add(&quot;手机&quot;); //这是对泛型方法的调用，类型是通过调用方法的时候来制定的，这个地方就是指定E类型为String String product1=productGetter.getProduct(strList); System.out.println(product1); &#125;&#125; 注意问题： 1.如果一个普通的成员方法用了类的这个泛型类型，是不能用static来修饰的 2.如果是泛型方法可以支持静态 静态类型的泛型方法 12345678910/* * 静态类型的泛型方法，采用多个泛型类型 */ public static &lt;E,T,K&gt; void printtype(E e,T t,K k) &#123; System.out.println(t.getClass()); System.out.println(e.getClass()); System.out.println(k.getClass()); &#125; 测试 123public static void main(String []args) &#123; ProductGetter.printtype(100,&quot;java&quot;,true);&#125; 泛型方法与可变参数 例子 1234567//因为参数的数目是可以变化的，所以可以形成数组//泛型方法对可变参数的支持public static &lt;E&gt; void print(E...e) &#123; for(int i=0;i&lt;e.length;i++) &#123; System.out.println(e[i]); &#125;&#125; 测试 123public static void main(String []args) &#123; ProductGetter.print(1,2,3,4,5,6);&#125; 总结：泛型方法能使方法独立于类而产生变化 如果static方法要使用泛型能力，就必须使其成为泛型方法 类型通配符方法参数使用类的泛型标识符时不能重载，因为标识符从根本上都是Object类 注意：1.类型通配符一般是使用“?”代替具体的类型实参 2.所以，类型通配符是类型实参，而不是类型形参 通配符初体验 1234567891011121314151617181920class Main&#123; public static void main(String []args) &#123; Box&lt;Number&gt; box1=new Box&lt;&gt;(); box1.setFirst(100); showBox(box1); Box&lt;Integer&gt; box2=new Box&lt;&gt;(); box2.setFirst(200); showBox(box2); &#125; public static void showBox(Box&lt;?&gt;box)//这个地方是问号就可以是任意类型的，都可以用这个showBox方法，但如果是Number类型的，即使是它的子类Integer也不能用因为标识符类型本质上都是一样的Object类所以不能进行方法重载 &#123; Object first=box.getFirst(); System.out.println(first); &#125;&#125; 通配符设置上限语法 类&#x2F;接口&lt;? extends 实参类型&gt; 要求该泛型的类型，只能是实参类型，或者是实参类型的子类类型 1234567891011121314151617181920class Main&#123; public static void main(String []args) &#123; Box&lt;Number&gt; box1=new Box&lt;&gt;(); box1.setFirst(100); showBox(box1); Box&lt;Integer&gt; box2=new Box&lt;&gt;(); box2.setFirst(200); showBox(box2); &#125; public static void showBox(Box&lt;? extends Number&gt;box)//这里意思就是最大接收的类型就是Number，如果单独是一个?的话就是最大是Object &#123; Number first=box.getFirst(); System.out.println(first); &#125;&#125; 例子： Cat是miniCat的父类，Animal是Cat的父类 1234567891011121314151617181920212223242526public class miniCat extends Cat&#123; public static void main(String[] args) &#123; ArrayList&lt;Animal&gt; animals=new ArrayList&lt;&gt;(); ArrayList&lt;Cat&gt; cats=new ArrayList&lt;&gt;(); ArrayList&lt;miniCat&gt; miniCats=new ArrayList&lt;&gt;(); //showAnimal(animals);这个会报错因为下面的通配符上限是Cat，传递的集合类型只能是Cat或Cat的子类 showAnimal(cats); showAnimal(miniCats); &#125; public static void showAnimal(ArrayList&lt;? extends Cat&gt; list) &#123; //这种用通配符来表述存储对象类型的集合是不能向其中添加元素的 /*list.add(new Cat()); list.add(new miniCat()); list.add(new Animal());*/ for(int i=0;i&lt;list.size();i++) &#123; //ArrayList通配符上限为Cat所以下面用Cat引用变量接受没有任何问题 Cat cat = list.get(i);//这个地方得到集合的类型，引用变量必须是最大的那一种 System.out.println(cat); &#125; &#125;&#125; 类型通配符的下限类&#x2F;接口&lt;? super 实参类型&gt; 要求该泛型的类型，只能是实参类型，或实参类型的父类类型 通配符下限初体验 12345678910111213141516171819202122232425import java.util.ArrayList;public class miniCat extends Cat&#123; public static void main(String[] args) &#123; ArrayList&lt;Animal&gt; animals=new ArrayList&lt;&gt;(); ArrayList&lt;Cat&gt; cats=new ArrayList&lt;&gt;(); ArrayList&lt;miniCat&gt; miniCats=new ArrayList&lt;&gt;(); showAnimal(animals); showAnimal(cats); // showAnimal(miniCats);要求只能是Cat或者Cat的父类类型，所以这个地方报错 &#125; /* * 类型通配符的下限，要求集合只能是Cat或Cat的父类类型 */ public static void showAnimal(ArrayList&lt;? super Cat&gt; list) &#123; for(Object o:list) &#123;//当接受用下限通配符标识的集合元素的时候，用object，因为Object是所有类的父类 System.out.println(o); &#125; &#125;&#125; TreeSet是通过自己定义的比较器来排序的 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Main&#123; public static void main(String []args) &#123; TreeSet&lt;Cat&gt; treeSet=new TreeSet&lt;&gt;(new Comprator2());//因为是comprator2所以是按照年龄大小来排序的 //TreeSet&lt;Cat&gt; treeSet=new TreeSet&lt;&gt;(new Comprator1());不会报错 //TreeSet&lt;Cat&gt; treeSet=new TreeSet&lt;&gt;(new Comprator3());会报错 //因为TreeSet的这个地方泛型是Cat它的构造方法也用到了泛型，只有是继承Cat或Cat子类标识Comparator接口的比较器才能够好用 treeSet.add(new Cat(&quot;jerry&quot;,20)); treeSet.add(new Cat(&quot;amy&quot;,22)); treeSet.add(new Cat(&quot;frank&quot;,23)); treeSet.add(new Cat(&quot;jim&quot;,25)); for(Cat cat:treeSet) &#123; System.out.println(cat); &#125; &#125;&#125;class Comprator1 implements Comparator&lt;Animal&gt;&#123; @Override public int compare(Animal o1, Animal o2) &#123; // TODO Auto-generated method stub return o1.name.compareTo(o2.name); &#125;&#125;class Comprator2 implements Comparator&lt;Cat&gt;&#123; @Override public int compare(Cat o1, Cat o2) &#123; // TODO Auto-generated method stub return o1.age-o2.age; &#125;&#125;class Comprator3 implements Comparator&lt;miniCat&gt;&#123; @Override public int compare(miniCat o1, miniCat o2) &#123; // TODO Auto-generated method stub return o1.level-o2.level; &#125;&#125; 12345public Treeset(Comparator &lt;? super E&gt; comparator)&#123;&#125; 类型擦除123456public static void main(String []args) &#123; //泛型类在创建对象的时候，来指定操作的具体的数据类型 Generic&lt;String&gt; strGeneric=new Generic&lt;&gt;(&quot;赵梓皓&quot;); String key1=strGeneric.getKey(); System.out.println(&quot;key1:&quot;+key1); Generic&lt;Integer&gt; intGeneric =new Generic&lt;&gt;(123); int key=intGeneric.getKey(); System.out.println(&quot;key:&quot;+key); //泛型类在创建对象的时候，没有指定类型，将按照Object类型来操作 Generic generic =new Generic(&quot;ABC&quot;); Object key3=generic.getKey(); System.out.println(&quot;key3:&quot;+key3); //泛型类不支持基本数据类型 // Generic &lt;int&gt; generic2=new Generic &lt;int&gt;(100); //同一泛型类，根据不同的数据类型创建的对象，本质上是同一类型，是Generic类型 System.out.println(intGeneric.getClass()); System.out.println(strGeneric.getClass()); System.out.println(intGeneric.getClass()==strGeneric.getClass()); } 判断两个类型是否相同 最后是相同的 因为泛型只有在编译阶段存在，编译结束之后类型就擦除了，都是Object类 泛型数组的创建可以声明带泛型的数组引用，但是不能直接创建带泛型的的数组对象 1234567891011class Main&#123; public static void main(String []args) &#123; ArrayList&lt;String&gt;[] listArr=new ArrayList[5];//定义泛型数组的方式，操作的时候就是拿引用去操作 ArrayList&lt;String&gt; strList=new ArrayList&lt;&gt;(); strList.add(&quot;abc&quot;); listArr[0]=strList; String s=listArr[0].get(0); System.out.println(s); &#125;&#125; 可以通过java.lang.reflect.Array的newInstance(Class,int) 创建T[]数组 Fruit 1234567891011121314151617181920212223package Main;import java.lang.reflect.Array;public class Fruit&lt;T&gt; &#123; private T[] array; public T[] getArray() &#123; return array; &#125; public void setArray(T[] array) &#123; this.array = array; &#125; public Fruit(Class&lt;T&gt; clz,int length)&#123;array=(T[])Array.newInstance(clz, length); &#125; public void put(int index, T string) &#123; array[index]=string; &#125; &#125; 测试 12345678910111213class Main&#123; public static void main(String []args) &#123; Fruit&lt;String&gt; fruit=new Fruit&lt;&gt;(String.class ,3); fruit.put(0,&quot;苹果&quot;); fruit.put(1,&quot;西瓜&quot;); fruit.put(2,&quot;香蕉&quot;); System.out.println(Arrays.toString(fruit.getArray())); &#125;&#125; 一个利用比较器以及string的compareTo的一个题 java的File类java.io.File类 文件和目录路径的抽象表示形式 java把电脑中的文件和文件夹封装为了一个File类，我们可以使用File类对文件和文件夹进行操作 我们可以使用File类的方法 创建一个文件&#x2F;文件夹等等 File类是一个和系统无关的类，任何的操作系统都可以使用这个类中的方法 重点记住三个单词：file：文件 directory：文件夹&#x2F;目录 path：路径 File类的静态属性 123456String pathSeparator=File.pathSeparator;//路径分隔符，分割多个路径的，windows系统是分号，linux系统是冒号System.out.println(pathSeparator);String separator=File.separator;System.out.println(separator);//文件名称分隔符，windows系统是反斜杠\\ linux系统是正斜杠///操作路径&quot;C:&quot;+File.separator+&quot;develop&quot;+File.separator+&quot;a&quot;+File.separator+&quot;a.txt&quot;//将反斜杠或者正斜杠用File.separator代替，不写死 绝对路径与相对路径 构造方法 &#96;&#96;&#96;java&#x2F;*一 File(String pathname) 通过将给定路径名字字符串转换为抽象路径来创建一个新的File实例 参数： String pathname 字符串的路径名称 路径可以是文件结尾也可以是文件夹结尾 路径可以是相对路径，也可以是绝对路径 路径可以存在也可以不存在，创建File对象，只是把字符串封装为File对象，不考虑路径的真假情况 *&#x2F;File f1&#x3D;new File(“D:\\放乱七八糟\\File.txt”);System.out.println(f1);&#x2F;&#x2F;重写了object类里的toString方法输出路径 D:\\放乱七八糟\\File.txt 1234567891011121314/* * ``` * File(String parent,Stringchild) * 参数分为两部分，String parent父路径 * String child 子路径 * 好处： * 父路径和子路径可以单独书写，使用起来非常灵活，父路径和子路径都可以变化 */ File f1=new File(&quot;c:\\\\&quot;,&quot;a.txt&quot;); System.out.println(f1); File f2=new File(&quot;d:\\\\&quot;,&quot;a.txt&quot;); System.out.println(f2); ​ &#x2F;* * ``` * File(File parent,String child)根据parent抽象路径名和child路径字符串创建一个新File实例 * 参数：把路径分为了两部分 * File parent：父路径 * String child：子路径 * 好处： * 父路径和子路径可以单独书写，使用起来非常灵活，父路径和子路径都可以变化 * */ File parent=new File(&quot;c:\\\\&quot;); File file=new File(parent,&quot;hello.java&quot;); System.out.println(file); 123456789 ## 常用方法### 获取方法public String getAbsolutePath() :返回此File的绝对路径字符串，获取构造方法中的传递的路径，不管你写的是相对的还是绝对的都返回绝对路径字符串 File f1&#x3D;new File(“C:\\a.txt”);System.out.println(f1.getAbsolutePath());File f2&#x3D;new File(“a.txt”);System.out.println(f2.getAbsolutePath());结果:C:\\a.txtD:\\Java\\12345\\a.txt 1234567891011public String getPath()将此File转换为路径名字符串```javaFile f1=new File(&quot;C:\\\\a.txt&quot;);System.out.println(f1.getPath());File f2=new File(&quot;a.txt&quot;);System.out.println(f2.getPath());结果：C:\\a.txta.txt public String getName()返回由此File表示的文件或目录的名称 1234567File f1=new File(&quot;C:\\\\a.txt&quot;);System.out.println(f1.getName());File f2=new File(&quot;a.txt&quot;);System.out.println(f2.getName());结果：a.txta.txt public long length() 获取的式构造方法指定的文件的大小，以字节为单位 注意： 文件夹是没有大小概念的，不能获取文件夹的大小，如果构造方法中给出的路径不存在，那么length方法返回零 文件夹没有大小概念，返回值也是零 1234567File f1=new File(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);System.out.println(f1.length());File f2=new File(&quot;a.txt&quot;);System.out.println(f2.length());结果：100 判断功能的方法public boolean exists() ：此File表示的文件或目录是否实际存在 用于判断构造方法中的路径是否存在 存在：true 不存在：false 123File f1=new File(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);System.out.println(f1.exists());结果：true 123File f1=new File(&quot;D:\\\\放乱七八糟\\\\Fil.txt&quot;);System.out.println(f1.exists());结果：false 注意下面两个判断方法的路径必须是存在的如果不存在则都返回false public boolean isDirectory() 表示此File是否为目录 用于判断构造方法中给定的路径是否是以文件夹结尾 123File f1=new File(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);System.out.println(f1.isDirectory());结果:false publicboolean isFile() 用于判断构造方法中给定的路径是否是以文件结尾 123File f1=new File(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);System.out.println(f1.isFile());结果：true 123File f1=new File(&quot;D:\\\\放乱七八糟\\\\Fil.txt&quot;);System.out.println(f1.isFile());结果：false 因为路径不存在 创建删除功能的方法public boolean createNewFile() :当且仅当具有该名称的文件尚不存在时，创建一个新的空文件 创建文件的路径和名称在构造方法中给出（构造方法的参数） 返回值：布尔值 true：文件不存在，创建文件，返回true false：文件存在不会创建，返回false 注意;1.此方法之恩那个创建文件，不能创建文件夹所以创建文件的路径必须存在，否则会抛出异常 123456File f1=new File(&quot;D:\\\\放乱七八糟\\\\Fil.txt&quot;);try &#123; System.out.println(f1.createNewFile());&#125; catch (IOException e) &#123; e.printStackTrace();//createNewFile声明抛出了IOException，我们调用这个方法，就必须的处理这个异常，要么throws，要么trycatch如果调用方法的时候也throws就会交给jvm处理&#125; 如果路径不存在则会抛出IO异常 public boolean mkdir() :创键单级空文件夹 public boolean mkdirs() :创建单级空文件夹，也可以创建多级文件夹 创建文件夹的路径和名称在构造方法中给出（构造方法的参数） 返回值：布尔值 true：文件夹不存在，创建文件夹，返回true false：文件夹存在不会创建，返回false，构造方法中给出的路径不存在返回false 注意;1.此方法只能创建文件夹，不能创建文件 123456789File f1=new File(&quot;D:\\\\放乱七八糟\\\\aaa\\\\bb&quot;);System.out.println(f1.mkdir());//不能创建多级目录File f2=new File(&quot;D:\\\\放乱七八糟\\\\aaa\\\\bb&quot;);System.out.println(f1.mkdirs());File f3=new File(&quot;D:\\\\放乱七八糟\\\\ccc&quot;);System.out.println(f3.mkdir());结果：falsetruetrue public boolean delete() 删除构造方法路径中给出的文件和文件夹 返回值也是一个布尔值 true：文件&#x2F;文件夹删除成功，返回true false：文件夹中有内容，不会删除返回false，构造方法中的路径不存在返回false，文件不管里面有没有内容都会删除 注意： delete方法是直接在硬盘删除文件&#x2F;文件夹，不走回收站，删除要谨慎 1234567File f2=new File(&quot;D:\\\\放乱七八糟\\\\aaa\\\\bb&quot;);System.out.println(f2.delete());File f3=new File(&quot;D:\\\\放乱七八糟\\\\ccc&quot;);System.out.println(f3.delete());结果：truetrue删除路径的最后一个文件或者文件夹 1234File f2=new File(&quot;D:\\\\放乱七八糟\\\\aaa&quot;);System.out.println(f2.delete());结果false因为文件夹aaa中有内容 1234File f2=new File(&quot;D:\\\\放乱七八糟\\\\aaa\\\\新建文本文档.txt&quot;);System.out.println(f2.delete());结果：true就算txt文件中有内容也会被删除 目录的遍历功能public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录（隐藏的也能获取到） 遍历构造方法中给出的目录，会获取目录中所有文件&#x2F;文件夹的名称，把获取到的多个名称存储到一个字符串String类型的数组中 public File[] listFiles(): 返回一个File数组，表示该File目录中所有的子文件或目录 遍历一个构造方法中给出的目录，会获取目录中所有个文件&#x2F;文件夹，把文件或文件夹封装为File对象，多个File对象存储到File数组里 注意： list方法和listFiles方法遍历的是构造方法中给出的目录 如果构造方法中给出的目录的路径不存在，会抛出空指针异常 如果构造方法中给出的路径不是一个目录，也会抛出空指针异常 1234567891011File f2=new File(&quot;D:\\\\放乱七八糟&quot;);String str[]=f2.list();for(String filename:str) &#123; System.out.println(filename);&#125;结果：eclipse.zipEverything-1.4.1.1017.x64-Setup.exeFil.txtFile.txtjava8中文说明文档321456第五章.ppt 1234567891011File file=new File(&quot;D:\\\\放乱七八糟&quot;);File []files=file.listFiles();for(File f:files) &#123; System.out.println(f);&#125;结果：D:\\放乱七八糟\\eclipse.zipD:\\放乱七八糟\\Everything-1.4.1.1017.x64-Setup.exeD:\\放乱七八糟\\Fil.txtD:\\放乱七八糟\\File.txtD:\\放乱七八糟\\java8中文说明文档321456D:\\放乱七八糟\\第五章.ppt 递归递归的分类：1.直接递归和间接递归 直接递归：main(){ a() } a(){ a();自己调用自己 } 间接递归：b(){ c();} c(){ b();} 注意事项：1.递归一定要有条件限定，保证递归能够停下来，否则会发生栈内存溢出 2.在递归中虽然有限定条件，但是递归次数不能太多，否则也会发生栈内存溢出 3.构造方法，禁止递归，编译错误，构造方法是创建对象时侯用的，一直递归会导致内存中有无数多个对象，直接编译报错 递归地使用前提：当调用方法的时候，方法的主体不变，每次调用方法的参数不同，可以使用递归 为什么递归无限制会导致栈内存溢出 a方法会在栈内存中一直调用a方法，就会导致栈内存中由无数多个a方法 方法太多了，超出栈内存的大小，就会导致内存溢出的错误 注意： 当一个方法调用其他方法时，被调用的方法没有执行完毕，当前方法就会一直等待低矮哦用的方法执行完毕才会继续执行 1使用递归计算0到n之间的和 1234567891011121314class Main&#123; public static void main(String []args) &#123; int s=Sum(3); System.out.println(s);&#125; public static int Sum(int n) &#123; if(n==1) return 1; return n+Sum(n-1); &#125;&#125; 递归计算阶乘 12345 public static void main(String []args) &#123; int s=Sum(7); System.out.println(s);&#125; public static int Sum(int n) &#123; if(n==1) return 1; return n*Sum(n-1); &#125; 递归打印多级目录 1遍历c:\\\\abc文件夹，及abc文件夹的子文件夹以及子文件夹中所有文件 12345678910111213141516171819class Main&#123;public static void main(String []args)&#123; File file=new File(&quot;d:\\\\放乱七八糟&quot;); getAllFile(file);&#125;public static void getAllFile(File dir) &#123; System.out.println(dir);//打印被遍历的目录 File[]files=dir.listFiles(); for(File f:files) &#123; if(f.isDirectory()) &#123; getAllFile(f); &#125; else &#123; System.out.println(f); &#125; &#125;&#125;&#125; 综合案例找出目录下文件中只有以.java为结尾的 12345678910111213141516171819202122232425262728293031323334353637class Main&#123;public static void main(String []args)&#123; File file=new File(&quot;D:\\\\同步空间\\\\新建文件夹&quot;); getAllFile(file);&#125;public static void getAllFile(File dir) &#123; // System.out.println(dir); File[]files=dir.listFiles(); for(File f:files) &#123; if(f.isDirectory()) &#123; getAllFile(f); &#125; else &#123; /* * 只要.java结尾的文件 * 把File对象f转换为字符串对象 * String name=f.getName(); * String path=f.getPath(); * String s=f.toString(); * System.out.println(f); */ /* * 2.调用String类中的方法endswith判断字符串是否是以.java结尾 * */ String s=f.toString(); //把字符串转换为小写 //s=s.toLowerCase(); boolean b=s.endsWith(&quot;.java&quot;); if(b) &#123; System.out.println(f); &#125; &#125; &#125;&#125;&#125; 第二种方法 1234567if(f.getName().toLowerCase().endsWith(&quot;.java&quot;))&#123;System.out.println(f);&#125; 文件过滤器优化 1234567891011121314151617181920212223需求：遍历某个文件夹，及其子文件夹，只要.java结尾的文件我们可以使用过滤器来实现，在File类中有两个和ListFiles重载的方法，方法的参数传递就是过滤器File[] listFiles(FileFilter filter)java.io.FileFilter接口：用于抽象路径名（File对象）的过滤器作用：用来过滤文件（File对象）抽象方法：用来过滤文件的方法boolean accept(File pathname) 测定指定抽象路径名是否应该包含在某一个路径名列表中参数： File pathname 使用listFiles方法遍历目录，得到的每一个文件对象 File[] listFiles(FilenameFileter filter) java.io.FilenameFilter接口：实现此接口的类实例可以用于过滤文件名 作用：用于过滤文件名称 抽象方法：用来过滤文件 boolean accept(File dir,String name) 参数： File dir:构造方法中传递的被遍历的目录，也就是除了最后一个之外的 String name:使用ListFiles方法遍历目录，获取的每一个文件/文件夹的名称(也就是最后一个)注意：两个过滤器接口是没有实现类的，需要我们自己写实现类，重写过滤的方法accept，在方法中自己定义过滤的规则 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.Scanner;//创建过滤器FileFilter的实现类，重写过滤方法accept，定义过滤规则//如果accept返回false就不会把这个文件对象放到文件对象数组中//如果accept返回true就可以把这个文件对象放到文件对象数组中class FileFilterimpl implements FileFilter&#123; @Override public boolean accept(File pathname) &#123; //如果是文件夹就返回true，再下面检测出是文件夹会继续调用getAllFile方法 if(pathname.isDirectory()) &#123; return true; &#125;return pathname.getName().toLowerCase().endsWith(&quot;.md&quot;);//要到.md结尾的文件对象 &#125;&#125;class Main&#123;public static void main(String []args)&#123; File file=new File(&quot;D:\\\\同步空间\\\\新建文件夹&quot;); getAllFile(file);&#125;public static void getAllFile(File dir) &#123; // System.out.println(dir); File[]files=dir.listFiles(new FileFilterimpl());//传递过滤器对象 /* * listFiles()方法做了三件事 * 1.listFiles方法会对构造方法中传递的目录进行遍历，获取目录中的每一个文件/文件夹--&gt;封装为File对象 * 2.listFiles会调用参数传递过程中的过滤器的方法accept * 3.listFiles方法会把遍历得到的每一个File对象传递给accept方法的参数叫pathname */ for(File f:files) &#123; if(f.isDirectory()) &#123; getAllFile(f); &#125; else &#123; System.out.println(f); &#125; &#125; &#125; &#125; FileNameFilter过滤器的使用和Lambda优化程序 当接口只有一个抽象方法的时候叫函数式接口此时可以用Lambda表达式来代替这个接口的实例化对像，要实现那一个抽象方法 匿名内部类是当这个接口的实例化对象只用一次时可以用来代替，要实现接口的所有抽象方法 1234567class Main&#123;public static void main(String []args)&#123; File file=new File(&quot;D:\\\\同步空间\\\\新建文件夹&quot;); getAllFile(file);&#125;public static void getAllFile(File dir) &#123;; File[]files=dir.listFiles(new FilenameFilter() &#123; @Override public boolean accept(File dir, String name) &#123; return new File(dir,name).isDirectory()||name.toLowerCase().endsWith(&quot;.md&quot;); &#125; &#125;);//传递过滤器对象 for(File f:files) &#123; if(f.isDirectory()) &#123; getAllFile(f); &#125; else &#123; System.out.println(f); &#125; &#125; &#125; &#125; java的IOio概述 字符和Ascii码的转换问题字符强转为(int)是获得它的Ascii码值 char a=&#39;a&#39;; int b=(int)a; System.out.println(b); 结果：97 ascii码值强转为char就是获得字符 int a =97; char b=(char)a; System.out.println(b); 结果：a 将字符1转换为数字1 123char a=&#x27;1&#x27;;System.out.println(a-&#x27;0&#x27;);结果：1 字节流一切文件数据在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据 在Ascii码中一个英文字符占用一个字节，一个汉字字符占用两个字节的空间 在unicode编码中，一个英文字符占用两个字节一个汉字字符也占用两个字节 UTF-8中，一个英文字符占用一个字节，一个汉字字符占用三个字节空间 字节输出流（OutputStream和FileOutputStream介绍） &#96;&#96;&#96;java java.io.OutputStream 字节输出流 这个抽象类是表示字节输出流的所有类的超类 定义了一些子类共性的成员方法 public void close() :关于此输出流并释放与此流相关联的任何系统资源 public void flush():刷新此输出流并强制任何缓冲的输出字节被写出 public void write(byte[] b):将 b.length字节从指定的字节数组写入此输出流。 public void write(byte[] b, int off, int len):从指定的字节数组写入 len个字节，从偏移 off开始输出到此输出流。 pubic void write(int b):将指定的字节写入此输出流。 java.io.FileOutputStream extends OutputStream FileOutputStream:文件字节输出流 作用：把内存中的数据给写入到硬盘的文件中 构造方法： FileOutputStream(File file)创建文件输出流以写入由指定的 File对象表示的文件。 FileOutputStream(String name) 创建文件输出流以指定的名称写入文件。构造方法作用1.创建一个FileOutputStream对象2.会根据构造方法中传递的文件&#x2F;文件路径，创建一个空的文件3.会把FileOutputStream对象指向创建好的文件 *&#x2F; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223​ **pubic void write(int b)**​ 写入数据的原理（内存到硬盘）：​ java程序--&gt;jvm(虚拟机)--&gt;os（操作系统）--&gt;os调用写数据的方法--&gt;把数据写入文件夹中字节输出流的使用步骤（重点） 1.创建一个FileOutputStream对象，构造方法中传递写入数据的目的地 2.调用FileOutputStream对象中的方法write，把数据写入到文件中 3.释放资源（流使用会占用一定的内存，使用完毕后把内存清空，提供程序效率） public static void main(String[]args) throws IOException &#123; //创建一个FileOutputStream对象，构造方法中传递写入数据的目的地 FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;); //调用FileOutputStream对象中的方法write，把数据写入到文件中 fos.write(97);//这个只能写入一个字节的大小的内容，97是这个字节对应的ASCII码值 //释放资源（流使用会占用一定的内存，使用完毕后把内存清空，提供程序效率） fos.close(); &#125;![image-20220630102639535](https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291918085.png)原理就是：97回先转换为二进制数储存在硬盘（文件）中，当用任何文本编辑器（记事本，notepad）再打开文件的时候，都会查询编码表，把字节转换为字符表示，0-127查询ASCII表 其他值：查询系统默认码表（中文windows系统GBK）我的电脑记事本查询的是UTF-8 **一次写多个字节的方法****public void write(byte[] b):将 b.length字节从指定的字节数组写入此输出流。**一次写多个字节： ​ 如果写的第一个字节是正数（0-127），那么显示的时候会查询ASCII表​ 如果写入的第一个字节是负数，那第一个字节会和第二个字节，两个字节组成一个中文显示，查询系统默认码表（中文系统GBK） 第一个例子 public static void main(String[]args) throws IOException &#123; //创建一个FileOutputStream对象，构造方法中传递写入数据的目的地 FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;); //调用FileOutputStream对象中的方法write，把数据写入到文件中 //在文件中显示100，写入3个字节 byte []bytes= &#123;49,48,48&#125;; fos.write(bytes); //释放资源 fos.close(); &#125;第二个例子 public static void main(String[]args) throws IOException &#123; //创建一个FileOutputStream对象，构造方法中传递写入数据的目的地 FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;); //调用FileOutputStream对象中的方法write，把数据写入到文件中 //在文件中显示100，写入3个字节 byte []bytes= &#123;-65,-66,-67,68,69&#125;; fos.write(bytes); //释放资源 fos.close(); &#125; 文件写入结果： 烤紻E就是前两个加起来组成一个系统默认码，后两个是一个组成一个系统默认码，最后一个时Ascii码**public void write(byte[] b, int off, int len):从指定的字节数组写入 len个字节，从偏移 off开始输出到此输出流。**把字节数组的一部分写入到文件中 public static void main(String[]args) throws IOException &#123; //创建一个FileOutputStream对象，构造方法中传递写入数据的目的地 FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;); //调用FileOutputStream对象中的方法write，把数据写入到文件中 byte []bytes= &#123;-65,-66,-67,68,69&#125;; fos.write(bytes,1,3);//从字节数组的下标1开始写入三个字节 //释放资源 fos.close(); &#125;写入字符的方法，可以使用String类方法把字符串，转换为字节数组，byte []getBytes() 把字符串转换为字节数组 public static void main(String[]args) throws IOException &#123; //创建一个FileOutputStream对象，构造方法中传递写入数据的目的地 FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;); byte []bytes=&quot;你好&quot;.getBytes(); System.out.println(Arrays.toString(bytes));//结果[-60, -29, -70, -61] //中文在eclipse中默认编码是GBK编码所以是一个中文两个字节 // 如果写入的第一个字节是负数，那第一个字节会和第二个字节，两个字节组成一个中文显示，查询系统默认码表（中文系统GBK） fos.write(bytes); fos.close(); &#125; 文件写入结果： 你好**数据的追加写和换行写**上面的方法都是将文件中原有的东西覆盖掉下面是追加写,续写FileOutputStream(String name, boolean append)创建文件输出流以指定的名称写入文件。FileOutputStream(File file, boolean append)创建文件输出流以写入由指定的 File对象表示的文件。​ 参数：​ String name File file：写入数据的目的地​ boolean append ：追加写开关 true ：创建对象不会覆盖源文件，继续在文件的末尾追加写数据​ false：创建一个新文件，覆盖原文件，在新文件中重新写数据 //创建一个FileOutputStream对象，构造方法中传递写入数据的目的地 FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;,true);//追加写 fos.write(&quot;你好&quot;.getBytes()); fos.close(); 源文件内容：你好 程序执行之后：你好你好**换行**写换行符号：windows \\r\\n​ linux:/n​ mac:/r //创建一个FileOutputStream对象，构造方法中传递写入数据的目的地 FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;,true);//追加写 for(int i=1;i&lt;=10;i++) &#123; fos.write(&quot;你好&quot;.getBytes()); fos.write(&quot;\\r\\n&quot;.getBytes()); &#125; fos.close(); 文件添加结果： 你好 你好 你好 你好 你好 你好 你好 你好 你好​ ### 字节输入流（InputStream）FileInputStream和InputStream的介绍java.io.InputStream抽象类时表示字节输入流的所有类的超类，可以读取字节信息到内存中，它定义了字节输入流的基本共性功能方法定义了所有子类的共性的方法：​ int `read()` 从输入流读取数据的下一个字节。返回读取的那一个字节的内容​ int `read(byte[] b)` 从输入流读取一些字节数，并将它们存储到缓冲区 `b` 。返回读取的字节数，读取的内容储存在参数数组​ void `close()` 关闭此输入流并释放与流相关联的任何系统资源。java.io.FileInputStream extends InputStreamFileInputStream :文件字节输入流作用：把硬盘文件中的数据，读取到内存中使用构造方法：`FileInputStream(String name)` - - `FileInputStream(File file)` - 参数：读取文件的数据源 - ​ String name是文件的路径 - ​ File file就是一个文件对象 - 构造方法的作用： - ​ 1.会创建一个FileInputStream对象 - ​ 2.会把FileInputStream对象指定构造方法中要读取的文件 读取数据的原理（硬盘--&gt;内存）：​ java程序--&gt;jvm--&gt;os--&gt;os读取数据的方法--&gt;读取文件字节输入流的使用步骤：​ 1.创建FileInputStream对象，构造方法中绑定要读取的数据源​ 2.使用FileInputStream对象中的方法read，读取文件​ 3.释放资源```java//1.创建FileInputStream对象，构造方法中绑定要读取的数据源 FileInputStream fos=new FileInputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;); //2.使用FileInputStream对象中的方法read，读取文件 int len=fos.read();//读取文件中的一个字节并返回，读取到文件末尾返回-1 //读取读入的那一个字节 System.out.println(len); len=fos.read();//每次read文件中的文件指针会向后移动一位 System.out.println(len); len=fos.read(); System.out.println(len); len=fos.read(); System.out.println(len); len=fos.read(); System.out.println(len); len=fos.read(); System.out.println(len); fos.close(); &#x2F;* 发现以上读取文件是一个重复的过程，所以可以使用循环优化，不知道文件中有多少字节，使用while循环，while循环结束条件，读取到-1时结束*&#x2F; 1234567FileInputStream fos=new FileInputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;); int len=0; while((len=fos.read())!=-1) &#123; System.out.println((char)(len)); &#125; fos.close(); 字节输入流一次读取一个字节的原理 java程序–&gt;jvm–&gt;os–&gt;os读取数据的方法–&gt;读取文件 每次读取结束，文件下标就会向后移一个 字节输入流一次读取多个字节 方法的参数byte[]作用 ​ 起到缓冲的作用，存储每次读取到的多个字节 ​ 数组的长度一般定义为1024（1kb）或者是1024的整数倍 int的返回值是什么 ​ 每次读取到的有效字节个数 123456789101112131415161718192021222324252627282930313233 int `read(byte[] b)` 从输入流读取一些字节数，并将它们存储到缓冲区 `b` 。 返回值是读入了多少个字节 public static void main(String[]args) throws IOException &#123; FileInputStream fis=new FileInputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;); //读取文件，指定读取多少字节 byte []bytes=new byte[2]; int len=fis.read(bytes); System.out.println(len);//2 System.out.println(Arrays.toString(bytes));//65,66 /* * String类的构造方法 * String(byte[] bytes) 通过使用平台的默认字符集解码指定的字节数组来构造新的 String 。String(byte[] bytes, int offset, int length) 通过使用平台的默认字符集解码指定的字节子阵列来构造新的 String offset是开始的下标，length是长度。 */ System.out.println(new String(bytes));//AB len=fis.read(bytes); System.out.println(len);//2,返回的是读到的字节的个数，没读到返回-1 System.out.println(new String(bytes));//CD len=fis.read(bytes); System.out.println(len);//1 System.out.println(new String(bytes));//ED len=fis.read(bytes); System.out.println(len);//-1 System.out.println(new String(bytes));//ED fis.close(); &#125; 第三次读取时只读取到一个E，故len返回1，而且byte数组的第二个位置没有被重新覆盖掉所以剩下的东西还是D，所以第三次输出数组还是ED，第四次没有东西读，所以返回-1结束标记，数组里还是上次的东西DE 循环优化 1234567891011121314public static void main(String[]args) throws IOException &#123;FileInputStream fis=new FileInputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;);//读取文件，指定读取多少字节byte []bytes=new byte[1024];int len=0;while((len=fis.read(bytes))!=-1) &#123; //String(byte[] bytes, int offset, int length) //通过使用平台的默认字符集解码指定的字节子阵列来构造新的 String offset是开始的下标，length是长度。 System.out.println(new String(bytes,0,5));&#125;fis.close();&#125; 字节流练习复制文件 12345678910111213public static void main(String []args) throws IOException &#123; FileInputStream fis=new FileInputStream(&quot;C:\\\\Users\\\\#赵梓皓&amp;\\\\Pictures\\\\Default.jpg&quot;); FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.jpg&quot;); int len=0; 读取之后再写入 while((len=fis.read())!=-1) &#123; fos.write(len); &#125; fos.close();//先关写的 fis.close();//后关闭读的，如果写完了，肯定读取完毕了 &#125; 更高效率 123456789101112 FileInputStream fis=new FileInputStream(&quot;C:\\\\Users\\\\#赵梓皓&amp;\\\\Pictures\\\\Default.jpg&quot;); FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.jpg&quot;); int len=0; byte []bytes=new byte[1024]; while((len=fis.read(bytes))!=-1) &#123; fos.write(bytes,0,len); &#125; fos.close();//先关写的 fis.close();//后关闭读的，如果写完了，肯定读取完毕了&#125; public static void main(String []args) throws IOException &#123; long s=System.currentTimeMillis(); FileInputStream fis=new FileInputStream(&quot;C:\\\\Users\\\\#赵梓皓&amp;\\\\Pictures\\\\Default.jpg&quot;); FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.jpg&quot;); int len=0; byte []bytes=new byte[1024]; while((len=fis.read(bytes))!=-1) &#123; fos.write(bytes,0,len); &#125; fos.close();//先关写的 fis.close();//后关闭读的，如果写完了，肯定读取完毕了 long e=System.currentTimeMillis(); System.out.println(&quot;复制文件共耗时&quot;+(e-s)+&quot;毫秒&quot;); &#125; 字符流一个中文 ​ GBK:占用两个字节 ​ UTF-8：占用3个字节 所以在从硬盘文件中读入中文时没有很好的办法读入中文 使用字节流读取中文文件会产生乱码 字符输入流Reader和FileReader类Reader定义 的一些子类公用的方法,它是字符输入流最顶级的父类 int read() 读一个字符并返回 int read(char[] cbuf) 将字符读入数组 用来一次读取多个字符，返回读取的字符个数。 void close() 关闭流并释放与之相关联的任何系统资源。 java.io.FileReader extends InputStreamReader extends Reader ​ FileReader:文件字符输入流 ​ 作用：把硬盘文件中的数据以字符的方式读取到内存中 构造方法： ​ 1.FileReader(String fileName) 创建一个新的 FileReader ，给定要读取的文件的名称。 ​ 2.FileReader(File file) 创建一个新的 FileReader ，给出 File读取。 作用：创建一个FileReader对象 ​ 会把FileReader对象指向要读取的文件 ​ 参数：String fileName和File file是数据来源 #### 读取字符数据（以及编码问题） 一次读取一个字节 int read() 读一个字符并返回 每次只读取一个字符无论是中文还是英文还是数字 public static void main(String []args) throws IOException &#123; FileReader fis=new FileReader(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;); int len=0; while((len=fis.read())!=-1) &#123; System.out.println((char)len); &#125; fis.close(); &#125; 这里出现了一点小插曲，因为我的电脑记事本默认是UTF-8编码，但eclipse默认编码是GBK所以会出现错误 我把电脑记事本编码转换为ASNI也就是默认是windows中文默认的GBK编码然后就可以实现了 int read(char[] cbuf) 将字符读入数组 用来一次读取多个字符，返回读取的字符个数。 12345678910111213public static void main(String []args) throws IOException &#123; FileReader fis=new FileReader(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;); char[] cs=new char[1024];//存储读取到的多个字符 int len=0; while((len=fis.read(cs))!=-1) &#123; System.out.println(new String(cs)); System.out.println(new String(cs,0,len));//0是开始的索引，len是转换的个数 &#125; fis.close();&#125;读取文件的结果 123你好 123你好 字符输出流Writer类和FileWriter类的介绍 Writer是字符输出流最顶层的父类 定义了一些共性的方法 void write(String str) 写一个字符串 void write(String str, int off, int len) 写一个字符串的一部分。 void write(int c) 写一个字符 void flush() 刷新流 子类：FileWriter java.io.FileWriter extends OutputStreamWriter extends Writer FileWriter:文件字符输出流 作用：把内存中的字符数据写入到文件中 构造方法： ​ FileWriter(File file) 给一个File对象构造一个FileWriter对象。 ​ FileWriter(String fileName) 构造一个给定文件名的FileWriter对象。 ​ 参数：写入数据的目的地 ​ String fileName：文件的路径 ​ File file：是一个文件 ​ 构造方法的作用： ​ 1.会创建一个FileWriter的对象 ​ 2.会根据构造方法中传递的文件&#x2F;文件的路径，创建文件 ​ 3.会把FileWriter对象指向创建好的文件 写出单个字符到文件 字符输出流的使用步骤： ​ 1.创建FileWriter对象，构造方法中绑定要写入数据的目的地 ​ 2.使用FileWriter中的方法write，把数据写到内存缓冲区中（字符转换字节的过程） ​ 3.使用FileWriter中的方法flush，把内存缓冲区中的数据，刷新到文件中 ​ 4.释放资源（会先把内存缓冲区的数据刷新到文件中）所以其实不用flush 如果没有调用flush或者close方法那么文件中将不会写入内容，因为write方法是把数据写到内存缓冲区 123456789public static void main(String []args) throws IOException &#123; //1.创建FileWriter对象，构造方法中绑定要写入数据的目的地 FileWriter fw=new FileWriter(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;); // 2.使用FileWriter中的方法write，把数据写到内存缓冲区中（字符转换字节的过程） fw.write(97); //3 3.使用FileWriter中的方法flush，把内存缓冲区中的数据，刷新到文件中 fw.flush(); fw.close();&#125; flush方法和close方法的区别 flush：刷新缓冲区，流对象可以继续使用 close：先刷新缓冲区，然后通知系统释放资源，流对象不可以再被使用了 字符输出流写数据的其他方法 void write(char []cbuf)写入字符数组 123456 public static void main(String []args) throws IOException &#123;FileWriter fw=new FileWriter(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);char []cs= &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;&#125;;fw.write(cs);fw.close(); &#125; void write(char []cbuf,int off,int len) 123456 public static void main(String []args) throws IOException &#123;FileWriter fw=new FileWriter(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);char []cs= &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;&#125;;fw.write(cs,0,2);//从下标为零开始，读取两个字符fw.close(); &#125; void write(String str)写入字符串 123456 public static void main(String []args) throws IOException &#123;FileWriter fw=new FileWriter(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);String a=&quot;你好&quot;;fw.write(a);fw.close(); &#125; void write(String str,int off,int len) 123456 public static void main(String []args) throws IOException &#123;FileWriter fw=new FileWriter(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);String a=&quot;你好我是java程序员&quot;;fw.write(a,0,4);//从下标为零然后读取四个字符fw.close(); &#125; 字符输出流写数据的续写和换行 续写： ​ 下面是追加写,续写 FileWriter(String name, boolean append)创建文件输出流以指定的名称写入文件。 FileWriter(File file, boolean append)创建文件输出流以写入由指定的 File对象表示的文件。 ​ 参数： ​ String name File file：写入数据的目的地 ​ boolean append ：追加写开关 true ：创建对象不会覆盖源文件，继续在文件的末尾追加写数据 ​ false：创建一个新文件，覆盖原文件，在新文件中重新写数据 换行：换行符号 ​ windows：\\r\\n ​ Linux:&#x2F;n ​ mac:&#x2F;r 123456789101112131415161718FileWriter fw=new FileWriter(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;,true);for(int i=0;i&lt;10;i++) &#123; fw.write(&quot;HelloWorld&quot;+i+&quot;\\r\\n&quot;);&#125;fw.close(); &#125;文件内容： 你好我是HelloWorld0HelloWorld1HelloWorld2HelloWorld3HelloWorld4HelloWorld5HelloWorld6HelloWorld7HelloWorld8HelloWorld9 IO异常的处理fw.close要放在finally中因为程序无论是否报错都得有这个流的关闭 同时fw.close也有异常，所以在fianally里要嵌套一个trycatch 12345678910111213141516171819202122232425262728public static void main(String []args) &#123; //提高变量fw的作用域，让finally可以使用 //变量在定义的时候可以没有值，但是使用的时候必须有值 //如果下面new执行失败了，则fw没有值，fw.close()会报错，所以 FileWriter fw=null; try &#123; //可能会产出异常的代码 fw=new FileWriter(&quot;w:\\\\放乱七八糟\\\\File.txt&quot;,true);for(int i=0;i&lt;10;i++) &#123; fw.write(&quot;HelloWorld&quot;+i+&quot;\\r\\n&quot;);&#125; &#125; catch(IOException e) &#123; System.out.println(e); &#125; finally &#123; //一定会指定的代码 //创建对象失败了，fw的默认值就是null，null是不能调用方法的，会抛出NullPointerException，需要增加一个判断，不是null再把资源释放 if(fw!=null)&#123;try &#123; //fw.close方法声明抛出了IOException异常对象，所以我们就处理这个异常对象，要么throws要么trycatch fw.close();&#125; catch (IOException e) &#123; e.printStackTrace();&#125;&#125; &#125;&#125; JDK7新特性 在try的后面可以增加一个()，在括号中可以定义流对象 那么这个流对象的作用域就在try中有效，就不用自己关闭流了 try中代码执行完毕，会自动把流对象释放，不再写finally try(定义流对象;定义流对象…){ &#x2F;&#x2F;可能会产生异常的代码 } catch(异常类变量 变量名){ 异常处理的逻辑 } 123456789//try括号中的这个流只在try中有效，就不用自己关闭流了 try (FileWriter fw=new FileWriter(&quot;d:\\\\放乱七八糟\\\\File.txt&quot;,true);)&#123;for(int i=0;i&lt;10;i++) &#123; fw.write(&quot;HelloWorld&quot;+i+&quot;\\r\\n&quot;);&#125; &#125; catch(IOException e) &#123; System.out.println(e); &#125; 缓冲流缓冲流都是在基本的流对象基础之上创建来的，就像穿上铠甲的武士一样，相当于是对基本流对象的一种增强 概述： 缓冲流也叫做高效流，是对四个基本的FileXxx流的增强，所以也是四个流，按照数据类型分类： 字节缓冲流：BufferedInputStream，BufferedOutputStream 字符缓冲流：BufferedReader，BufferedWriter 缓冲流的基本原理是在创建流对象的时候，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写效率 就是返回文件内容的时候，不是一个一个返回，是把所有的都整到一个缓冲区里然后全部一起以一个数组的形式返回 字节缓冲输出流java.io.BufferedOutputStream extends OutputStream 继承的父类的共性方法 OutputStream有的方法它都有 构造方法 BufferedOutputStream(OutputStream out) 创建一个新的缓冲输出流，以将数据写入指定的底层输出流 BufferedOutputStream(OutputStream out, int size) 创建一个新的缓冲输出流，以便以指定的缓冲区大小将数据写入指定的底层输出流。 参数：OutputStream 就是一个字节输出流 我们可以传递FileOutputStream，缓冲流会给FileOutputStream增加一个缓冲区，提高FileOutputStream的的写入效率 int size：指定缓冲流内部缓冲区的大小，不指定就是默认的大小 使用步骤： ​ 1.创建FileOutputStream对象，构造方法中绑定要输出的目的地 ​ 2.创建BufferedOutputStream对象，构造方法中传递FileOutputStream对象，提高FileOutputStream对象效率 ​ 3.使用BufferedOutputStream对象中的方法write，把数据写入到内部缓冲区中 ​ 4.使用BufferedOutputStream对象中方法flush，吧内部缓冲区的数据刷新到文件中 ​ 5.释放资源（会先调用flush方法刷新数据，所以第四步可以省略） 12345678910111213141516class Main&#123;public static void main(String []args) throws IOException &#123; // 1.创建FileOutputStream对象，构造方法中绑定要输出的目的地 FileOutputStream fos= new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;); //2.创建BufferedOutputStream对象，构造方法中传递FileOutputStream对象，提高FileOutputStream对象效率 BufferedOutputStream bos=new BufferedOutputStream(fos); //3.使用BufferedOutputStream对象中的方法write，把数据写入到内部缓冲区中 bos.write(&quot;我把数据写入到内部缓冲区中&quot;.getBytes()); //4.使用BufferedOutputStream对象中方法flush，吧内部缓冲区的数据刷新到文件中 bos.flush(); //5.释放资源（会先调用flush方法刷新数据，所以第四步可以省略） bos.close();&#125;&#125; 字节缓冲输入流java.io.BufferedInputStream extends InputStream BufferedInputStream:字节缓冲输入流 所有InputStream有的方法他都有 构造方法 BufferedInputStream(InputStream in) 创建一个 BufferedInputStream并保存其参数，输入流 in ，供以后使用。 BufferedInputStream(InputStream in, int size) 创建 BufferedInputStream具有指定缓冲区大小，并保存其参数，输入流 in ，供以后使用 参数; ​ InputStream in:字节输入流 ​ 我们可以传递FileInputStream，缓冲区会给FileInputStream增加一个缓冲区，提高FileInputStream的读取效率 使用步骤： ​ 1.创建一个FileInputStream对象，构造方法中绑定要读取的数据源 ​ 2.创建BufferedInputStream对象，构造方法中传递FileInputStream对象，提高FileInputStream对象的读取效率 ​ 3.使用BufferedInputStream对象中的方法read()，读取文件 ​ 4.释放资源 123456789101112public static void main(String []args) throws IOException &#123; //1.创建一个FileInputStream对象，构造方法中绑定要读取的数据源 FileInputStream fis=new FileInputStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;); //2.创建BufferedInputStream对象，构造方法中传递FileInputStream对象，提高FileInputStream对象的读取效率 BufferedInputStream bis=new BufferedInputStream(fis); // 3.使用BufferedInputStream对象中的方法read()，读取文件 int len=0;//记录每次读取到的字节 while((len=bis.read())!=-1) &#123; System.out.println(len); &#125; bis.close();&#125; 12345678910111213public static void main(String []args) throws IOException &#123; //1.创建一个FileInputStream对象，构造方法中绑定要读取的数据源 FileInputStream fis=new FileInputStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;); //2.创建BufferedInputStream对象，构造方法中传递FileInputStream对象，提高FileInputStream对象的读取效率 BufferedInputStream bis=new BufferedInputStream(fis); // 3.使用BufferedInputStream对象中的方法read()，读取文件 int len=0;//记录每次读取的有效字节个数 byte[] bytes=new byte[1024]; while((len=bis.read(bytes))!=-1) &#123;//最后这个-1是不会返回给len的 System.out.println(new String(bytes,0,len)); &#125; bis.close();&#125; 用缓冲流来复制文件速度变得更快，可见效率变得更高 123456789101112131415161718public static void main(String []args) throws IOException &#123; long end =System.currentTimeMillis(); FileInputStream fis=new FileInputStream(&quot;C:\\\\Users\\\\#赵梓皓&amp;\\\\Pictures\\\\Default.jpg&quot;); BufferedInputStream bis=new BufferedInputStream(fis); FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.jpg&quot;); BufferedOutputStream bos=new BufferedOutputStream(fos); int len=0; while((len=bis.read())!=-1) &#123; bos.write(len); &#125; bos.close(); bis.close(); long end1=System.currentTimeMillis(); System.out.println(&quot;耗时&quot;+(end1-end)+&quot;毫秒&quot;);&#125;耗时42毫秒 123456789101112131415161718public static void main(String []args) throws IOException &#123; long end =System.currentTimeMillis(); FileInputStream fis=new FileInputStream(&quot;C:\\\\Users\\\\#赵梓皓&amp;\\\\Pictures\\\\Default.jpg&quot;); BufferedInputStream bis=new BufferedInputStream(fis); FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.jpg&quot;); BufferedOutputStream bos=new BufferedOutputStream(fos); int len=0; byte []bytes=new byte[1024]; while((len=bis.read(bytes))!=-1) &#123; bos.write(bytes,0,len); &#125; bos.close(); bis.close(); long end1=System.currentTimeMillis(); System.out.println(&quot;耗时&quot;+(end1-end)+&quot;毫秒&quot;);&#125;耗时4毫秒 字符缓冲输出流 &#96;&#96;&#96;public class BufferedWriterextends Writer123456789101112131415161718192021222324252627282930313233343536有继承自父类的共性成员方法，所有Writer的方法他都有构造方法- - `BufferedWriter(Writer out)` 创建使用默认大小的输出缓冲区的缓冲字符输出流- - `BufferedWriter(Writer out, int sz)` 创建一个新的缓冲字符输出流，使用给定大小的输出缓冲区参数：​ 第一个参数是一个字符输出流​ 我们可以传递FileWriter，缓冲流会给FileWriter增加一个缓冲区，提高FileWriter的写入效率​ 第二个参数 int sz：指定缓冲区的大小，不写是默认大小特有的成员方法- - `void newLine()` 写一行行分隔符。方法和上面的都一样，便不再注释```javapublic static void main(String []args) throws IOException &#123; FileWriter fw=new FileWriter(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);BufferedWriter bw=new BufferedWriter(fw);for(int i=0;i&lt;10;i++) &#123; bw.write(&quot;你好&quot;); bw.newLine();//用来进行换行&#125;bw.flush();bw.close();&#125; BufferedReader字符缓冲输入流 Java.io.BufferedReader extends Reader 继承自父类的共性成员方法 构造方法 BufferedReader(Reader in) 创建使用默认大小的输入缓冲区的缓冲字符输入流。 BufferedReader(Reader in, int sz) 创建使用指定大小的输入缓冲区的缓冲字符输入流 参数： 字符输入流 ​ 我们可以传递FileReader，缓冲流会给FileReader增加一个缓冲区，提高FileReader的读取效率 特有的成员方法 String readLine() 读一行文字。 ​ 行的终止符浩：通过下列字符之一即可认为某行已经终止：换行(‘\\n’),回车(‘\\r’),或回车后直接跟着换行(\\r\\n) ​ 返回值： ​ 包含该行内容的字符串，不包含任何终止符，如果已经达到里流末尾，返回null 1234567891011public static void main(String []args) throws IOException &#123;FileReader fr=new FileReader(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);BufferedReader br=new BufferedReader(fr);String line;while((line=br.readLine())!=null) &#123; System.out.println(line);&#125;br.close();&#125;结果:可以输出所有行 练习：文本排序（以及转义）12345678910111213141516171819202122232425262728class Main&#123;public static void main(String []args) throws IOException &#123; HashMap&lt;String,String&gt; hm=new HashMap&lt;String,String&gt;();FileReader fr=new FileReader(&quot;D:\\\\放乱七八糟\\\\File1.txt&quot;);FileWriter fw=new FileWriter(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);BufferedWriter bw=new BufferedWriter(fw);BufferedReader br=new BufferedReader(fr);String line;while((line=br.readLine())!=null) &#123; String []str=line.split(&quot;\\\\.&quot;);//split用的是正则表达式.有特殊含义，所以用\\转义，而java中\\\\才是\\ // \\t,\\n等有特殊含义所以java中字符串如果出现\\会有歧义，所以用\\\\来吧\\替换为一个普通字符，这个普通字符进了正则表达式中又可以把.转义，所以在java中使用正则表达式匹配“\\”时就需要写成&quot;\\\\\\\\&quot; //把切割好的序号和文本内容储存到HashMap集合中(key序号是有序的，会自动排序1，2，3，4) hm.put(str[0], str[1]);&#125;for(String b:hm.keySet()) &#123; String value=hm.get(b); line=b+&quot;.&quot;+value; bw.write(line); bw.newLine();&#125;bw.close();br.close();&#125;&#125; 文件原内容 12341.我是2.我才不是4.我真的不是3.你不是 文件变更以后 12341.我是2.我才不是3.你不是4.我真的不是 插曲：我读取内容的文件是utf-8形式的，写入的文件是以gbk打开，所以出现乱码我把utf-8改为gbk就好了 转换流字符编码： 计算机中储存的信息都是用二进制表示的，而我们在屏幕上看到的数字英文标点符号汉字等字符是二进制转换之后的结果 按照某种规则，将字符储存到计算机中，成为编码，反之，将存储在计算机中的二进制数按照某种规则解析出来称为解码，比如说按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号，反之，按照A规则存储，按照B规则解析，就会出现乱码 编码：字符–》字节 解码：字节–》字符 字符编码：就是一套自然语言的字符与二进制数之间的对应规则。 编码表：生活中文字和计算机中二进制的对应规则 字符集： Ascii码字符集–》Ascii码编码 GBK字符集–》GBK编码 Unicode字符集–》UTF8编码，UTF16编码，UTF32编码 转换流原理输入转换原理 用InputStreamReader FileReader底层还是FileInputStream将字节转换为字符时只能用IDE默认编码 而InputStreamReader可以指定字节转换为字符的编码形式 输出转换原理 用OutputStreamWriter FileWriter的底层实现还是FileOutputStream，只能将字符转换为IDE默认的编码的字节 如果用OutputStreamWriter 可以指定字符转字节的时候的编码格式 编码引出的问题FileReader读取文件 就是FileReader能读取编译器默认编码的文件，比如eclipse时GBK，IDEA是UTF-8 下面演示在eclipse用FileReader读取UTF-8 OutputStreamWriter OutputStreamWriter是字符的桥梁流以字节流：向其写入的字符编码成使用指定的字节charset 。 它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集。 java.io.BufferedWriter extends Writer Writer中的方法都可以使用 构造方法： OutputStreamWriter(OutputStream out) 创建一个使用默认字符编码的OutputStreamWriter OutputStreamWriter(OutputStream out, String charsetName) 创建一个使用命名字符集的OutputStreamWriter。 参数：OutputStream out：字节输出流，可以用来写转换之后的字节到文件中 ​ String charsetName：指定的编码表的名称，不区分大小写，可以使utf-8&#x2F;UTF-8&#x2F;GBK&#x2F; public static void main(String []args) throws IOException &#123; //创建OutputStreamWriter对象，构造方法中传递字节输出流的指定的编码表名称 OutputStreamWriter osw=new OutputStreamWriter(new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;),&quot;UTF-8&quot;); //使用OutputStreamWriter对象中的方法write，把字符转换为字节存储缓冲区中（编码） osw.write(&quot;你好&quot;); //使用OutputStreamWriter对象中的flush，把内存缓冲区中的字节刷新到文件中（使用字节流写字节） osw.flush(); //释放内存 osw.close(); &#125; 将你好写入了UTF-8编码显示的文件 InputStreamReaderjava.io.InputStreamReader extends Reader InputStreamReader是从字节流到字符流的桥：它读取字节，并使用指定的charset将其解码为字符 。 它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集。 它由继承字父类的共性的成员方法 ​ Reader有的方法它都有 构造方法： ​ InputStreamReader(InputStream in) 创建一个使用默认字符集的InputStreamReader ​ InputStreamReader(InputStream in, String charsetName) 创建一个使用命名字符集的InputStreamReader ​ 参数： ​ InputStream in：字节输入流，用来读取文件中保存的字节 ​ String charsetName：字符表名称 public static void main(String []args) throws IOException &#123; //创建InputStreamWriter对象，构造方法中传递字节输入流和指定的编码表名称 InputStreamReader osw=new InputStreamReader(new FileInputStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;),&quot;UTF-8&quot;); //使用InputStreamWriter对象中的方法read()，把字符转换为字节存储缓冲区中（编码） int len=0; while((len=osw.read())!=-1) &#123; System.out.println((char)len); &#125; //释放内存 osw.close(); &#125; 即是文件内容是UTF-8，也可以给他读入到内存中 结果：你 好 转换文件编码的练习 1234567891011public static void main(String []args) throws IOException &#123; InputStreamReader isr=new InputStreamReader(new FileInputStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;),&quot;UTF-8&quot;); OutputStreamWriter osw=new OutputStreamWriter(new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\File1.txt&quot;),&quot;GBK&quot;); int len=0; while((len=isr.read())!=-1) &#123; osw.write(len); &#125; osw.close(); isr.close();&#125;将UTF-8的文件转换为GBK编码的文件 序列化ObjectOutputStream extends OutputStream ObjectOutputStream：对象的序列化流 作用：把对象以流的形式写入到文件中保存 构造方法： ​ ObjectOutputStream(OutputStream out) 创建一个写入指定的OutputStream的ObjectOutputStream。 ​ 参数： ​ 床第一个字节输出流 特有的成员方法： ​ writeObject(Object obj) 将指定的对象写入ObjectOutputStream。 使用步骤; ​ 1.创建ObjectOutputStream对象，构造方法中传递字节输出流 ​ 2.使用ObjectOutputStream对象中的writeObject，把对象写入到文件中 ​ 3.释放资源 类只有实现了Serializable接口才能被序列化或者反序列化 1234567891011121314151617181920212223242526272829class Test implements Serializable&#123;private String name;public String getName() &#123; return name;&#125;public void setName(String name) &#123; this.name = name;&#125;public int getAge() &#123; return age;&#125;public void setAge(int age) &#123; this.age = age;&#125;private int age;public Test() &#123; &#125;public Test(String name,int age) &#123; this.name=name; this.age=age;&#125;&#125;文件内容以二进制字节来存储所以无法直接打开看 1234567 public static void main(String []args) throws IOException, ClassNotFoundException &#123;ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;));oos.writeObject(new Test(&quot;小美女&quot;,18));oos.close(); &#125; ObjectInputStream extends InputStream ObjectInputStream :对象的反序列化流 作用：把文件中保存的对象以流的形式读取出来使用过 构造方法: ​ ObjectInputStream(InputStream in) 创建从指定的InputStream读取的ObjectInputStream ​ 参数：传入一个字节输入流 特有的成员方法： ​ readObject() 从ObjectInputStream读取一个对象。 使用步骤： 1.创建ObjectInputStream对象，构造方法中传递字节输入流 2.使用ObjectInputStream对象中的方法readObject读取保存对象的文件 3.释放资源 4.使用读取出来的对象（打印） readObject方法声明抛出了ClassNotFoundException（Class文件找不到异常）当不存在对象的class文件时抛出此异常 反序列化的前提： ​ 1.类必须实现Serializable接口 ​ 2.必须存在类对应的class文件 1234567891011public static void main(String []args) throws IOException, ClassNotFoundException &#123; //1.创建ObjectInputStream对象，构造方法中传递字节输入流 ObjectInputStream ois=new ObjectInputStream(new FileInputStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;)); //2.使用ObjectInputStream对象中的方法readObject读取保存对象的文件 Object o=ois.readObject();//这里必须使用Object类型来接受 ois.close(); //4.使用读取出来的对象（打印） System.out.println(o); Test t=(Test)o; System.out.println(t.getName()+t.getAge());&#125; transient关键字 static关键字:静态关键字 1.静态优先于非静态加载到内存中（静态优先于对象进入到内存中） 被static修饰的成员变量不能被序列化的，序列化的都是对象 private static int age oos.writeObject(new Person(“小美女”,18)); Object o&#x3D;ois.readObject(); Person{name&#x3D;”小美女”,age&#x3D;0} 所以静态的不能够被序列化 transient关键字：瞬态关键字 ​ 被transient修饰的成员变量，不能被序列化 它的功能就是不让某个属性序列化，但是又没有静态的含义 InvalidClassException异常当分别一次序列化和反序列化之后是正常的，但现在你去改了那个序列化的类属性，然后没有对他序列化而是直接反序列化 就会报InvalidClassException 就是当你改动了类之后你txt文件中的类的id和你class文件中的id不同就导致不能够反序列化成功 所以就在类中加一个private static final long serialVersionUID&#x3D;1L; 这样无论怎么改id都不会变了 练习：序列化集合练习：序列化集合 ​ 当我们想在文件中保存多个对象的时候 ​ 可以把多个对象储存到一个集合中 ​ 对集合进行序列化和反序列化 分析： ​ 1.定义一个存储Person对象的集合和ArrayList集合 ​ 2.往ArrayList集合中存储Person对象 ​ 3.创建一个序列化流ObjectOutputStream ​ 4.使用ObjectOutputStream对象中的方法writeObject，对集合进行序列化 ​ 5.创建一个反序列化ObjectInputStream对象 ​ 6.使用ObjectInput中的方法readObject读取文件中保存的集合 ​ 7.把Object类型的集合转换为ArrayList类型 ​ 8，遍历这个ArrayList集合 ​ 9.释放资源 public static void main(String []args) throws IOException, ClassNotFoundException &#123; // 1.定义一个存储Person对象的集合和ArrayList集合 ArrayList&lt;Test&gt; list=new ArrayList&lt;Test&gt;(); // 2.往ArrayList集合中存储Person对象 list.add(new Test(&quot;张三&quot;,18)); list.add(new Test(&quot;例四&quot;,18)); list.add(new Test(&quot;赵武&quot;,18)); //3.创建一个序列化流ObjectOutputStream ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;)); //4.使用ObjectOutputStream对象中的方法writeObject，对集合进行序列化 oos.writeObject(list); // 5.创建一个反序列化ObjectInputStream对象 ObjectInputStream ois=new ObjectInputStream(new FileInputStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;)); // 6.使用ObjectInput中的方法readObject读取文件中保存的集合 Object o=ois.readObject(); //7.把Object类型的集合转换为ArrayList类型 ArrayList&lt;Test&gt; list2=(ArrayList&lt;Test&gt;)o; //8，遍历这个ArrayList集合 for(Test p:list2) &#123; System.out.println(p); &#125; // 9.释放资源 ois.close(); oos.close(); &#125; 打印流重定向标准输入输出java.io.PrintStream ​ PrintStream为另一个输出流添加了功能，即能够方便地打印各种数据值的表示。 PrintStream特带你： ​ 1.只负责数据的输出，不负责数据的读取 ​ 2.与其他输出流不同，PrintStream永远不会抛出IOException ​ 3.有特有的方法，print，println方法 ​ void print(任意类型的值) ​ void println(任意类型的值并换行) 构造方法： ​ PrintStream(File file) 输出的目的地是一个文件 ​ PrintStream(OutputStream out) 输出的目的地是一个字节输出流 ​ PrintStream(String fileName) 输出的目的地是一个文件路径 printStream extends OutputStream 继承自父类的成员方法 注意： ​ 如果使用继承自父类的write方法那么查看数据的时候会查询编码表 ​ 如果是用自己特有的方法print&#x2F;println方法写数据，写的数据原样输出 123456789101112131415161718192021222324```java用父类的方法会查询编码表 public static void main(String []args) throws IOException, ClassNotFoundException &#123;PrintStream ps=new PrintStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);ps.write(97);ps.close(); &#125;文件：文件的内容是a```用自己的方法是原样输出 public static void main(String []args) throws IOException, ClassNotFoundException &#123;PrintStream ps=new PrintStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);ps.println(&quot;a&quot;);ps.println(97);ps.println(100);ps.println(&quot;我是&quot;);ps.close(); &#125; 文件内容是：a 97 100 我是 可以改变输出语句的目的地（打印流的流向） 输出语句：默认在控制台输出 使用System.setOut放法改变输出语句的目的为参数传递的打印流的目的地 ​ static void setOut(printStream out) ​ 重新分配”标准”输出流 下面这个是将System.out的输出重定向到文件输出而不是在屏幕上输出 12345678 public static void main(String []args) throws IOException, ClassNotFoundException &#123; System.out.println(&quot;我在控制台输出&quot;);PrintStream ps=new PrintStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);System.setOut(ps);//把输出语句的目的地改变为打印流的目的地System.out.println(&quot;我在打印流的目的地中输出&quot;);&#125; 改变这个输出语句在流里输出 使用System的setIn()方法将系统标准输入重定向到该文件输入流，不会等待用户输入而是直接输出了文件的内容 java的多线程详解概念多线程案例：一起开黑打王者荣耀，你给我发消息的时候我也能给你发消息 多线程： 可以实现一个并发操作，在一个程序中可以定义多个线程并同时运行它们，每个线程可以执行不同的任务。 进程（Process）：在操作系统中运行的程序就是进程，比如你的qq播放器游戏IDE 进程则是执行程序的一次执行过程，它是一个动态的概念，是系统资源分配的单位 线程(Thread)：一个进程可以有多个线程，如视频中同时听声音，看图像，看弹幕等等 进程可以包含多个线程，一个进程至少有一个Main线程，不然没有存在的意义 多线程和多任务的区别：多任务是针对操作系统而言的，代表操作系统可以同时执行的程序个数；多线程是针对一个程序而言的，代表一个程序可以同时执行的线程的个数，每个线程完成不同的任务。 在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器(cpu)是与操作系统紧密相关的，先后顺序是不能人为干预的 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制（10000个人抢100张票必定有人抢不到） 继承Thread类 创建一个新的执行线程有两种方法。 一个是将一个类声明为Thread的子类。 这个子类应该重写run类的方法Thread 。 创建线程对象，调用start()方法启动线程 12345678910111213141516171819202122public class Hello extends Thread&#123; @Overridepublic void run() &#123; //run方法线程体 for(int i=0;i&lt;20;i++) &#123; System.out.println(&quot;我在看书&quot;); &#125;&#125; public static void main(String []args) &#123; //main线程主线程 //创建一个线程对象 Hello testThread=new Hello(); //调用start()方法开启线程 testThread.start(); for(int i=0;i&lt;20;i++) &#123; System.out.println(&quot;我在学习&quot;); &#125; &#125; &#125;用start方法是开了一条新线程，两条线程同时执行（线程不一定立即执行,cpu调度安排），如果是调用run方法则就是先执行run方法再回到主线程执行 注意：县城开启不一定立即执行，由cpu调度执行 网图下载 建立多个TestThread2对象，开辟多个线程，同时执行 实现Runnable接口定义MyRunnable类实现Runnable接口 实现run()方法，编写线程执行体 创建线程对象，调用start()方法启动线程 1234567891011121314151617@Override public void run() &#123; //run方法线程体 for(int i=0;i&lt;20;i++) &#123; System.out.println(&quot;我在看书&quot;); &#125; &#125; public static void main(String []args) &#123; //创建一个runnable接口的实现类对象 Hello testThread3=new Hello(); //创建线程对象，通过线程对象来开启我们的线程，代理 Thread thread=new Thread(testThread3); thread.start(); for(int i=0;i&lt;20;i++) &#123; System.out.println(&quot;我在学习&quot;); &#125; &#125; 小结 初始并发问题 &#x2F;&#x2F;多个线程同时操作同一个对象 &#x2F;&#x2F;买火车票的例子 &#x2F;&#x2F;返现问题：多个线程操作同一个资源的情况下，线程不安全，数据紊乱，就是小明老师黄牛党都拿到了第十张票， 12345678910111213141516171819202122232425262728public class Hello implements Runnable&#123; private int ticketNums=10; public void run() &#123; while(true) &#123; if(ticketNums&lt;=0) &#123; break; &#125; try &#123; Thread.sleep(200);//模拟延时,是当前线程进入休息状态 &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;--&gt;拿到了第&quot;+ticketNums--+&quot;票&quot;); &#125; &#125;public static void main(String []args) &#123; Hello ticket=new Hello(); //Thread后面的第二个参数是这个线程的名字 new Thread(ticket,&quot;小明&quot;).start(); new Thread(ticket,&quot;老师&quot;).start(); new Thread(ticket,&quot;黄牛党&quot;).start(); &#125;&#125; 龟兔赛跑相当于乌龟和兔子是两条线程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package hello;public class Hello implements Runnable&#123; private String winner;public void run() &#123; for(int i=0;i&lt;=100;i++) &#123; //模拟兔子休息 if(Thread.currentThread().getName().equals(&quot;兔子&quot;)&amp;&amp;i%10==0) &#123; try &#123; Thread.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //判断比赛是否结束 boolean flag=gameOver(i); //如果比赛结束了，就停止程序 if(flag) &#123; break; &#125; System.out.println(Thread.currentThread().getName()+&quot;--&gt;跑了&quot;+i+&quot;步&quot;); &#125;&#125;private boolean gameOver(int step) &#123; //判断是否存在胜利者 if(winner!=null) &#123; return true; &#125; else &#123; if(step&gt;=100) &#123; winner=Thread.currentThread().getName(); System.out.println(&quot;winner is&quot;+winner); return true; &#125; &#125; return false; &#125;public static void main(String []args) &#123; Hello race=new Hello(); new Thread(race,&quot;兔子&quot;).start(); new Thread(race,&quot;乌龟&quot;).start();&#125;&#125; 实现Callable接口好处：1.可以定义返回值 2.可以抛出异常 t1就是实现Callable接口的类的实例化对象 要重写call方法，可以自己设定它的返回值和哪个Collable接口的泛型类型一致 静态代理模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package hello;//静态代理模式：//真实对象和代理对象都要实现同一个接口//代理对象要代理真实角色//好处： //代理对象可以做很多真实对象做不了的事情 //真实对象专注做自己的事情public class Hello&#123; public static void main(String []args) &#123; WeddingCompany weddingCompany=new WeddingCompany(new You());//我来、把自己给婚庆公司 weddingCompany.HappyMarry();//婚庆公司代理我结婚，没有通过我直接去调用结婚的方法 &#125;&#125;interface Marry&#123; void HappyMarry();&#125;class You implements Marry&#123; @Override public void HappyMarry() &#123; System.out.println(&quot;我要结婚了&quot;); &#125;&#125;//婚庆公司代理我去结婚，还是我去结婚class WeddingCompany implements Marry&#123; //这个地方是一个真实的结婚的角色 private Marry target; public WeddingCompany(Marry target) &#123; this.target=target; &#125; @Override public void HappyMarry() &#123; before(); this.target.HappyMarry();//这就是真实对象 after(); &#125; private void after() &#123; System.out.println(&quot;结婚之后，收尾款&quot;); &#125; private void before() &#123; System.out.println(&quot;结婚之前，布置现场&quot;); &#125;&#125; 类比到多线程：new Thread(()-&gt;System.out.println(“我爱你”)).start(); Thread类代理Runnable接口那个真实对象 线程状态 new是创建状态 dead是死亡状态 停止线程不推荐使用jdk提供的stop() destroy()方法 推荐线程自己停下来 建议使用一个标志位进行终止变量 当flag&#x3D;false，则终止线程运行 &#x2F;&#x2F;测试stop&#x2F;&#x2F;1.建议线程正常停止—》利用次数，不建议死循环&#x2F;&#x2F;2.建议使用标志位–&gt;设置一个标志位&#x2F;&#x2F;3.不要使用stop或者destroy等果实或者JDK不建议使用的方法 12345678910111213141516171819202122232425262728293031public class Hello implements Runnable&#123; //1设置一个标识位 private boolean flag=true; @Override public void run() &#123; int i=0; while(flag) &#123; System.out.println(&quot;run thread&quot;+i++); &#125; &#125; //2.设置一个公开的方法停止线程 public void stop() &#123; this.flag=false; &#125; public static void main(String []args) &#123; Hello teststop=new Hello(); new Thread(teststop).start(); for(int i=0;i&lt;1000;i++) &#123; System.out.println(&quot;main&quot;+i); if(i==900) &#123; //调用stop方法切换标志位，让线程停止 teststop.stop(); System.out.println(&quot;线程该停止了&quot;); &#125; &#125; &#125;&#125; 线程休眠（sleep）sleep指定当前线程阻塞的毫秒数 sleep存在异常InterruptedException sleep时间达到后线程进入就绪状态 sleep可以模拟网络延迟，倒计时等 每一个对象都有一个锁，sleep不会释放锁 &#x2F;&#x2F;模拟网络延时，放大问题的发生性 12345678910111213141516171819202122232425262728public class Hello implements Runnable&#123; private int ticketNums=10; public void run() &#123; while(true) &#123; if(ticketNums&lt;=0) &#123; break; &#125; try &#123; Thread.sleep(200);//模拟延时,是当前线程进入休息状态 &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;--&gt;拿到了第&quot;+ticketNums--+&quot;票&quot;); &#125; &#125;public static void main(String []args) &#123; Hello ticket=new Hello(); //Thread后面的第二个参数是这个线程的名字 new Thread(ticket,&quot;小明&quot;).start(); new Thread(ticket,&quot;老师&quot;).start(); new Thread(ticket,&quot;黄牛党&quot;).start(); &#125;&#125; 模拟倒计时 12345678910111213141516171819202122public class Hello&#123; public static void tenDown() throws InterruptedException&#123; int num=10; while(true) &#123; Thread.sleep(1000); System.out.println(num--); if(num&lt;=0) &#123; break; &#125; &#125; &#125; public static void main(String []args) &#123; try &#123; tenDown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 获取当前系统时间 1234567891011121314151617public class Hello&#123; public static void main(String []args) &#123; Date startTime=new Date(System.currentTimeMillis()); //获取当前的时间Mon Jul 04 16:40:30 CST 2022 while(true) &#123; try &#123; Thread.sleep(1000); System.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(startTime));//16:40:30 startTime=new Date(System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;&#125; 礼让线程礼让线程(yield)：让当前正在执行的线程暂停，但不阻塞 将线程从运行状态转为就绪状态 让cpu重新调度，礼让不一定成功，看CPU心情 123456789101112131415161718192021222324public class Hello&#123; public static void main(String []args) &#123; Myyield e=new Myyield(); new Thread(e,&quot;a&quot;).start(); new Thread(e,&quot;b&quot;).start();&#125;&#125;class Myyield implements Runnable&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+&quot;线程开始执行&quot;); Thread.yield();//礼让 System.out.println(Thread.currentThread().getName()+&quot;线程停止执行&quot;); &#125;&#125;结果：a线程开始执行 b线程开始执行 a线程停止执行 b线程停止执行 线程强制执行（join）join合并线程，待此线程执行完成之后再执行其他线程，其他线程阻塞 可以想象成插队 123456789101112131415161718192021222324class Hello implements Runnable&#123; @Override public void run() &#123; for(int i=0;i&lt;1000;i++) &#123; System.out.println(&quot;线程vip来了&quot;); &#125; &#125; public static void main(String []args) throws InterruptedException &#123; //启动我们的线程 Hello testjoin=new Hello(); Thread a=new Thread(testjoin); a.start(); //主线程 for(int i=0;i&lt;500;i++) &#123; if(i==200) &#123; a.join();//强制让run方法线程执行完毕再执行主线程 &#125; System.out.println(&quot;main&quot;+i); &#125; &#125;&#125; 观测线程状态 NEW尚未启动的线程处于此状态。 RUNNABLE在Java虚拟机中执行的线程处于此状态。 BLOCKED被阻塞等待监视器锁定的线程处于此状态。 WAITING正在等待另一个线程执行特定动作的线程处于此状态。 TIMED_WAITING正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。 TERMINATED已退出的线程处于此状态 12345678910111213141516171819202122232425262728293031class Hello &#123; public static void main(String []args) throws InterruptedException &#123; Thread thread=new Thread(()-&gt;&#123; for(int i=0;i&lt;5;i++) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; System.out.println(&quot;abc&quot;); &#125;); //观察状态 Thread.State state=thread.getState(); System.out.println(state);//NEW //观察启动后 thread.start(); state=thread.getState(); while(state!=Thread.State.TERMINATED) &#123; Thread.sleep(100); state=thread.getState(); System.out.println(state); &#125; &#125;&#125;死亡之后的线程不能够被重新启动，一个线程不能够启动两次 线程的优先级123456789101112131415161718192021222324252627282930313233343536class Hello &#123; public static void main(String []args) throws InterruptedException &#123; System.out.println(Thread.currentThread().getPriority());//主线程默认优先级 MyPriority myPriority=new MyPriority(); Thread t1=new Thread(myPriority,&quot;1&quot;); Thread t2=new Thread(myPriority,&quot;2&quot;); Thread t3=new Thread(myPriority,&quot;3&quot;); Thread t4=new Thread(myPriority,&quot;4&quot;); Thread t5=new Thread(myPriority,&quot;5&quot;); Thread t6=new Thread(myPriority,&quot;6&quot;); //先设置优先级，再启动 t1.start(); t2.setPriority(1); t2.start(); t3.setPriority(4); t3.start(); t4.setPriority(Thread.MAX_PRIORITY); t4.start(); //设置优先级大于10小于0会报错 /*t5.setPriority(-1); t5.start(); t6.setPriority(11); t6.start();*/ &#125;&#125;class MyPriority implements Runnable&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+&quot;--&gt;&quot;+Thread.currentThread().getPriority()); &#125;&#125; 优先级低只是意味着获得调度的概率低，并不是优先级低就不会被调用了，这都是看cpu的调度 优先级低的执行，优先级高的在等待，这个就会造成性能倒置 守护线程线程分为用户线程（main）和守护线程（gc） 虚拟机必须确保用户线程执行完毕 虚拟机不用等待守护线程执行完毕 如，后台记录操作日志，监控内存，垃圾回收等待 1234567891011121314151617181920212223242526272829class Hello &#123; public static void main(String []args) throws InterruptedException &#123; God god =new God(); You you=new You(); Thread thread =new Thread(god); thread.setDaemon(true);//默认是false表示是用户线程,正常的线程都是用户线程 thread.start();//上帝守护线程启动，这个线程不停止程序也会在用户线程执行完毕时停止,这时守护线程也就停止了 new Thread(you).start();//你 用户线程启动&#125;&#125;class God implements Runnable&#123; public void run() &#123; while(true) &#123; System.out.println(&quot;上帝健康快乐地活着&quot;); &#125; &#125;&#125;class You implements Runnable&#123; public void run() &#123; for(int i=0;i&lt;36000;i++) &#123; System.out.println(&quot;我健康快乐的活着&quot;); &#125; System.out.println(&quot;goodbyeworld&quot;); &#125;&#125; 线程同步多个线程操作同一个资源 并发：同一个对象被多个线程同时操作 保证线程安全要有队列而且要有锁，线程同步需要队列加锁 锁就相当于排队上厕所的时候，你进去把门关上防止后面的人进来，等你解决完了下一个人才能够进来 关键词：synchronized 当一个线程获得对象的排它锁，独占资源，其他线程必须等待 存在问题：1.一个线程持有锁会导致其他所有需要此锁的线程挂起 ​ 2.在多线竞争下，加锁释放锁会导致比较多的上下文切换和调度延时，引起性能问题 ​ 3.如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题 不安全的买票 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.text.SimpleDateFormat;import java.util.Date;//不安全的买票//可能三个人都抢到同一个第十张票//出现负数，就是他们都认为有一张票，当他们买完之后有人拿到的就是负的public class Hello&#123; public static void main(String []args) &#123; buyticket station=new buyticket(); new Thread(station,&quot;小明&quot;).start(); new Thread(station,&quot;小红&quot;).start(); new Thread(station,&quot;小蓝&quot;).start(); &#125;&#125;class buyticket implements Runnable&#123; //票 private int ticketNum=10; boolean flag=true;//外部停止方式 public void run() &#123; //买票 while(flag) &#123; try &#123; buy(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; private void buy() throws InterruptedException &#123; //判断是否有票 if(ticketNum&lt;=0) &#123; flag=false; return; &#125; //模拟延时 Thread.sleep(100); //买票 System.out.println(Thread.currentThread().getName()+&quot;拿到&quot;+ticketNum--); &#125;&#125; 银行取钱不安全 最后钱会变成负数，总共100，你想取50你对象想去100，你俩看到的都是余额100块，所以会造成余额为负数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Hello&#123; public static void main(String []args) &#123; //账户 Account account=new Account(100,&quot;结婚基金&quot;); Drawing you=new Drawing(account,50,&quot;你&quot;); Drawing girl=new Drawing(account,100,&quot;她&quot;);//第三个参数传入的是这个线程的名字 you.start(); girl.start(); &#125;&#125;class Account&#123; int money;//金额 String name;//卡名 Account account;//账户 public Account(int money, String name) &#123; super(); this.money = money; this.name = name; &#125;&#125;//银行：模拟取款class Drawing extends Thread&#123; //取了多少钱 int drawingMoney; //现在手里有多少钱 int nowMoney; Account account ; public Drawing(Account account, int drawingMoney, String name) &#123; super(name);//这个线程的名字 this.account = account; this.drawingMoney = drawingMoney; &#125; public void run() &#123; //判断有没有钱 if(account.money-drawingMoney&lt;0) &#123; System.out.println(Thread.currentThread().getName()+&quot;钱不够取不到&quot;); return; &#125; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //卡内金额=金额-你取的钱 account.money=account.money-drawingMoney; //你手里的钱 nowMoney=nowMoney+drawingMoney; System.out.println(account.name+&quot;余额为:&quot;+account.money); //Thread.currentThread().getName()=this.getName() System.out.println(this.getName()+&quot;手里的钱:&quot;+nowMoney); &#125;&#125; ArrayList集合线程不安全 123456789101112131415161718192021222324252627import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.List;public class Hello&#123; public static void main(String []args) &#123; List&lt;String&gt; lise=new ArrayList&lt;String&gt;(); for(int i=0;i&lt;10000;i++) &#123; new Thread(()-&gt;&#123; lise.add(Thread.currentThread().getName()); &#125;).start(); &#125; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(lise.size()); &#125;&#125;结果：9992 可能会有两个元素同时占同一个坑位 线程同步的修改 使用synchronized修饰那个会出现线程问题的方法 这个买票的例子就是一个对象所以在buy方法前面加一个synchronized就可以 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.text.SimpleDateFormat;import java.util.Date;//不安全的买票//可能三个人都抢到同一个第十张票//出现负数，就是他们都认为有一张票，当他们买完之后有人拿到的就是负的public class Main&#123; public static void main(String []args) &#123; buyticket station=new buyticket(); new Thread(station,&quot;小明&quot;).start(); new Thread(station,&quot;小红&quot;).start(); new Thread(station,&quot;小蓝&quot;).start(); &#125;&#125;class buyticket implements Runnable&#123; //票 private int ticketNum=10; boolean flag=true;//外部停止方式 public void run() &#123; //买票 while(flag) &#123; try &#123; buy(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; //synchronized同步方法，锁的是this，会一个一个进来 private synchronized void buy() throws InterruptedException &#123; //判断是否有票 if(ticketNum&lt;=0) &#123; flag=false; return; &#125; //模拟延时 Thread.sleep(100); //买票 System.out.println(Thread.currentThread().getName()+&quot;拿到&quot;+ticketNum--); &#125;&#125; 下面这个取钱的如果按照上面那个一样在run方法前面加synchronized还是会出现负的余额，因为它是两个对象 这个就要用同步块 synchronized (Obj){} obj称之为同步监视器 同步监视器的执行过程 1.第一个线程访问，锁定同步监视器，执行器中的代码 2.第二个·线程访问，发现同步监视器被锁定，无法继续访问 3.第一个线程访问完毕，解锁同步监视器 4.第二个线程访问，发现同步监视器没有锁，然后锁定并访问 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Main&#123; public static void main(String []args) &#123; //账户 Account account=new Account(100,&quot;结婚基金&quot;); Drawing you=new Drawing(account,50,&quot;你&quot;); Drawing girl=new Drawing(account,100,&quot;她&quot;);//第三个参数传入的是这个线程的名字 you.start(); girl.start(); &#125;&#125;class Account&#123; int money;//金额 String name;//卡名 Account account;//账户 public Account(int money, String name) &#123; super(); this.money = money; this.name = name; &#125;&#125;//银行：模拟取款class Drawing extends Thread&#123; //取了多少钱 int drawingMoney; //现在手里有多少钱 int nowMoney; Account account ; public Drawing(Account account, int drawingMoney, String name) &#123; super(name);//这个线程的名字 this.account = account; this.drawingMoney = drawingMoney; &#125; public void run() &#123; //判断有没有钱 synchronized(account) &#123;//这里面是就是需要排队使用的资源，也就是account对象 if(account.money-drawingMoney&lt;0) &#123; System.out.println(Thread.currentThread().getName()+&quot;钱不够取不到&quot;); return; &#125; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //卡内金额=金额-你取的钱 account.money=account.money-drawingMoney; //你手里的钱 nowMoney=nowMoney+drawingMoney; System.out.println(account.name+&quot;余额为:&quot;+account.money); //Thread.currentThread().getName()=this.getName() System.out.println(this.getName()+&quot;手里的钱:&quot;+nowMoney); &#125; &#125;&#125; 下面这个和上面那个一样，锁住的是lise集合 123456789101112131415161718192021222324252627import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.List;public class Main&#123; public static void main(String []args) &#123; List&lt;String&gt; lise=new ArrayList&lt;String&gt;(); for(int i=0;i&lt;10000;i++) &#123; new Thread(()-&gt;&#123; synchronized(lise) &#123; lise.add(Thread.currentThread().getName()); &#125; &#125;).start(); &#125; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(lise.size()); &#125;&#125; 放在synchronized块里面的是可能会出现问题的代码 一个线程安全的集合1234567891011121314151617181920import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.List;import java.util.concurrent.CopyOnWriteArrayList;public class Main&#123; public static void main(String []args) &#123; CopyOnWriteArrayList&lt;String&gt; list=new CopyOnWriteArrayList&lt;String&gt;(); for(int i=0;i&lt;1000;i++) &#123; new Thread(()-&gt;&#123; list.add(Thread.currentThread().getName()); &#125;).start(); &#125; System.out.println(list.size()); &#125;&#125; 死锁多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形，某一个同步块同时拥有两个以上的锁时，就可能会发生死锁的问题 &#x2F;&#x2F;死锁：多个线程互相抱着对方需要的资源，然后形成僵持 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class Main&#123; public static void main(String []args) &#123; MakeUp g1=new MakeUp(0,&quot;灰姑娘&quot;); MakeUp g2=new MakeUp(1,&quot;白雪公主&quot;); g1.start(); g2.start(); &#125;&#125;//口红class Lipstick&#123; &#125;//镜子class Mirror&#123; &#125;class MakeUp extends Thread&#123; //需要的资源只有一份，用static保证只有一份 static Lipstick lipstick=new Lipstick(); static Mirror mirror=new Mirror(); public MakeUp(int choice,String girlname) &#123; this.choice=choice; this.girlname=girlname; &#125; int choice;//选择 String girlname;//使用化妆品的人 public void run() &#123; try &#123; makeup(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; //化妆，互相持有对方的锁，就是需要拿到对方的资源 private void makeup() throws InterruptedException &#123; if(choice==0) &#123; synchronized(lipstick) &#123; System.out.println(this.girlname+&quot;获得口红的锁&quot;); Thread.sleep(1000); synchronized(mirror) &#123;//一秒钟之后获得镜子 System.out.println(this.girlname+&quot;获得镜子的锁&quot;); &#125; &#125; &#125; else &#123; synchronized(mirror) &#123; System.out.println(this.girlname+&quot;获得镜子的锁&quot;); Thread.sleep(1000); synchronized(lipstick) &#123;//一秒钟之后获得镜子 System.out.println(this.girlname+&quot;获得口红的锁&quot;); &#125; &#125; &#125;​ &#125;&#125;结果： 白雪公主获得镜子的锁灰姑娘获得口红的锁 这样之后他们还想要对方的东西，所以程序就卡死了 解决方法 变成两个锁，不是一个锁在另一个锁里面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.List;import java.util.concurrent.CopyOnWriteArrayList;//死锁：多个线程互相抱着对方需要的资源，然后形成僵持public class Main&#123; public static void main(String []args) &#123; MakeUp g1=new MakeUp(0,&quot;灰姑娘&quot;); MakeUp g2=new MakeUp(1,&quot;白雪公主&quot;); g1.start(); g2.start(); &#125;&#125;//口红class Lipstick&#123; &#125;//镜子class Mirror&#123; &#125;class MakeUp extends Thread&#123; //需要的资源只有一份，用static保证只有一份 static Lipstick lipstick=new Lipstick(); static Mirror mirror=new Mirror(); public MakeUp(int choice,String girlname) &#123; this.choice=choice; this.girlname=girlname; &#125; int choice;//选择 String girlname;//使用化妆品的人 public void run() &#123; try &#123; makeup(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; //化妆，互相持有对方的锁，就是需要拿到对方的资源 private void makeup() throws InterruptedException &#123; if(choice==0) &#123; synchronized(lipstick) &#123; System.out.println(this.girlname+&quot;获得口红的锁&quot;); Thread.sleep(1000); &#125; synchronized(mirror) &#123;//一秒钟之后获得镜子 System.out.println(this.girlname+&quot;获得镜子的锁&quot;); &#125; &#125; else &#123; synchronized(mirror) &#123; System.out.println(this.girlname+&quot;获得镜子的锁&quot;); Thread.sleep(1000); &#125; synchronized(lipstick) &#123;//一秒钟之后获得镜子 System.out.println(this.girlname+&quot;获得口红的锁&quot;); &#125; &#125; &#125;&#125; 产生死锁的条件：1.互斥条件：一个资源每次只能被一个进程使用 2，请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放 3.不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺 4.循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关闭 破坏上面的一个条件就可以避免死锁的发生 Lock锁控制多个线程对共享资源进行访问的工具 ReentrantLock类实现了Lock 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.concurrent.locks.ReentrantLock;public class Main&#123; public static void main(String args[]) &#123; testlock testlock1=new testlock(); new Thread(testlock1,&quot;小蓝&quot;).start(); new Thread(testlock1,&quot;小红&quot;).start(); new Thread(testlock1,&quot;小明&quot;).start(); &#125;&#125;class testlock implements Runnable&#123;private int ticketnums=10;//定义lock锁private final ReentrantLock lock=new ReentrantLock(); @Override public void run() &#123; while(true) &#123; try &#123; lock.lock();//加锁 if(ticketnums&gt;0) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;拿到了第&quot;+ticketnums--+&quot;票&quot;); &#125; else &#123; break; &#125; &#125; finally&#123; //解锁 lock.unlock(); &#125; &#125; &#125; &#125; 加锁和解锁最好是在try和finally里面，而且try中是可能会出现问题的代码 线程协作线程通信：这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件 对于生产者，没有生产产品之前，要通知消费者等待，有了产品之后，马上通知消费者消费 对于消费者，在消费之后，要通知生产者结束消费，需要生产新的产品以供消费 在生产者消费者问题中，仅有synchronized是不够的 ​ synchronized可阻止并发更新同一个共享资源，实现了同步 ​ synchronized不能用来实现不同线程之间的消息传递 通过一个标志来判断什么时候应该等待，什么时候应该唤醒 notifyAll方法是唤醒线程只能唤醒wait等待的线程 wait方法是让该线程等待 管程法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import java.util.concurrent.locks.ReentrantLock;//测试：生产者消费者模型，利用缓冲区来解决：管程法public class Main&#123; public static void main(String []args) &#123; SynContainer container=new SynContainer(); new Productor(container).start(); new Consumer(container).start(); &#125; &#125;//生产者class Productor extends Thread&#123; SynContainer container; public Productor(SynContainer container) &#123; this.container=container; &#125; //生产 public void run() &#123; for(int i=0;i&lt;100;i++) &#123; System.out.println(&quot;生产了&quot;+i+&quot;只鸡&quot;); container.push(new Chicken(i)); &#125; &#125; &#125;//消费者class Consumer extends Thread&#123; SynContainer container; public Consumer(SynContainer container) &#123; this.container=container; &#125; //消费 public void run() &#123; for(int i=0;i&lt;100;i++) &#123; System.out.println(&quot;消费了--&gt;&quot;+container.pop().id+&quot;只鸡&quot;); &#125; &#125;&#125;//产品class Chicken&#123; public int id; public Chicken(int id) &#123; this.id=id; &#125;&#125;//缓冲区class SynContainer&#123; //需要一个容器大小 Chicken[] chickens=new Chicken[10]; //容器计数器 int count=0; //生产者放入产品 public synchronized void push(Chicken chicken) &#123; //如果容器满了就要等待消费者消费 if(count==chickens.length) &#123; //通知生产者消费，生产等待 try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; //如果没有满，我们就需要放入产品 chickens[count]=chicken; count++; //可以通知消费者消费了 this.notifyAll(); &#125; //消费者消费产品 public synchronized Chicken pop() &#123; //判断是否能消费 if(count==0) &#123; //等待生产者生产，消费者等待 try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; //如果可以消费 count--; Chicken chicken=chickens[count]; //吃完了，通知生产者生产 this.notifyAll(); return chicken; &#125; &#125; 信号灯法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.util.concurrent.locks.ReentrantLock;//测试：生产者消费者模型，信号灯法，标志位解决public class Main&#123; public static void main(String []args) &#123; TV tv=new TV(); new Player(tv).start(); new Watcher(tv).start(); &#125;&#125;//生产者-&gt;演员class Player extends Thread&#123; TV tv; public Player(TV tv) &#123; this.tv=tv; &#125; public void run() &#123; for(int i=0;i&lt;20;i++) &#123; if(i%2==0) &#123; this.tv.play(&quot;快乐大本营播放中&quot;); &#125; else &#123; this.tv.play(&quot;抖音:记录美好生活&quot;); &#125; &#125; &#125;&#125;//消费者-&gt;观众class Watcher extends Thread&#123; TV tv; public Watcher(TV tv) &#123; this.tv=tv; &#125; public void run() &#123; for(int i=0;i&lt;20;i++) &#123; this.tv.watch(); &#125; &#125;&#125;//产品-&gt;节目class TV&#123; //演员表演，观众等待 t //观众观看，演员等待 f String voice;//表演的节目 boolean flag=true; //表演 public synchronized void play(String voice) &#123; if(!flag) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; System.out.println(&quot;演员表演了&quot;+voice); //通知观众观看 this.notifyAll();//通知唤醒 this.voice=voice; this.flag=!this.flag; &#125; //观看 public synchronized void watch() &#123; if(flag) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; System.out.println(&quot;观看了&quot;+voice); //通知演员要表演了 this.notifyAll(); this.flag=!this.flag; &#125;&#125; 线程池java反射1.Reflection是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性和方法 2.加载完类之后，在堆内存中的方法区就产生了一个Class类型的对象，这个对象就包含了完整的类的结构信息，我们可以通过这个对象看到类的结构，这个对象就像一个面镜子，透过这个镜子看到类的结构，所以我们形象的称之为，反射 动态语言和静态语言的区别就是动态语言在运行时代码可以根据某些条件改变自身结构 java之所以成为准动态语言是因为有反射机制 正常方式：引入需要的包类名称 —》通过new实例化对象–》取得实例化对象 反射方式：实例化对象–》getClass()方法–》得到完整的包类名称 反射的功能反射的功能 反射相关的API java.lang.Class:代表一个类 java.lang.reflect.Method:代表类的方法 java.lang.reflect.Field:代表类的成员变量 java.lang.reflect.Constructor:代表类的构造器 一个反射的演示Person类 123456789101112131415161718192021222324252627282930313233343536373839404142public class Person &#123; private String name; public int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125;private Person(String name)&#123; this.name=name;&#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; public void show()&#123; System.out.println(&quot;你好，我是一个人&quot;); &#125; private String showNation(String nation)&#123; System.out.println(&quot;我的国籍是&quot;+nation); return nation; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; ReflectionTest 12345678910111213141516171819202122232425262728293031323334353637383940414243import org.junit.Test;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class ReflectionTest &#123; //反射之前，对于Person操作 @Test public void test1()&#123; //创建Person类的对象 Person p1=new Person(&quot;Tom&quot;,12); //通过对象，调用其内部属性方法 p1.age=10; System.out.println(p1.toString()); p1.show(); &#125; //在Person类外部不能通过person对象调用内部私有结构 //比如name。showNation()以及私有的构造器 //反射之后，对于Person的操作，做的是和上面一样的事 @Test public void test2() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException &#123; //获取一个Class类的实例对象 Class clazz=Person.class; //1.通过反射，创建Person类的对象 //获取构造器 Constructor cons=clazz.getConstructor(String.class,int.class); //创建实例 Object obj=cons.newInstance(&quot;Tom&quot;,12); Person p=(Person)obj; System.out.println(p.toString()); //2.通过反射，调用对象的指定属性方法 Field age=clazz.getDeclaredField(&quot;age&quot;); age.set(p,10); System.out.println(p.toString()); //调用空参的show方法 Method show=clazz.getDeclaredMethod(&quot;show&quot;); show.invoke(p); &#125;&#125; 疑问：通过直接new的方式或反射的方式都可以调用公共的结构，开发中到底用哪个 建议：用直接new的方式 疑问：什么时候用反射的方式 反射的特性是动态性，比如在编译的时候你无法确定到底是要实例化哪个类就是要用这种反射的方式 关于Class类理解1.类的加载过程 程序经过javac.exe命令以后，会生成一个或多个字节码文件（.class结尾） 接着我们使用java.exe命令对某个字节码文件进行解释运行，相当于将某个字节码文件加载到内存中，此过程就称为类的加载，加载到内存中的类，我们就称为运行时类，此运行时类，就作为Class的一个实例 2.换句话说，Class的实例就对应的一个运行时类 3.加载到内存中的运行时类，会缓存一定的时间，在此时间之内，我们可以通过不同的方式来获取此运行时类 123456789101112131415161718192021222324//获取大的class实例的方式 @Test public void test3() throws ClassNotFoundException &#123; //方式一 //加上泛型之后就避免了你后面进行强转 Class&lt;Person&gt; clazz1=Person.class; System.out.println(clazz1); //方式二:通过运行时类的对象 Person p1=new Person(); Class clazz2=p1.getClass(); System.out.println(clazz2); //方式三：调用Class的静态方法，forName(String classPath) //这个路径就是看以src为基准，这种文件直接在src下就直接用文件名，如果底下还有包，就要加上包名 Class clazz3=Class.forName(&quot;Person&quot;); System.out.println(clazz3); System.out.println(clazz1==clazz2); System.out.println(clazz2==clazz3); //方式四 ClassLoader classLoader = ReflectionTest.class.getClassLoader(); Class clazz4=classLoader.loadClass(&quot;Person&quot;); System.out.println(clazz1==clazz4); &#125; 其他可以有Class实例的类型 哪些类型可以有Class对象？ （1）class： 外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类 （2）interface：接口 （3）[]：数组 （4）enum：枚举 （5）annotation：注解@interface （6）primitive type：基本数据类型 （7）void 理解类的加载过程 在类的加载过程中就已经执行了静态代码块，构建对象才调用实例代码块和构造方法，且实例代码块比构造方法早 子类加载时，先加载子类的父类，也就是父类的静态代码块先执行再是子类的静态代码块 子类实例化时，先是父类的实例代码块和构造器再是子类的实例代码块和构造器 ClassLoader类加载器作用： 将class文件字节码内容加载到内存中，并将这些静态数据转换成方 法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为 方法区中类数据的访问入口。 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器 中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。 读取文件的时候，把这个Transparent native-to-ascii conversion勾上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import org.junit.Test;import java.io.FileInputStream;import java.io.InputStream;import java.util.Properties;public class ClassLoaderTest &#123; @Test public void test1()&#123; // 1.获取一个系统类加载器 ClassLoader classLoader = ClassLoaderTest.class.getClassLoader(); System.out.println(classLoader); //调用系统类加载器的getParent()：获取扩展类加载器 ClassLoader classLoader1 = classLoader.getParent(); System.out.println(classLoader1); //调用扩展类加载器的getParent()：无法获取引导类加载器 //引导类加载器主要负责加载java的核心类库，无法加载自定义类的。 ClassLoader classLoader2 = classLoader1.getParent(); System.out.println(classLoader2); ClassLoader classLoader3 = String.class.getClassLoader(); System.out.println(classLoader3); &#125; /* Properties 用来读取配置文件 */ @Test public void test2() throws Exception &#123; Properties pros=new Properties(); //读取配置文件的方式一 //此时的文件默认在当前的module下 FileInputStream fis=new FileInputStream(&quot;./jdbc.properties&quot;); //FileInputStream fis=new FileInputStream(&quot;src\\\\jdbc1.properties&quot;); System.out.println(fis); //pros.load(fis); //读取配置文件的方式二，使用ClassLoader ClassLoader classLoader = ClassLoaderTest.class.getClassLoader(); //这个方法直接是映射到src下的文件 //在java中路径字符串中/和\\\\都是一样的 InputStream resource = classLoader.getResourceAsStream(&quot;jdbc1.properties&quot;); pros.load(resource); String user=pros.getProperty(&quot;user&quot;); String password=pros.getProperty(&quot;password&quot;); System.out.println(&quot;user=&quot;+user+&quot;password=&quot;+password); &#125;&#125; java项目中的路径问题123456File file=new File(&quot;/&quot;);System.out.println(file.getAbsolutePath());//D:\\File file1=new File(&quot;.&quot;);System.out.println(file1.getAbsolutePath());D:\\IDEAjava工程\\javaSE\\javareflect\\. &#x2F;代表的是盘符 .代表的是工程目录下的 使用FileInputStream fis&#x3D;new FileInputStream(“jdbc.properties”); 所以这个jdbc.properties也可以是.&#x2F;jdbc.properties 默认就是项目路径下，而不是src路径下，也可以用 全部的整个路径比如D:\\IDEAjava工程\\javaSE\\javareflect\\jdbc.properties InputStream resource &#x3D; classLoader.getResourceAsStream(“jdbc1.properties”);方法就是映射到scr目录下 一般就不用相对路径了，用不明白 1而且idea中路径字符串中\\\\和/是同样的效果 创建运行时类的对象和体会动态加载到内存中的类我们就把它叫做运行时类 test1时创建运行时类的对象 test2是体会反射的动态性，就是在编译时不能确定创建哪个类对象，运行时才确定创建对象的类型 并且方法有参数别用@test 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import org.junit.Test;import java.util.Random;/** * 通过反射创建对应的运行时类的对象 */public class NewInstanceTest &#123; @Test public void test1() throws IllegalAccessException, InstantiationException &#123; //用了泛型之后后面就不用强转了 Class&lt;Person&gt; clazz=Person.class; //newInstance();调用子方法创建对应的运行时类的对象 //其实内部还是调用了Person的空参构造器， //所以这个方法要求1.类必须有空参构造器 // 2.这个空参构造器的权限不是私有。通常为public //在javabean中要求提供一个public的空参构造其，原因： //1.便于通过反射，创建运行时类的对象 //2.便于子类继承此运行时类时，默认调用super(),保证父类有空参构造器 Person obj = clazz.newInstance(); System.out.println(obj); &#125; @Test public void test2() &#123;int num=new Random().nextInt(3);//0.1.2String path=&quot;&quot;;switch(num) &#123; case 0: path = &quot;java.util.Date&quot;; break; case 1: path = &quot;java.lang.Object&quot;; break; case 2: path = &quot;Person&quot;; break;&#125; try &#123; Object obj = getInstance(path); System.out.println(obj); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125;&#125; /** * 创建一个指定类的对象 * @param classPath 指定类的全类名 * @return * @throwsException */ public Object getInstance(String classPath) throws Exception&#123; Class clazz=Class.forName(classPath); return clazz.newInstance(); &#125;&#125; 提供结构丰富的Person类1234567891011121314151617181920212223242526272829303132333435363738package com.atguigu.java;public class Person extends Creature&lt;String&gt; implements Comparable&lt;String&gt;,MyInterface&#123; private String name; int age; public int id; protected int score; public Person()&#123; &#125; private Person(String name)&#123; this.name=name; &#125; public Person(String name,int age)&#123; this.name=name; this.age=age; &#125; private String show(String nation)&#123; System.out.println(&quot;我的国际时&quot;+nation); return nation; &#125; public String display(String interests)&#123; return interests; &#125; @Override public int compareTo(String o) &#123; return 0; &#125; @Override public void info() &#123; System.out.println(&quot;我是一个人&quot;); &#125;&#125; 获取运行时类的属性结构及其内部结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.atguigu.java1;import com.atguigu.java.Person;import com.sun.deploy.util.SystemUtils;import org.junit.Test;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import java.util.Locale;/*获取运行时类的属性结构 */public class FieldTest &#123;@Test public void test1()&#123; Class clazz= Person.class; //获取属性结构 //getFields():获取当前运行时类及其父类中声明为public访问权限的属性 Field[] fields = clazz.getFields(); for (Field f : fields) &#123; System.out.println(f); &#125;System.out.println(&quot;******************&quot;); //getDeclaredFields():获取当前运行时类当中的所有属性 Field[] declaredFields = clazz.getDeclaredFields(); for (Field f : declaredFields) &#123; System.out.println(f); &#125;&#125;//每一个属性的具体的部分也是可以拿到的//权限，修饰符，数据类型，变量名，变量值 @Test public void test2()&#123; Class clazz=Person.class; Field[] declaredFields = clazz.getDeclaredFields(); for (Field f : declaredFields) &#123; //1.权限修饰符 //这个地方获取的是一个表示访问类型的数字 int modifier =f.getModifiers(); //这个地方是将访问类型的数字转换成访问类型的文字,空白是默认类型 System.out.println(Modifier.toString(modifier)); //2.数据类型 Class type=f.getType();//type获得的是一个类型 System.out.println(type.getName());//这样是获得type的全名 //3.变量名 String name = f.getName(); System.out.println(name); &#125;&#125;&#125; 获取运行时类的方法结构和内部结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.atguigu.java1;import com.atguigu.java.Person;import org.junit.Test;import java.lang.reflect.Method;import java.lang.reflect.Modifier;/*获取运行时类的方法结构 */public class MethodTest &#123; @Test public void test1() &#123; Class clazz = Person.class; //getMethods:获取当前运行时类及其所有父类中声明为public权限的方法 Method[] methods = clazz.getMethods(); for (Method m : methods) &#123; System.out.println(m); &#125; System.out.println(&quot;****************************&quot;); //获取当前运行时类中声明的所有方法，不包含父类中声明的 Method[] declaredMethods = clazz.getDeclaredMethods(); for (Method m : declaredMethods) &#123; System.out.println(m); &#125; &#125; @Test /* @注解 权限修饰符，返回值类型，方法名（参数类型 形参名1，...）throws Exception()&#123; &#125; */ public void test2() &#123; Class clazz = Person.class; Method[] methods = clazz.getDeclaredMethods(); for (Method m : methods) &#123; //获取权限修饰符 System.out.println(Modifier.toString(m.getModifiers())); //获取方法的返回值类型 System.out.println(m.getReturnType().getName()); //获取方法名 System.out.println(m.getName()); System.out.println(&quot;(&quot;); //获取形参列表 Class[] parameterTypes = m.getParameterTypes(); if (!(parameterTypes != null &amp;&amp; parameterTypes.length == 0)) &#123; for (int i = 0; i &lt; parameterTypes.length; i++) &#123; if (i == parameterTypes.length - 1) &#123; System.out.println(parameterTypes[i].getName() + &quot; args_&quot; + i); break; &#125; System.out.println(parameterTypes[i].getName() + &quot; args_&quot; + i + &quot;,&quot;); &#125; System.out.println(&quot;)&quot;); &#125; //获取抛出的异常 Class[] exceptionTypes = m.getExceptionTypes(); if (exceptionTypes.length &gt; 0) &#123; System.out.print(&quot;throws&quot;); for (int i = 0; i &lt; exceptionTypes.length; i++) &#123; if (i == exceptionTypes.length - 1) &#123; System.out.println(exceptionTypes[i].getName()); break; &#125; System.out.println(exceptionTypes[i].getName() + &quot;,&quot;); &#125; &#125; &#125; &#125;&#125; 获取运行时类的构造器结构1234567891011121314151617181920212223242526package com.atguigu.java1;import com.atguigu.java.Person;import org.junit.Test;import java.lang.reflect.Constructor;import java.lang.reflect.Method;public class OtherTest &#123;@Test public void test1()&#123; Class clazz= Person.class; //getConstructors获取当前运行时类中声明为public的构造器 Constructor[] constructors = clazz.getConstructors(); for (Constructor constructor : constructors) &#123; System.out.println(constructor); &#125; System.out.println(&quot;***********************&quot;); //getDeclaredMethods获取当前运行时类中声明的所有的构造器 Constructor[] declaredMethods = clazz.getDeclaredConstructors(); for (Constructor declaredMethod : declaredMethods) &#123; System.out.println(declaredMethod); &#125;&#125;&#125; 获取运行时类的父类和泛型ParameterizedType是Type的子接口 Type是Class的父接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 /* 获取运行时类的父类 */ @Test public void test2()&#123; Class clazz = Person.class; Class superclass = clazz.getSuperclass(); System.out.println(superclass); &#125; /* 获取运行时类的带泛型的父类 */ @Test public void test3()&#123; Class clazz = Person.class; Type genericSuperclass = clazz.getGenericSuperclass(); System.out.println(genericSuperclass); &#125; /* 获取运行时类的带泛型的父类的泛型 代码：逻辑性代码 vs 功能性代码 */ @Test public void test4()&#123; Class clazz = Person.class; Type genericSuperclass = clazz.getGenericSuperclass(); //ParameterizedType是Type的子接口 //Type是Class的父接口，就像是List和ArrayList的关系 ParameterizedType paramType = (ParameterizedType) genericSuperclass; //获取泛型类型 Type[] actualTypeArguments = paramType.getActualTypeArguments();// System.out.println(actualTypeArguments[0].getTypeName()); //将Type类型强转为class，然后再用getName，只有Type才有getTypename方法 System.out.println(((Class)actualTypeArguments[0]).getName()); &#125; /* 获取运行时类实现的接口 */ @Test public void test5()&#123; Class clazz = Person.class; Class[] interfaces = clazz.getInterfaces(); for(Class c : interfaces)&#123; System.out.println(c); &#125; System.out.println(); //获取运行时类的父类实现的接口 Class[] interfaces1 = clazz.getSuperclass().getInterfaces(); for(Class c : interfaces1)&#123; System.out.println(c); &#125; &#125; 获取运行时类实现的接口，所在的包，注解123456789101112131415161718192021222324252627282930313233343536373839404142434445/*获取运行时类实现的接口 */@Testpublic void test5()&#123; Class clazz = Person.class; Class[] interfaces = clazz.getInterfaces(); for(Class c : interfaces)&#123; System.out.println(c); &#125; System.out.println(); //获取运行时类的父类实现的接口 Class[] interfaces1 = clazz.getSuperclass().getInterfaces(); for(Class c : interfaces1)&#123; System.out.println(c); &#125;&#125;/* 获取运行时类所在的包 */@Testpublic void test6()&#123; Class clazz = Person.class; Package pack = clazz.getPackage(); System.out.println(pack);&#125;/* 获取运行时类声明的注解 */@Testpublic void test7()&#123; Class clazz = Person.class; Annotation[] annotations = clazz.getAnnotations(); for(Annotation annos : annotations)&#123; System.out.println(annos); &#125;&#125; 调用运行时类的指定结构指定结构主要指的是属性和方法构造器","categories":[],"tags":[]}],"categories":[],"tags":[]}