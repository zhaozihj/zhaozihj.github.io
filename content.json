{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"标题","date":"2022-09-29T15:18:19.000Z","updated":"2022-09-30T03:08:53.351Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"123321321312321"}],"posts":[{"title":"jdbc","slug":"jdbc","date":"2022-09-29T15:31:35.000Z","updated":"2022-09-29T15:37:39.326Z","comments":true,"path":"2022/09/29/jdbc/","link":"","permalink":"http://example.com/2022/09/29/jdbc/","excerpt":"","text":"JDBC核心技术 讲师：宋红康 微博：尚硅谷-宋红康 第1章：JDBC概述1.1 数据的持久化 持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。 持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。 用数据库存储大量数据，方便快捷高效 1.2 Java中的数据存储技术 在Java中，数据库存取技术可分为如下几类： JDBC直接访问数据库 JDO (Java Data Object )技术 第三方O&#x2F;R工具，如Hibernate, Mybatis 等 JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。 1.3 JDBC介绍 JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口（一组API），定义了用来访问数据库的标准Java类库，（java.sql,javax.sql）使用这些类库可以以一种标准的方法、方便地访问数据库资源。 JDBC为访问不同的数据库提供了一种统一的途径，为开发者屏蔽了一些细节问题。 JDBC的目标是使Java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。 如果没有JDBC，那么Java程序访问数据库时是这样的： 有了JDBC，Java程序访问数据库时是这样的： 总结如下： 1.4 JDBC体系结构 JDBC接口（API）包括两个层次： 面向应用的API：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。 面向数据库的API：Java Driver API，供开发商开发数据库驱动程序用。 JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。 不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。 ————面向接口编程 1.5 JDBC程序编写步骤 补充：ODBC(Open Database Connectivity，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。 第2章：获取数据库连接2.1 要素一：Driver接口实现类2.1.1 Driver接口介绍 java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。 在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。 Oracle的驱动：oracle.jdbc.driver.OracleDriver mySql的驱动： com.mysql.jdbc.Driver 导入这些驱动的方法在csdn的收藏里有 2.1.2 加载与注册JDBC驱动 加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名 Class.forName(“com.mysql.jdbc.Driver”); 注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序 使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动 通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码： 2.2 要素二：URL JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。 JDBC URL的标准由三部分组成，各部分间用冒号分隔。 jdbc:子协议:子名称 协议：JDBC URL中的协议总是jdbc 子协议：子协议用于标识一个数据库驱动程序 子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了定位数据库提供足够的信息。包含主机名(对应服务端的ip地址)，端口号，数据库名 举例： 几种常用数据库的 JDBC URL MySQL的连接URL编写方式： jdbc:mysql:&#x2F;&#x2F;主机名称:mysql服务端口号&#x2F;数据库名称?参数&#x3D;值&amp;参数&#x3D;值 jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;atguigu jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;atguigu**?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集） jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;atguigu?user&#x3D;root&amp;password&#x3D;123456 Oracle 9i的连接URL编写方式： jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称 jdbc:oracle:thin:@localhost:1521:atguigu SQLServer的连接URL编写方式： jdbc:sqlserver:&#x2F;&#x2F;主机名称:sqlserver服务端口号:DatabaseName&#x3D;数据库名称 jdbc:sqlserver:&#x2F;&#x2F;localhost:1433:DatabaseName&#x3D;atguigu 2.3 要素三：用户名和密码 user,password可以用“属性名&#x3D;属性值”方式告诉数据库 可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接 2.4 数据库连接方式举例2.4.1 连接方式一12345678910111213141516171819202122@Test public void testConnection1() &#123; try &#123; //1.提供java.sql.Driver接口实现类的对象 Driver driver = null; driver = new com.mysql.jdbc.Driver(); //2.提供url，指明具体操作的数据 String url = &quot;jdbc:mysql://localhost:3306/test&quot;; //3.提供Properties的对象，指明用户名和密码 Properties info = new Properties(); info.setProperty(&quot;user&quot;, &quot;root&quot;); info.setProperty(&quot;password&quot;, &quot;root&quot;); //4.调用driver的connect()，获取连接 Connection conn = driver.connect(url, info); System.out.println(conn); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; 说明：上述代码中显式出现了第三方数据库的API Class.forName的介绍Class 类加载的形式常见类加载的方式 执行一个类自己的main方法这个类也会被加载 1 类名.Class2 new 对象3 Class.forName(“类的全路径”) ps(有个点注意一下)在执行的时候加上以下一句JVM的运行参数，可以观看类加载过程-XX:+TraceClassLoading例，用idea就这样添加来吧，小伙子们，上代码~ 第一种形式，类名.Classclass ClassTest{ static { System.out.println(“执行了静态代码块”); }}public class ClassLoderTest { public static void main(String[] args) throws ClassNotFoundException { Class&lt;?&gt; aClass2 &#x3D; ClassTest.class; }} 运行结果如下 ClassTest 这个类有被加载器加载，但是并没有输出语句，所以并没有被执行。 第二种形式， new 对象new 一个对象，以及利用这个对象调用成员变量方法等，就不在一一赘述。 class ClassTest{ static { System.out.println(“执行了静态代码块”); }}public class ClassLoderTest { public static void main(String[] args) throws ClassNotFoundException { new ClassTest(); }} 运行结果如下 ClassTest 这个 类有被加载，并且静态块语句有被输出，所以，这种方式会执行静态代码块。 第三种形式 ，Class.forName(“类的全路径”)class ClassTest{ static { System.out.println(“执行了静态代码块”); }}public class ClassLoderTest { public static void main(String[] args) throws ClassNotFoundException { Class&lt;?&gt; aClass3 &#x3D; Class.forName(“com.management.JavassistTest.ClassTest”); }} 运行结果如下 ClassTest 这个 类有被加载，并且静态块语句有被输出，所以，这种方式会执行静态代码块。 第三种形式的特殊用法但是第三种的形式有另一种方式使得它不执行。如下： class ClassTest{ static { System.out.println(“执行了静态代码块”); }}public class ClassLoderTest { public static void main(String[] args) throws ClassNotFoundException { Class&lt;?&gt; aClass3 &#x3D; Class.forName(“com.management.JavassistTest.ClassTest”, false,&#x2F;&#x2F;true的时候会执行 ClassLoader.getSystemClassLoader()); }} 2.4.2 连接方式二方式二，对方式一的迭代：在如下的程序中不出现第三方的api，使得程序具有更好的可移植性 123456789101112131415public void testConnection2() throws Exception &#123; //1.获取Driver实现类对象，使用反射 Class clazz = Class.forName(&quot;com.mysql.jdbc.Driver&quot;); Driver driver= (Driver) clazz.newInstance(); //2.提供要链接的数据库 String url=&quot;jdbc:mysql://localhost:3306/test&quot;; //3.提供连接需要的用户名和密码 Properties info=new Properties(); info.setProperty(&quot;user&quot;,&quot;root&quot;); info.setProperty(&quot;password&quot;,&quot;root&quot;); //4.获取连接 Connection connect = driver.connect(url, info); System.out.println(connect);&#125; 说明：相较于方式一，这里使用反射实例化Driver，不在代码中体现第三方数据库的API。体现了面向接口编程思想。 2.4.3 连接方式三12345678910111213141516171819202122@Test public void testConnection3() &#123; try &#123; //1.数据库连接的4个基本要素： String url = &quot;jdbc:mysql://localhost:3306/test&quot;; String user = &quot;root&quot;; String password = &quot;root&quot;; String driverName = &quot;com.mysql.jdbc.Driver&quot;; //2.实例化Driver Class clazz = Class.forName(driverName); Driver driver = (Driver) clazz.newInstance(); //3.注册驱动 DriverManager.registerDriver(driver); //4.获取连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 说明：使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。 2.4.4 连接方式四但这个地方最好不要用这个，mysql好使可能其他的就不好使了 123456789101112131415161718192021222324252627282930313233343536373839@Test public void testConnection4() &#123; try &#123; //1.数据库连接的4个基本要素： String url = &quot;jdbc:mysql://localhost:3306/test&quot;; String user = &quot;root&quot;; String password = &quot;root&quot;; String driverName = &quot;com.mysql.jdbc.Driver&quot;; //下面这一步是把com.mysql.jdbc.Driver类加载到内存中，一加载就执行静态代码块，进行了注册驱动和实例化 //2.加载驱动 （①实例化Driver ②注册驱动） Class.forName(driverName); //Driver driver = (Driver) clazz.newInstance(); //3.注册驱动 //DriverManager.registerDriver(driver); /* 可以注释掉上述代码的原因，是因为在mysql的Driver类中声明有： Driver类中的静态代码块 static &#123; try &#123; DriverManager.registerDriver(new Driver()); &#125; catch (SQLException var1) &#123; throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;); &#125; &#125; */ //3.获取连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 说明：不必显式的注册驱动了。因为在DriverManager的源码中已经存在静态代码块，实现了驱动的注册。 当类加载的时候会执行静态代码块 2.4.5 连接方式五(最终版)将数据库连接需要的四个基本信息声明在配置文件中，通过读取配置文件的格式，获取连接 123456789101112131415161718192021222324252627282930313233343536import java.io.File;import java.io.FileInputStream;import java.io.InputStream;import java.sql.Connection;import java.sql.Driver;import java.sql.DriverManager;import java.sql.SQLException;import java.util.Properties;class Main&#123; public static void main(String[] args) throws Exception &#123; testConnection5(); &#125; public static void testConnection5() throws Exception &#123; //1.加载配置文件 InputStream is=JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); Properties pros = new Properties(); pros.load(is); //2.读取配置信息 String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); String url = pros.getProperty(&quot;url&quot;); String driverClass = pros.getProperty(&quot;driverClass&quot;); //3.加载驱动 Class.forName(driverClass); //4.获取连接 Connection conn = DriverManager.getConnection(url, user, password); return conn; &#125;&#125; 其中，配置文件声明在工程的src目录下：【jdbc.properties】 1234user=rootpassword=abc123url=jdbc:mysql://localhost:3306/testdriverClass=com.mysql.jdbc.Driver 说明：使用配置文件的方式保存配置信息，在代码中加载配置文件 使用配置文件的好处： ①实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码②如果修改了配置信息，省去重新编译的过程也就是避免程序重新打包。 第3章：使用PreparedStatement实现CRUD操作crud就是增删改查 PreparedStatement是Statement的子接口 3.1 操作和访问数据库 数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。 在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式： Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。 CallableStatement：用于执行 SQL 存储过程 3.2 使用Statement操作数据表的弊端 通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。 Statement 接口中定义了下列方法用于执行 SQL 语句： 12int excuteUpdate(String sql)：执行更新操作INSERT、UPDATE、DELETEResultSet executeQuery(String sql)：执行查询操作SELECT 但是使用Statement操作数据表存在弊端： 问题一：存在拼串操作，繁琐 问题二：存在SQL注入问题 SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user&#x3D;’a’ OR 1 &#x3D; ‘ AND password &#x3D; ‘ OR ‘1’ &#x3D; ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。 对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public class StatementTest &#123; // 使用Statement的弊端：需要拼写sql语句，并且存在SQL注入的问题 @Test public void testLogin() &#123; Scanner scan = new Scanner(System.in); System.out.print(&quot;用户名：&quot;); String userName = scan.nextLine(); System.out.print(&quot;密 码：&quot;); String password = scan.nextLine(); // SELECT user,password FROM user_table WHERE USER = &#x27;1&#x27; or &#x27; AND PASSWORD = &#x27;=&#x27;1&#x27; or &#x27;1&#x27; = &#x27;1&#x27;; //上面这个是一个sql注入的语句让AND条件失效，or满足一个即可执行，最后一个恒能执行 String sql = &quot;SELECT user,password FROM user_table WHERE user = &#x27;&quot; + userName + &quot;&#x27; AND password = &#x27;&quot; + password+ &quot;&#x27;&quot;; User user = get(sql, User.class); if (user != null) &#123; System.out.println(&quot;登陆成功!&quot;); &#125; else &#123; System.out.println(&quot;用户名或密码错误！&quot;); &#125; &#125; // 使用Statement实现对数据表的查询操作 public &lt;T&gt; T get(String sql, Class&lt;T&gt; clazz) &#123; T t = null; Connection conn = null; Statement st = null; ResultSet rs = null; try &#123; // 1.加载配置文件 InputStream is = StatementTest.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); Properties pros = new Properties(); pros.load(is); // 2.读取配置信息 String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); String url = pros.getProperty(&quot;url&quot;); String driverClass = pros.getProperty(&quot;driverClass&quot;); // 3.加载驱动 Class.forName(driverClass); // 4.获取连接 conn = DriverManager.getConnection(url, user, password); st = conn.createStatement(); rs = st.executeQuery(sql); // 获取结果集的元数据 ResultSetMetaData rsmd = rs.getMetaData(); // 获取结果集的列数 int columnCount = rsmd.getColumnCount(); if (rs.next()) &#123; t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) &#123; // //1. 获取列的名称 // String columnName = rsmd.getColumnName(i+1); // 1. 获取列的别名 String columnName = rsmd.getColumnLabel(i + 1); // 2. 根据列名获取对应数据表中的数据 Object columnVal = rs.getObject(columnName); // 3. 将数据表中得到的数据，封装进对象 Field field = clazz.getDeclaredField(columnName); field.setAccessible(true); field.set(t, columnVal); &#125; return t; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭资源 if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (st != null) &#123; try &#123; st.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return null; &#125;&#125; User类 12345678910111213141516171819202122232425262728293031323334package com.atguigu2.statement.crud;public class User &#123; private String user; private String password; public User() &#123; &#125; public User(String user, String password) &#123; this.user = user; this.password = password; &#125; public String toString() &#123; return &quot;User [user=&quot; + this.user + &quot;, password=&quot; + this.password + &quot;]&quot;; &#125; public String getUser() &#123; return this.user; &#125; public void setUser(String user) &#123; this.user = user; &#125; public String getPassword() &#123; return this.password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 综上： 3.3 PreparedStatement的使用3.3.1 PreparedStatement介绍 可以通过调用 Connection 对象的 preparedStatement(String sql) 方法获取 PreparedStatement 对象 PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句 PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值 3.3.2 PreparedStatement vs Statement 代码的可读性和可维护性。 PreparedStatement 能最大可能提高性能： DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。 在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样每执行一次都要对传入的语句编译一次。 (语法检查，语义检查，翻译成二进制命令，缓存) PreparedStatement 可以防止 SQL 注入 3.3.3 Java与SQL对应数据类型转换表 Java类型 SQL类型 boolean BIT byte TINYINT short SMALLINT int INTEGER long BIGINT String CHAR,VARCHAR,LONGVARCHAR byte array BINARY , VAR BINARY java.sql.Date DATE java.sql.Time TIME java.sql.Timestamp TIMESTAMP 获取连接和关闭资源很常用所以进行封装 InputStream is&#x3D;JDBCUtils.class.getClassLoader().getResourceAsStream(“jdbc.properties”); 这个方法是用来锁定src目录下的内容 如果jdbc.properties在基础目录下，参数就应该变为 基础&#x2F;jdbc.properties 在idea java中路径都是使用&#x2F; 做斜杠，只有用到io用到整个windows系统的绝对路径时用\\斜杠来表示路径，而此时也不要用相对路径了，直接用绝对路径 在idea中文件中相对路径都用&#x2F; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124package 基础;import org.apache.commons.dbutils.DbUtils;import com.alibaba.druid.pool.DruidDataSource;import java.io.InputStream;import java.sql.*;import java.util.Properties;public class JDBCUtils &#123; /* 封装的是获取连接的操作 */ public static Connection getConnection() throws Exception&#123; //1.加载配置文件 InputStream is=JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); Properties pros = new Properties(); pros.load(is); //2.读取配置信息 String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); String url = pros.getProperty(&quot;url&quot;); String driverClass = pros.getProperty(&quot;driverClass&quot;); //3.加载驱动 Class.forName(driverClass); //4.获取连接 Connection conn = DriverManager.getConnection(url, user, password); return conn; &#125; /* 封装的是关闭资源的操作 */ public static void closeResource(Connection conn, Statement ps)&#123; //这个地方就不仅仅一定是mysql了所以用Statement try &#123; if (ps != null) &#123; ps.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(conn!=null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /* 封装的是查询时关闭资源的操作 */ public static void closeResource(Connection conn, Statement ps,ResultSet rs)&#123; //这个地方就不仅仅一定是mysql了所以用Statement try &#123; if (ps != null) &#123; ps.close(); &#125; &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; try &#123; if(conn!=null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; try &#123; if (rs != null) &#123; rs.close(); &#125; &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; //用DBUtils关闭资源 public static void closeResource1(Connection conn,Statement ps,ResultSet rs)&#123; DbUtils.closeQuietly(conn); DbUtils.closeQuietly(ps); DbUtils.closeQuietly(rs); &#125; private static DruidDataSource dataSource; /*static &#123; try&#123; Properties properties=new Properties(); //奇怪的是这个地方不能用绝对路径 InputStream inputStream=JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); properties.load(inputStream); dataSource= (DruidDataSource) DruidDataSourceFactory.createDataSource(properties); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;*/ //获取数据库连接池中的连接，如果返回null就是获取失败，有值就是获取成功 public static Connection getConnection3()&#123; Connection conn=null; try &#123; conn=dataSource.getConnection(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return conn; &#125;&#125; 3.3.4 使用PreparedStatement实现增、删、改操作更新数据 123456789101112131415161718import java.sql.*;public class ConnectionTest &#123; public void testupdate() throws Exception &#123; //获取数据库连接 Connection conn = JDBCUtils.getConnection(); //预编译sql语句，返回PreparedStarement实例 String sql=&quot;update customers set name= ? where id = ?&quot;; PreparedStatement ps=conn.prepareStatement(sql); //填充占位符 ps.setString(1,&quot;莫扎特&quot;); ps.setInt(2,18); //执行 ps.execute(); //资源的关闭 JDBCUtils.closeResource(conn,ps); &#125;&#125; 增加数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//向customers表中添加一条记录//没用自己封装的方法public void testInsert() &#123; Connection conn=null; PreparedStatement ps=null;try &#123; //一.获取连接 //1.加载配置文件 InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); Properties pros = new Properties(); pros.load(is); //2.读取配置信息 String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); String url = pros.getProperty(&quot;url&quot;); String driverClass = pros.getProperty(&quot;driverClass&quot;); //3.加载驱动 Class.forName(driverClass); //4.获取连接 conn = DriverManager.getConnection(url, user, password); System.out.println(conn); //5.预编译sql语句，返回PreparedStatement的实例 String sql = &quot;insert into customers(name,email,birth)values(?,?,?)&quot;;//?占位符 ps = conn.prepareStatement(sql); //6.填充占位符,第一个参数索引是从1开始的 ps.setString(1, &quot;哪吒&quot;); ps.setString(2, &quot;nezha&quot;); ps.setDate(3, new Date(32235235325L)); //7.执行操作 ps.execute();&#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; //8.关闭资源 try &#123; if (ps != null) &#123; ps.close(); &#125; &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; try &#123; conn.close(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125;&#125;&#125; 1234567891011121314151617181920212223242526272829//增删改通用方法 //用到了自己封装的方法//通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表）//可变形参args的个数应该和sql语句中的占位符数量相等 public void update(String sql,Object ... args)&#123; Connection conn = null; PreparedStatement ps = null; try &#123; //1.获取数据库的连接 conn = JDBCUtils.getConnection(); //2.获取PreparedStatement的实例 (或：预编译sql语句) ps = conn.prepareStatement(sql); //3.填充占位符 for(int i = 0;i &lt; args.length;i++)&#123; ps.setObject(i + 1, args[i]); &#125; //4.执行sql语句 ps.execute(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; //5.关闭资源 JDBCUtils.closeResource(conn, ps); &#125; &#125; 增删改通用方法的测试 123456789public static void main(String[] args) &#123; String sql=&quot;update `order` set order_name = ? where order_id=?&quot;; try &#123; update(sql,&quot;DD&quot;,&quot;2&quot;); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125;&#125; 3.3.5 使用PreparedStatement实现查询操作更复杂，因为查询之后会返回一个结果集 第一种 这个是针对customers表中的一种操作，并不是通用customers表的通用操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void testQuery1() &#123; Connection conn=null; ResultSet resultSet=null; PreparedStatement ps=null; try &#123; conn = JDBCUtils.getConnection(); //预编译sql语句 String sql = &quot;select id,name,email,birth from customers where id=?&quot;; ps = conn.prepareStatement(sql); //写满填充符 ps.setObject(1,1); //执行,并返回结果集 resultSet = ps.executeQuery(); //处理结果集 if (resultSet.next()) &#123;//判断结果集的下一条是否有数据，如果有数据返回true，并指针下移 //获取当前这条数据的各个字段的值 int id = resultSet.getInt(1); String name = resultSet.getString(2); String email = resultSet.getString(3);//获得当前这条的第三个字段 Date birth = resultSet.getDate(4); //方式一 System.out.println(&quot;id=&quot; + id + &quot;,name=&quot; + name + &quot;,email=&quot; + email + &quot;,birth&quot; + birth); //方式二 Object[] data = new Object[]&#123;id, name, email, birth&#125;; System.out.println(Arrays.toString(data)); //方式三 Customer customer = new Customer(id, name, email, birth); System.out.println(customer); &#125; &#125; catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; //关闭资源 JDBCUtils.closeResource(conn, ps, resultSet); &#125;&#125; 这种根据数据库设计的类就是JavaBean类 Customer类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class Customer &#123; /* ORM编程思想 一个数据表对应一个java类 表中的一条记录对应java类的一个对象 表中的一个字段对应java类的一个属性 */ public Customer(int id, String name, String email, Date birth) &#123; this.id = id; this.name = name; this.email = email; this.birth = birth; &#125; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Date getBirth() &#123; return birth; &#125; public void setBirth(Date birth) &#123; this.birth = birth; &#125; private String email; private Date birth; @Override public String toString() &#123; return &quot;Customer&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, email=&#x27;&quot; + email + &#x27;\\&#x27;&#x27; + &quot;, birth=&quot; + birth + &#x27;&#125;&#x27;; &#125;&#125; 第二种 针对customers表的一个通用操作 123456789101112131415161718192021222324252627282930313233343536373839404142public static Customer queryForCustomers(String sql,Object...args) throws Exception &#123; Connection conn=null; PreparedStatement ps=null; ResultSet rs=null; try &#123; conn = JDBCUtils.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; rs = ps.executeQuery(); //获取结果集的元数据 ResultSetMetaData rsmd = rs.getMetaData(); //得到结果集的列数 int columnCount = rsmd.getColumnCount(); if (rs.next()) &#123;//判断结果集是否还有下一行 Customer cust = new Customer(); //处理结果集一行数据中的每一个列 for (int i = 0; i &lt; columnCount; i++) &#123; Object value = rs.getObject(i + 1); //获取每个列的列名 String columnName = rsmd.getColumnName(i + 1); //给cust对象指定的columnName属性，赋值为value，通过反射 //获得的是Customer的columnName代指这个属性 Field field = Customer.class.getDeclaredField(columnName); field.setAccessible(true);//让这个属性可以被访问 field.set(cust, value); &#125; return cust; &#125; &#125;catch(Exception e)&#123;e.printStackTrace();&#125;finally &#123; JDBCUtils.closeResource(conn,ps,rs); &#125; return null; &#125; 这个地方如果字段名和Customer类中的属性名不一致将字段名起别名这样结果集就的字段名就和属性名一致了 用order表做例子 1String sql=&quot;select order_id orderId,order_name orderName,order_date orderDate from `order` where id=?&quot;; 这样就将order_id字段起别名为orderId 同时要将getColumnName()换成getColumnLabel()获取列的别名 getColumnName()不推荐使用 测试： 12345678910public static void main(String[] args) throws Exception &#123; String sql=&quot;select id,name,birth,email from customers where id = ?&quot;; Customer customer=queryForCustomers(sql,13); System.out.println(customer); String sql1=&quot;select name,email from customers where name=?&quot;; Customer customer1=queryForCustomers(sql1,&quot;周杰伦&quot;); System.out.println(customer1);&#125; 第三种 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 // 通用的针对于不同表的查询:返回表中的一条记录//这是一个泛型方法 public &lt;T&gt; T getInstance(Class&lt;T&gt; clazz, String sql, Object... args) &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; // 1.获取数据库连接 conn = JDBCUtils.getConnection(); // 2.预编译sql语句，得到PreparedStatement对象 ps = conn.prepareStatement(sql); // 3.填充占位符 for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; // 4.执行executeQuery(),得到结果集：ResultSet rs = ps.executeQuery(); // 5.得到结果集的元数据：ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); // 6.1通过ResultSetMetaData得到columnCount(列数),columnLabel(列标签)；通过ResultSet得到列值 int columnCount = rsmd.getColumnCount(); if (rs.next()) &#123;//判断结果集的下一条是否有数据，如果有数据返回true，并指针下移 //如果返回false指针不会下移 T t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) &#123;// 遍历每一个列 // 获取列值 Object columnVal = rs.getObject(i + 1); // 获取列的别名:列的别名，使用类的属性名充当 String columnLabel = rsmd.getColumnLabel(i + 1); // 6.2使用反射，给对象的相应属性赋值 Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columnVal); &#125; return t; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 7.关闭资源 JDBCUtils.closeResource(conn, ps, rs); &#125; return null; &#125; 说明：使用PreparedStatement实现的查询操作可以替换Statement实现的查询操作，解决Statement拼串和SQL注入问题。 测试 12345public static void main(String[] args) &#123; String sql=&quot;select id,name,email from customers where id=?&quot;; Customer instance = getInstance(Customer.class, sql, 12); System.out.println(instance);&#125; 第四种情况 当结果集有多行的时候使用集合来存储 这个不是查询好多次，是一次查询出来很多的时候用 1234567891011121314151617181920212223242526272829303132333435363738394041424344public static&lt;T&gt; List&lt;T&gt; getInstance(Class&lt;T&gt; clazz, String sql, Object...args)&#123; Connection conn=null; PreparedStatement ps=null; ResultSet rs=null; try &#123; conn = JDBCUtils.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; rs = ps.executeQuery(); //获取结果集的元数据 ResultSetMetaData rsmd = rs.getMetaData(); //得到结果集的列数 int columnCount = rsmd.getColumnCount(); //创建集合 ArrayList&lt;T&gt; list = new ArrayList&lt;T&gt;(); while (rs.next()) &#123;//判断结果集是否还有下一行 T t = clazz.newInstance(); //处理结果集一行数据中的每一个列 for (int i = 0; i &lt; columnCount; i++) &#123; Object value = rs.getObject(i + 1); //获取每个列的列名 String columnName = rsmd.getColumnName(i + 1); //给t对象指定的columnName属性，赋值为value，通过反射 Field field = clazz.getDeclaredField(columnName); field.setAccessible(true);//让这个属性可以被访问 field.set(t, value); &#125; list.add(t); &#125; return list; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; JDBCUtils.closeResource(conn,ps,rs); &#125; return null;&#125; 测试 1234567public static void main(String[] args) &#123; String sql=&quot;select id,name,email from customers where id&lt;?&quot;; List&lt;Customer&gt; instance = getInstance(Customer.class, sql, 12); for (Customer customer : instance) &#123; System.out.println(customer); &#125;&#125; PreparedStatement防止了sql注入 主要是对sql语句进行了预编译，and关系就是and关系不可能再变成是or关系 其他好处：1.PreparedStatement操作Blob数据，而Statement做不到 ​ 2.PreparedStatement可以实现更高效的批量操作 3.4 ResultSet与ResultSetMetaData3.4.1 ResultSet 查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象 ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现 ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。 ResultSet 对象维护了一个指向当前数据行的游标，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。 当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。 例如: getInt(1), getString(“name”) 注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。 ResultSet 接口的常用方法： boolean next() getString() … 3.4.2 ResultSetMetaData 可用于获取关于 ResultSet 对象中列的类型和属性信息的对象 ResultSetMetaData meta &#x3D; rs.getMetaData(); getColumnName(int column)：获取指定列的名称 getColumnLabel(int column)：获取指定列的别名 getColumnCount()：返回当前 ResultSet 对象中的列数。 getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。 getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。 isNullable(int column)：指示指定列中的值是否可以为 null。 isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。 问题1：得到结果集后, 如何知道该结果集中有哪些列 ？ 列名是什么？ ​ 需要使用一个描述 ResultSet 的对象， 即 ResultSetMetaData 问题2：关于ResultSetMetaData 如何获取 ResultSetMetaData： 调用 ResultSet 的 getMetaData() 方法即可 获取 ResultSet 中有多少列：调用 ResultSetMetaData 的 getColumnCount() 方法 获取 ResultSet 每一列的列的别名是什么：调用 ResultSetMetaData 的getColumnLabel() 方法 3.5 资源的释放 释放ResultSet, Statement,Connection。 数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是尽量晚创建，尽量早的释放。 可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。 3.6 JDBC API小结 两种思想 面向接口编程的思想 ORM思想(object relational mapping) 一个数据表对应一个java类 表中的一条记录对应java类的一个对象 表中的一个字段对应java类的一个属性 sql是需要结合列名和表的属性名来写。注意起别名。 两种技术 JDBC结果集的元数据：ResultSetMetaData 获取列数：getColumnCount() 获取列的别名：getColumnLabel() 通过反射，创建指定类的对象，获取指定的属性并赋值 章节练习练习题1：从控制台向数据库的表customers中插入一条数据，表结构如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class ConnectionTest &#123; public static void main(String[] args) &#123; Scanner scanner =new Scanner(System.in); System.out.println(&quot;请输入用户名&quot;); String name=scanner.next(); System.out.println(&quot;请输入邮箱&quot;); String email=scanner.next(); System.out.println(&quot;请输入生日&quot;); String birthday=scanner.next();//可以用字符串但是格式一定要正确 String sql=&quot;insert into customers(name,email,birth)values(?,?,?)&quot;; int insertCount=update(sql,name,email,birthday); if(insertCount&gt;0)&#123; System.out.println(&quot;添加成功&quot;); &#125; else &#123; System.out.println(&quot;添加失败&quot;); &#125; &#125; public static int update(String sql,Object...args)&#123; Connection conn=null; PreparedStatement ps=null; try&#123; conn=JDBCUtils.getConnection(); ps=conn.prepareStatement(sql); for(int i=0;i&lt;args.length;i++)&#123; ps.setObject(i+1,args[i]); &#125; //如果执行的是查询操作有返回结果，则此方法返回true //如果执行的是增删改操作，没有返回结果，则此方法返回false //方式一 //return ps.execute(); //方式二 return ps.executeUpdate();//返回的是影响的行数,增删改都可以是这个，同时也可以执行sql语句 &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; finally&#123; JDBCUtils.closeResource(conn,ps); &#125; return 0; &#125;//这种id是递增的可以默认不添加也会自增一个，也可以指定id但不能够指定与原表中重复的id， 练习题2：创立数据库表 examstudent，表结构如下： 向数据表中添加如下数据： 代码实现1：插入一个新的student 信息 请输入考生的详细信息 Type:IDCard:ExamCard:StudentName:Location:Grade: 信息录入成功! 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Main&#123; public static int update(String sql,Object ... args)&#123; Connection conn = null; PreparedStatement ps = null; try &#123; //1.获取数据库的连接 conn = JDBCUtils.getConnection(); //2.获取PreparedStatement的实例 (或：预编译sql语句) ps = conn.prepareStatement(sql); //3.填充占位符 for(int i = 0;i &lt; args.length;i++)&#123; ps.setObject(i + 1, args[i]); &#125; return ps.executeUpdate(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; //5.关闭资源 JDBCUtils.closeResource(conn, ps); return 0; &#125; &#125; public static void main(String[] args) throws Exception &#123;//问题一，向examstudent表中添加一条记录 Scanner in=new Scanner(System.in); System.out.print(&quot;四级/六级:&quot;); int type=in.nextInt(); System.out.println(&quot;身份证号&quot;); String IDCard=in.next(); System.out.println(&quot;准考证号&quot;); String examCard=in.next(); System.out.print(&quot;学生姓名：&quot;); String studentName=in.next(); System.out.println(&quot;所在城市&quot;); String location=in.next(); System.out.println(&quot;考试成绩&quot;); int grade=in.nextInt(); String sql=&quot;insert into examstudent(Type,IDCard,ExamCard,StudentName,Location,Grade)values(?,?,?,?,?,?)&quot;; int insertCount=update(sql,type,IDCard,examCard,studentName,location,grade); if(insertCount&gt;0)&#123; System.out.println(&quot;添加成功&quot;); &#125; else &#123; System.out.println(&quot;添加失败&quot;); &#125; &#125;&#125; 代码实现2：在 eclipse中建立 java 程序：输入身份证号或准考证号可以查询到学生的基本信息。结果如下： 代码实现3：完成学生信息的删除功能 第4章 操作BLOB类型字段4.1 MySQL BLOB类型 MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。 插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。 MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的) 实际使用中根据需要存入的数据大小定义不同的BLOB类型。 需要注意的是：如果存储的文件过大，数据库的性能会下降。 如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： max_allowed_packet&#x3D;16M。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。 4.2 向数据表中插入大数据类型12345678910111213141516171819//获取连接Connection conn = JDBCUtils.getConnection(); String sql = &quot;insert into customers(name,email,birth,photo)values(?,?,?,?)&quot;;PreparedStatement ps = conn.prepareStatement(sql);// 填充占位符ps.setString(1, &quot;徐海强&quot;);ps.setString(2, &quot;xhq@126.com&quot;);ps.setDate(3, new Date(new java.util.Date().getTime()));// 操作Blob类型的变量FileInputStream fis = new FileInputStream(&quot;xhq.png&quot;);ps.setBlob(4, fis);//执行ps.execute(); fis.close();JDBCUtils.closeResource(conn, ps); 4.3 修改数据表中的Blob类型字段1234567891011121314Connection conn = JDBCUtils.getConnection();String sql = &quot;update customers set photo = ? where id = ?&quot;;PreparedStatement ps = conn.prepareStatement(sql);// 填充占位符// 操作Blob类型的变量FileInputStream fis = new FileInputStream(&quot;coffee.png&quot;);ps.setBlob(1, fis);ps.setInt(2, 25);ps.execute();fis.close();JDBCUtils.closeResource(conn, ps); 4.4 从数据表中读取大数据类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import com.mysql.jdbc.JDBC4PreparedStatement;import java.io.*;import java.sql.*;import java.util.*;import java.util.Date;public class Main &#123; public static void main(String[] args) throws Exception &#123; testQueryBlob(); &#125; public static void testQueryBlob() &#123; Connection conn=null; PreparedStatement ps=null; FileOutputStream fos = null; InputStream is = null; try &#123; conn = JDBCUtils.getConnection(); String sql = &quot;select id,name,email,birth,photo from customers where id=?&quot;; ps = conn.prepareStatement(sql); ps.setInt(1, 27); ResultSet rs = ps.executeQuery(); if (rs.next()) &#123; /* 方式一 int id=rs.getInt(1); String name=rs.getString(2); String email=rs.getString(3); Date date=rs.getDate(4); */ int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); String email = rs.getString(&quot;email&quot;); Date birth = rs.getDate(&quot;birth&quot;); Customer cust = new Customer(id, name, email, birth); System.out.println(cust); //将Blob类型的字段下载下来，以文件的方式保存在本地 Blob photo = rs.getBlob(&quot;photo&quot;); is = photo.getBinaryStream(); fos = new FileOutputStream(&quot;D:\\\\同步空间\\\\新建文件夹\\\\java\\\\zz.jpg&quot;); byte[] buffer = new byte[1024]; int len; while ((len = is.read(buffer)) != -1) &#123; fos.write(buffer, 0, len); &#125; &#125; &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; finally &#123; try &#123; if(is!=null) &#123; is.close(); &#125; &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; try &#123; if(fos!=null) &#123; fos.close(); &#125; &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; JDBCUtils.closeResource(conn, ps); &#125; &#125;&#125; 第5章 批量插入5.1 批量执行SQL语句当需要成批插入或者更新记录时，可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率 JDBC的批量处理语句包括下面三个方法： addBatch(String)：添加需要批量处理的SQL语句或是参数； executeBatch()：执行批量处理语句； clearBatch():清空缓存的数据 通常我们会遇到两种批量执行SQL语句的情况： 多条SQL语句的批量处理； 一个SQL语句的批量传参； 5.2 高效的批量插入举例：向数据表中插入20000条数据 数据库中提供一个goods表。创建如下： 1234CREATE TABLE goods(id INT PRIMARY KEY AUTO_INCREMENT,NAME VARCHAR(20)); 5.2.1 实现层次一：使用Statement123456Connection conn = JDBCUtils.getConnection();Statement st = conn.createStatement();for(int i = 1;i &lt;= 20000;i++)&#123; String sql = &quot;insert into goods(name) values(&#x27;name_&#x27; + &quot;+ i +&quot;)&quot;; st.executeUpdate(sql);&#125; 5.2.2 实现层次二：使用PreparedStatement123456789101112131415161718192021222324252627282930313233343536373839import com.mysql.jdbc.JDBC4PreparedStatement;import java.io.*;import java.sql.*;import java.util.*;import java.util.Date;public class Main &#123; public static void main(String[] args) throws Exception &#123; testInsearch(); &#125; public static void testInsearch() &#123; Connection conn=null; PreparedStatement ps=null; try&#123; long start = System.currentTimeMillis(); conn = JDBCUtils.getConnection(); String sql=&quot;insert into goods(name)value(?)&quot;;//预编译sql语句，缓存下来之后每次只需要该改变占位符的值， ps=conn.prepareStatement(sql); for(int i=1;i&lt;=20000;i++) &#123; ps.setObject(1,&quot;name_&quot;+i); ps.execute(); &#125; long end = System.currentTimeMillis(); System.out.println(&quot;花费的时间&quot;+(end-start)); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; finally&#123; JDBCUtils.closeResource(conn,ps); &#125; &#125;&#125; 5.2.3 实现层次三12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * 修改1： 使用 addBatch() / executeBatch() / clearBatch() * 修改2：mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。 * ?rewriteBatchedStatements=true 写在配置文件的url后面 * 修改3：使用更新的mysql 驱动：mysql-connector-java-5.1.37-bin.jar * */import com.mysql.jdbc.JDBC4PreparedStatement;import java.io.*;import java.sql.*;import java.util.*;import java.util.Date;public class Main &#123; public static void main(String[] args) throws Exception &#123; testInsearch(); &#125; public static void testInsearch() &#123; Connection conn=null; PreparedStatement ps=null; try&#123; long start = System.currentTimeMillis(); conn = JDBCUtils.getConnection(); String sql=&quot;insert into goods(name)value(?)&quot;;//预编译sql语句，缓存下来之后每次只需要该改变占位符的值， ps=conn.prepareStatement(sql); for(int i=1;i&lt;=20000;i++) &#123; ps.setObject(1,&quot;name_&quot;+i); //1.攒sql ps.addBatch(); if(i%500==0)&#123; //2.执行batch,每五百次执行一次 ps.executeBatch(); //3.清空batch ps.clearBatch(); &#125; &#125; long end = System.currentTimeMillis(); System.out.println(&quot;花费的时间&quot;+(end-start)); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; finally&#123; JDBCUtils.closeResource(conn,ps); &#125; &#125;&#125; 5.2.4 实现层次四1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** 层次四：在层次三的基础上操作* 使用Connection 的 setAutoCommit(false) / commit()*/import com.mysql.jdbc.JDBC4PreparedStatement;import java.io.*;import java.sql.*;import java.util.*;import java.util.Date;public class Main &#123; public static void main(String[] args) throws Exception &#123; testInsearch(); &#125; public static void testInsearch() &#123; Connection conn=null; PreparedStatement ps=null; try&#123; long start = System.currentTimeMillis(); conn = JDBCUtils.getConnection(); //设置不允许自动提交数据 conn.setAutoCommit(false);//就是那些数据不是立马提交的 String sql=&quot;insert into goods(name)value(?)&quot;;//预编译sql语句，缓存下来之后每次只需要该改变占位符的值， ps=conn.prepareStatement(sql); for(int i=1;i&lt;=20000;i++) &#123; ps.setObject(1,&quot;name_&quot;+i); //1.攒sql ps.addBatch(); if(i%500==0)&#123; //2.执行batch,每五百次执行一次 ps.executeBatch(); //3.清空batch ps.clearBatch(); &#125; &#125; //提交数据 conn.commit();//统一提交所有的数据 long end = System.currentTimeMillis(); System.out.println(&quot;花费的时间&quot;+(end-start)); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; finally&#123; JDBCUtils.closeResource(conn,ps); &#125; &#125;&#125; 第6章： 数据库事务6.1 数据库事务介绍 事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。(一个或多个DML操作) 事务处理（事务操作）：保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都**被提交(commit)，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务回滚(rollback)**到最初状态。 为确保数据库中数据的一致性，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。 6.2 JDBC事务处理 数据一旦提交，就不可回滚。 数据什么时候意味着提交？ 当一个连接对象被创建时，默认情况下是自动提交事务：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。 关闭数据库连接，数据就会自动的提交。如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。 JDBC程序中为了让多个 SQL 语句作为一个事务执行： 调用 Connection 对象的 setAutoCommit(false); 以取消自动提交事务 在所有的 SQL 语句都成功执行后，调用 commit(); 方法提交事务 在出现异常时，调用 rollback(); 方法回滚事务 若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。 【案例：用户AA向用户BB转账100】 AA的账户余额减100，BB的账户余额加100 同时要保证这两个操作要么都进行，要么都不进行 错误案例 123456789101112131415161718192021222324252627282930313233343536import java.sql.Connection;import java.sql.PreparedStatement;class Main &#123; public static void main(String []args)&#123; String sql1=&quot;update user_table set balance=balance-100 where user = ?&quot;;update(sql1,&quot;AA&quot;);//模拟网络异常 System.out.println(10/0);//这个地方出现了异常的话只有AA的钱减100，BB不会增加 String sql2=&quot;update user_table set balance=balance+100 where user = ?&quot;; update(sql2,&quot;BB&quot;); System.out.println(&quot;转账成功&quot;); &#125; //update version1.0 public static int update(String sql, Object... args) &#123; Connection conn = null; PreparedStatement ps = null; try &#123; conn = JDBCUtils.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; return ps.executeUpdate();//返回的是影响的行数,增删改都可以是这个，同时也可以执行sql语句 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(conn, ps); &#125; return 0; &#125;&#125; 正确的方法 原理：1.数据一旦提交，就不可回滚 ​ 哪些操作会导致数据的自动提交 1.DDL操作一旦执行，都会自动提交 2.DML默认情况下，一旦执行，就会自动提交，我们可以通过set autocommit&#x3D;false的方式取消DML操作的自动提交 3.默认在关闭连接的时候，会自动提交数据 正确案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;class Main &#123; public static void main(String []args) &#123; Connection conn = null; try &#123; conn = JDBCUtils.getConnection(); System.out.println(conn.getAutoCommit()); //取消数据的自动提交 conn.setAutoCommit(false);//让他不能自动提交 String sql1 = &quot;update user_table set balance=balance-100 where user = ?&quot;; update(conn, sql1, &quot;AA&quot;);//模拟网络异常 System.out.println(10 / 0); String sql2 = &quot;update user_table set balance=balance+100 where user = ?&quot;; update(conn, sql2, &quot;BB&quot;); System.out.println(&quot;转账成功&quot;); //提交数据 conn.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; conn.rollback();//回滚数据，保证了如果有异常两个都不执行成功 &#125; catch (SQLException ex) &#123; ex.printStackTrace(); &#125; &#125; finally &#123; conn.setAutoCommit(true); JDBCUtils.closeResource(conn, null); &#125; &#125; //update version2.0 public static int update(Connection conn,String sql, Object... args) &#123;//conn作为参数是因为要让几次操作都用一个连接 PreparedStatement ps = null; try &#123; ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; return ps.executeUpdate();//返回的是影响的行数,增删改都可以是这个，同时也可以执行sql语句 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(null, ps); &#125; return 0; &#125;&#125; 6.3 事务的ACID属性 原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency）事务必须使数据库从一个一致性状态变换到另外一个一致性状态。 隔离性（Isolation）事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。 6.3.1 数据库的并发问题 对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题: 脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。 不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段。之后, T1再次读取同一个字段, 值就不同了。 幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。 数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。 一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。 6.3.2 四种隔离级别 数据库提供的4种事务隔离级别： Oracle 支持的 2 种事务隔离级别：READ COMMITED, SERIALIZABLE。 Oracle 默认的事务隔离级别为: READ COMMITED 。 Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: REPEATABLE READ。 6.3.3 在MySql中设置隔离级别 每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。 查看当前的隔离级别: 1SELECT @@tx_isolation; 设置当前 mySQL 连接的隔离级别: 1set transaction isolation level read committed; 设置数据库系统的全局的隔离级别: 1set global transaction isolation level read committed; 补充操作： 创建mysql数据库用户： 1create user tom identified by &#x27;abc123&#x27;; 授予权限 123456#授予通过网络方式登录的tom用户，对所有库所有表的全部权限，密码设为abc123.grant all privileges on *.* to tom@&#x27;%&#x27; identified by &#x27;abc123&#x27;; #给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。grant select,insert,delete,update on atguigudb.* to tom@localhost identified by &#x27;abc123&#x27;; 设置隔离级别演示 （有报错） 防止脏读 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import jdk.nashorn.internal.scripts.JD;import src.User;import java.lang.reflect.Field;import java.sql.*;class Main &#123; public static void main(String []args) throws Exception &#123; testTranscationSelect(); &#125; public static void testTranscationSelect() throws Exception &#123; Connection conn= JDBCUtils.getConnection(); //获得当前的隔离级别 System.out.println(conn.getTransactionIsolation()); //设计数据库的隔离级别 conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED); //取消自动提交 conn.setAutoCommit(false); String sql=&quot;select user,password,balance from user_table where user=?&quot;; Main main=new Main(); User user=main.getInstance(conn, User.class,sql,&quot;CC&quot;); System.out.println(user); &#125; public static void testTranscationUpdate() throws Exception &#123; Connection conn= JDBCUtils.getConnection(); //取消自动提交 conn.setAutoCommit(false); String sql=&quot;update user_table set balance=? where user=?&quot;; update(conn,sql,5000,&quot;CC&quot;); &#125; //考虑上事务的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz, String sql, Object... args) &#123; PreparedStatement ps = null; ResultSet rs = null; try &#123; // 2.预编译sql语句，得到PreparedStatement对象 ps = conn.prepareStatement(sql); // 3.填充占位符 for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; // 4.执行executeQuery(),得到结果集：ResultSet rs = ps.executeQuery(); // 5.得到结果集的元数据：ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); // 6.1通过ResultSetMetaData得到columnCount(列数),columnLabel(列标签)；通过ResultSet得到列值 int columnCount = rsmd.getColumnCount(); if (rs.next()) &#123;//判断结果集的下一条是否有数据，如果有数据返回true，并指针下移 //如果返回false指针不会下移 T t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) &#123;// 遍历每一个列 // 获取列值 Object columnVal = rs.getObject(i + 1); // 获取列的别名:列的别名，使用类的属性名充当 String columnLabel = rsmd.getColumnLabel(i + 1); // 6.2使用反射，给对象的相应属性赋值 Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columnVal); &#125; return t; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 7.关闭资源 JDBCUtils.closeResource(null, ps, rs); &#125; return null; &#125; public static int update(Connection conn,String sql, Object... args) &#123;//conn作为参数是因为要让几次操作都用一个连接 PreparedStatement ps = null; try &#123; ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; return ps.executeUpdate();//返回的是影响的行数,增删改都可以是这个，同时也可以执行sql语句 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(null, ps); &#125; return 0; &#125;&#125; 小结这是关于增删改查询的几种方法，是在外面用conn 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132import java.lang.reflect.Field;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.ResultSetMetaData;import java.util.ArrayList;import java.util.List;public class BaseDao &#123;//增删改通用方法 public static int update(Connection conn, String sql, Object... args) &#123;//conn作为参数是因为要让几次操作都用一个连接 PreparedStatement ps = null; try &#123; ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; return ps.executeUpdate();//返回的是影响的行数,增删改都可以是这个，同时也可以执行sql语句 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(null, ps); &#125; return 0; &#125; //查询返回一条数据的方法 //version2.0 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz, String sql, Object... args) &#123; PreparedStatement ps = null; ResultSet rs = null; try &#123; // 2.预编译sql语句，得到PreparedStatement对象 ps = conn.prepareStatement(sql); // 3.填充占位符 for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; // 4.执行executeQuery(),得到结果集：ResultSet rs = ps.executeQuery(); // 5.得到结果集的元数据：ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); // 6.1通过ResultSetMetaData得到columnCount(列数),columnLabel(列标签)；通过ResultSet得到列值 int columnCount = rsmd.getColumnCount(); if (rs.next()) &#123;//判断结果集的下一条是否有数据，如果有数据返回true，并指针下移 //如果返回false指针不会下移 T t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) &#123;// 遍历每一个列 // 获取列值 Object columnVal = rs.getObject(i + 1); // 获取列的别名:列的别名，使用类的属性名充当 String columnLabel = rsmd.getColumnLabel(i + 1); // 6.2使用反射，给对象的相应属性赋值 Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columnVal); &#125; return t; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 7.关闭资源 JDBCUtils.closeResource(null, ps, rs); &#125; return null; &#125; //查询返回多条数据的方法 //version2.0 public &lt;T&gt; List&lt;T&gt; getForList(Connection conn,Class&lt;T&gt; clazz, String sql, Object...args)&#123; PreparedStatement ps=null; ResultSet rs=null; try &#123; conn = JDBCUtils.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; rs = ps.executeQuery(); //获取结果集的元数据 ResultSetMetaData rsmd = rs.getMetaData(); //得到结果集的列数 int columnCount = rsmd.getColumnCount(); //创建集合 ArrayList&lt;T&gt; list = new ArrayList&lt;T&gt;(); while (rs.next()) &#123;//判断结果集是否还有下一行 T t = clazz.newInstance(); //处理结果集一行数据中的每一个列 for (int i = 0; i &lt; columnCount; i++) &#123; Object value = rs.getObject(i + 1); //获取每个列的列名 String columnName = rsmd.getColumnName(i + 1); //给t对象指定的columnName属性，赋值为value，通过反射 Field field = clazz.getDeclaredField(columnName); field.setAccessible(true);//让这个属性可以被访问 field.set(t, value); &#125; list.add(t); &#125; return list; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; JDBCUtils.closeResource(null,ps,rs); &#125; return null; &#125;&#125; DAO类BaseDAO这是一个封装的所有的查询和增删改的方法的类用作抽象类，提供方法 封装了针对数据表的通用操作，具体表具体实现 BaseDao.class 封装起来，用来给具体的数据表处理类来做父类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153import java.lang.reflect.Field;import java.sql.*;import java.util.ArrayList;import java.util.List;public abstract class BaseDao &#123; public static void main(String[] args) throws Exception &#123; &#125; public static int update(Connection conn, String sql, Object... args) &#123;//conn作为参数是因为要让几次操作都用一个连接 PreparedStatement ps = null; try &#123; ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; return ps.executeUpdate();//返回的是影响的行数,增删改都可以是这个，同时也可以执行sql语句 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(null, ps); &#125; return 0; &#125; //version2.0 public &lt;T&gt; T getInstance(Connection conn, Class&lt;T&gt; clazz, String sql, Object... args) &#123; PreparedStatement ps = null; ResultSet rs = null; try &#123; // 2.预编译sql语句，得到PreparedStatement对象 ps = conn.prepareStatement(sql); // 3.填充占位符 for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; // 4.执行executeQuery(),得到结果集：ResultSet rs = ps.executeQuery(); // 5.得到结果集的元数据：ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); // 6.1通过ResultSetMetaData得到columnCount(列数),columnLabel(列标签)；通过ResultSet得到列值 int columnCount = rsmd.getColumnCount(); if (rs.next()) &#123;//判断结果集的下一条是否有数据，如果有数据返回true，并指针下移 //如果返回false指针不会下移 T t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) &#123;// 遍历每一个列 // 获取列值 Object columnVal = rs.getObject(i + 1); // 获取列的别名:列的别名，使用类的属性名充当 String columnLabel = rsmd.getColumnLabel(i + 1); // 6.2使用反射，给对象的相应属性赋值 Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columnVal); &#125; return t; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 7.关闭资源 JDBCUtils.closeResource(null, ps, rs); &#125; return null; &#125; //version2.0 public &lt;T&gt; List&lt;T&gt; getForList(Connection conn, Class&lt;T&gt; clazz, String sql, Object... args) &#123; PreparedStatement ps = null; ResultSet rs = null; try &#123; conn = JDBCUtils.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; rs = ps.executeQuery(); //获取结果集的元数据 ResultSetMetaData rsmd = rs.getMetaData(); //得到结果集的列数 int columnCount = rsmd.getColumnCount(); //创建集合 ArrayList&lt;T&gt; list = new ArrayList&lt;T&gt;(); while (rs.next()) &#123;//判断结果集是否还有下一行 T t = clazz.newInstance(); //处理结果集一行数据中的每一个列 for (int i = 0; i &lt; columnCount; i++) &#123; Object value = rs.getObject(i + 1); //获取每个列的列名 String columnName = rsmd.getColumnName(i + 1); //给t对象指定的columnName属性，赋值为value，通过反射 Field field = clazz.getDeclaredField(columnName); field.setAccessible(true);//让这个属性可以被访问 field.set(t, value); &#125; list.add(t); &#125; return list; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.closeResource(null, ps, rs); &#125; return null; &#125; //用于查询一些特殊值的通用方法，就只有一行一列的时候一般用这个 public &lt;E&gt; E getValue(Connection conn, String sql, Object... args) &#123; PreparedStatement ps = null; ResultSet rs = null; try &#123; ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; rs = ps.executeQuery(); if (rs.next()) &#123; return (E) rs.getObject(1); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally&#123; JDBCUtils.closeResource(null, ps, rs); &#125;return null; &#125; CustomerDAO针对Customer接口来设计一个API 具体的类实现的接口 123456789101112131415161718192021222324252627import java.sql.Connection;import java.util.List;import java.sql.Date;//此接口用于规范针对于customers表的常用操作public interface CustomerDAO &#123; //将cust对象添加到数据库中 void insert(Connection conn, Customer cust); //针对指定的id，删除表中的一条记录 void deleteById(Connection conn,int id); //针对内存中的cust对象，去修改数据表中的指定的记录 void update(Connection conn,Customer cust); //针对指定的id查询得到对应的Customer对象 void getCustomerById(Connection conn,int id); //查询表中的所有记录构成的集合 List&lt;Customer&gt; getAll(Connection conn); //返回数据表中数据的条目数 Long getCount(Connection conn); //返回数据表中最大的生日 Date getMaxBirth(Connection conn);&#125; CustomerDAOImpl 针对一个表具体的类，继承了上面的类，实现了上面的接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.sql.Connection;import java.sql.Date;import java.util.List;public class CustomerDAOImpl extends BaseDao implements CustomerDAO&#123; @Override public void insert(Connection conn, Customer cust) &#123; String sql=&quot;insert into customers(name,email,birth)values(?,?,?)&quot;; update(conn,sql,cust.getName(),cust.getEmail(),cust.getBirth()); &#125; @Override public void deleteById(Connection conn, int id) &#123; String sql=&quot;delete from customers where id=?&quot;;update(conn,sql,id); &#125; @Override public void update(Connection conn, Customer cust) &#123; String sql=&quot;update customers set name=?,email=?,birth=? where id=?&quot;; update(conn,sql,cust.getName(),cust.getEmail(),cust.getBirth(),cust.getBirth()); &#125; @Override public Customer getCustomerById(Connection conn, int id) &#123; String sql=&quot;select id,name,email,birth from customers where id=?&quot;; Customer customer=getInstance(conn,Customer.class,sql,id); return customer; &#125; @Override public List&lt;Customer&gt; getAll(Connection conn) &#123; String sql=&quot;select id,name,email,birth from customers&quot;; List&lt;Customer&gt; list=getForList(conn,Customer.class,sql); return list; &#125; @Override public Long getCount(Connection conn) &#123; String sql=&quot;select count(*) from customers&quot;; return getValue(conn,sql); &#125; @Override public Date getMaxBirth(Connection conn) &#123; String sql=&quot;select max(birth) from customers&quot;; return getValue(conn,sql); &#125;&#125; 升级后的DAO在IDEA优化文件夹中写好了,报错 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package 优化;import 基础.BaseDao;import 基础.Customer;import 基础.CustomerDAO;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.sql.Connection;import java.sql.Date;import java.util.List;public class CustomerDAOImpl extends BaseDao&lt;Customer&gt; implements CustomerDAO &#123; @Override public void insert(Connection conn, Customer cust) &#123; String sql=&quot;insert into customers(name,email,birth)values(?,?,?)&quot;; update(conn,sql,cust.getName(),cust.getEmail(),cust.getBirth()); &#125; @Override public void deleteById(Connection conn, int id) &#123; String sql=&quot;delete from customers where id=?&quot;;update(conn,sql,id); &#125; @Override public void update(Connection conn, Customer cust) &#123; String sql=&quot;update customers set name=?,email=?,birth=? where id=?&quot;; update(conn,sql,cust.getName(),cust.getEmail(),cust.getBirth(),cust.getBirth()); &#125; @Override public Customer getCustomerById(Connection conn, int id) &#123; String sql=&quot;select id,name,email,birth from customers where id=?&quot;; Customer customer= getInstance(conn,sql,id); return customer; &#125; @Override public List&lt;Customer&gt; getAll(Connection conn) &#123; String sql=&quot;select id,name,email,birth from customers&quot;; List&lt;Customer&gt; list= getForList(conn,sql); return list; &#125; @Override public Long getCount(Connection conn) &#123; String sql=&quot;select count(*) from customers&quot;; return getValue(conn,sql); &#125; @Override public Date getMaxBirth(Connection conn) &#123; String sql=&quot;select max(birth) from customers&quot;; return getValue(conn,sql); &#125;&#125; DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO 作用：为了实现功能的模块化，更有利于代码的维护和升级。 下面是尚硅谷JavaWeb阶段书城项目中DAO使用的体现： 层次结构： 【BaseDAO.java】下面是用的那个DBUtils来操作的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.atguigu.bookstore.dao;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.sql.Connection;import java.sql.SQLException;import java.util.List;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.apache.commons.dbutils.handlers.ScalarHandler;/** * 定义一个用来被继承的对数据库进行基本操作的Dao * * @author HanYanBing * * @param &lt;T&gt; */public abstract class BaseDao&lt;T&gt; &#123; private QueryRunner queryRunner = new QueryRunner(); // 定义一个变量来接收泛型的类型 private Class&lt;T&gt; type; // 获取T的Class对象，获取泛型的类型，泛型是在被子类继承时才确定 public BaseDao() &#123; // 获取子类的类型 Class clazz = this.getClass(); // 获取父类的类型 // getGenericSuperclass()用来获取当前类的父类的类型 // ParameterizedType表示的是带泛型的类型 ParameterizedType parameterizedType = (ParameterizedType) clazz.getGenericSuperclass(); // 获取具体的泛型类型 getActualTypeArguments获取具体的泛型的类型 // 这个方法会返回一个Type的数组 Type[] types = parameterizedType.getActualTypeArguments(); // 获取具体的泛型的类型· this.type = (Class&lt;T&gt;) types[0]; &#125; /** * 通用的增删改操作 * * @param sql * @param params * @return */ public int update(Connection conn,String sql, Object... params) &#123; int count = 0; try &#123; count = queryRunner.update(conn, sql, params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return count; &#125; /** * 获取一个对象 * * @param sql * @param params * @return */ public T getBean(Connection conn,String sql, Object... params) &#123; T t = null; try &#123; t = queryRunner.query(conn, sql, new BeanHandler&lt;T&gt;(type), params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return t; &#125; /** * 获取所有对象 * * @param sql * @param params * @return */ public List&lt;T&gt; getBeanList(Connection conn,String sql, Object... params) &#123; List&lt;T&gt; list = null; try &#123; list = queryRunner.query(conn, sql, new BeanListHandler&lt;T&gt;(type), params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return list; &#125; /** * 获取一个但一值得方法，专门用来执行像 select count(*)...这样的sql语句 * * @param sql * @param params * @return */ public Object getValue(Connection conn,String sql, Object... params) &#123; Object count = null; try &#123; // 调用queryRunner的query方法获取一个单一的值 count = queryRunner.query(conn, sql, new ScalarHandler&lt;&gt;(), params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return count; &#125;&#125; 【BookDAO.java】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.atguigu.bookstore.dao;import java.sql.Connection;import java.util.List;import com.atguigu.bookstore.beans.Book;import com.atguigu.bookstore.beans.Page;public interface BookDao &#123; /** * 从数据库中查询出所有的记录 * * @return */ List&lt;Book&gt; getBooks(Connection conn); /** * 向数据库中插入一条记录 * * @param book */ void saveBook(Connection conn,Book book); /** * 从数据库中根据图书的id删除一条记录 * * @param bookId */ void deleteBookById(Connection conn,String bookId); /** * 根据图书的id从数据库中查询出一条记录 * * @param bookId * @return */ Book getBookById(Connection conn,String bookId); /** * 根据图书的id从数据库中更新一条记录 * * @param book */ void updateBook(Connection conn,Book book); /** * 获取带分页的图书信息 * * @param page：是只包含了用户输入的pageNo属性的page对象 * @return 返回的Page对象是包含了所有属性的Page对象 */ Page&lt;Book&gt; getPageBooks(Connection conn,Page&lt;Book&gt; page); /** * 获取带分页和价格范围的图书信息 * * @param page：是只包含了用户输入的pageNo属性的page对象 * @return 返回的Page对象是包含了所有属性的Page对象 */ Page&lt;Book&gt; getPageBooksByPrice(Connection conn,Page&lt;Book&gt; page, double minPrice, double maxPrice);&#125; 【UserDAO.java】12345678910111213141516171819202122232425262728293031package com.atguigu.bookstore.dao;import java.sql.Connection;import com.atguigu.bookstore.beans.User;public interface UserDao &#123; /** * 根据User对象中的用户名和密码从数据库中获取一条记录 * * @param user * @return User 数据库中有记录 null 数据库中无此记录 */ User getUser(Connection conn,User user); /** * 根据User对象中的用户名从数据库中获取一条记录 * * @param user * @return true 数据库中有记录 false 数据库中无此记录 */ boolean checkUsername(Connection conn,User user); /** * 向数据库中插入User对象 * * @param user */ void saveUser(Connection conn,User user);&#125; 【BookDaoImpl.java】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.atguigu.bookstore.dao.impl;import java.sql.Connection;import java.util.List;import com.atguigu.bookstore.beans.Book;import com.atguigu.bookstore.beans.Page;import com.atguigu.bookstore.dao.BaseDao;import com.atguigu.bookstore.dao.BookDao;public class BookDaoImpl extends BaseDao&lt;Book&gt; implements BookDao &#123; @Override public List&lt;Book&gt; getBooks(Connection conn) &#123; // 调用BaseDao中得到一个List的方法 List&lt;Book&gt; beanList = null; // 写sql语句 String sql = &quot;select id,title,author,price,sales,stock,img_path imgPath from books&quot;; beanList = getBeanList(conn,sql); return beanList; &#125; @Override public void saveBook(Connection conn,Book book) &#123; // 写sql语句 String sql = &quot;insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)&quot;; // 调用BaseDao中通用的增删改的方法 update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(),book.getImgPath()); &#125; @Override public void deleteBookById(Connection conn,String bookId) &#123; // 写sql语句 String sql = &quot;DELETE FROM books WHERE id = ?&quot;; // 调用BaseDao中通用增删改的方法 update(conn,sql, bookId); &#125; @Override public Book getBookById(Connection conn,String bookId) &#123; // 调用BaseDao中获取一个对象的方法 Book book = null; // 写sql语句 String sql = &quot;select id,title,author,price,sales,stock,img_path imgPath from books where id = ?&quot;; book = getBean(conn,sql, bookId); return book; &#125; @Override public void updateBook(Connection conn,Book book) &#123; // 写sql语句 String sql = &quot;update books set title = ? , author = ? , price = ? , sales = ? , stock = ? where id = ?&quot;; // 调用BaseDao中通用的增删改的方法 update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getId()); &#125; @Override public Page&lt;Book&gt; getPageBooks(Connection conn,Page&lt;Book&gt; page) &#123; // 获取数据库中图书的总记录数 String sql = &quot;select count(*) from books&quot;; // 调用BaseDao中获取一个单一值的方法 long totalRecord = (long) getValue(conn,sql); // 将总记录数设置都page对象中 page.setTotalRecord((int) totalRecord); // 获取当前页中的记录存放的List String sql2 = &quot;select id,title,author,price,sales,stock,img_path imgPath from books limit ?,?&quot;; // 调用BaseDao中获取一个集合的方法 List&lt;Book&gt; beanList = getBeanList(conn,sql2, (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE); // 将这个List设置到page对象中 page.setList(beanList); return page; &#125; @Override public Page&lt;Book&gt; getPageBooksByPrice(Connection conn,Page&lt;Book&gt; page, double minPrice, double maxPrice) &#123; // 获取数据库中图书的总记录数 String sql = &quot;select count(*) from books where price between ? and ?&quot;; // 调用BaseDao中获取一个单一值的方法 long totalRecord = (long) getValue(conn,sql,minPrice,maxPrice); // 将总记录数设置都page对象中 page.setTotalRecord((int) totalRecord); // 获取当前页中的记录存放的List String sql2 = &quot;select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? limit ?,?&quot;; // 调用BaseDao中获取一个集合的方法 List&lt;Book&gt; beanList = getBeanList(conn,sql2, minPrice , maxPrice , (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE); // 将这个List设置到page对象中 page.setList(beanList); return page; &#125;&#125; 【UserDaoImpl.java】123456789101112131415161718192021222324252627282930313233343536373839package com.atguigu.bookstore.dao.impl;import java.sql.Connection;import com.atguigu.bookstore.beans.User;import com.atguigu.bookstore.dao.BaseDao;import com.atguigu.bookstore.dao.UserDao;public class UserDaoImpl extends BaseDao&lt;User&gt; implements UserDao &#123; @Override public User getUser(Connection conn,User user) &#123; // 调用BaseDao中获取一个对象的方法 User bean = null; // 写sql语句 String sql = &quot;select id,username,password,email from users where username = ? and password = ?&quot;; bean = getBean(conn,sql, user.getUsername(), user.getPassword()); return bean; &#125; @Override public boolean checkUsername(Connection conn,User user) &#123; // 调用BaseDao中获取一个对象的方法 User bean = null; // 写sql语句 String sql = &quot;select id,username,password,email from users where username = ?&quot;; bean = getBean(conn,sql, user.getUsername()); return bean != null; &#125; @Override public void saveUser(Connection conn,User user) &#123; //写sql语句 String sql = &quot;insert into users(username,password,email) values(?,?,?)&quot;; //调用BaseDao中通用的增删改的方法 update(conn,sql, user.getUsername(),user.getPassword(),user.getEmail()); &#125;&#125; 【Book.java】1234567891011121314151617package com.atguigu.bookstore.beans;/** * 图书类 * @author songhongkang * */public class Book &#123; private Integer id; private String title; // 书名 private String author; // 作者 private double price; // 价格 private Integer sales; // 销量 private Integer stock; // 库存 private String imgPath = &quot;static/img/default.jpg&quot;; // 封面图片的路径 //构造器，get()，set()，toString()方法略&#125; 【Page.java】12345678910111213141516package com.atguigu.bookstore.beans;import java.util.List;/** * 页码类 * @author songhongkang * */public class Page&lt;T&gt; &#123; private List&lt;T&gt; list; // 每页查到的记录存放的集合 public static final int PAGE_SIZE = 4; // 每页显示的记录数 private int pageNo; // 当前页// private int totalPageNo; // 总页数，通过计算得到 private int totalRecord; // 总记录数，通过查询数据库得到 【User.java】12345678910111213package com.atguigu.bookstore.beans;/** * 用户类 * @author songhongkang * */public class User &#123; private Integer id; private String username; private String password; private String email; 第8章：数据库连接池8.1 JDBC数据库连接池的必要性 在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤： 在主程序（如servlet、beans）中建立数据库连接 进行sql操作 断开数据库连接 这种模式开发，存在的问题: 普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。数据库的连接资源并没有得到很好的重复利用。若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。 对于每一次数据库连接，使用完后都得断开。否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？） 这种开发不能控制被创建的连接对象数，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 8.2 数据库连接池技术 为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。 数据库连接池的基本思想：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。 数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。 工作原理： 数据库连接池技术的优点 1. 资源重用 由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。 2. 更快的系统反应速度 数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间 3. 新的资源分配手段 对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源 4. 统一的连接管理，避免数据库连接泄漏 在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露 8.3 多种开源的数据库连接池 JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现： DBCP 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。速度相对c3p0较快，但因自身存在BUG，Hibernate3已不再提供支持。 C3P0 是一个开源组织提供的一个数据库连接池，速度相对较慢，稳定性还可以。hibernate官方推荐使用 Proxool 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点 BoneCP 是一个开源组织提供的数据库连接池，速度快 Druid 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快 DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池 DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。 特别注意： 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。 8.3.1 C3P0数据库连接池 获取连接方式一 12345678910111213//使用C3P0数据库连接池的方式，获取数据库的连接：不推荐public static Connection getConnection1() throws Exception&#123; ComboPooledDataSource cpds = new ComboPooledDataSource(); cpds.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); cpds.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;); cpds.setUser(&quot;root&quot;); cpds.setPassword(&quot;abc123&quot;); // cpds.setMaxPoolSize(100); Connection conn = cpds.getConnection(); return conn;&#125; 获取连接方式二 123456//使用C3P0数据库连接池的配置文件方式，获取数据库的连接：推荐private static DataSource cpds = new ComboPooledDataSource(&quot;helloc3p0&quot;);public static Connection getConnection2() throws SQLException&#123; Connection conn = cpds.getConnection(); return conn;&#125; 其中，src下的配置文件为：【c3p0-config.xml】 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;c3p0-config&gt; &lt;named-config name=&quot;helloc3p0&quot;&gt; &lt;!-- 获取连接的4个基本信息 --&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;abc123&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql:///test&lt;/property&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!-- 涉及到数据库连接池的管理的相关属性的设置 --&gt; &lt;!-- 若数据库中连接数不足时, 一次向数据库服务器申请多少个连接 --&gt; &lt;property name=&quot;acquireIncrement&quot;&gt;5&lt;/property&gt; &lt;!-- 初始化数据库连接池时连接的数量 --&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;5&lt;/property&gt; &lt;!-- 数据库连接池中的最小的数据库连接数 --&gt; &lt;property name=&quot;minPoolSize&quot;&gt;5&lt;/property&gt; &lt;!-- 数据库连接池中的最大的数据库连接数 --&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;10&lt;/property&gt; &lt;!-- C3P0 数据库连接池可以维护的 Statement 的个数 --&gt; &lt;property name=&quot;maxStatements&quot;&gt;20&lt;/property&gt; &lt;!-- 每个连接同时可以使用的 Statement 对象的个数 --&gt; &lt;property name=&quot;maxStatementsPerConnection&quot;&gt;5&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; 8.3.2 DBCP数据库连接池 DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件： Commons-dbcp.jar：连接池的实现 Commons-pool.jar：连接池实现的依赖库 Tomcat 的连接池正是采用该连接池来实现的。该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。 配置属性说明 属性 默认值 说明 initialSize 0 连接池启动时创建的初始化连接数量 maxActive 8 连接池中可同时连接的最大的连接数 maxIdle 8 连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制 minIdle 0 连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。 maxWait 无限制 最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待 poolPreparedStatements false 开启池的Statement是否prepared maxOpenPreparedStatements 无限制 开启池的prepared 后的同时最大连接数 minEvictableIdleTimeMillis 连接池中连接，在时间段内一直空闲， 被逐出连接池的时间 removeAbandonedTimeout 300 超过时间限制，回收没有用(废弃)的连接 removeAbandoned false 超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收 获取连接方式一： 1234567891011121314public static Connection getConnection3() throws Exception &#123; BasicDataSource source = new BasicDataSource(); source.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); source.setUrl(&quot;jdbc:mysql:///test&quot;); source.setUsername(&quot;root&quot;); source.setPassword(&quot;abc123&quot;); // source.setInitialSize(10); Connection conn = source.getConnection(); return conn;&#125; 获取连接方式二： 12345678910111213141516171819202122//使用dbcp数据库连接池的配置文件方式，获取数据库的连接：推荐private static DataSource source = null;static&#123; try &#123; Properties pros = new Properties(); InputStream is = DBCPTest.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;); pros.load(is); //根据提供的BasicDataSourceFactory创建对应的DataSource对象 source = BasicDataSourceFactory.createDataSource(pros); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;public static Connection getConnection4() throws Exception &#123; Connection conn = source.getConnection(); return conn;&#125; 其中，src下的配置文件为：【dbcp.properties】 1234567driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&amp;useServerPrepStmts=falseusername=rootpassword=abc123initialSize=10#... 8.3.3 Druid（德鲁伊）数据库连接池（报错了）Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，可以说是目前最好的连接池之一。 这个是放在JDBCUtils文件里的，这一块的静态代码块有问题 12345678910111213141516private static DataSource source1=null;static&#123; try&#123; Properties pros=new Properties(); InputStream is= new FileInputStream(&quot;D:\\\\IDEAjava工程\\\\JDBC\\\\src\\\\基础\\\\druid.properties&quot;); pros.load(is); source1= DruidDataSourceFactory.createDataSource(pros); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125;&#125;public static Connection getConnection3()throws Exception&#123; Connection conn=source1.getConnection(); return conn;&#125; 测试 123456789101112131415public class DruidTest &#123; public static void main(String[] args) &#123; CustomerDAOImpl dao=new CustomerDAOImpl(); Connection conn=null; try&#123; conn=JDBCUtils.getConnection3(); Customer cust=dao.getCustomerById(conn,3); System.out.println(cust); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 其中，src下的配置文件为：【druid.properties】 123456789url=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=trueusername=rootpassword=rootdriverClassName=com.mysql.jdbc.DriverinitialSize=10maxActive=20maxWait=1000filters=wall 详细配置参数： 配置 缺省 说明 name 配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是：”DataSource-” + System.identityHashCode(this) url 连接数据库的url，不同数据库不一样。例如：mysql : jdbc:mysql:&#x2F;&#x2F;10.20.153.104:3306&#x2F;druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto username 连接数据库的用户名 password 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter driverClassName 根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下) initialSize 0 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 maxActive 8 最大连接池数量 maxIdle 8 已经不再使用，配置了也没效果 minIdle 最小连接池数量 maxWait 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 poolPreparedStatements false 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 maxOpenPreparedStatements -1 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 validationQuery 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 testOnBorrow true 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 testOnReturn false 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testWhileIdle false 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 timeBetweenEvictionRunsMillis 有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明 numTestsPerEvictionRun 不再使用，一个DruidDataSource只支持一个EvictionRun minEvictableIdleTimeMillis connectionInitSqls 物理连接初始化的时候执行的sql exceptionSorter 根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接 filters 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall proxyFilters 类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系 第9章：Apache-DBUtils实现CRUD操作9.1 Apache-DBUtils简介 commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。 API介绍： org.apache.commons.dbutils.QueryRunner org.apache.commons.dbutils.ResultSetHandler 工具类：org.apache.commons.dbutils.DbUtils API包说明： 9.2 主要API的使用9.2.1 DbUtils DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下： public static void close(…) throws java.sql.SQLException： DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。 public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。 public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接 public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断 public static void rollbackAndClose(Connection conn)throws SQLException rollbackAndCloseQuietly(Connection) public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。 9.2.2 QueryRunner类 该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。 QueryRunner类提供了两个构造器： 默认的构造器 需要一个 javax.sql.DataSource 来作参数的构造器 QueryRunner类的主要方法： 更新 public int update(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。 …… 插入 public T insert(Connection conn,String sql,ResultSetHandler rsh, Object… params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys. 返回值: An object generated by the handler.即自动生成的键值 …. 批处理 public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句 public T insertBatch(Connection conn,String sql,ResultSetHandler rsh,Object[][] params)throws SQLException：只支持INSERT语句 ….. 查询 public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。 …… update方法测试 update方法能执行delete update insert语句 123456789101112131415161718192021222324252627282930313233//添加数据import org.apache.commons.dbutils.QueryRunner;import java.sql.Connection;import java.sql.SQLException;public class DbUtilsTest &#123; public static void main(String[] args) &#123;DbUtilsTest list=new DbUtilsTest();list.testInsert(); &#125; public void testInsert() &#123; QueryRunner runner = new QueryRunner(); Connection conn= null; try &#123; conn = JDBCUtils.getConnection(); String sql = &quot;insert into customers(name,email,birth)values(?,?,?)&quot;; int insertCount = runner.update(conn, sql, &quot;易烊千玺&quot;, &quot;3241525035@qq.com&quot;, &quot;1997-09-08&quot;); System.out.println(&quot;添加了&quot; + insertCount + &quot;记录&quot;); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; finally&#123; JDBCUtils.closeResource(conn,null); &#125; &#125;&#125; 12345678910111213// 测试删除@Testpublic void testDelete() throws Exception &#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection(); String sql = &quot;delete from customers where id &lt; ?&quot;; int count = runner.update(conn, sql,3); System.out.println(&quot;删除了&quot; + count + &quot;条记录&quot;); JDBCUtils.closeResource(conn, null);&#125; 9.2.3 ResultSetHandler接口及实现类 该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。 ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。 接口的主要实现类： ArrayHandler：把结果集中的第一行数据转成对象数组。 ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。 BeanHandler：将结果集中的第一行数据封装到一个对应的JavaBean实例中。 BeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。 ColumnListHandler：将结果集中某一列的数据存放到List中。 KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。 MapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。 MapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List ScalarHandler：查询单个值对象 测试 BeanHandler是ResultSetHandler接口的实现类 12345678910111213141516171819/* * 测试查询:查询一条记录 * * 使用ResultSetHandler的实现类：BeanHandler */@Testpublic void testQueryInstance() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection(); String sql = &quot;select id,name,email,birth from customers where id = ?&quot;; // BeanHandler&lt;Customer&gt; handler = new BeanHandler&lt;&gt;(Customer.class); Customer customer = runner.query(conn, sql, handler, 23); System.out.println(customer); JDBCUtils.closeResource(conn, null);&#125; 12345678910111213141516171819/* * 测试查询:查询多条记录构成的集合 * * 使用ResultSetHandler的实现类：BeanListHandler，用于封装表中的多条记录构成的集合 */@Testpublic void testQueryList() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection(); String sql = &quot;select id,name,email,birth from customers where id &lt; ?&quot;; // BeanListHandler&lt;Customer&gt; handler = new BeanListHandler&lt;&gt;(Customer.class); List&lt;Customer&gt; list = runner.query(conn, sql, handler, 23); list.forEach(System.out::println); JDBCUtils.closeResource(conn, null);&#125; 12345678910111213141516171819202122232425262728293031323334353637/* * 自定义ResultSetHandler的实现类 */@Testpublic void testQueryInstance1() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection(); String sql = &quot;select id,name,email,birth from customers where id = ?&quot;; ResultSetHandler&lt;Customer&gt; handler = new ResultSetHandler&lt;Customer&gt;() &#123;//这个地方必须要写后面那个Customer @Override public Customer handle(ResultSet rs) throws SQLException &#123; System.out.println(&quot;handle&quot;);// return new Customer(1,&quot;Tom&quot;,&quot;tom@126.com&quot;,new Date(123323432L)); if(rs.next())&#123; int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); String email = rs.getString(&quot;email&quot;); Date birth = rs.getDate(&quot;birth&quot;); return new Customer(id, name, email, birth); &#125; return null; &#125; &#125;; Customer customer = runner.query(conn, sql, handler, 23); System.out.println(customer); JDBCUtils.closeResource(conn, null);&#125; 1234567891011121314151617181920212223242526/* * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据， * 使用ScalarHandler 这个就是用来返回一些特殊的熟知的和那个BASEDAO中的getValue方法有些类似 * */@Testpublic void testQueryValue() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection(); //测试一：// String sql = &quot;select count(*) from customers where id &lt; ?&quot;;// ScalarHandler handler = new ScalarHandler();// long count = (long) runner.query(conn, sql, handler, 20);// System.out.println(count); //测试二： String sql = &quot;select max(birth) from customers&quot;; ScalarHandler handler = new ScalarHandler(); Date birth = (Date) runner.query(conn, sql, handler); System.out.println(birth); JDBCUtils.closeResource(conn, null);&#125; 12345678910111213用MapHandler这个实现类，返回的是一个map形式的对象将字段及相应字段的值作为map的key和valuepublic void testQuery() throws SQLException &#123; QueryRunner runner = new QueryRunner(); Connection conn=JDBCUtils.getConnection(); String sql=&quot;select id,name,email,birth from customers where id&lt;?&quot;; MapHandler handler=new MapHandler(); Map&lt;String,Object&gt; map=runner.query(conn,sql,handler,23); System.out.println(map);&#125;// &#123;name=汪峰, birth=2010-02-02, id=1, email=wf@126.com&#125;结果 12345678910111213141516打印多个Map，对应表中的多条记录public void testQueryList() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection(); String sql = &quot;select id,name,email,birth from customers where id &lt; ?&quot;; // MapListHandler handler = new MapListHandler(); List&lt;Map&lt;String,Object&gt;&gt; list = runner.query(conn, sql, handler, 23); list.forEach(System.out::println); JDBCUtils.closeResource(conn, null);&#125; 关闭连接，可以放在JDBCUtils类中当作关闭方法 123456//用DBUtils关闭资源public static void closeResource1(Connection conn,Statement ps,ResultSet rs)&#123; DbUtils.closeQuietly(conn); DbUtils.closeQuietly(ps); DbUtils.closeQuietly(rs);&#125; 用 自己用DBUtils实现的BaseDao1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.atguigu.dao.impl;import com.atguigu.utils.JdbcUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.apache.commons.dbutils.handlers.ScalarHandler;import java.sql.Connection;import java.sql.SQLException;import java.util.List;public class BaseDao &#123; //使用DbUtils操作数据库private QueryRunner queryRunner=new QueryRunner();/*update()方法用来执行：insert update delete语句如果返回-1说明执行失败， 否则返回其他表示影响的行数 */ public int update(String sql,Object...args)&#123; Connection conn= JdbcUtils.getConnection(); try &#123; return queryRunner.update(conn, sql, args); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; return -1; &#125; /* 查询返回一个javaBean的sql语句 type为返回对象类型，args是sql对应的参数值，sql是执行的sql语句 &lt;T&gt;返回的类型和泛型 */ public &lt;T&gt; T queryForOne(Class&lt;T&gt; type,String sql,Object...args) &#123; Connection con=JdbcUtils.getConnection(); try &#123; return queryRunner.query(con,sql,new BeanHandler&lt;T&gt;(type),args); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; finally&#123; JdbcUtils.close(con); &#125; return null; &#125; public &lt;T&gt; List&lt;T&gt; queryForList(Class&lt;T&gt; type,String sql,Object...args)&#123; Connection con=JdbcUtils.getConnection(); try &#123; return queryRunner.query(con,sql,new BeanListHandler&lt;T&gt;(type),args); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; return null; &#125; public Object queryForSingleValue(String sql,Object...args)&#123; Connection conn=JdbcUtils.getConnection(); try &#123; return queryRunner.query(conn, sql,new ScalarHandler(), args); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; return null; &#125;&#125; JDBC总结12345678910111213141516171819202122232425262728293031323334353637总结@Testpublic void testUpdateWithTx() &#123; Connection conn = null; try &#123; //1.获取连接的操作（ //① 手写的连接：JDBCUtils.getConnection(); //② 使用数据库连接池：C3P0;DBCP;Druid //2.对数据表进行一系列CRUD操作 //① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \\ version 2.0)//version2.0的增删改public void update(Connection conn,String sql,Object ... args)&#123;&#125;//version2.0的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql,Object ... args)&#123;&#125; //② 使用dbutils提供的jar包中提供的QueryRunner类 //提交数据 conn.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; //回滚数据 conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125;finally&#123; //3.关闭连接等操作 //① JDBCUtils.closeResource(); //② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作 &#125;&#125;","categories":[],"tags":[]},{"title":"javaweb","slug":"javaweb","date":"2022-09-29T11:22:42.000Z","updated":"2022-09-29T11:26:47.974Z","comments":true,"path":"2022/09/29/javaweb/","link":"","permalink":"http://example.com/2022/09/29/javaweb/","excerpt":"","text":"Javaweb HTML.CSS,Javascript前端三刺客HTML是超文本标记语言，是一个网站页面的主要内容和主体框架（主要是实现内容） CSS是层叠样式表，主要用来控制调整网页的样式，它与网页的结构和内容没有关系，仅仅是通过不同语义的标签来调整网页内容的不同表现样式。(主要是实现表现，一种呈现的效果) JavaScript是一种完整的网页脚本语言，有自己独立的语法，可以完成复杂的程序逻辑，而HTML和CSS仅仅是标记语言，不具备编程语言的程序逻辑。(行为，指的是页面中元素与输入设备交互的响应，一般使用javascript技术实现) B&#x2F;S软件结构： 客户端：浏览器 服务器端：web服务器 HTMLhtml书写规范1234567891011&lt;!DOCTYPE html&gt;&lt;!--约束，声明--&gt;&lt;html lang=&quot;zh_CN&quot;&gt;&lt;!--html标签表示html的开始 lang=&quot;zh_CN表示中文&quot;--&gt;&lt;!--html标签中一般分为两部分，head和body--&gt;&lt;head&gt; &lt;!--表示头部信息，一般包含三部分内容，title标签，css样式，js代码--&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;!--表示当前页面使用UTF-8字符集--&gt; &lt;title&gt;标题&lt;/title&gt;&lt;!--表示标题--&gt;&lt;/head&gt;&lt;body&gt;&lt;!--body标签是整个html页面显示的主体内容--&gt;hello&lt;/body&gt;&lt;/html&gt; html标签1.标签名大小写不敏感 2.标签名有自己的属性 基本属性：bgcolor&#x3D;“red” 可以修改简单的样式 12&lt;!--背景颜色属性--&gt;&lt;body bgcolor=&quot;green&quot;&gt;&lt;!--body标签是整个html页面显示的主体内容--&gt; 事件属性： onclick&#x3D;“alert(‘你好’);” 点击body主题内容触发 12&lt;!--onclick表示点击事件--&gt;&lt;body onclick=&quot;alert(1)&quot;&gt;&lt;!--body标签是整个html页面显示的主体内容--&gt; 3.分为单标签和双标签 &lt;标签名 &#x2F;&gt; 和&lt;标签名&gt; &lt;&#x2F;标签名&gt; 1&lt;br /&gt;换行 &lt;hr /&gt; 标签语法 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;0-标签语法.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- ①标签不能交叉嵌套 --&gt; 正确：&lt;div&gt;&lt;span&gt;早安，尚硅谷&lt;/span&gt;&lt;/div&gt; 错误：&lt;div&gt;&lt;span&gt;早安，尚硅谷&lt;/div&gt;&lt;/span&gt; &lt;hr /&gt; &lt;!-- ②标签必须正确关闭(闭合) --&gt; &lt;!-- i.有文本内容的标签： --&gt; 正确：&lt;div&gt;早安，尚硅谷&lt;/div&gt; 错误：&lt;div&gt;早安，尚硅谷 &lt;hr /&gt; &lt;!-- ii.没有文本内容的标签： --&gt; 正确：&lt;br /&gt;1 错误：&lt;br &gt;2 &lt;hr /&gt; &lt;!-- ③属性必须有值，属性值必须加引号 --&gt; 正确：&lt;font color=&quot;blue&quot;&gt;早安，尚硅谷&lt;/font&gt; 错误：&lt;font color=blue&gt;早安，尚硅谷&lt;/font&gt; 错误：&lt;font color&gt;早安，尚硅谷&lt;/font&gt; &lt;hr /&gt; &lt;!-- ④注释不能嵌套 --&gt; 正确：&lt;!-- 注释内容 --&gt; &lt;br/&gt; 错误：&lt;!-- 注释内容 &lt;!-- 注释内容 --&gt;--&gt; &lt;hr /&gt;&lt;/body&gt;&lt;/html&gt; font标签 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;1.font标签.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 字体标签 需求1：在网页上显示 我是字体标签 ，并修改字体为 宋体，颜色为红色。 font标签是字体标签,它可以用来修改文本的字体,颜色,大小(尺寸) color属性修改颜色 face属性修改字体 size属性修改文本大小 --&gt; &lt;font color=&quot;red&quot; face=&quot;宋体&quot; size=&quot;7&quot;&gt;我是字体标签&lt;/font&gt;&lt;/body&gt;&lt;/html&gt; 特殊字符 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;2.特殊字符.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 特殊字符 需求1：把 &lt;br&gt; 换行标签 变成文本 转换成字符显示在页面上 常用的特殊字符: &lt; ===&gt;&gt;&gt;&gt; &amp;lt; &gt; ===&gt;&gt;&gt;&gt; &amp;gt; 空格 ===&gt;&gt;&gt;&gt; &amp;nbsp;如果在html文件中出现多个空白字符，那么就只保留一个，必须用特殊字符才可以出现多个空格 --&gt; 我是&amp;lt;br&amp;gt;标签&lt;br/&gt; 国哥好&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;帅啊!&lt;/body&gt;&lt;/html&gt; 标题标签 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;3.标题标签.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 标题标签 需求1：演示标题1到 标题6的 h1 - h6 都是标题标签 h1 最大 h6 最小 align 属性是对齐属性 left 左对齐(默认) center 剧中 right 右对齐 --&gt; &lt;h1 align=&quot;left&quot;&gt;标题1&lt;/h1&gt; &lt;h2 align=&quot;center&quot;&gt;标题2&lt;/h2&gt; &lt;h3 align=&quot;right&quot;&gt;标题3&lt;/h3&gt; &lt;h4&gt;标题4&lt;/h4&gt; &lt;h5&gt;标题5&lt;/h5&gt; &lt;h6&gt;标题6&lt;/h6&gt; &lt;h7&gt;标题7&lt;/h7&gt;&lt;/body&gt;&lt;/html&gt; 超链接标签 网页中点击跳转的内容就是超链接 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;4.超链接.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- a标签是 超链接 href属性设置连接的地址 target属性设置哪个目标进行跳转 _self 表示当前页面(默认值) _blank 表示打开新页面来进行跳转 --&gt; &lt;a href=&quot;http://localhost:8080&quot;&gt;百度&lt;/a&gt;&lt;br/&gt; &lt;a href=&quot;http://localhost:8080&quot; target=&quot;_self&quot;&gt;百度_self&lt;/a&gt;&lt;br/&gt; &lt;a href=&quot;http://localhost:8080&quot; target=&quot;_blank&quot;&gt;百度_blank&lt;/a&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 列表标签 和浏览器有关的或多或少都会有一些兼容问题，所以换了个浏览器可能会不一样比如下面的type 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--需求1：使用无序，列表方式，把东北F4，赵四，刘能，小沈阳，宋小宝，展示出来 ul 是无序列表 type属性可以修改列表项前面的符号 li 是列表项 --&gt; &lt;!--无序列表--&gt; &lt;ul type=&quot;none&quot;&gt; &lt;li&gt;赵四&lt;/li&gt; &lt;li&gt;刘能&lt;/li&gt; &lt;li&gt;小沈阳&lt;/li&gt; &lt;li&gt;宋小宝&lt;/li&gt; &lt;/ul&gt; &lt;!--有序列表,前面会加上序号--&gt; &lt;ol type=&quot;none&quot;&gt; &lt;li&gt;赵四&lt;/li&gt; &lt;li&gt;刘能&lt;/li&gt; &lt;li&gt;小沈阳&lt;/li&gt; &lt;li&gt;宋小宝&lt;/li&gt; &lt;/ol&gt;&lt;/body&gt;&lt;/html&gt; img标签 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;5.img标签.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--需求1：使用img标签显示一张美女的照片。并修改宽高，和边框属性 img标签是图片标签,用来显示图片 src属性可以设置图片的路径 width属性设置图片的宽度 height属性设置图片的高度 border属性设置图片边框大小 alt属性设置当指定路径找不到图片时,用来代替显示的文本内容 在JavaSE中路径也分为相对路径和绝对路径. 相对路径:从工程名开始算 绝对路径:盘符:/目录/文件名 在web中路径分为相对路径和绝对路径两种 相对路径: . 表示当前文件所在的目录 .. 表示当前文件所在的上一级目录 文件名 表示当前文件所在目录的文件,相当于 ./文件名 ./ 可以省略 绝对路径: 正确格式是: http://ip:port/工程名/资源路径 错误格式是: 盘符:/目录/文件名 --&gt; &lt;!--下面这些值的单位是像素--&gt; &lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;260&quot; border=&quot;1&quot; alt=&quot;美女找不到&quot;/&gt; &lt;img src=&quot;../../2.jpg&quot; width=&quot;200&quot; height=&quot;260&quot; alt=&quot;美女找不到&quot; /&gt; &lt;img src=&quot;../imgs/3.jpg&quot; width=&quot;200&quot; height=&quot;260&quot; /&gt; &lt;img src=&quot;../imgs/4.jpg&quot; width=&quot;200&quot; height=&quot;260&quot; /&gt; &lt;img src=&quot;../imgs/5.jpg&quot; width=&quot;200&quot; height=&quot;260&quot; /&gt; &lt;img src=&quot;../imgs/6.jpg&quot; width=&quot;200&quot; height=&quot;260&quot; /&gt;&lt;/body&gt;&lt;/html&gt; 表格标签 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;表格标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 需求1：做一个 带表头的 ，三行，三列的表格，并显示边框 需求2：修改表格的宽度，高度，表格的对齐方式，单元格间距。 table 标签是表格标签 border 设置表格标框 width 设置表格宽度 height 设置表格高度 align 设置表格相对于页面的对齐方式 cellspacing 设置单元格间距 tr 是行标签 th 是表头标签 td 是单元格标签 align 设置单元格文本对齐方式 b 是加粗标签 --&gt;&lt;table align=&quot;center&quot; border=&quot;1&quot; width=&quot;300&quot; height=&quot;300&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;th&gt;1.1&lt;/th&gt; &lt;!--注释上面和下面的两个标签是等价的--&gt; &lt;td align=&quot;center&quot;&gt;&lt;b&gt;1.1&lt;/b&gt;&lt;/td&gt; &lt;th&gt;1.2&lt;/th&gt; &lt;th&gt;1.3&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2.1&lt;/td&gt; &lt;td&gt;2.2&lt;/td&gt; &lt;td&gt;2.3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3.1&lt;/td&gt; &lt;td&gt;3.2&lt;/td&gt; &lt;td&gt;3.3&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 表格跨行跨列标签 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;7.表格的跨行跨列&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;!-- 需求1： 新建一个五行，五列的表格， 第一行，第一列的单元格要跨两列， 第二行第一列的单元格跨两行， 第四行第四列的单元格跨两行两列。 colspan 属性设置跨列，被作用的单元格横向合并一个 rowspan 属性设置跨行,指的是被作用的单元格向下合并一个 --&gt; &lt;table width=&quot;500&quot; height=&quot;500&quot; cellspacing=&quot;0&quot; border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;1.1&lt;/td&gt; &lt;td&gt;1.3&lt;/td&gt; &lt;td&gt;1.4&lt;/td&gt; &lt;td&gt;1.5&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspqn=&quot;2&quot;&gt;2.1&lt;/td&gt; &lt;td&gt;2.2&lt;/td&gt; &lt;td&gt;2.3&lt;/td&gt; &lt;td&gt;2.4&lt;/td&gt; &lt;td&gt;2.5&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3.2&lt;/td&gt; &lt;td&gt;3.3&lt;/td&gt; &lt;td&gt;3.4&lt;/td&gt; &lt;td&gt;3.5&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;4.1&lt;/td&gt; &lt;td&gt;4.2&lt;/td&gt; &lt;td&gt;4.3&lt;/td&gt; &lt;td colspan=&quot;2&quot; rowspan=&quot;2&quot;&gt;4.4&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;5.1&lt;/td&gt; &lt;td&gt;5.2&lt;/td&gt; &lt;td&gt;5.3&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; iframe标签 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;8.iframe标签.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 我是一个单独的完整的页面&lt;br/&gt;&lt;br/&gt; &lt;!--ifarme标签可以在页面上开辟一个小区域显示一个单独的页面 ifarme和a标签组合使用的步骤: 1 在iframe标签中使用name属性定义一个名称 2 在a标签的target属性上设置iframe的name的属性值 --&gt; &lt;iframe src=&quot;3.标题标签.html&quot; width=&quot;200&quot; height=&quot;200&quot; name=&quot;abc&quot;&gt;&lt;/iframe&gt; &lt;br/&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;0-标签语法.html&quot; target=&quot;abc&quot;&gt;0-标签语法.html&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;1.font标签.html&quot; target=&quot;abc&quot;&gt;1.font标签.html&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;2.特殊字符.html&quot; target=&quot;abc&quot;&gt;2.特殊字符.html&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 表单显示 什么是表单，表单就是html页面中用来收集用户信息的所有元素的集合，然后把这些信息发送给服务器 同时用标签让表单像表格一样的形式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;表单的显示&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--需求1:创建一个个人信息注册的表单界面。包含用户名，密码，确认密码。性别（单选），兴趣爱好（多选），国籍（下拉列表）。隐藏域，自我评价（多行文本域）。重置，提交。--&gt; &lt;!-- form标签就是表单 input type=text 是文件输入框 value设置默认显示内容 input type=password 是密码输入框 value设置默认显示内容 input type=radio 是单选框 name属性可以对其进行分组 checked=&quot;checked&quot;表示默认选中 input type=checkbox 是复选框 checked=&quot;checked&quot;表示默认选中 input type=reset 是重置按钮 value属性修改按钮上的文本 input type=submit 是提交按钮 value属性修改按钮上的文本 input type=button 是按钮 value属性修改按钮上的文本 input type=file 是文件上传域 input type=hidden 是隐藏域 当我们要发送某些信息，而这些信息，不需要用户参与，就可以使用隐藏域（提交的时候同时发送给服务器） select 标签是下拉列表框 option 标签是下拉列表框中的选项 selected=&quot;selected&quot;设置默认选中 textarea 表示多行文本输入框 （起始标签和结束标签中的内容是默认值） rows 属性设置可以显示几行的高度 cols 属性设置每行可以显示几个字符宽度 --&gt; &lt;form&gt; &lt;h1 align=&quot;center&quot;&gt;用户注册&lt;/h1&gt; &lt;table align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td&gt; 用户名称：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; value=&quot;默认值&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 用户密码：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; value=&quot;abc&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;确认密码：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; value=&quot;abc&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot;/&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked=&quot;checked&quot; /&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 兴趣爱好：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; /&gt;Java &lt;input type=&quot;checkbox&quot; /&gt;JavaScript &lt;input type=&quot;checkbox&quot; /&gt;C++ &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;国籍：&lt;/td&gt; &lt;td&gt; &lt;select&gt; &lt;option&gt;--请选择国籍--&lt;/option&gt; &lt;option selected=&quot;selected&quot;&gt;中国&lt;/option&gt; &lt;option&gt;美国&lt;/option&gt; &lt;option&gt;小日本&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;自我评价：&lt;/td&gt; &lt;td&gt;&lt;textarea rows=&quot;10&quot; cols=&quot;20&quot;&gt;我才是默认值&lt;/textarea&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;reset&quot; /&gt;&lt;/td&gt; &lt;td align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;文件上传&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;file&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 表单提交的细节 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;表单的显示&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- form标签是表单标签 action属性设置提交的服务器地址 method属性设置提交的方式GET(默认值)或POST 表单提交的时候，数据没有发送给服务器的三种情况： 1、表单项没有name属性值(可是我测试的真实情况是没有也可以) 2、单选、复选（下拉列表中的option标签）都需要添加value属性，以便发送给服务器 3、表单项不在提交的form标签中 GET请求的特点是： 1、浏览器地址栏中的地址是：action属性[+?+请求参数] 请求参数的格式是：name=value&amp;name=value 2、不安全 3、它有数据长度的限制 POST请求的特点是： 1、浏览器地址栏中只有action属性值 2、相对于GET请求要安全 3、理论上没有数据长度的限制 --&gt; &lt;form action=&quot;http://www.baidu.com&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;login&quot; /&gt; &lt;h1 align=&quot;center&quot;&gt;用户注册&lt;/h1&gt; &lt;table align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td&gt; 用户名称：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;默认值&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 用户密码：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;abc&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;boy&quot;/&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked=&quot;checked&quot; value=&quot;girl&quot; /&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 兴趣爱好：&lt;/td&gt; &lt;td&gt; &lt;input name=&quot;hobby&quot; type=&quot;checkbox&quot; checked=&quot;checked&quot; value=&quot;java&quot;/&gt;Java &lt;input name=&quot;hobby&quot; type=&quot;checkbox&quot; value=&quot;js&quot;/&gt;JavaScript &lt;input name=&quot;hobby&quot; type=&quot;checkbox&quot; value=&quot;cpp&quot;/&gt;C++ &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;国籍：&lt;/td&gt; &lt;td&gt; &lt;select name=&quot;country&quot;&gt; &lt;option value=&quot;none&quot;&gt;--请选择国籍--&lt;/option&gt; &lt;option value=&quot;cn&quot; selected=&quot;selected&quot;&gt;中国&lt;/option&gt; &lt;option value=&quot;usa&quot;&gt;美国&lt;/option&gt; &lt;option value=&quot;jp&quot;&gt;小日本&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;自我评价：&lt;/td&gt; &lt;td&gt;&lt;textarea name=&quot;desc&quot; rows=&quot;10&quot; cols=&quot;20&quot;&gt;我才是默认值&lt;/textarea&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;reset&quot; /&gt;&lt;/td&gt; &lt;td align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 其他标签div span p等等 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;其他标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--需求1：div、span、p标签的演示 div标签 默认独占一行 span标签 它的长度是封装数据的长度 p段落标签 默认会在段落的上方和下方各空出一行来（如果已有就不再空） --&gt; &lt;div&gt;div标签1&lt;/div&gt; &lt;div&gt;div标签2&lt;/div&gt; &lt;span&gt;span标签1&lt;/span&gt; &lt;span&gt;span标签2&lt;/span&gt; &lt;p&gt;p段落标签1&lt;/p&gt; &lt;p&gt;p段落标签2&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; CSScss是层叠样式表单，是用于控制网页样式并允许将样式信息与网页内容分割的一种标记性语言 选择器：1.浏览器根据选择器绝顶受css样式影响的html元素&lt;标签&gt; 属性：是你要改变的样式名，并且每一个属性都有一个值，属性和值被冒号分开，并由花括号包裹，这样就是一个完整的声明，例如 p{color:blue} 多个声明：如果要定义不止一个声明，则需要用分号将每个声明分开，虽然最后一条声明的最后可以不加分号，但尽量在每条声明的末尾加上分号 例如： p{ color:red; font-size:30px; } 不过一般一行只写一个属性 css注释&#x2F;* *&#x2F; CSS和HTML的结合方式结合方式一 在标签的属性上设置“key:value value”,修改标签样式 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--需求1：分别定义两个 div、span标签，分别修改每个 div 标签的样式为：边框1个像素，实线，红色。--&gt; &lt;div style=&quot;border: 1px solid red;&quot;&gt;div标签1&lt;/div&gt; &lt;div style=&quot;border: 1px solid red;&quot;&gt;div标签2&lt;/div&gt; &lt;span style=&quot;border: 1px solid red;&quot;&gt;span标签1&lt;/span&gt; &lt;span style=&quot;border: 1px solid red;&quot;&gt;span标签2&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 缺点：1.如果标签写多了，样式多了，代码量太大 ​ 2.可读性非常差 ​ 3.Css代码没有什么复用性可言 结合方式二 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--style标签专门用来定义css样式代码--&gt; &lt;style type=&quot;text/css&quot;&gt; /* 需求1：分别定义两个 div、span标签，分别修改每个 div 标签的样式为：边框1个像素，实线，红色。*/ div&#123; border: 1px solid red; &#125; span&#123; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;div标签1&lt;/div&gt; &lt;div&gt;div标签2&lt;/div&gt; &lt;span&gt;span标签1&lt;/span&gt; &lt;span&gt;span标签2&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 缺点：1.只能在一个页面内复用代码，不能再多个页面中复用css代码 ​ 2.维护起来不方便，实际的项目中会有成千上万的也买你，要到每个页面中去修改，工作量太大了 结合方式三 把css样式写成一个单独的css文件，再通过link标签引入即可复用 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--link标签专门用来引入css样式代码--&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;1.css&quot;/&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;div标签1&lt;/div&gt; &lt;div&gt;div标签2&lt;/div&gt; &lt;span&gt;span标签1&lt;/span&gt; &lt;span&gt;span标签2&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 标签名选择器标签名选择器的格式是 标签名{ 属性:值 } 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;CSS选择器&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123; border: 1px solid yellow; color: blue; font-size: 30px; &#125; span&#123; border: 5px dashed blue; color: yellow; font-size: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 需求1：在所有div标签上修改字体颜色为蓝色，字体大小30个像素。边框为1像素黄色实线。 并且修改所有span 标签的字体颜色为黄色，字体大小20个像素。边框为5像素蓝色虚线。 --&gt; &lt;div&gt;div标签1&lt;/div&gt; &lt;div&gt;div标签2&lt;/div&gt; &lt;span&gt;span标签1&lt;/span&gt; &lt;span&gt;span标签2&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 标签名选择器可以决定哪些标签被动的使用这个样式 id选择器id选择器的格式是： #id 属性值{ 属性:值 } id选择器，可以让我们通过id属性选择性的去使用这个样式 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;ID选择器&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #id001&#123; color: blue; font-size: 30px; border: 1px yellow solid; &#125; #id002&#123; color: red; font-size: 20px; border: 5px blue dotted ; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 需求1：分别定义两个 div 标签， 第一个div 标签定义 id 为 id001 ，然后根据id 属性定义css样式修改字体颜色为蓝色， 字体大小30个像素。边框为1像素黄色实线。 第二个div 标签定义 id 为 id002 ，然后根据id 属性定义css样式 修改的字体颜色为红色，字体大小20个像素。 边框为5像素蓝色点线。 --&gt; &lt;div id=&quot;id002&quot;&gt;div标签1&lt;/div&gt; &lt;div id=&quot;id001&quot;&gt;div标签2&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; class选择器class 类型选择器的格式是 .class属性值{ 属性:值 } class类型选择器可以通过class属性有效的选择地去使用这个样式 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;class类型选择器&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .class01&#123; color: blue; font-size: 30px; border: 1px solid yellow; &#125; .class02&#123; color: grey; font-size: 26px; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 需求1：修改 class 属性值为 class01的 span 或 div 标签，字体颜色为蓝色，字体大小30个像素。边框为1像素黄色实线。 需求2：修改 class 属性值为 class02的 div 标签，字体颜色为灰色，字体大小26个像素。边框为1像素红色实线。 --&gt; &lt;div class=&quot;class01&quot;&gt;div标签class01&lt;/div&gt; &lt;div class=&quot;class02&quot;&gt;div标签&lt;/div&gt; &lt;span class=&quot;class02&quot;&gt;span标签class01&lt;/span&gt; &lt;span&gt;span标签2&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 组合选择器组合选择器的格式是： 选择器1,选择器2,选择器n{ 属性:值 } 让多个选择器或者多种类型的选择器共用同一块代码 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;class类型选择器&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .class01 , #id01&#123; color: blue; font-size: 20px; border: yellow 1px solid; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 需求1：修改 class=&quot;class01&quot; 的div 标签 和 id=&quot;id01&quot; 所有的span标签， 字体颜色为蓝色，字体大小20个像素。边框为1像素黄色实线。 --&gt; &lt;div id=&quot;id01&quot;&gt;div标签class01&lt;/div&gt; &lt;br /&gt; &lt;span class=&quot;class01&quot;&gt;span 标签&lt;/span&gt; &lt;br /&gt; &lt;div&gt;div标签&lt;/div&gt; &lt;br /&gt; &lt;div&gt;div标签id01&lt;/div&gt; &lt;br /&gt;&lt;/body&gt;&lt;/html&gt; css常用样式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;06-css常用样式.html&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123; color: red; 红色 border: 1px yellow solid; 边框属性 width: 300px; 宽度 height: 300px; 高度 background-color: green; 背景颜色 font-size: 30px; 字体大小 margin-left: auto; 这个和下面那个两行表示div居中 margin-right: auto; text-align: center; 文字居中 &#125; table&#123; border: 1px red solid; 设置边框 border-collapse: collapse; 将边框合并，就是td单元格的边框和表格的边框合并 &#125; td&#123; border: 1px red solid; &#125; a&#123; text-decoration: none; 超链接去下划线 &#125; ul&#123; list-style: none; 列表去除修饰 &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;11111111111&lt;/li&gt; &lt;li&gt;11111111111&lt;/li&gt; &lt;li&gt;11111111111&lt;/li&gt; &lt;li&gt;11111111111&lt;/li&gt; &lt;li&gt;11111111111&lt;/li&gt; &lt;/ul&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;1.1&lt;/td&gt; &lt;td&gt;1.2&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; &lt;div&gt;我是div标签&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; JavascriptjQueryjQuery就是javascript和查询，他就是辅助javascript开发的js类库 jQuery 的核心思想就是write less ，do more 所以他实现了很多浏览器的兼容问题 基础使用 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; // window.onload = function () &#123; // var btnObj = document.getElementById(&quot;btnId&quot;); // // alert(btnObj);//[object HTMLButtonElement] ====&gt;&gt;&gt; dom对象 // btnObj.onclick = function () &#123; // alert(&quot;js 原生的单击事件&quot;); // &#125; // &#125; $(function () &#123; // 表示页面加载完成 之后，相当 window.onload = function () &#123;&#125; var $btnObj = $(&quot;#btnId&quot;); // 表示按id查询标签对象，jQuery对象变量都加一个$ $btnObj.click(function () &#123; // 绑定单击事件 alert(&quot;jQuery 的单击事件&quot;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btnId&quot;&gt;SayHello&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; jQuery中的$是一个函数 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt; &lt;!--引入jQuery文件--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; //使用$()代替window.onload$(function()&#123; //使用选择器获取按钮对象，随后绑定单击响应函数 //表示按id查询对象 $(&quot;#btnId&quot;).click(function()&#123; //弹出Hello alert(&#x27;Hello&#x27;); &#125;); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btnId&quot;&gt;SayHello&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 为按钮添加响应函数 1.使用jQuery查询到标签对象 2.使用标签对象.click(function(){}); $介绍$是jQuery的核心函数，能完成jQuery的很多功能，$()就是调用$这个函数 1.传入的参数是函数时 表示页面加载完成之后。相当于window.onload&#x3D;function(){}; 2.传入的参数为HTML字符串时，会对我们创建这个html标签对象 3.传入参数为【选择器字符串时】， $(“#id属性值”)：id选择器，根据id查询标签对象 $(“标签名”): 标签名选择器，根据指定的标签名查询标签对象 $(“.class属性值”):类型选择器，根据class属性查询标签对象 4.传入的参数是dom对象，将这个dom对象转换为jQuery对象 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; //核心函数的4个作用 $(function () &#123; // alert(&quot;页面加载完成之后，自动调用&quot;);//将生成的html标签对象直接加给了body标签，这样就可以显示 $(&quot; &lt;div&gt;&quot; + &quot; &lt;span&gt;div-span1&lt;/span&gt;&quot; + &quot; &lt;span&gt;div-span2&lt;/span&gt;&quot; + &quot; &lt;/div&gt;&quot;).appendTo(&quot;body&quot;); // alert($(&quot;button&quot;).length); var btnObj = document.getElementById(&quot;btn01&quot;); // alert(btnObj); // alert( $(btnObj) ); // alert( $(&quot;&lt;h1&gt;&lt;/h1&gt;&quot;) ); alert($(&quot;button&quot;)); &#125;); //传入参数为[函数]时：在文档加载完成后执行这个函数 //传入参数为[HTML字符串]时：根据这个字符串创建元素节点对象，创建的是jQuery对象 //传入参数为[选择器字符串]时：根据这个字符串查找元素节点对象，创建的是jQuery对象 //传入参数为[DOM对象]时：将DOM对象包装为jQuery对象返回&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn01&quot;&gt;按钮1&lt;/button&gt; &lt;button&gt;按钮2&lt;/button&gt; &lt;button&gt;按钮3&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; jQuery对象和dom对象区分DOM对象 1.通过各种方法查询出来的标签对象是dom对象 jQuery对象 1.通过jQuery提供的API创建的对象，是jQuery对象 alert( $(““) ); 2.通过JQuery包装的Dom对象，也是JQuery对象 alert( $(btnObj) ); btnObj是一个dom对象 3.它通过JQuery提供的API查询到的对象，是JQuery对象 alert($(“button”)); JQuery对象alert出来的效果是[Object Object] jQuery对象的本质jQuery对象是 dom对象的数组+jQuery提供的一系列功能函数 jQuery对象和Dom对象的使用区别jQuery对象不能使用dom对象的属性和方法 dom对象也不能使用jQuery对象的属性和方法 Dom对象和JQuery对象之间的相互转换1.dom对象转化为jQUery对象 现有Dom对象，然后 $(Dom)对象就可以转换为jQuery对象 2.jQuery对象转为dom对象 现有jQuery对象，jQuery对象[下标]取出相应的dom对象 Insert title here ​ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 //jQuery对象的本质的演示 $(function()&#123; //testDiv.css(&quot;color&quot;,&quot;red&quot;) //testDiv.style.color = &quot;blue&quot;; // var arr = [12,&quot;abc&quot;,true]; // // var $btns = $(&quot;button&quot;); // // for (var i = 0; i &lt; $btns.length; i++)&#123; // alert($btns[i]); // &#125; //jQuery和Dom的使用区别的演示 //document.getElementById(&quot;testDiv&quot;).innerHTML = &quot;这是dom对象的属性InnerHTML&quot;; //$(&quot;#testDiv&quot;).innerHTML = &quot;这是dom对象的属性InnerHTML&quot;; //$(&quot;#testDiv&quot;).click(function () &#123; //alert(&quot;click()是jQuery对象的方法&quot;); //&#125;); //document.getElementById(&quot;testDiv&quot;).click(function () &#123; //alert(&quot;click()是jQuery对象的方法&quot;); //&#125;); //下面是jQuery对象转换为dom对象的演示，用下标来取出 // alert( $(document.getElementById(&quot;testDiv&quot;))[0] ); alert( $(&quot;button:first&quot;) ); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;testDiv&quot;&gt;Atguigu is Very Good!&lt;/div&gt; &lt;button id=&quot;dom2dom&quot;&gt;使用DOM对象调用DOM方法&lt;/button&gt; &lt;button id=&quot;dom2jQuery&quot;&gt;使用DOM对象调用jQuery方法&lt;/button&gt; &lt;button id=&quot;jQuery2jQuery&quot;&gt;使用jQuery对象调用jQuery方法&lt;/button&gt; &lt;button id=&quot;jQuery2dom&quot;&gt;使用jQuery对象调用DOM方法&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; jQuery基本选择器基本选择器 #ID 选择器：根据id查找标签对象 .class 选择器：根据class查找标签对象 element 选择器：根据标签名查找标签对象 *选择器：表示任意的，所有的元素 selector1,selector2 组合器：合并选择器1,选择器2的结果并返回 特殊的 p.myClass表示标签名必须是p标签，而且class类型还要是myClass 基本选择器的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; &lt;!--应该是div标签且class为mini--&gt; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; //1.选择 id 为 one 的元素 &quot;background-color&quot;,&quot;#bbffaa&quot; $(&quot;#btn1&quot;).click(function () &#123; // css() 方法 可以设置和获取样式,第二个参数是颜色属性的值 $(&quot;#one&quot;).css(&quot;background-color&quot;,&quot;#bbffaa&quot;); &#125;); //2.选择 class 为 mini 的所有元素 $(&quot;#btn2&quot;).click(function () &#123; $(&quot;.mini&quot;).css(&quot;background-color&quot;,&quot;#bbffaa&quot;); &#125;); //3.选择 元素名是 div 的所有元素 $(&quot;#btn3&quot;).click(function () &#123; $(&quot;div&quot;).css(&quot;background-color&quot;,&quot;#bbffaa&quot;); &#125;); //4.选择所有的元素 $(&quot;#btn4&quot;).click(function () &#123; $(&quot;*&quot;).css(&quot;background-color&quot;,&quot;#bbffaa&quot;); &#125;); //5.选择所有的 span 元素和id为two的元素 $(&quot;#btn5&quot;).click(function () &#123; $(&quot;span,#two&quot;).css(&quot;background-color&quot;,&quot;#bbffaa&quot;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;!-- &lt;div&gt; &lt;h1&gt;基本选择器&lt;/h1&gt; &lt;/div&gt; --&gt; &lt;input type=&quot;button&quot; value=&quot;选择 id 为 one 的元素&quot; id=&quot;btn1&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择 class 为 mini 的所有元素&quot; id=&quot;btn2&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择 元素名是 div 的所有元素&quot; id=&quot;btn3&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择 所有的元素&quot; id=&quot;btn4&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择 所有的 span 元素和id为two的元素&quot; id=&quot;btn5&quot; /&gt; &lt;br&gt; &lt;div class=&quot;one&quot; id=&quot;one&quot;&gt; id 为 one,class 为 one 的div &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot; id=&quot;two&quot; title=&quot;test&quot;&gt; id为two,class为one,title为test的div &lt;div class=&quot;mini&quot; title=&quot;other&quot;&gt;class为mini,title为other&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;test&quot;&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;tesst&quot;&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;!--display:none就是不显示--&gt; &lt;div style=&quot;display:none;&quot; class=&quot;none&quot;&gt;style的display为&quot;none&quot;的div&lt;/div&gt; &lt;div class=&quot;hide&quot;&gt;class为&quot;hide&quot;的div&lt;/div&gt; &lt;div&gt; 包含input的type为&quot;hidden&quot;的div&lt;input type=&quot;hidden&quot; size=&quot;8&quot;&gt; &lt;/div&gt; &lt;span class=&quot;one&quot; id=&quot;span&quot;&gt;^^span元素^^&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; jQuery层级选择器ancestor descendant 后代选择器 ：在给定的祖先元素下匹配所有的后代元素 parent &gt; child 子元素选择器：在给定的父元素下匹配所有的子元素 prev + next 相邻元素选择器：匹配所有紧接在 prev 元素后的 next 元素 prev ~ sibings 之后的兄弟元素选择器：匹配 prev 元素之后的所有 siblings 元素 儿子元素和孙子元素是有区别的，而且后代元素包括所有的后代包括儿子孙子 $(“lable + input”) 所有紧跟在lable标签后面的input标签，必须是紧跟 $(“form &gt; input”)匹配表单中所有的子级input元素，只有儿子辈的，没有孙子辈的 $(“form input”)匹配form后代的所有的input元素 $(“form ~input”)找到form后面所有与form同辈的input元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; //$(function()&#123;&#125;);的全写 //1.选择 body 内的所有 div 元素 $(&quot;#btn1&quot;).click(function()&#123; $(&quot;body div&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //2.在 body 内, 选择div子元素 $(&quot;#btn2&quot;).click(function()&#123; $(&quot;body &gt; div&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //3.选择 id 为 one 的下一个 div 元素 $(&quot;#btn3&quot;).click(function()&#123; $(&quot;#one+div&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //4.选择 id 为 two 的元素后面的所有 div 兄弟元素 $(&quot;#btn4&quot;).click(function()&#123; $(&quot;#two~div&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- &lt;div&gt; &lt;h1&gt;层级选择器:根据元素的层级关系选择元素&lt;/h1&gt; ancestor descendant ： parent &gt; child ： prev + next ： prev ~ siblings ： &lt;/div&gt; --&gt; &lt;input type=&quot;button&quot; value=&quot;选择 body 内的所有 div 元素&quot; id=&quot;btn1&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;在 body 内, 选择div子元素&quot; id=&quot;btn2&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择 id 为 one 的下一个 div 元素&quot; id=&quot;btn3&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择 id 为 two 的元素后面的所有 div 兄弟元素&quot; id=&quot;btn4&quot; /&gt; &lt;br&gt;&lt;br&gt; &lt;div class=&quot;one&quot; id=&quot;one&quot;&gt; id 为 one,class 为 one 的div &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot; id=&quot;two&quot; title=&quot;test&quot;&gt; id为two,class为one,title为test的div &lt;div class=&quot;mini&quot; title=&quot;other&quot;&gt;class为mini,title为other&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;test&quot;&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;tesst&quot;&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;display:none;&quot; class=&quot;none&quot;&gt;style的display为&quot;none&quot;的div&lt;/div&gt; &lt;div class=&quot;hide&quot;&gt;class为&quot;hide&quot;的div&lt;/div&gt; &lt;div&gt; 包含input的type为&quot;hidden&quot;的div&lt;input type=&quot;hidden&quot; size=&quot;8&quot;&gt; &lt;/div&gt; &lt;span id=&quot;span&quot;&gt;^^span元素^^&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; jQuery基本过滤选择器:first 获取第一个元素 :last 获取最后个元素 :not(selector) 去除所有与给定选择器匹配的元素 :even 匹配所有索引值为偶数的元素，从 0 开始计数 :odd 匹配所有索引值为奇数的元素，从 0 开始计数 :eq(index) 匹配一个给定索引值的元素 :gt(index) 匹配所有大于给定索引值的元素 :lt(index) 匹配所有小于给定索引值的元素 :header 匹配如 h1, h2, h3 之类的标题元素 :animated 匹配所有正在执行动画效果的元 :hidden匹配被隐藏起来的元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; //这是一个动画的代码 $(document).ready(function()&#123; function anmateIt()&#123; $(&quot;#mover&quot;).slideToggle(&quot;slow&quot;, anmateIt); &#125; anmateIt(); &#125;); $(document).ready(function()&#123; //1.选择第一个 div 元素 $(&quot;#btn1&quot;).click(function()&#123; $(&quot;div:first&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //2.选择最后一个 div 元素 $(&quot;#btn2&quot;).click(function()&#123; $(&quot;div:last&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //3.选择class不为 one 的所有 div 元素 $(&quot;#btn3&quot;).click(function()&#123; $(&quot;div:not(.one)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //4.选择索引值为偶数的 div 元素 $(&quot;#btn4&quot;).click(function()&#123; $(&quot;div:even&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //5.选择索引值为奇数的 div 元素 $(&quot;#btn5&quot;).click(function()&#123; $(&quot;div:odd&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //6.选择索引值为大于 3 的 div 元素 $(&quot;#btn6&quot;).click(function()&#123; $(&quot;div:gt(3)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //7.选择索引值为等于 3 的 div 元素 $(&quot;#btn7&quot;).click(function()&#123; $(&quot;div:eq(3)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //8.选择索引值为小于 3 的 div 元素 $(&quot;#btn8&quot;).click(function()&#123; $(&quot;div:lt(3)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //9.选择所有的标题元素 $(&quot;#btn9&quot;).click(function()&#123; $(&quot;:header&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //10.选择当前正在执行动画的所有元素 $(&quot;#btn10&quot;).click(function()&#123; $(&quot;:animated&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //11.选择没有执行动画的最后一个div $(&quot;#btn11&quot;).click(function()&#123; $(&quot;div:not(:animated):last&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;选择第一个 div 元素&quot; id=&quot;btn1&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择最后一个 div 元素&quot; id=&quot;btn2&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择class不为 one 的所有 div 元素&quot; id=&quot;btn3&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择索引值为偶数的 div 元素&quot; id=&quot;btn4&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择索引值为奇数的 div 元素&quot; id=&quot;btn5&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择索引值为大于 3 的 div 元素&quot; id=&quot;btn6&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择索引值为等于 3 的 div 元素&quot; id=&quot;btn7&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择索引值为小于 3 的 div 元素&quot; id=&quot;btn8&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择所有的标题元素&quot; id=&quot;btn9&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择当前正在执行动画的所有元素&quot; id=&quot;btn10&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择没有执行动画的最后一个div&quot; id=&quot;btn11&quot; /&gt; &lt;h3&gt;基本选择器.&lt;/h3&gt; &lt;br&gt;&lt;br&gt; &lt;div class=&quot;one&quot; id=&quot;one&quot;&gt; id 为 one,class 为 one 的div &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot; id=&quot;two&quot; title=&quot;test&quot;&gt; id为two,class为one,title为test的div &lt;div class=&quot;mini&quot; title=&quot;other&quot;&gt;class为mini,title为other&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;test&quot;&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;tesst&quot;&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;display:none;&quot; class=&quot;none&quot;&gt;style的display为&quot;none&quot;的div&lt;/div&gt; &lt;div class=&quot;hide&quot;&gt;class为&quot;hide&quot;的div&lt;/div&gt; &lt;div&gt; 包含input的type为&quot;hidden&quot;的div&lt;input type=&quot;hidden&quot; size=&quot;8&quot;&gt; &lt;/div&gt; &lt;div id=&quot;mover&quot;&gt;正在执行动画的div元素.&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; jQuery内容过滤器文本也算是子元素 :contains(text) 匹配包含给定文本的元素 :empty 匹配所有不包含子元素或者文本的空元素 :parent 匹配含有子元素或者文本的元素 :has(selector) 匹配含有选择器所匹配的元素的元 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; function anmateIt()&#123; $(&quot;#mover&quot;).slideToggle(&quot;slow&quot;, anmateIt); &#125; anmateIt(); &#125;); /** :contains(text) :empty :has(selector) :parent */ $(document).ready(function()&#123; //1.选择 含有文本 &#x27;di&#x27; 的 div 元素 $(&quot;#btn1&quot;).click(function()&#123; $(&quot;div:contains(&#x27;di&#x27;)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //2.选择不包含子元素(包括文本元素) 的 div 空元素 $(&quot;#btn2&quot;).click(function()&#123; $(&quot;div:empty&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //3.选择含有 class 为 mini 元素的 div 元素 $(&quot;#btn3&quot;).click(function()&#123; $(&quot;div:has(.mini)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //4.选择含有子元素(包括文本元素)的div元素 $(&quot;#btn4&quot;).click(function()&#123; $(&quot;div:parent&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;选择 含有文本 &#x27;di&#x27; 的 div 元素&quot; id=&quot;btn1&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择不包含子元素(或者文本元素) 的 div 空元素&quot; id=&quot;btn2&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择含有 class 为 mini 元素的 div 元素&quot; id=&quot;btn3&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择含有子元素(或者文本元素)的div元素&quot; id=&quot;btn4&quot; /&gt; &lt;br&gt;&lt;br&gt; &lt;div class=&quot;one&quot; id=&quot;one&quot;&gt; id 为 one,class 为 one 的div &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot; id=&quot;two&quot; title=&quot;test&quot;&gt; id为two,class为one,title为test的div &lt;div class=&quot;mini&quot; title=&quot;other&quot;&gt;class为mini,title为other&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;test&quot;&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;tesst&quot;&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;display:none;&quot; class=&quot;none&quot;&gt;style的display为&quot;none&quot;的div&lt;/div&gt; &lt;div class=&quot;hide&quot;&gt;class为&quot;hide&quot;的div&lt;/div&gt; &lt;div&gt; 包含input的type为&quot;hidden&quot;的div&lt;input type=&quot;hidden&quot; size=&quot;8&quot;&gt; &lt;/div&gt; &lt;div id=&quot;mover&quot;&gt;正在执行动画的div元素.&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; jQuery属性过滤选择器[attribute] 匹配包含给定属性的元素。 [attribute&#x3D;value] 匹配给定的属性是某个特定值的元素 [attribute!&#x3D;value] 匹配所有不含有指定的属性，或者属性不等于特定值的元素。 [attribute^&#x3D;value] 匹配给定的属性是以某些值开始的元素 [attribute$&#x3D;value] 匹配给定的属性是以某些值结尾的元素 [attribute*&#x3D;value] 匹配给定的属性是以包含某些值的元素 [attrSel1][attrSel2][attrSelN] 复合属性选择器，需要同时满足多个条件时使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Untitled Document&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;div,span,p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana;&#125;div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px;&#125;div.hide &#123; display: none;&#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; /**[attribute] [attribute=value] [attribute!=value] [attribute^=value] [attribute$=value] [attribute*=value] [attrSel1][attrSel2][attrSelN] */ $(function() &#123; //1.选取含有 属性title 的div元素 $(&quot;#btn1&quot;).click(function() &#123; $(&quot;div[title]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //2.选取 属性title值等于&#x27;test&#x27;的div元素 $(&quot;#btn2&quot;).click(function() &#123; $(&quot;div[title=&#x27;test&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //3.选取 属性title值不等于&#x27;test&#x27;的div元素(*没有属性title的也将被选中) $(&quot;#btn3&quot;).click(function() &#123; $(&quot;div[title!=&#x27;test&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //4.选取 属性title值 以&#x27;te&#x27;开始 的div元素 $(&quot;#btn4&quot;).click(function() &#123; $(&quot;div[title^=&#x27;te&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //5.选取 属性title值 以&#x27;est&#x27;结束 的div元素 $(&quot;#btn5&quot;).click(function() &#123; $(&quot;div[title$=&#x27;est&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //6.选取 属性title值 含有&#x27;es&#x27;的div元素 $(&quot;#btn6&quot;).click(function() &#123; $(&quot;div[title*=&#x27;es&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //7.首先选取有属性id的div元素，然后在结果中 选取属性title值 含有&#x27;es&#x27;的 div 元素 $(&quot;#btn7&quot;).click(function() &#123; $(&quot;div[id][title*=&#x27;es&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //8.选取 含有 title 属性值, 且title 属性值不等于 test 的 div 元素 $(&quot;#btn8&quot;).click(function() &#123; $(&quot;div[title][title!=&#x27;test&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;选取含有 属性title 的div元素.&quot; id=&quot;btn1&quot; style=&quot;display: none;&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;选取 属性title值等于&#x27;test&#x27;的div元素.&quot; id=&quot;btn2&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选取 属性title值不等于&#x27;test&#x27;的div元素(没有属性title的也将被选中).&quot; id=&quot;btn3&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选取 属性title值 以&#x27;te&#x27;开始 的div元素.&quot; id=&quot;btn4&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选取 属性title值 以&#x27;est&#x27;结束 的div元素.&quot; id=&quot;btn5&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选取 属性title值 含有&#x27;es&#x27;的div元素.&quot; id=&quot;btn6&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;组合属性选择器,首先选取有属性id的div元素，然后在结果中 选取属性title值 含有&#x27;es&#x27;的 div 元素.&quot; id=&quot;btn7&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选取 含有 title 属性值, 且title 属性值不等于 test 的 div 元素.&quot; id=&quot;btn8&quot; /&gt; &lt;br&gt; &lt;br&gt; &lt;div class=&quot;one&quot; id=&quot;one&quot;&gt; id 为 one,class 为 one 的div &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot; id=&quot;two&quot; title=&quot;test&quot;&gt; id为two,class为one,title为test的div &lt;div class=&quot;mini&quot; title=&quot;other&quot;&gt;class为mini,title为other&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;test&quot;&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;tesst&quot;&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;display: none;&quot; class=&quot;none&quot;&gt;style的display为&quot;none&quot;的div&lt;/div&gt; &lt;div class=&quot;hide&quot;&gt;class为&quot;hide&quot;的div&lt;/div&gt; &lt;div&gt; 包含input的type为&quot;hidden&quot;的div&lt;input type=&quot;hidden&quot; value=&quot;123456789&quot; size=&quot;8&quot;&gt; &lt;/div&gt; &lt;div id=&quot;mover&quot;&gt;正在执行动画的div元素.&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; jQuery表单过滤选择器:input 匹配所有 input, textarea, select 和 button 元素 :text 匹配所有 文本输入框 :password 匹配所有的密码输入框 :radio 匹配所有的单选框 :checkbox 匹配所有的复选框 :submit 匹配所有提交按钮 :image 匹配所有 img 标签 :reset 匹配所有重置按钮 :button 匹配所有 input type&#x3D;button 按钮 :file 匹配所有 input type&#x3D;file 文件上传 :hidden 匹配所有不可见元素 display:none :enabled 匹配所有可用元素 :disabled 匹配所有不可用元素 :checked 匹配所有选中的单选，复选，和下拉列表中选中的 option 标签对象 :selected 匹配所有选中的 option 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; /** :input :text :password :radio :checkbox :submit :image :reset :button :file :hidden 表单对象的属性 :enabled :disabled :checked :selected */ //1.对表单内 可用input 赋值操作 $(&quot;#btn1&quot;).click(function()&#123; // val()可以操作表单项的value属性值 //表单项是那个form标签里面的那些 // 它可以设置和获取 $(&quot;:text:enabled&quot;).val(&quot;我是万能的程序员&quot;); &#125;); //2.对表单内 不可用input 赋值操作 $(&quot;#btn2&quot;).click(function()&#123; $(&quot;:text:disabled&quot;).val(&quot;管你可用不可用，反正我是万能的程序员&quot;); &#125;); //3.获取多选框选中的个数 使用size()方法获取选取到的元素集合的元素个数 $(&quot;#btn3&quot;).click(function()&#123; alert( $(&quot;:checkbox:checked&quot;).length ); &#125;); //4.获取多选框，每个选中的value值 $(&quot;#btn4&quot;).click(function()&#123; // 获取全部选中的复选框标签对象 var $checkboies = $(&quot;:checkbox:checked&quot;); // 老式遍历 // for (var i = 0; i &lt; $checkboies.length; i++)&#123; // alert( $checkboies[i].value ); // &#125; // each方法是jQuery对象提供用来遍历元素的方法 // 在遍历的function函数中，有一个this对象，这个this对象，就是当前遍历到的dom对象 $checkboies.each(function () &#123; alert( this.value ); &#125;); &#125;); //5.获取下拉框选中的内容 $(&quot;#btn5&quot;).click(function()&#123; // 选中select后代的option标签且被选中的 var $options = $(&quot;select option:selected&quot;); // 遍历，获取option标签中的文本内容 $options.each(function () &#123; // 在each遍历的function函数中，有一个this对象。这个this对象是当前正在遍历到的dom对象 alert(this.innerHTML); &#125;); &#125;); &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;表单对象属性过滤选择器&lt;/h3&gt; &lt;button id=&quot;btn1&quot;&gt;对表单内 可用input 赋值操作.&lt;/button&gt; &lt;button id=&quot;btn2&quot;&gt;对表单内 不可用input 赋值操作.&lt;/button&gt;&lt;br /&gt;&lt;br /&gt; &lt;button id=&quot;btn3&quot;&gt;获取多选框选中的个数.&lt;/button&gt; &lt;button id=&quot;btn4&quot;&gt;获取多选框选中的内容.&lt;/button&gt;&lt;br /&gt;&lt;br /&gt; &lt;button id=&quot;btn5&quot;&gt;获取下拉框选中的内容.&lt;/button&gt;&lt;br /&gt;&lt;br /&gt; &lt;form id=&quot;form1&quot; action=&quot;#&quot;&gt; 可用元素: &lt;input name=&quot;add&quot; value=&quot;可用文本框1&quot;/&gt;&lt;br&gt; &lt;!--diabled=&quot;disabled就是让文本框不可选&quot;--&gt; 不可用元素: &lt;input name=&quot;email&quot; disabled=&quot;disabled&quot; value=&quot;不可用文本框&quot;/&gt;&lt;br&gt; 可用元素: &lt;input name=&quot;che&quot; value=&quot;可用文本框2&quot;/&gt;&lt;br&gt; 不可用元素: &lt;input name=&quot;name&quot; disabled=&quot;disabled&quot; value=&quot;不可用文本框&quot;/&gt;&lt;br&gt; &lt;br&gt; 多选框: &lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;newsletter&quot; checked=&quot;checked&quot; value=&quot;test1&quot; /&gt;test1 &lt;input type=&quot;checkbox&quot; name=&quot;newsletter&quot; value=&quot;test2&quot; /&gt;test2 &lt;input type=&quot;checkbox&quot; name=&quot;newsletter&quot; value=&quot;test3&quot; /&gt;test3 &lt;input type=&quot;checkbox&quot; name=&quot;newsletter&quot; checked=&quot;checked&quot; value=&quot;test4&quot; /&gt;test4 &lt;input type=&quot;checkbox&quot; name=&quot;newsletter&quot; value=&quot;test5&quot; /&gt;test5 &lt;br&gt;&lt;br&gt; 下拉列表1: &lt;br&gt; &lt;!--multiple属性决定了这个下拉表可以多选--&gt; &lt;select name=&quot;test&quot; multiple=&quot;multiple&quot; style=&quot;height: 100px&quot; id=&quot;sele1&quot;&gt; &lt;option&gt;浙江&lt;/option&gt; &lt;option selected=&quot;selected&quot;&gt;辽宁&lt;/option&gt; &lt;option&gt;北京&lt;/option&gt; &lt;option selected=&quot;selected&quot;&gt;天津&lt;/option&gt; &lt;option&gt;广州&lt;/option&gt; &lt;option&gt;湖北&lt;/option&gt; &lt;/select&gt; &lt;br&gt;&lt;br&gt; 下拉列表2: &lt;br&gt; &lt;select name=&quot;test2&quot;&gt; &lt;option&gt;浙江&lt;/option&gt; &lt;option&gt;辽宁&lt;/option&gt; &lt;option selected=&quot;selected&quot;&gt;北京&lt;/option&gt; &lt;option&gt;天津&lt;/option&gt; &lt;option&gt;广州&lt;/option&gt; &lt;option&gt;湖北&lt;/option&gt; &lt;/select&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; jQuery元素的筛选eq() 获取给定索引的元素 功能跟 :eq() 一样 first() 获取第一个元素 功能跟 :first 一样 last() 获取最后一个元素 功能跟 :last 一样 filter(exp) 留下匹配的元素 is(exp) 判断是否匹配给定的选择器，只要有一个匹配就返回，true has(exp) 返回包含有匹配选择器的元素的元素 功能跟 :has 一样 not(exp) 删除匹配选择器的元素 功能跟 :not 一样 children(exp) 返回匹配给定选择器的子元素 功能跟 parent&gt;child 一样 find(exp) 返回匹配给定选择器的后代元素 功能跟 ancestor descendant 一样 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;DOM查询&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; function anmateIt()&#123; $(&quot;#mover&quot;).slideToggle(&quot;slow&quot;, anmateIt); &#125; anmateIt(); /** 过滤 eq(index|-index) first() last() hasClass(class) filter(expr|obj|ele|fn) is(expr|obj|ele|fn)1.6* has(expr|ele) not(expr|ele|fn) slice(start,[end]) 查找 children([expr]) closest(expr,[con]|obj|ele)1.6* find(expr|obj|ele) next([expr]) nextall([expr]) nextUntil([exp|ele][,fil])1.6* parent([expr]) parents([expr]) parentsUntil([exp|ele][,fil])1.6* prev([expr]) prevall([expr]) prevUntil([exp|ele][,fil])1.6* siblings([expr]) 串联 add(expr|ele|html|obj[,con]) */ //(1)eq() 选择索引值为等于 3 的 div 元素 $(&quot;#btn1&quot;).click(function()&#123; $(&quot;div&quot;).eq(3).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(2)first()选择第一个 div 元素 $(&quot;#btn2&quot;).click(function()&#123; //first() 选取第一个元素 $(&quot;div&quot;).first().css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(3)last()选择最后一个 div 元素 $(&quot;#btn3&quot;).click(function()&#123; //last() 选取最后一个元素 $(&quot;div&quot;).last().css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(4)filter()在div中选择索引为偶数的 $(&quot;#btn4&quot;).click(function()&#123; //filter() 过滤 传入的是选择器字符串 $(&quot;div&quot;).filter(&quot;:even&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(5)is()判断#one是否为:empty或:parent //is用来检测jq对象是否符合指定的选择器 $(&quot;#btn5&quot;).click(function()&#123; alert( $(&quot;#one&quot;).is(&quot;:empty&quot;) ); &#125;); //(6)has()选择div中包含.mini的 $(&quot;#btn6&quot;).click(function()&#123; //has(selector) 选择器字符串 是否包含selector $(&quot;div&quot;).has(&quot;.mini&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(7)not()选择div中class不为one的 $(&quot;#btn7&quot;).click(function()&#123; //not(selector) 选择不是selector的元素 $(&quot;div&quot;).not(&#x27;.one&#x27;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(8)children()在body中选择所有class为one的div子元素 $(&quot;#btn8&quot;).click(function()&#123; //children() 选出所有的子元素 $(&quot;body&quot;).children(&quot;div.one&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(9)find()在body中选择所有class为mini的div元素 $(&quot;#btn9&quot;).click(function()&#123; //find() 选出所有的后代元素 $(&quot;body&quot;).find(&quot;div.mini&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(10)next() #one的下一个div $(&quot;#btn10&quot;).click(function()&#123; //next() 选择下一个兄弟元素 $(&quot;#one&quot;).next(&quot;div&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(11)nextAll() #one后面所有的span元素 $(&quot;#btn11&quot;).click(function()&#123; //nextAll() 选出后面所有的元素 $(&quot;#one&quot;).nextAll(&quot;span&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(12)nextUntil() #one和span之间的元素，不算两边 $(&quot;#btn12&quot;).click(function()&#123; // $(&quot;#one&quot;).nextUntil(&quot;span&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;) &#125;); //(13)parent() .mini的父元素 $(&quot;#btn13&quot;).click(function()&#123; $(&quot;.mini&quot;).parent().css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(14)prev() #two的上一个div $(&quot;#btn14&quot;).click(function()&#123; //prev() $(&quot;#two&quot;).prev(&quot;div&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;) &#125;); //(15)prevAll() span前面所有的div $(&quot;#btn15&quot;).click(function()&#123; //prevAll() 选出前面所有的元素 $(&quot;span&quot;).prevAll(&quot;div&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;) &#125;); //(16)prevUntil() span向前直到#one的元素，都不算两个边界 $(&quot;#btn16&quot;).click(function()&#123; //prevUntil(exp) 找到之前所有的兄弟元素直到找到exp停止 $(&quot;span&quot;).prevUntil(&quot;#one&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;) &#125;); //(17)siblings() #two的所有兄弟元素 $(&quot;#btn17&quot;).click(function()&#123; //siblings() 找到所有的兄弟元素，包括前面的和后面的 $(&quot;#two&quot;).siblings().css(&quot;background-color&quot;,&quot;#bfa&quot;) &#125;); //(18)add()选择所有的 span 元素和id为two的元素 $(&quot;#btn18&quot;).click(function()&#123; // $(&quot;span,#two,.mini,#one&quot;) $(&quot;span&quot;).add(&quot;#two&quot;).add(&quot;#one&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;eq()选择索引值为等于 3 的 div 元素&quot; id=&quot;btn1&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;first()选择第一个 div 元素&quot; id=&quot;btn2&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;last()选择最后一个 div 元素&quot; id=&quot;btn3&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;filter()在div中选择索引为偶数的&quot; id=&quot;btn4&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;is()判断#one是否为:empty或:parent&quot; id=&quot;btn5&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;has()选择div中包含.mini的&quot; id=&quot;btn6&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;not()选择div中class不为one的&quot; id=&quot;btn7&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;children()在body中选择所有class为one的div子元素&quot; id=&quot;btn8&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;find()在body中选择所有class为mini的div后代元素&quot; id=&quot;btn9&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;next()#one的下一个div&quot; id=&quot;btn10&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;nextAll()#one后面所有的span元素&quot; id=&quot;btn11&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;nextUntil()#one和span之间的元素&quot; id=&quot;btn12&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;parent().mini的父元素&quot; id=&quot;btn13&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;prev()#two的上一个div&quot; id=&quot;btn14&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;prevAll()span前面所有的div&quot; id=&quot;btn15&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;prevUntil()span向前直到#one的元素&quot; id=&quot;btn16&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;siblings()#two的所有兄弟元素&quot; id=&quot;btn17&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;add()选择所有的 span 元素和id为two的元素&quot; id=&quot;btn18&quot; /&gt; &lt;h3&gt;基本选择器.&lt;/h3&gt; &lt;br /&gt;&lt;br /&gt; 文本框&lt;input type=&quot;text&quot; name=&quot;account&quot; disabled=&quot;disabled&quot; /&gt; &lt;br&gt;&lt;br&gt; &lt;div class=&quot;one&quot; id=&quot;one&quot;&gt; id 为 one,class 为 one 的div &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot; id=&quot;two&quot; title=&quot;test&quot;&gt; id为two,class为one,title为test的div &lt;div class=&quot;mini&quot; title=&quot;other&quot;&gt;&lt;b&gt;class为mini,title为other&lt;/b&gt;&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;test&quot;&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;tesst&quot;&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;display:none;&quot; class=&quot;none&quot;&gt;style的display为&quot;none&quot;的div&lt;/div&gt; &lt;div class=&quot;hide&quot;&gt;class为&quot;hide&quot;的div&lt;/div&gt; &lt;span id=&quot;span1&quot;&gt;^^span元素 111^^&lt;/span&gt; &lt;div&gt; 包含input的type为&quot;hidden&quot;的div&lt;input type=&quot;hidden&quot; size=&quot;8&quot;&gt; &lt;/div&gt; &lt;span id=&quot;span2&quot;&gt;^^span元素 222^^&lt;/span&gt; &lt;div id=&quot;mover&quot;&gt;正在执行动画的div元素.&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; jQuery属性操作html() 它可以设置和获取起始标签和结束标签中的内容，根dom属性innerHTML一样 不传参数是获取，传入参数是设置 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh_CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;$(function()&#123; alert($(&quot;div&quot;).html());//获取 $(&quot;div&quot;).html(&quot;&lt;h1&gt;我是赵梓皓&lt;/h1&gt;&quot;);//设置&#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;我是div标签&lt;span&gt;我是div中的spqn&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; text() 它可以设置和获取起始标签和结束标签中的文本，根dom属性innerText一样 不传参数是获取，传入参数是设置 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh_CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;$(function()&#123; alert($(&quot;div&quot;).text()); $(&quot;div&quot;).text(&quot;&lt;h1&gt;我是赵梓皓&lt;/h1&gt;&quot;);&#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;我是div标签&lt;span&gt;我是div中的spqn&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; text()方法只能让内容全部以文本形式显示，不能识别标签，但html标签可以 val() 它可以设置和获取表单项的value属性值 跟dom属性value一样 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh_CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123;$(&quot;button&quot;).click(function()&#123;alert($(&quot;#username&quot;).val());&#125;);$(&quot;#username&quot;).val(&quot;超级程序员&quot;);&#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;我是div标签&lt;span&gt;我是div中的spqn&lt;/span&gt;&lt;/div&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; /&gt;&lt;button&gt;操作输入框&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 表单选择器练习 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh_CN&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Title&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;$(function () &#123;/*// 批量操作单选$(&quot;:radio&quot;).val([&quot;radio2&quot;]);// 批量操作筛选框的选中状态$(&quot;:checkbox&quot;).val([&quot;checkbox3&quot;,&quot;checkbox2&quot;]);// 批量操作多选的下拉框选中状态$(&quot;#multiple&quot;).val([&quot;mul2&quot;,&quot;mul3&quot;,&quot;mul4&quot;]);// 操作单选的下拉框选中状态$(&quot;#single&quot;).val([&quot;sin2&quot;]);*/$(&quot;#multiple,#single,:radio,:checkbox&quot;).val([&quot;radio2&quot;,&quot;checkbox1&quot;,&quot;checkbox3&quot;,&quot;mul1&quot;,&quot;mul4&quot;,&quot;sin3&quot;]);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;body&gt;单选：&lt;input name=&quot;radio&quot; type=&quot;radio&quot; value=&quot;radio1&quot; /&gt;radio1&lt;input name=&quot;radio&quot; type=&quot;radio&quot; value=&quot;radio2&quot; /&gt;radio2&lt;br/&gt;多选：&lt;input name=&quot;checkbox&quot; type=&quot;checkbox&quot; value=&quot;checkbox1&quot; /&gt;checkbox1&lt;input name=&quot;checkbox&quot; type=&quot;checkbox&quot; value=&quot;checkbox2&quot; /&gt;checkbox2&lt;input name=&quot;checkbox&quot; type=&quot;checkbox&quot; value=&quot;checkbox3&quot; /&gt;checkbox3&lt;br/&gt;下拉多选 ：&lt;select id=&quot;multiple&quot; multiple=&quot;multiple&quot; size=&quot;4&quot;&gt;&lt;option value=&quot;mul1&quot;&gt;mul1&lt;/option&gt;&lt;option value=&quot;mul2&quot;&gt;mul2&lt;/option&gt;&lt;option value=&quot;mul3&quot;&gt;mul3&lt;/option&gt;&lt;option value=&quot;mul4&quot;&gt;mul4&lt;/option&gt;&lt;/select&gt;&lt;br/&gt;下拉单选 ：&lt;select id=&quot;single&quot;&gt;&lt;option value=&quot;sin1&quot;&gt;sin1&lt;/option&gt;&lt;option value=&quot;sin2&quot;&gt;sin2&lt;/option&gt;&lt;option value=&quot;sin3&quot;&gt;sin3&lt;/option&gt;&lt;/select&gt;&lt;/body&gt;&lt;/body&gt;&lt;/html&gt; attr() 可以设置和获取属性的值，不推荐操作checked，readOnly，selected，disabled等等 还不可以操作非标准的属性，比如自定义属性：abc什么的 prop() 可以设置和获取属性的值，只推荐操作上面不操作的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh_CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;$(function () &#123;//attralert($(&quot;:checkbox:first&quot;).attr(&quot;name&quot;));//获取属性的值$(&quot;:checkbox:first&quot;).attr(&quot;name&quot;,&quot;abc&quot;);alert($(&quot;:checkbox:first&quot;).attr(&quot;checked&quot;));//会返回undefined，但是这个时候没办法判断是没被选还是没有这个属性，所以用到prop()alert($(&quot;:checkbox:first&quot;).prop(&quot;checked&quot;));//返回的是false$(&quot;:checkbox&quot;).prop(&quot;checked&quot;,true);//让所有多选框都选中$(&quot;:checkbox:first&quot;).attr(&quot;abc&quot;,&quot;abcvalue&quot;);//设置自定义属性alert($(&quot;:checkbox:first&quot;).attr(&quot;abc&quot;));//查看自定义属性//&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;body&gt;单选：&lt;input name=&quot;radio&quot; type=&quot;radio&quot; value=&quot;radio1&quot; /&gt;radio1&lt;input name=&quot;radio&quot; type=&quot;radio&quot; value=&quot;radio2&quot; /&gt;radio2&lt;br/&gt;多选：&lt;input name=&quot;checkbox&quot; type=&quot;checkbox&quot; value=&quot;checkbox1&quot; /&gt;checkbox1&lt;input name=&quot;checkbox&quot; type=&quot;checkbox&quot; value=&quot;checkbox2&quot; /&gt;checkbox2&lt;input name=&quot;checkbox&quot; type=&quot;checkbox&quot; value=&quot;checkbox3&quot; /&gt;checkbox3&lt;br/&gt;下拉多选 ：&lt;select id=&quot;multiple&quot; multiple=&quot;multiple&quot; size=&quot;4&quot;&gt; &lt;option value=&quot;mul1&quot;&gt;mul1&lt;/option&gt; &lt;option value=&quot;mul2&quot;&gt;mul2&lt;/option&gt; &lt;option value=&quot;mul3&quot;&gt;mul3&lt;/option&gt; &lt;option value=&quot;mul4&quot;&gt;mul4&lt;/option&gt;&lt;/select&gt;&lt;br/&gt;下拉单选 ：&lt;select id=&quot;single&quot;&gt; &lt;option value=&quot;sin1&quot;&gt;sin1&lt;/option&gt; &lt;option value=&quot;sin2&quot;&gt;sin2&lt;/option&gt; &lt;option value=&quot;sin3&quot;&gt;sin3&lt;/option&gt;&lt;/select&gt;&lt;/body&gt;&lt;/body&gt;&lt;/html&gt; jQuery练习（全选全不选）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; //给全选绑定单击事件 $(&quot;#checkedAllBtn&quot;).click(function()&#123; $(&quot;:checkbox&quot;).prop(&quot;checked&quot;,true);//这个地方checked的属性值是true，且属性名checked也要加双引号 &#125;); //给全不选绑定单击事件 $(&quot;#checkedNoBtn&quot;).click(function()&#123; $(&quot;:checkbox&quot;).prop(&quot;checked&quot;,false); &#125;); //给反选绑定单击事件 $(&quot;#checkedRevBtn&quot;).click(function()&#123; //查询全部球类的复选框 $(&quot;:checkbox[name=&#x27;items&#x27;]&quot;).each(function()&#123; //each方法中这个this就是每一个dom对象，也就是jQuery数组中的一个元素 this.checked=!this.checked; &#125;); //要检查是否满选 //获取球类运动总数 var length=$(&quot;:checkbox[name=&#x27;items&#x27;]&quot;).length; //获取被选中的球类运动总数 var length2=$(&quot;:checkbox[name=&#x27;items&#x27;]:checked&quot;).length; //比较,两种 /* if(length==length2)&#123; $(&quot;#checkedAllBox&quot;).prop(&quot;checked&quot;,true); &#125;*/ $(&quot;#checkedAllBox&quot;).prop(&quot;checked&quot;,length==length2); &#125;); //给提交按钮绑定事件 $(&quot;#sendBtn&quot;).click(function()&#123; $(&quot;:checkbox[name=&#x27;items&#x27;]:checked&quot;).each(function()&#123; alert(this.value); &#125;); &#125;);//给全选或者全不选那个框框榜单机事件$(&quot;#checkedAllBox&quot;).click(function()&#123;//再事件的function函数中，有一个this对象，这个this对象是当前正在响应事件的dom对象$(&quot;:checkbox[name=&#x27;items&#x27;]&quot;).prop(&quot;checked&quot;,this.checked);&#125;);//给全部球类绑定单击事件,让所有框被选上之后也可以让全选框被选$(&quot;[name=items]&quot;).click(function()&#123; var length=$(&quot;:checkbox[name=&#x27;items&#x27;]&quot;).length; //获取被选中的球类运动总数 var length2=$(&quot;:checkbox[name=&#x27;items&#x27;]:checked&quot;).length; $(&quot;#checkedAllBox&quot;).prop(&quot;checked&quot;,length==length2); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form method=&quot;post&quot; action=&quot;&quot;&gt; 你爱好的运动是？&lt;input type=&quot;checkbox&quot; id=&quot;checkedAllBox&quot; /&gt;全选/全不选 &lt;br /&gt; &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;足球&quot; /&gt;足球 &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;篮球&quot; /&gt;篮球 &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;羽毛球&quot; /&gt;羽毛球 &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;乒乓球&quot; /&gt;乒乓球 &lt;br /&gt; &lt;input type=&quot;button&quot; id=&quot;checkedAllBtn&quot; value=&quot;全 选&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;checkedNoBtn&quot; value=&quot;全不选&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;checkedRevBtn&quot; value=&quot;反 选&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;sendBtn&quot; value=&quot;提 交&quot; /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; jQuery 对标签的增删改内部插入 用jQuery对象的方法来操作标签的增删改 appendTo a.appendTo(b) 把a插入到b子元素末尾，成为最后一个子元素 prependTo() a.prependTo(b) 把a插入到b所有子元素之前，成为第一个子元素 外部插入 insertAfter() a.insertAfter(b) 得到ba insertBefore() a.insertBefore(b) 得到ab 替换 replaceWith() a.replaceWith(b) 用b替换掉a replaceAll() a.replaceAll(b) 用a替换掉所有b 删除 remove() a.remove(); 删除a标签 empty() a.empty(); 清空标签里的内容 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh_CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;//$(&quot;&lt;h1&gt;标题&lt;/h1&gt;&quot;).appendTo(&quot;div&quot;);//$(&quot;&lt;h1&gt;标题&lt;/h1&gt;&quot;).prependTo(&quot;div&quot;);//$(&quot;&lt;h1&gt;标题&lt;/h1&gt;&quot;).insertAfter(&quot;div&quot;);//$(&quot;&lt;h1&gt;标题&lt;/h1&gt;&quot;).insertBefore($(&quot;div&quot;));//$(&quot;&lt;h1&gt;标题&lt;/h1&gt;&quot;).replaceWith(&quot;div&quot;);//$(&quot;div&quot;).replaceWith(&quot;&lt;h1&gt;标题&lt;/h1&gt;&quot;);//$(&quot;&lt;h1&gt;标题&lt;/h1&gt;&quot;).replaceAll&quot;div&quot;);//$(&quot;div&quot;).remove();//$(&quot;div&quot;).empty(); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;1234&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; jQuery练习从左到右从右到左 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; select &#123; width: 100px; height: 140px; &#125; div &#123; width: 130px; float: left; text-align: center; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; //实现左边的可以添加到右边 $(function()&#123; $(&quot;button:first&quot;).click(function()&#123;//这个就是叫先找标签select的第一个然后找他后代的所有option中被选中的 $(&quot;select:eq(0) option:selected&quot;).appendTo($(&quot;select:eq(1)&quot;)); &#125;); //实现将左边的全部添加到右边 $(&quot;button:eq(1)&quot;).click(function()&#123; $(&quot;select:eq(0) option&quot;).appendTo($(&quot;select:eq(1)&quot;)); &#125;); //将右边的添加到左边 $(&quot;button:eq(2)&quot;).click(function()&#123;//这个就是叫先找标签select的第一个然后找他后代的所有option中被选中的 $(&quot;select:eq(1) option:selected&quot;).appendTo($(&quot;select:eq(0)&quot;)); &#125;); //将右边的全部添加到左边 $(&quot;button:eq(3)&quot;).click(function()&#123; $(&quot;select:eq(1) option&quot;).appendTo($(&quot;select:eq(0)&quot;)); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;left&quot;&gt; &lt;select multiple=&quot;multiple&quot; name=&quot;sel01&quot;&gt; &lt;option value=&quot;opt01&quot;&gt;选项1&lt;/option&gt; &lt;option value=&quot;opt02&quot;&gt;选项2&lt;/option&gt; &lt;option value=&quot;opt03&quot;&gt;选项3&lt;/option&gt; &lt;option value=&quot;opt04&quot;&gt;选项4&lt;/option&gt; &lt;option value=&quot;opt05&quot;&gt;选项5&lt;/option&gt; &lt;option value=&quot;opt06&quot;&gt;选项6&lt;/option&gt; &lt;option value=&quot;opt07&quot;&gt;选项7&lt;/option&gt; &lt;option value=&quot;opt08&quot;&gt;选项8&lt;/option&gt; &lt;/select&gt; &lt;button&gt;选中添加到右边&lt;/button&gt; &lt;button&gt;全部添加到右边&lt;/button&gt; &lt;/div&gt; &lt;div id=&quot;rigth&quot;&gt; &lt;select multiple=&quot;multiple&quot; name=&quot;sel02&quot;&gt; &lt;/select&gt; &lt;button&gt;选中删除到左边&lt;/button&gt; &lt;button&gt;全部删除到左边&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; jQuery练习，删除添加记录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Untitled Document&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styleB/css.css&quot; /&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; $(&quot;#addEmpButton&quot;).click(function()&#123; //获取输入框的内容 var name=$(&quot;#empName&quot;).val(); var email=$(&quot;#email&quot;).val(); var salary=$(&quot;#salary&quot;).val(); //创建一个行标签对象，添加到显示数据的表格中 var $tobr=$(&quot;&lt;tr&gt;&quot;+ &quot;&lt;td&gt;&quot;+name+&quot;&lt;/td&gt;&quot;+ &quot;&lt;td&gt;&quot;+email+&quot;&lt;/td&gt;&quot;+ &quot;&lt;td&gt;&quot;+salary+&quot;&lt;/td&gt;&quot;+ &quot;&lt;td&gt;&lt;a href=\\&quot;deleteEmp?id=002\\&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt;&quot;+ &quot;&lt;/tr&gt;&quot;); //添加到显示数据的表格中 $tobr.appendTo($(&quot;#employeeTable&quot;)); //这里是每次添加新的信息之后，给他绑定删除事件，防止新添加的这些无法删除 $tobr.find(&quot;a&quot;).click(function()&#123; //在事件响应function的时候会有一个this对象，这个this对象是当前正在响应事件的dom对象 //得到a标签对象的父亲的父亲 var $tbr=$(this).parent().parent(); //获取第一个td标签的内容 var name=$tbr.find(&quot;td:first&quot;).text(); //confirm是js提供的一个确认提示框，你给他传什么它就提示什么，用户点击确定就返回true，点击取消就返回false if(confirm(&quot;你确定要删除&quot;+name+&quot;么&quot;))&#123; $tbr.remove(); &#125; //return false; 可以阻止，元素的默认行为 return false;//可以点击标签时不跳转 &#125;); &#125;); //给删除a标签绑定单机事件 $(&quot;a&quot;).click(function()&#123; //在事件响应function的时候会有一个this对象，这个this对象是当前正在响应事件的dom对象 //得到a标签对象的父亲的父亲 var $tbr=$(this).parent().parent(); //获取第一个td标签的内容 var name=$tbr.find(&quot;td:first&quot;).text(); //confirm是js提供的一个确认提示框，你给他传什么它就提示什么，用户点击确定就返回true，点击取消就返回false if(confirm(&quot;你确定要删除&quot;+name+&quot;么&quot;))&#123; $tbr.remove(); &#125; //return false; 可以阻止，元素的默认行为 return false;//可以点击标签时不跳转 &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;table id=&quot;employeeTable&quot;&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Email&lt;/th&gt; &lt;th&gt;Salary&lt;/th&gt; &lt;th&gt;&amp;nbsp;&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Tom&lt;/td&gt; &lt;td&gt;tom@tom.com&lt;/td&gt; &lt;td&gt;5000&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteEmp?id=001&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Jerry&lt;/td&gt; &lt;td&gt;jerry@sohu.com&lt;/td&gt; &lt;td&gt;8000&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteEmp?id=002&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Bob&lt;/td&gt; &lt;td&gt;bob@tom.com&lt;/td&gt; &lt;td&gt;10000&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteEmp?id=003&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div id=&quot;formDiv&quot;&gt; &lt;h4&gt;添加新员工&lt;/h4&gt; &lt;table&gt; &lt;tr&gt; &lt;td class=&quot;word&quot;&gt;name: &lt;/td&gt; &lt;td class=&quot;inp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;empName&quot; id=&quot;empName&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;word&quot;&gt;email: &lt;/td&gt; &lt;td class=&quot;inp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot; id=&quot;email&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;word&quot;&gt;salary: &lt;/td&gt; &lt;td class=&quot;inp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;salary&quot; id=&quot;salary&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt; &lt;button id=&quot;addEmpButton&quot; value=&quot;abc&quot;&gt; Submit &lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 优化后，封装函数复用的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Untitled Document&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styleB/css.css&quot; /&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; var deleteFun=function()&#123; //在事件响应function的时候会有一个this对象，这个this对象是当前正在响应事件的dom对象 //得到a标签对象的父亲的父亲 var $tbr=$(this).parent().parent(); //获取第一个td标签的内容 var name=$tbr.find(&quot;td:first&quot;).text(); //confirm是js提供的一个确认提示框，你给他传什么它就提示什么，用户点击确定就返回true，点击取消就返回false if(confirm(&quot;你确定要删除&quot;+name+&quot;么&quot;))&#123; $tbr.remove(); &#125; //return false; 可以阻止，元素的默认行为 return false;//可以点击标签时不跳转 &#125;; $(&quot;#addEmpButton&quot;).click(function()&#123; //获取输入框的内容 var name=$(&quot;#empName&quot;).val(); var email=$(&quot;#email&quot;).val(); var salary=$(&quot;#salary&quot;).val(); //创建一个行标签对象，添加到显示数据的表格中 var $tobr=$(&quot;&lt;tr&gt;&quot;+ &quot;&lt;td&gt;&quot;+name+&quot;&lt;/td&gt;&quot;+ &quot;&lt;td&gt;&quot;+email+&quot;&lt;/td&gt;&quot;+ &quot;&lt;td&gt;&quot;+salary+&quot;&lt;/td&gt;&quot;+ &quot;&lt;td&gt;&lt;a href=\\&quot;deleteEmp?id=002\\&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt;&quot;+ &quot;&lt;/tr&gt;&quot;); //添加到显示数据的表格中 $tobr.appendTo($(&quot;#employeeTable&quot;)); //这里是每次添加新的信息之后，给他绑定删除事件，防止新添加的这些无法删除 $tobr.find(&quot;a&quot;).click(deleteFun);&#125;); //给删除a标签绑定单机事件 $(&quot;a&quot;).click(deleteFun); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;table id=&quot;employeeTable&quot;&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Email&lt;/th&gt; &lt;th&gt;Salary&lt;/th&gt; &lt;th&gt;&amp;nbsp;&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Tom&lt;/td&gt; &lt;td&gt;tom@tom.com&lt;/td&gt; &lt;td&gt;5000&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteEmp?id=001&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Jerry&lt;/td&gt; &lt;td&gt;jerry@sohu.com&lt;/td&gt; &lt;td&gt;8000&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteEmp?id=002&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Bob&lt;/td&gt; &lt;td&gt;bob@tom.com&lt;/td&gt; &lt;td&gt;10000&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteEmp?id=003&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div id=&quot;formDiv&quot;&gt; &lt;h4&gt;添加新员工&lt;/h4&gt; &lt;table&gt; &lt;tr&gt; &lt;td class=&quot;word&quot;&gt;name: &lt;/td&gt; &lt;td class=&quot;inp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;empName&quot; id=&quot;empName&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;word&quot;&gt;email: &lt;/td&gt; &lt;td class=&quot;inp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot; id=&quot;email&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;word&quot;&gt;salary: &lt;/td&gt; &lt;td class=&quot;inp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;salary&quot; id=&quot;salary&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt; &lt;button id=&quot;addEmpButton&quot; value=&quot;abc&quot;&gt; Submit &lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; jQuery中css样式操作addClass() 添加样式 removeClass() 删除样式 toggleClass() 有就删除，没有就添加样式 offset() 获取和设置元素的坐标，下面是这个的样例显示 top: 10.777777671813965, left: 118.55555725097656} 这两个参数top是符合条件的标签到浏览器顶上的距离，left是到左边框距离 123div.whiteborder&#123; border: 2px white solid;&#125; 这个div是指这个样式只能给div这个标签使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt; div&#123; width:100px; height:260px; &#125; div.whiteborder&#123; border: 2px white solid; &#125; div.redDiv&#123; background-color: red; &#125; div.blueBorder&#123; border: 5px blue solid; &#125; &lt;/style&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; var $divEle = $(&#x27;div:first&#x27;); $(&#x27;#btn01&#x27;).click(function()&#123; //addClass() - 向被选元素添加一个或多个类 $divEle.addClass(&quot;redDiv blueBorder&quot;); &#125;); $(&#x27;#btn02&#x27;).click(function()&#123; //removeClass() - 从被选元素删除一个或多个类 $divEle.removeClass(&quot;redDiv blueBorder&quot;); //$divEle.removeClass();全部删除 &#125;); $(&#x27;#btn03&#x27;).click(function()&#123; //toggleClass() - 对被选元素进行添加/删除类的切换操作 $divEle.toggleClass(&#x27;redDiv&#x27;); &#125;); $(&#x27;#btn04&#x27;).click(function()&#123; //offset() - 返回第一个匹配元素相对于文档的位置。 var pos=$divEle.offset(); //得到top和left console.log(pos); //还可以自己设置top和left，不一定是自己输入的值，按照当前屏幕大小给的值 $divEle.offset(&#123; top:100, left:50 &#125;); &#125;); &#125;)&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;table align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td&gt; &lt;div class=&quot;border&quot;&gt; &lt;/div&gt; &lt;/td&gt; &lt;td&gt; &lt;div class=&quot;btn&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;addClass()&quot; id=&quot;btn01&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;removeClass()&quot; id=&quot;btn02&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;toggleClass()&quot; id=&quot;btn03&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;offset()&quot; id=&quot;btn04&quot;/&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;/body&gt;&lt;/html&gt; jQuery动画基本动画 show() 将隐藏的元素显示 hide() 将可见的元素隐藏 toggle() 可见就隐藏，不可见就显示 以上动画方法都可以添加参数 这七个函数的参数都是这俩，只有fadeTo是不一样的，因为fadeTo多一个透明度的参数 ​ 1.第一个参数是动画执行的时常，以毫秒为单位 ​ 2.第二个参数是动画的回调函数（动画完成后自动调用的函数） 淡入淡出动画 fadeln() 淡入 慢慢可见 fadeOut() 淡出 慢慢消失 fadeTo() 在指定时常内慢慢的将透明度修改到指定的值 0透明 0.5半透明 1不透明 fadeToggle() 淡入淡出切换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;link href=&quot;css/style.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; /* 基本 show([speed,[easing],[fn]]) hide([speed,[easing],[fn]]) toggle([speed],[easing],[fn]) 滑动 slideDown([spe],[eas],[fn]) slideUp([speed,[easing],[fn]]) slideToggle([speed],[easing],[fn]) 淡入淡出 fadeIn([speed],[eas],[fn]) fadeOut([speed],[eas],[fn]) fadeTo([[spe],opa,[eas],[fn]]) fadeToggle([speed,[eas],[fn]]) */ $(function()&#123; //显示 show() $(&quot;#btn1&quot;).click(function()&#123; $(&quot;#div1&quot;).show(1000,function()&#123; alert(&quot;show动画完成&quot;) &#125;); &#125;); //隐藏 hide() $(&quot;#btn2&quot;).click(function()&#123; $(&quot;#div1&quot;).hide(1000,function()&#123; alert(&quot;hide动画执行完成&quot;) &#125;); &#125;); //切换 toggle() $(&quot;#btn3&quot;).click(function()&#123; $(&quot;#div1&quot;).toggle(1000,function()&#123; alert(&quot;toggle动画执行完成&quot;) &#125;); &#125;); //动画的演示方式，就是不断的调用他自己 /*var abc=function()&#123; $(&quot;#div1&quot;).toggle(1000,abc); &#125; abc();*/ //淡入 fadeIn() $(&quot;#btn4&quot;).click(function()&#123; $(&#x27;#div1&#x27;).fadeIn(2000,function()&#123; alert(&quot;淡入完成&quot;); &#125;); &#125;); //淡出 fadeOut() $(&quot;#btn5&quot;).click(function()&#123; $(&#x27;#div1&#x27;).fadeOut(2000,function()&#123; alert(&quot;淡出完成&quot;); &#125;); &#125;); //淡化到 fadeTo() $(&quot;#btn6&quot;).click(function()&#123; $(&quot;#div1&quot;).fadeTo(2000,0.5,function()&#123; alert(&quot;fadeTo完成&quot;); &#125;); &#125;); //淡化切换 fadeToggle() $(&quot;#btn7&quot;).click(function()&#123; $(&#x27;#div1&#x27;).fadeToggle(2000,function()&#123; alert(&quot;切换完成&quot;); &#125;); &#125;); &#125;)&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;table style=&quot;float: left;&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;button id=&quot;btn1&quot;&gt;显示show()&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button id=&quot;btn2&quot;&gt;隐藏hide()&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button id=&quot;btn3&quot;&gt;显示/隐藏切换 toggle()&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button id=&quot;btn4&quot;&gt;淡入fadeIn()&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button id=&quot;btn5&quot;&gt;淡出fadeOut()&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button id=&quot;btn6&quot;&gt;淡化到fadeTo()&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button id=&quot;btn7&quot;&gt;淡化切换fadeToggle()&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div id=&quot;div1&quot; style=&quot;float:left;border: 1px solid;background-color: blue;width: 300px;height: 200px;&quot;&gt; jquery动画定义了很多种动画效果，可以很方便的使用这些动画效果 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; jQuery动画练习1234.showmore a span &#123; padding-left: 15px; background: url(img/down.gif) no-repeat 0 0;&#125; 这个css选择器的意思是 类选择器 且用这个选择器的标签子代必须有一个a，a的子代必须有一个span 添加cssclass样式的时候既可以用prop也可以用addClass 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;品牌展示练习&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;* &#123; margin: 0; padding: 0;&#125;body &#123; font-size: 12px; text-align: center;&#125;a &#123; color: #04D; text-decoration: none;&#125;a:hover &#123; color: #F50; text-decoration: underline;&#125;.SubCategoryBox &#123; width: 600px; margin: 0 auto; text-align: center; margin-top: 40px;&#125;.SubCategoryBox ul &#123; list-style: none;&#125;.SubCategoryBox ul li &#123; display: block; float: left; width: 200px; line-height: 20px;&#125;.showmore , .showless&#123; clear: both; text-align: center; padding-top: 10px;&#125;.showmore a , .showless a&#123; display: block; width: 120px; margin: 0 auto; line-height: 24px; border: 1px solid #AAA;&#125;.showmore a span &#123; padding-left: 15px; background: url(img/down.gif) no-repeat 0 0;&#125;.showless a span &#123; padding-left: 15px; background: url(img/up.gif) no-repeat 0 0;&#125;.promoted a &#123; color: #F50;&#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function() &#123; //基本初始状态$(&quot;li:gt(5):not(:last)&quot;).hide();//hide是动画操作//给功能的按钮绑定单击事件$(&quot;div div a&quot;).click(function()&#123;$(&quot;li:gt(5):not(:last)&quot;).toggle();//切换回显示//按钮上的文本，1.显示全部品牌，角标向下，文字显示全部品牌if( $(&quot;li:gt(5):not(:last)&quot;).is(&quot;:hidden&quot;))&#123;$(&quot;div div a span&quot;).text(&quot;显示全部品牌&quot;);$(&quot;div div&quot;).removeClass();$(&quot;div div&quot;).addClass(&quot;showmore&quot;);//$(&quot;div div&quot;).prop(&quot;class&quot;,&quot;showmore&quot;);,添加自己定义的css类的时候也可以用prop//高亮取消$(&quot;li:contains(&#x27;索尼&#x27;)&quot;).removeClass(&quot;promoted&quot;);&#125;else&#123;//显示精简品牌，角标向上，且文字是显示精简品牌$(&quot;div div a span&quot;).text(&quot;显示精简品牌&quot;);$(&quot;div div&quot;).removeClass();$(&quot;div div&quot;).addClass(&quot;showless&quot;);//$(&quot;div div&quot;).prop(&quot;class&quot;,&quot;showless&quot;);//高亮取消$(&quot;li:contains(&#x27;索尼&#x27;)&quot;).addClass(&quot;promoted&quot;);&#125;return false;&#125;); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;SubCategoryBox&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;佳能&lt;/a&gt;&lt;i&gt;(30440) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;索尼&lt;/a&gt;&lt;i&gt;(27220) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;三星&lt;/a&gt;&lt;i&gt;(20808) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;尼康&lt;/a&gt;&lt;i&gt;(17821) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;松下&lt;/a&gt;&lt;i&gt;(12289) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;卡西欧&lt;/a&gt;&lt;i&gt;(8242) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;富士&lt;/a&gt;&lt;i&gt;(14894) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;柯达&lt;/a&gt;&lt;i&gt;(9520) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;宾得&lt;/a&gt;&lt;i&gt;(2195) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;理光&lt;/a&gt;&lt;i&gt;(4114) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;奥林巴斯&lt;/a&gt;&lt;i&gt;(12205) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;明基&lt;/a&gt;&lt;i&gt;(1466) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;爱国者&lt;/a&gt;&lt;i&gt;(3091) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;其它品牌相机&lt;/a&gt;&lt;i&gt;(7275) &lt;/i&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;showmore&quot;&gt; &lt;a href=&quot;more.html&quot;&gt;&lt;span&gt;显示全部品牌&lt;/span&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 原生js和jQuery页面加载完成之后的区别$( function(){} ); 和 window.onload &#x3D; function(){} 的区别？ 他们分别是在什么时候触发？ 1、jQuery 的页面加载完成之后是浏览器的内核解析完页面的标签创建好 DOM 对象之后就会马上执行。 2、原生 js 的页面加载完成之后，除了要等浏览器内核解析完标签创建好 DOM 对象，还要等标签显示时需要的内容加载 完成。 他们触发的顺序？ 1、jQuery 页面加载完成之后先执行 2、原生 js 的页面加载完成之后 他们执行的次数？ 1、原生 js 的页面加载完成之后，只会执行最后一次的赋值函数。 2、jQuery 的页面加载完成之后是全部把注册的 function 函数，依次顺序全部执行 jQuery中常用的事件处理方法click() 可以绑定单击事件，以及触发单击事件 mouseover() 鼠标移入事件 mouseout() 鼠标移出事件 bind() 可以给元素一次性绑定一个或多个事件 one() 使用上和bind一样，但是one方法绑定的事件只会触发一次 unbind () 和bind方法相反的操作，解除事件的绑定 live() 也是用来绑定事件的，可以用来绑定选择器匹配的所有元素的事件，哪怕这个元素是后面动态创建出来的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;link href=&quot;css/style.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; //1.通常绑定事件的方式 //3.合并“鼠标移入”和“鼠标移出”事件 //4.合并单击事件 //5.切换元素可见状态 //6.只绑定一次 // 触发事件的讲解 $(&quot;h5&quot;).click(function()&#123;//传function是绑定事件 alert(&quot;h5单击事件&quot;); &#125;); /*$(&quot;button&quot;).click(function()&#123; $(&quot;h5&quot;).click();//不传function是触发事件，就是调用了h5的绑定事件 &#125;);*/ //鼠标移入事件 /*$(&quot;h5&quot;).mouseover(function()&#123; console.log(&quot;你进来了&quot;); &#125;);*/ //鼠标移除事件 /*$(&quot;h5&quot;).mouseout(function()&#123; console.log(&quot;你出来了&quot;); &#125;);*/ //jQuery提供的绑定方式：bind()函数 /*$(&quot;h5&quot;).bind(&quot;click mouseover mouseout&quot;,function()&#123; console.log(&quot;这是bind绑定的事件&quot;); &#125;);*/ //one()函数 /* $(&quot;h5&quot;).one(&quot;click mouseover mouseout&quot;,function()&#123; console.log(&quot;这是one绑定的事件&quot;); &#125;);*/ //unbind()函数,不加参数就全删了 /*$(&quot;h5&quot;).unbind(&quot;click mouseover&quot;);*/ //live()函数 //正常的绑定函数就是只有一开始那个被绑定的标签有效果，现在后来添加的标签依然是有效果的 $(&quot;h5&quot;).live(&quot;click&quot;,function()&#123; alert(&#x27;h5单击事件==live方法绑定&#x27;); &#125;); $(&#x27;&lt;h5 class=&quot;head&quot;&gt;什么是jQuery?&lt;/h5&gt;&#x27;).appendTo($(&quot;#panel&quot;)); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;panel&quot;&gt; &lt;h5 class=&quot;head&quot;&gt;什么是jQuery?&lt;/h5&gt; &lt;div class=&quot;content&quot;&gt; jQuery是继Prototype之后又一个优秀的JavaScript库，它是一个由 John Resig 创建于2006年1月的开源项目。jQuery凭借简洁的语法和跨平台的兼容性，极大地简化了JavaScript开发人员遍历HTML文档、操作DOM、处理事件、执行动画和开发Ajax。它独特而又优雅的代码风格改变了JavaScript程序员的设计思路和编写程序的方式。 &lt;/div&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; jQuery事件的冒泡事件冒泡是指父子元素同时监听一个事件，当触发子元素事件的时候，同一个事件也被传递到了父元素的事件里去响应 在子元素事件函数体内，return false 可以阻止事件的冒泡传递 简单来说就是，如果父子元素绑定同一个事件，子元素的事件被触发的时候，父元素的这个事件也会被触发 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0; padding: 0; &#125; body&#123; font-size: 13px; line-height: 130%; padding: 60px; &#125; #content&#123; width: 220px; border: 1px solid #0050D0; background: #96E555; &#125; span&#123; width: 200px; margin: 10px; background: #666666; cursor: pointer; color: white; display: block; &#125; p&#123; width: 200px; background: #888; color: white; height: 16px; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; $(&quot;#content&quot;).click(function()&#123; alert(&quot;这是div&quot;); &#125;); $(&quot;span&quot;).click(function()&#123; alert(&quot;这是span&quot;); //return false; &#125;); &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;content&quot;&gt; 外层div元素 &lt;span&gt;内层span元素&lt;/span&gt; 外层div元素 &lt;/div&gt; &lt;div id=&quot;msg&quot;&gt;&lt;/div&gt; &lt;br&gt;&lt;br&gt; &lt;a href=&quot;http://www.hao123.com&quot;&gt;WWW.HAO123.COM&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; jQuery事件对象事件对象，是封装有触发的事件信息的一个javascript对象 我们重点关心的是怎么拿到这个javasccript的事件对象 再给元素绑定事件的时候，在事件的function参数列表中添加一个参数，这个event就是javasccript传递参事件处理函数的事件对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt; #areaDiv &#123; border: 1px solid black; width: 300px; height: 50px; margin-bottom: 10px; &#125; #showMsg &#123; border: 1px solid black; width: 300px; height: 20px; &#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; //1.原生javascript获取 事件对象 /*window.onload=function()&#123; document.getElementById(&quot;areaDiv&quot;).onclick=function(event)&#123; console.log(event); &#125; &#125;;*/ //2.JQuery代码获取 事件对象 /*$(function()&#123; $(&quot;#areaDiv&quot;).click(function(event)&#123; console.log(event); &#125;); &#125;);*/ //3.使用bind同时对多个事件绑定同一个函数。怎么获取当前操作是什么事件。 //这个操作可以让bind绑定的多个事件做不一样的事情 $(function()&#123; $(&quot;#areaDiv&quot;).bind(&quot;mouseout mouseover&quot;,function(event)&#123; if(event.type==&quot;mouseover&quot;)&#123; console.log(&quot;鼠标移入&quot;); &#125; else if(event.type==&quot;mouseout&quot;) &#123; console.log(&quot;鼠标移出&quot;); &#125; &#125;); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;areaDiv&quot;&gt;&lt;/div&gt; &lt;div id=&quot;showMsg&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; jQuery练习，图片跟随123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt; body &#123; text-align: center; &#125; #small &#123; margin-top: 150px; &#125; #showBig &#123; position: absolute; display: none; &#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; $(&quot;#small&quot;).bind(&quot;mouseover mouseout mousemove&quot;,function(event)&#123; if(event.type==&quot;mouseover&quot;)&#123; $(&quot;#showBig&quot;).show(); &#125; else if(event.type==&quot;mouseout&quot;)&#123; $(&quot;#showBig&quot;).hide(); &#125; else if(event.type==&quot;mousemove&quot;)&#123; $(&quot;#showBig&quot;).offset(&#123; left:event.pageX+10, top:event.pageY+10 &#125;); &#125; &#125;); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;img id=&quot;small&quot; src=&quot;img/small.jpg&quot; /&gt; &lt;div id=&quot;showBig&quot;&gt; &lt;img src=&quot;img/big.jpg&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 书城项目的第一个阶段表单验证规定了注册时用户名密码的格式，以及错误提示等等， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;尚硅谷会员注册页面&lt;/title&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;../../static/css/style.css&quot; &gt; &lt;script src=&quot;../../static/script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; //1.验证用户名，必须由数字字母下划线组成，并且长度为5到12位 $(&quot;#sub_btn&quot;).click(function()&#123; //1.获取用户名输入框中的内容 var username=$(&quot;#username&quot;).val(); //2.创建正则表达式对象 var pattern=/^\\w&#123;5,12&#125;$/; //3.使用test方法进行验证 if(!pattern.test(username))&#123; $(&quot;span.errorMsg&quot;).text(&quot;用户名不合法&quot;); //有了return false不会跳转 return false; &#125;//2.验证密码 //1.获取用户名输入框中的内容 var password=$(&quot;#password&quot;).val(); //2.创建正则表达式对象 var pspattern=/^\\w&#123;5,12&#125;$/; //3.使用test方法进行验证 if(!pspattern.test(password))&#123; $(&quot;span.errorMsg&quot;).text(&quot;密码不合法&quot;); //有了return false不会跳转 return false; &#125;//3.确认密码 //1.获取确认密码内容 var repassword =$(&quot;#repwd&quot;).val(); if(repassword!=password)&#123; $(&quot;span.errorMsg&quot;).text(&quot;确认密码与密码不一致&quot;); return false; &#125;//4.验证邮箱 //1.获取邮箱当中的内容 var emailText=$(&quot;#email&quot;).val(); var emailpt=/^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]&#123;2,6&#125;)$/; if(!emailpt.test(emailText))&#123; $(&quot;span.errorMsg&quot;).text(&quot;邮箱格式不合法&quot;); return false; &#125;//5.验证码，验证由输入内容即可 var codeText=$(&quot;#code&quot;).val(); //去掉验证码前后空格 codeText=$.trim(codeText); if(codeText==null||codeText==&quot;&quot;)&#123; $(&quot;span.errorMsg&quot;).text(&quot;无验证码&quot;); return false; &#125; $(&quot;span.errorMsg&quot;).text(&quot;&quot;);//如果用户名密码邮箱又合法了再给他改过来&#125;); &#125;); &lt;/script&gt;&lt;style type=&quot;text/css&quot;&gt; .login_form&#123; height:420px; margin-top: 25px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;login_header&quot;&gt; &lt;img class=&quot;logo_img&quot; alt=&quot;&quot; src=&quot;../../static/img/logo.gif&quot; &gt; &lt;/div&gt; &lt;div class=&quot;login_banner&quot;&gt; &lt;div id=&quot;l_content&quot;&gt; &lt;span class=&quot;login_word&quot;&gt;欢迎注册&lt;/span&gt; &lt;/div&gt; &lt;div id=&quot;content&quot;&gt; &lt;div class=&quot;login_form&quot;&gt; &lt;div class=&quot;login_box&quot;&gt; &lt;div class=&quot;tit&quot;&gt; &lt;h1&gt;注册尚硅谷会员&lt;/h1&gt; &lt;span class=&quot;errorMsg&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;form&quot;&gt; &lt;form action=&quot;regist_success.html&quot;&gt; &lt;label&gt;用户名称：&lt;/label&gt; &lt;input class=&quot;itxt&quot; type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; autocomplete=&quot;off&quot; tabindex=&quot;1&quot; name=&quot;username&quot; id=&quot;username&quot; /&gt; &lt;br /&gt; &lt;br /&gt; &lt;label&gt;用户密码：&lt;/label&gt; &lt;input class=&quot;itxt&quot; type=&quot;password&quot; placeholder=&quot;请输入密码&quot; autocomplete=&quot;off&quot; tabindex=&quot;1&quot; name=&quot;password&quot; id=&quot;password&quot; /&gt; &lt;br /&gt; &lt;br /&gt; &lt;label&gt;确认密码：&lt;/label&gt; &lt;input class=&quot;itxt&quot; type=&quot;password&quot; placeholder=&quot;确认密码&quot; autocomplete=&quot;off&quot; tabindex=&quot;1&quot; name=&quot;repwd&quot; id=&quot;repwd&quot; /&gt; &lt;br /&gt; &lt;br /&gt; &lt;label&gt;电子邮件：&lt;/label&gt; &lt;input class=&quot;itxt&quot; type=&quot;text&quot; placeholder=&quot;请输入邮箱地址&quot; autocomplete=&quot;off&quot; tabindex=&quot;1&quot; name=&quot;email&quot; id=&quot;email&quot; /&gt; &lt;br /&gt; &lt;br /&gt; &lt;label&gt;验证码：&lt;/label&gt; &lt;input class=&quot;itxt&quot; type=&quot;text&quot; style=&quot;width: 150px;&quot; id=&quot;code&quot;/&gt; &lt;img alt=&quot;&quot; src=&quot;../../static/img/code.bmp&quot; style=&quot;float: right; margin-right: 40px&quot;&gt; &lt;br /&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot; id=&quot;sub_btn&quot; /&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;bottom&quot;&gt; &lt;span&gt; 尚硅谷书城.Copyright &amp;copy;2015 &lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; XML什么是XML？ xml是可扩展性标记性语言 XML的作用 ​ 1.用来保存数据，而且这些数据具有自我描述性 ​ 2.它还可以做为项目或者模块的配置文件 ​ 3.还可以作为网络传输数据的格式(JSON为主) 示例 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;以上内容就是xml文件的声明version=&quot;1.0&quot; encoding=&quot;utf-8&quot; version表示xml的版本 encoding表示xml文件本身的编码--&gt;&lt;books&gt; &lt;book sb=&quot;SN123412123412&quot;&gt;&lt;!--book表示一个图书信息 sn属性表示图书序列号--&gt; &lt;name&gt;时间监视&lt;/name&gt;&lt;!--name标签表示书名--&gt; &lt;author&gt;霍金&lt;/author&gt;&lt;!--author表示作者--&gt; &lt;price&gt;75&lt;/price&gt;&lt;!--price表示图书价格--&gt; &lt;/book&gt; &lt;book sb=&quot;SN123412123411&quot;&gt;&lt;!--book表示一个图书信息 sn属性表示图书序列号--&gt; &lt;name&gt;java入门&lt;/name&gt;&lt;!--name标签表示书名--&gt; &lt;author&gt;沙老师&lt;/author&gt;&lt;!--author表示作者--&gt; &lt;price&gt;9.9&lt;/price&gt;&lt;!--price表示图书价格--&gt; &lt;/book&gt;&lt;/books&gt; XML文件的写法 1-2 xml 发明的目的： 传输和 存储数据。 **xml 发明的*目的*： *传输和 存储数据。* xml 发明的目的： 传输和 存储数据。 **xml 发明的*目的*： *传输和 存储数据。* xml 不是为了展示数据， html 才是为了展示数据用的。 所有的xml 必须要有一个根节点： 这种写法是错误的 正确的写法： 浏览器展示 第二章： xml的 基本语法。 Xml的头声明， 可以有，也可以省略 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&quot;&quot;&quot;version参数是版本号&quot;&quot;&quot; encoding是编码&lt;!--&lt;a&gt;ddd &lt;b&gt;hh&lt;/a&gt;&lt;/b&gt;--&gt;&quot;&quot;&quot;这里是一个xml文件的一个注释&quot;&quot;&quot;&lt;root&gt; &lt;shuibian&gt;....&lt;/shuibian&gt; &lt;xie&gt;...&lt;/xie&gt;&lt;/root&gt; 标签交叉，在xml 是不允许的。 属性：就是描述这个标签额外的信息。 例子：比如img 标签，必须要有 src属性 。 Img 标签，本身的目的：就是个图片标签 。 Src 属性 的作用是： 告诉你要展示的图片 在哪里 属性规则： 但是在xml中，我们不需要额外的信息进行展示。 因为我们是自定义标签的 。 Html标签，必须要用到属性，因为我们不能自定义html标签。 Xml 中，属性就是鸡肋。 属性，在xml中可以用。但是用的真不多 CDATA的写法 展示效果： DTD简介 1.对xml文件的格式进行约束，保证xml是一个有效的xml 2.dtd可以分为两种，内部dtd(你在写xml代码的时候就把内部dtd写好了)，外部dtd(他是一个外部的单独的dtd文件，需要引入进来) 使用 内部的dtd的定义，语法如下： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--声明dtd--&gt;&lt;!DOCTYPE scores [&lt;!ELEMENT scores (student*)&gt;&lt;!--这里的星号表示出现任意次--&gt;&lt;!ELEMENT student (name,course,score)&gt;&lt;!ATTLIST student id CDATA #REQUIRED&gt;&lt;!ELEMENT name (#PCDATA)&gt;&lt;!ELEMENT score (#PCDATA)&gt;&lt;!ELEMENT course (#PCDATA)&gt;&lt;!--让name标签里面只能写文本而不能写其他的标签之类的--&gt;&lt;!--PCDATA 是会被解析器解析的文本。. 这些文本将被解析器检查实体以及标记。. 文本中的标签会被当作标记来处理，而实体会被展开。. 不过，被解析的字符数据不应当包含任何 &amp; &lt; &gt; 字符；需要使用 &amp; &lt; &gt; 实体来分别替换它们--&gt;&lt;!ENTITY jt &quot;Joe Test&quot;&gt;&lt;!--实例--&gt;&lt;!ENTITY % jtt &quot;Joe Test&quot;&gt;&lt;!--这相当于声明了一个对象，只能在dtd文件中使用,用的时候就是%jjt;--&gt;&lt;scores&gt; &lt;student id=&quot;1&quot;&gt; &lt;name&gt;王同&lt;/name&gt; &lt;course&gt;java&lt;/course&gt; &lt;score&gt;89&lt;/score&gt; &lt;/student&gt; &lt;student id=&quot;2&quot;&gt; &lt;name&gt;李佳&lt;/name&gt; &lt;course&gt;sql&lt;/course&gt; &lt;score&gt;58&lt;/score&gt; &lt;test&gt;&amp;jt;&lt;/test&gt; &lt;!--实例，这里的;不会显示--&gt; &lt;/student&gt;&lt;/scores&gt;]&gt;&lt;!--加入了dtd之后，写xml文件之后就有模板有提示了--&gt; 12345678910111213141516171819202122这就是&lt;!ATTLIST student id CDATA #REQUIRED&gt;条代码的解释基本语法：&lt;!ATTLIST 元素名称 属性名称 属性类型 默认值&gt;上面对id属性的限制的最后一个参数类型有#REQUIRED 表示属性值必须#IMPLIED 表示属性值不是必须的#FIXED value 属性值是固定的值 默认值上面对id属性的限制倒数第二个参数类型有CDATA 字符或数字(en1|en2|……) 枚举类型 ID 属性唯一IDREF 对某个唯一属性进行引用 123456789101112131415&lt;!ELEMENT 元素名称 类别&gt; 或&lt;!ELEMENT 元素名称 (元素内容)&gt;类别：约束标签的内容EMPTY：空标签(#PCDATA)：普通字符串（没有子标签）ANY ： 可以是任何内容（包含子标签）(元素内容)： 标签包含子标签的情况顺序问题：(A,B,C,D): 按顺序依次出现(A|B|C|D): 任意出现一个(枚举式出现) 数量词 + 表示出现一次或者多次，至少一次 ?表示出现0次或1次 *表示出现任意次 外部dtd 1.创建一个外部的dtd文件 这是一个文件的格式 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--声明dtd--&gt;&lt;!ELEMENT scores (student*)&gt;&lt;!--上面的空格是必须要有的--&gt;&lt;!--这里的星号表示出现任意次--&gt;&lt;!ELEMENT student (name,course,score)&gt;&lt;!ATTLIST student id CDATA #REQUIRED&gt;&lt;!ELEMENT name (#PCDATA)&gt;&lt;!ELEMENT score (#PCDATA)&gt;&lt;!ELEMENT course (#PCDATA)&gt; 2.在xml中引入一个外部的dtd文件 1&lt;!DPCTYPE scores SYSTEM “scores.dtd&quot;&gt; 这有的浏览器对其可能不支持 第二个是根标签，scores.dtd是一个要引入的文件，SYSTEM也是必要的 ENTITY的使用实例 关于ENTITY的讲解，在xxe漏洞当中介绍 XML解析技术介绍xml 可扩展的标记语言。 不管是 html 文件还是 xml 文件它们都是标记型文档，都可以使用 w3c 组织制定的 dom 技术来解析 document 对象表示的是整个文档（可以是 html 文档，也可以是 xml 文档） 使用dom4j读取xml文件得到document对象dom4j的使用直接看pdf 被用来解析的xml文件 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;books&gt; &lt;book sn=&quot;SN12341232&quot;&gt; &lt;name&gt;辟邪剑谱&lt;/name&gt; &lt;price&gt;9.9&lt;/price&gt; &lt;author&gt;班主任&lt;/author&gt; &lt;/book&gt; &lt;book sn=&quot;SN12341231&quot;&gt; &lt;name&gt;葵花宝典&lt;/name&gt; &lt;price&gt;99.99&lt;/price&gt; &lt;author&gt;班长&lt;/author&gt; &lt;/book&gt;&lt;/books&gt; 解析xml文件的代码 @Test是指一个测试方法，这个方法使用需要导包导关于junit4的包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import com.atguigu.pojo.Book;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;import org.junit.Test;import java.util.List;import static java.lang.Double.parseDouble;public class Dom4jTest &#123; @Test//是指这是一个测试方法，可以不用主方法来调用 public void test1() throws DocumentException &#123; //创建一个SaxReader输入流，去读取xml配置文件，生成Document对象 SAXReader saxReader=new SAXReader(); Document document = saxReader.read(&quot;src/books.xml&quot;); System.out.println(document); &#125; @Test public void test2() throws DocumentException &#123; //1.读取books.xml文件 SAXReader reader= new SAXReader(); // 2.通过Document对象获取根元素 //在Junit测试中，相对路径是从模块开始的也就是从xml模块开始的，所以路径中第一个是src Document read = reader.read(&quot;src/books.xml&quot;); //3.通过根元素获取book标签对象 Element element = read.getRootElement(); //element()和elements()都是通过标签名查找子元素，elements()返回多个，element()返回一个 List&lt;Element&gt; books = element.elements(&quot;book&quot;); //4.遍历，处理每个book标签转化为Book类 for(Element book:books)&#123; //asXML()把标签对象转换为标签字符串 Element nameElement=book.element(&quot;name&quot;); //getText()获取标签文本内容 String nameText=nameElement.getText(); //直接获取指定标签名的文本内容 String priceText=book.elementText(&quot;price&quot;); String authorText=book.elementText(&quot;author&quot;); //获取属性值 String snValue=book.attributeValue(&quot;sn&quot;); System.out.println(new Book(snValue,nameText,parseDouble(priceText),authorText)); &#125; &#125;&#125; Idea文件结构项目-&gt;模块-&gt;包 src文件夹中放置你的源代码，out目录放置src文件夹里面的java程序 Tomcatjavaweb概念javaweb是指所有通过java语言编写的可以通过浏览器访问的程序的总成称叫javaweb java是基于请求和响应来开发的 什么是请求 请求是指客户端发给服务器发送数据，叫请求request 什么是响应 相应是指服务器给客户端回传数据，叫响应reponse 请求和响应的关系 成对出现的，有请求就有回应 2.Web 资源的分类 web 资源按实现的技术和呈现的效果的不同，又分为静态资源和动态资源两种。 静态资源： html、css、js、txt、mp4 视频 , jpg 图片 动态资源： jsp 页面、Servlet 程序 3.常用的 Web 服务器 Tomcat：由 Apache 组织提供的一种 Web 服务器，提供对 jsp 和 Servlet 的支持。它是一种轻量级的 javaWeb 容器（服务 器），也是当前应用最广的 JavaWeb 服务器（免费）。 Jboss：是一个遵从 JavaEE 规范的、开放源代码的、纯 Java 的 EJB 服务器，它支持所有的 JavaEE 规范（免费）。 GlassFish： 由 Oracle 公司开发的一款 JavaWeb 服务器，是一款强健的商业服务器，达到产品级质量（应用很少）。 Resin：是 CAUCHO 公司的产品，是一个非常流行的服务器，对 servlet 和 JSP 提供了良好的支持， 性能也比较优良，resin 自身采用 JAVA 语言开发（收费，应用比较多）。 WebLogic：是 Oracle 公司的产品，是目前应用最广泛的 Web 服务器，支持 JavaEE 规范， 而且不断的完善以适应新的开发要求，适合大型项目（收费，用的不多，适合大公司）。 Tomcat服务器和Servelet版本的对应关系 Tomcat使用安装 找到你需要用的 Tomcat 版本对应的 zip 压缩包，解压到需要安装的目录即可。 目录介绍bin 专门用来存放 Tomcat 服务器的可执行程序 conf 专门用来存放 Tocmat 服务器的配置文件 lib 专门用来存放 Tomcat 服务器的 jar 包 logs 专门用来存放 Tomcat 服务器运行时输出的日记信息 temp 专门用来存放 Tomcdat 运行时产生的临时数据 webapps 专门用来存放部署的 Web 工程。 work 是 Tomcat 工作时的目录，用来存放 Tomcat 运行时 jsp 翻译为 Servlet 的源码，和 Session 钝化（序列化）的目录 如何启动tomcat服务器 找到 Tomcat 目录下的 bin 目录下的 startup.bat 文件，双击，就可以启动 Tomcat 服务器 另一种启动Tomcat服务器的方式 1、打开命令行 2、cd 到 你的 Tomcat 的 bin 目录下 3、敲入启动命令： catalina ru 直接在命令行里输入D:就可以进入D盘 Tomcat的停止1、点击 tomcat 服务器窗口的 x 关闭按钮 2、把 Tomcat 服务器窗口置为当前窗口，然后按快捷键 Ctrl+C 3、找到 Tomcat 的 bin 目录下的 shutdown.bat 双击，就可以停止 Tomcat 服务器 如何修改Tomcat默认的端口号Mysql 默认的端口号是：3306 Tomcat 默认的端口号是：8080 找到 Tomcat 目录下的 conf 目录，找到 server.xml 配置文件。 修改port属性来修改服务器端口 如何把web工程部署到tomcat服务器中第一种方法：只需要把web工程的目录拷贝到Tomcat服务器的webapps目录下即可 第二种方法 123http://localhost:8080/abc/index.html 这个xml文件名和那个path不一定非得一样，且这个xml文件在变成xml文件之前必须是UTF-8的记事本文件，然后改名为xml文件 1.让txt文件变成html文件被访问的时候，用ANSI编码格式，否则会出现乱码 Tomcat中创建动态的web工程csdn中记载那样创建 先创建一个java模块，然后右键java模块找到add framework support 再在WEB-INF目录里创建lib目录，存放jar包，将jar复制进去之后，右键jar包，选add as libray Application server 是自己找到那个自己的Tomcat 如何在 IDEA 中部署工程到 Tomcat 上运行看pdf文件即可 如何给Tomcat添加第三方jar包看pdf即可 Servlet路径 什么是·Servlet 1.Servlet是javaEE规范之一，规范就是接口 2.Servlet是javaweb三大组件之一，三大组件分别是servlet程序，filter过滤器，listener监听器 3.Servlet是运行在服务器上的Java小程序，它可以接受客户端发送过来的请求，并响应数据给客户端 手动实现Servlet程序1.编写一个类去实现Servlet接口 2.实现service方法，处理请求，并响应数据 3.到web.xml中配置servlet程序的访问地址 实现servlet接口的程序 12345678910111213141516171819202122232425262728293031package com.atguigu.servlet;import javax.servlet.*;import java.io.IOException;public class HelloServlet implements Servlet &#123; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; /*service方法是专门用来处理请求和响应的*/ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println(&quot;hello servlet访问了&quot;); &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; &#125;&#125; web.xml文件 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;!--servlet标签给Tomcat配置Servlet程序--&gt; &lt;servlet-name&gt; HelloServlet &lt;!--这个名字一般是和类名一样的，但也是别名可以不同，但一定要和下面的servlet-mapping中的name相同，servlet-class是必须和真实类名相同的--&gt; &lt;/servlet-name&gt; &lt;!--servlet-class是Servlet程序的全类名--&gt; &lt;servlet-class&gt; com.atguigu.servlet.HelloServlet &lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;!--servlet-name标签的作用是告诉服务器，我当前配置的地址给那个Servlet程序使用--&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!--servlet-name标签的作用是告诉服务器，我当前配置的地址给那个Servlet程序使用--&gt; &lt;!-- url-pattern标签配置访问地址 / 斜杠在服务器解析的时候，表示地址为http://ip:port/工程路径 /hello 表示地址为:http://ip:port/工程路径/hello --&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;!--这里的这个hello最好是和servlet的名字有点联系，一眼能看出--&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 运行tomcat实例之后，在url后面添加&#x2F;hello就可以访问到这个HelloServlet程序，也就是调用了上面java代码中的service方法 常见的错误 url地址如何定位servlet程序去访问的 Servlet的生命周期一个servlet的执行顺序 1.执行Servlet构造器方法 2.执行init初始化方法 第一二步是在第一次方法的时候创建Servlet程序会调用，就是如果刷新页面再次访问不会再执行1，2 3.执行service方法 每次访问都会调用，每次刷新页面再次访问就会调用 4.执行destroy方法 第四步，在web工程停止的时候会调用 四个方法实现的演示 1234567891011121314151617181920212223242526272829303132333435package com.atguigu.servlet;import javax.servlet.*;import java.io.IOException;public class HelloServlet implements Servlet &#123; public HelloServlet() &#123; System.out.println(&quot;1 构造器方法&quot;); &#125; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; System.out.println(&quot;2.ini方法&quot;); &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; /*service方法是专门用来处理请求和响应的*/ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println(&quot;3 service===hello servlet访问了&quot;); &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; System.out.println(&quot;4.destroy方法&quot;); &#125;&#125; 12345启动服务器之后，访问http://localhost:8080/ab/hello结果：1 构造器方法 2.ini方法 3 service===hello servlet访问了 Servlet请求的分发处理1在模块文件夹下的html文件，可以通过http://localhost:8080/servlet/a.html访问 a.html前面的都是工程路径 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://localhost:8080/servlet/hello&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; method可以有post和get，对应不同的操作，所以应该对Servlet程序进行改良 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.atguigu.servlet;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;public class HelloServlet implements Servlet &#123; public HelloServlet() &#123; System.out.println(&quot;1 构造器方法&quot;); &#125; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; System.out.println(&quot;2.ini方法&quot;); &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; /*service方法是专门用来处理请求和响应的*/ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; //类型转换，HttpServletRequest是ServletRequest的子接口，Servlet没有getMethod方法 HttpServletRequest httpServletRequest= (HttpServletRequest) servletRequest; //获取请求的方式 String method = httpServletRequest.getMethod(); if(&quot;GET&quot;.equals(method))&#123; System.out.println(&quot;get请求&quot;); &#125; else if(&quot;POST&quot;.equals(&quot;post请求&quot;))&#123; System.out.println(&quot;post请求&quot;); &#125; &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; System.out.println(&quot;4.destroy方法&quot;); &#125;&#125; 一个方法中又执行get又执行post不太好，将这两个方法分开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.atguigu.servlet;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;public class HelloServlet implements Servlet &#123; public HelloServlet() &#123; System.out.println(&quot;1 构造器方法&quot;); &#125; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; System.out.println(&quot;2.ini方法&quot;); &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; /*service方法是专门用来处理请求和响应的*/ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; //类型转换，HttpServletRequest是ServletRequest的子接口，Servlet没有getMethod方法 HttpServletRequest httpServletRequest= (HttpServletRequest) servletRequest; //获取请求的方式 String method = httpServletRequest.getMethod(); if(&quot;GET&quot;.equals(method))&#123; doGet(); &#125; else if(&quot;POST&quot;.equals(&quot;post请求&quot;))&#123; doPost(); &#125; &#125; public void doGet()&#123; System.out.println(&quot;get请求&quot;); System.out.println(&quot;get请求&quot;); System.out.println(&quot;get请求&quot;); System.out.println(&quot;get请求&quot;); System.out.println(&quot;get请求&quot;); &#125; public void doPost()&#123; System.out.println(&quot;post请求&quot;); System.out.println(&quot;post请求&quot;); System.out.println(&quot;post请求&quot;); System.out.println(&quot;post请求&quot;); System.out.println(&quot;post请求&quot;); &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; System.out.println(&quot;4.destroy方法&quot;); &#125;&#125; 通过继承HttpServlet实现Servlet程序一般在实际项目中，都是使用继承HttpServlet类的方式去实现Servlet程序 1.编写一个类去继承 HttpServlet类 2.根据业务需要重写doGet或者doPost方法 3.到web.xml中配置Servlet程序的访问地址 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://localhost:8080/servlet/hello2&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class HelloServlet2 extends HttpServlet &#123; /* doGet()方法在Get请求的时候调用 doPost()方法在Post请求的时候调用 */ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;helloservlet2 doget&quot;); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;helloservlet2 dopost&quot;); &#125;&#125; 使用IDEA菜单生成Servlet程序整个Servlet类的继承体系 ServletConfig类ServletConfig从类名上看，就是Servlet程序的配置信息类 servlet程序和servletConfig对象都是由Tomcat负责创建，我们负责使用 Servlet程序默认是第一次访问的时候创建，ServletConfig是每个Servlet程序创建的时候，就创建一个对应的ServletConfig对象 三大作用 1.可以获取Servlet的别名额就是servlet-name的值 2.获取初始化参数init-param 3.获取servletContext对象 init方法体现了ServletConfig的三大作用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.atguigu.servlet;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;public class HelloServlet implements Servlet &#123; public HelloServlet() &#123; System.out.println(&quot;1 构造器方法&quot;); &#125; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; System.out.println(&quot;2.ini方法&quot;); // 1.可以获取Servlet的别名额就是servlet-name的值System.out.println(&quot;servlet的别名是:&quot;+servletConfig.getServletName()); //2.获取初始化参数init-paramSystem.out.println(&quot;初始化参数username的值为&quot;+servletConfig.getInitParameter(&quot;username&quot;));System.out.println(&quot;初始化参数password的值为&quot;+servletConfig.getInitParameter(&quot;password&quot;)); //3.获取servletContext对象 System.out.println(servletConfig.getServletContext()); &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; /*service方法是专门用来处理请求和响应的*/ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; //类型转换，HttpServletRequest是ServletRequest的子接口，Servlet没有getMethod方法 HttpServletRequest httpServletRequest= (HttpServletRequest) servletRequest; //获取请求的方式 String method = httpServletRequest.getMethod(); if(&quot;GET&quot;.equals(method))&#123; doGet(); &#125; else if(&quot;POST&quot;.equals(&quot;post请求&quot;))&#123; doPost(); &#125; &#125; public void doGet()&#123; System.out.println(&quot;get请求&quot;); System.out.println(&quot;get请求&quot;); System.out.println(&quot;get请求&quot;); System.out.println(&quot;get请求&quot;); System.out.println(&quot;get请求&quot;); &#125; public void doPost()&#123; System.out.println(&quot;post请求&quot;); System.out.println(&quot;post请求&quot;); System.out.println(&quot;post请求&quot;); System.out.println(&quot;post请求&quot;); System.out.println(&quot;post请求&quot;); &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; System.out.println(&quot;4.destroy方法&quot;); &#125;&#125; 每个Servlet程序对应一个ServletConfig对象，所以不可能在HelloServlet2中获得的ServletConfig对象来获取给HelloServlet1配置的信息 1234567891011121314151617181920212223242526272829303132package com.atguigu.servlet;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class HelloServlet2 extends HttpServlet &#123; /* doGet()方法在Get请求的时候调用 doPost()方法在Post请求的时候调用 */ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;helloservlet2 doget&quot;); //可以使用getServletConfig()方法来获得servletConfig对象 ServletConfig servletConfig=getServletConfig(); System.out.println(servletConfig); System.out.println(&quot;初始化参数username的值为&quot;+servletConfig.getInitParameter(&quot;username&quot;)); System.out.println(&quot;初始化参数password的值为&quot;+servletConfig.getInitParameter(&quot;password&quot;)); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;helloservlet2 dopost&quot;); &#125;&#125; 重写Servlet程序的init方法的时候一定要就是调用它父类的init方法 123456789public class HelloServlet2 extends HttpServlet &#123; //重写init程序的时候必须有这个super.init(config) @Override public void init(ServletConfig config) throws ServletException &#123; super.init(config);//调用父类的init方法才能让this.config获值 System.out.println(&quot;重写了init初始化方法，做了一些工作&quot;); &#125; /* ServletContext类1.ServletContext是一个接口，它表示servlet上下文对象 2.一个web工程只有一个ServletConText对象实例，不管调用getServletContext()几次，得到的都是一个ServletContext对象 3.ServletContext对象是一个域对象 4.ServletContext是在web工程部署启动的时候创建，在web工程停止的时候销毁 重新部署或者重启服务器之后，存储的数据就会消失 什么是域对象 域对象是可以象Map一样存储数据的对象，叫域对象 这里的域指的是存储数据的操作范围，整个web工程 ​ 存数据 取数据 删除数据 Map put() get() remove() 域对象 setAttribute() getAttribute() removeAttribute() ServletContext类的四个作用 1.获取web.xml中配置的上下文参数context.param 2.获取当前的工程路径，格式:&#x2F;工程路径 3.获取工程部署后在服务器硬盘上的绝对路径 4.像Map一样存储数据 当正常在网址栏输入网址访问基本都是get请求 以下路径是IDEA整合Tomcat之后，Tomcat被拷贝的一些副本内容 C:\\Users#赵梓皓&amp;\\AppData\\Local\\JetBrains\\IntelliJIdea2020.3\\tomcat\\cc813db2-dbda-4294-89c0-505f477c0964 1D:\\IDEAjava工程\\javaweb\\out\\artifacts\\servlet_war_exploded\\ 这个就是项目部署之后在磁盘中的位置 servlet:war exploded就是一个文件夹，里面是项目中的web文件夹中的内容 前三个功能 1234567891011121314151617181920212223242526272829package com.atguigu.servlet;import javax.servlet.ServletConfig;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class ContextServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.获取web.xml中配置的上下文参数context.param ServletContext context= getServletConfig().getServletContext(); String username=context.getInitParameter(&quot;username&quot;); System.out.println(&quot;context-param参数username是&quot;+username); System.out.println(&quot;context-param参数password是&quot;+context.getInitParameter(&quot;password&quot;)); //2.获取当前的工程路径，格式:/工程路径System.out.println(&quot;当前工程的路径&quot;+context.getContextPath()); //3.获取工程部署后在服务器硬盘上的绝对路径 // 斜杠 被服务器解析地址为http://ip:port/工程名/ 映射到IDEA代码的web目录 //就是得到的这个地址访问之后就是web目录下的东西 System.out.println(&quot;工程部书之后的路径&quot;+context.getRealPath(&quot;/&quot;)); //获取web目录下的其他文件的绝对路径 System.out.println(&quot;工程下css目录的绝对路径是&quot;+context.getRealPath(&quot;/css&quot;)); System.out.println(&quot;工程目录下imgs目录1.jpg的绝对路径是&quot;+context.getRealPath(&quot;/imgs/1.jpg&quot;)); &#125;&#125; 第四个功能.像Map一样存储数据， ContextServlet1和ContextServlet2只要有一个存了key1的值，另一个也能获取key1的值，但重新部署或者重启服务器数据就消失了 ContextServlet1 1234567891011121314151617181920212223242526272829package com.atguigu.servlet;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class ContextServlet1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取ServletContext对象 ServletContext context = getServletContext(); //打印context的地址看两个Servlet中的地址相不相同 System.out.println(context); System.out.println(&quot;保存之前：Context1获取key1的值是&quot;+context.getAttribute(&quot;key1&quot;)); context.setAttribute(&quot;key1&quot;,&quot;value&quot;); System.out.println(&quot;context1中获取域数据key1的值为&quot;+context.getAttribute(&quot;key1&quot;)); System.out.println(&quot;context1中获取域数据key1的值为&quot;+context.getAttribute(&quot;key1&quot;)); System.out.println(&quot;context1中获取域数据key1的值为&quot;+context.getAttribute(&quot;key1&quot;)); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; &#125;&#125; ContextServlet2 123456789101112131415161718package com.atguigu.servlet;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class ContextServlet2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException&#123; ServletContext context = getServletContext(); System.out.println(context); System.out.println(&quot;Context2中获取域数据key1的值是&quot;+context.getAttribute(&quot;key1&quot;)); &#125;&#125; 两个文件中context地址相同 org.apache.catalina.core.ApplicationContextFacade@467b6a76 org.apache.catalina.core.ApplicationContextFacade@467b6a76 HTTP协议请求的HTTP协议协议是指双方或者多方约定好，大家都需要遵守的规则，叫协议 所谓HTTP协议就是指，客户端和服务器之间通信时，发送的数据需要遵守的规则，叫http协议 HTTP 协议中的数据又叫报文。 客户端给服务器发送数据叫请求。 服务器给客户端回传数据叫响应。 请求又分为 GET 请求，和 POST 请求两种 GET 请求 getpost都会对url进行url编码 1、请求行(报文行) (1) 请求的方式 GET (2) 请求的资源路径[+?+请求参数] (3) 请求的协议的版本号 HTTP&#x2F;1.1 2、请求头(报文头) key : value 组成 不同的键值对，表示不同的含义 ii. POST 请求 1、请求行 (1)请求的方式 POST (2) 请求的资源路径[+?+请求参数] (3) 请求的协议的版本号 HTTP&#x2F;1.1 2、 2.请求头 key : value 不同的请求头，有不同的含义 空行(请求头和请求体之间有空行) 3、请求体 &#x3D;&#x3D;&#x3D;&gt;&gt;&gt; 就是发送给服务器的数据 iii. 常用请求头的说明 Accept: 表示客户端可以接收的数据类型 Accpet-Languege: 表示客户端可以接收的语言类型 User-Agent: 表示客户端浏览器的信息 Host： 表示请求时的服务器 ip 和端口 iv. 哪些是 GET 请求，哪些是 POST 请求 GET 请求有哪些： 1、form 标签 method&#x3D;get 2、a 标签 3、link 标签引入 css 4、Script 标签引入 js 文件 5、img 标签引入图片 6、iframe 引入 html 页面 7、在浏览器地址栏中输入地址后敲回车 POST 请求有哪些： 8、form 标签 method&#x3D;post 响应的 HTTP 协议格式1、响应行 (1) 响应的协议和版本号 HTTP&#x2F;1.1 ​ (2) 响应状态码 200 ​ (3) 响应状态描述符 2、响应头 (1) key : value 不同的响应头，有其不同含义 空行 3、响应体 —-&gt;&gt;&gt; 就是回传给客户端的数 常见的响应码 200 表示请求成功 302 表示请求重定向（明天讲） 404 表示请求服务器已经收到了，但是你要的数据不存在（请求地址错误） 500 表示服务器已经收到请求，但是服务器内部错误（代码错误） MIME 类型说明 MIME 是 HTTP 协议中数据类型。 MIME 的英文全称是”Multipurpose Internet Mail Extensions” 多功能 Internet 邮件扩充服务。MIME 类型的格式是“大类型&#x2F;小 类型”，并与某一种文件的扩展名相对应 ServletRequest每次只要有请求进入，tomcat服务器就会把请求过来的HTTP协议信息解析好封装到request对象中。 然后传递到service方法，也含有doget dopost方法中给我们使用。我们可以通过HttpServletRequest对象，获取到所有请求的信息 HttpServletRequest 类的常用方法i. getRequestURI() 获取请求的资源路径 ii. getRequestURL() 获取请求的统一资源定位符（绝对路径） iii. getRemoteHost() 获取客户端的 ip 地址 iv. getHeader() 获取请求头 v. getParameter() 获取请求的参数 vi. getParameterValues() 获取请求的参数（多个值的时候使用） vii. getMethod() 获取请求的方式 GET 或 POST viii. setAttribute(key, value); 设置域数据 ix. getAttribute(key); 获取域数据 x. getRequestDispatcher() 获取请求转发对象 1234567891011121314151617181920212223242526272829package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class RequestAPIServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // i. getRequestURI() 获取请求的资源路径System.out.println(&quot;url=&gt;&quot;+req.getRequestURI()); //ii. getRequestURL() 获取请求的统一资源定位符（绝对路径）System.out.println(&quot;ulr=&gt;&quot;+req.getRequestURL()); //iii. getRemoteHost() 获取客户端的 ip 地址System.out.println(&quot;客户端 ip 地址&quot;+req.getRemoteHost());/*在IDEA中，使用使用localhost访问时，得到的客户端ip地址是127.0.0.1在IDEA中，使用使用127.0.0.1访问时，得到的客户端ip地址是127.0.0.1在IDEA中，使用使用真实ip访问时，得到的客户端ip地址是真实ip */ //iv. getHeader() 获取请求头System.out.println(&quot;请求头&quot;+req.getHeader(&quot;User-Agent&quot;)); //vii. getMethod() 获取请求的方式 GET 或 POST System.out.println(&quot;请求的方式&quot;+req.getMethod()); &#125;&#125; Servlet获取请求的参数值用来发送参数的form表单 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://localhost:8086/servlet2/parameterServlet&quot; method=&quot;get&quot;&gt; 用户名 &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt; 密码 &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br/&gt; 兴趣爱好 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;cpp&quot;&gt;c++ &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;java&quot;&gt;java &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;javascript&quot;&gt;javascript&lt;br/&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Arrays;public class ParameterServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求的参数，用name属性的值来作为参数获取 System.out.println(req.getParameter(&quot;username&quot;)); System.out.println(req.getParameter(&quot;password&quot;));//获取有多个参数的请求String []hobby=req.getParameterValues(&quot;hobby&quot;);System.out.println(Arrays.toString(hobby)); &#125;&#125; 解决post请求中的中文乱码问题 req.setCharacterEncoding(“UTF-8”); 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://localhost:8086/servlet2/parameterServlet&quot; method=&quot;post&quot;&gt; 用户名 &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt; 密码 &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br/&gt; 兴趣爱好 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;cpp&quot;&gt;c++ &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;java&quot;&gt;java &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;javascript&quot;&gt;javascript&lt;br/&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Arrays;public class ParameterServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求的参数，用name属性的值来作为参数获取 System.out.println(req.getParameter(&quot;username&quot;)); System.out.println(req.getParameter(&quot;password&quot;));//获取有多个参数的请求String []hobby=req.getParameterValues(&quot;hobby&quot;);System.out.println(Arrays.toString(hobby)); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置请求体的字符集为UTF-8，从而解决post请求的中文乱码问题 //这个方法只有在所有获取请求参数方法之前调用才有效 req.setCharacterEncoding(&quot;UTF-8&quot;); System.out.println(&quot;=-----post----&quot;); //获取请求的参数，用name属性的值来作为参数获取 System.out.println(req.getParameter(&quot;username&quot;)); System.out.println(req.getParameter(&quot;password&quot;));//获取有多个参数的请求 String []hobby=req.getParameterValues(&quot;hobby&quot;); System.out.println(Arrays.toString(hobby)); &#125;&#125; 请求的转发什么是请求的转发? 请求转发是指，服务器收到请求后，从一次资源跳转到另一个资源的操作叫请求转发 请求转发的特点第四条 如果form.html在WEB-INF目录下无法通过http://localhost:8086/servlet2/WEB-INF/form.html访问 但可以通过请求转发访问 下面两种都可以，第一个是绝对路径，第二个是相对路径 1RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;/WEB-INF/form.html&quot;); 1RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;WEB-INF/form.html&quot;); 在web中 &#x2F;斜杠就代表http://ip:port/工程名/ 可以映射到web目录下，可以在后面直接加web目录中的资源访问，但不能直接访问 WEB-INF目录中的资源 这是实现图片中的请求转发的步骤 servlet1 1234567891011121314151617181920212223242526272829303132package com.atguigu.servlet;import javafx.scene.control.TextInputControl;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class servlet1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求参数，(办事的材料)查看 //这个参数也可以用get传参直接传 String username=req.getParameter(&quot;username&quot;); System.out.println(&quot;在servlet1柜台中查看参数(材料)&quot;+username); //给材料盖一个章，并传递到servlet2柜台二去查看 req.setAttribute(&quot;key&quot;,&quot;柜台1的章&quot;); /* 请求转发必须要以斜杠打头，斜杠表示地址为：http://ip:port/工程名/ ,映射到IDEA代码的web目录，然后在后面加这个servlet文件名即可 */ //问路servlet2(柜台二在哪) RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;/servlet2&quot;); //走向servlet2，柜台二 requestDispatcher.forward(req,resp); &#125;&#125; servlet2 1234567891011121314151617181920212223package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class servlet2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求参数，(办事的材料)查看 String username=req.getParameter(&quot;username&quot;); System.out.println(&quot;在servlet1柜台中查看参数(材料)&quot;+username); //查看柜台1 是否有盖章 Object key = req.getAttribute(&quot;key&quot;); System.out.println(&quot;柜台一是否有章&quot;+key); //处理自己的业务 System.out.println(&quot;servlet2处理自己的业务&quot;); &#125;&#125; 关于重定向以及javaweb的路径补充服务器对服务器(请求转发)发起请求：(也叫服务器对斜杠&#x2F;进行解析的时候) 绝对路径：&#x2F; 斜杠代表的是项目根目录 也就是http://ip:port/工程名， 可以映射到web目录下，后面直接跟web目录下内容，除了WEB-INF 浏览器对服务器(重定向)发起请求：(也叫浏览器对斜杠&#x2F;进行解析的时候) 绝对路径：&#x2F; 斜杠代表的是tomcat根目录，也就是http://ip:port 需要自己去加工程名 当这种&#x2F;表示tomcat根目录的时候，绝对路径开头的 &#x2F;工程名 就是自己设置的那个 而不是文件名 不管是哪个相对路径都是看相对位置 这个就是规定了工程的目录 也就是http://ip:port/servlet2 请求转发路径解释： 这个是web.xml文件中规定的Servlet文件的访问路径 等于是在web文件夹中创立一个contextservlet2文件，这也为什么http://ip:port/servlet2/contextservlet2能访问到servlet文件的原因 请求转发 这个地方用servlet2是因为这可以用相对路径，他们访问路径都在web目录下 也可以用&#x2F;servlet2 这是绝对路径，因为servlet2访问路径在web目录下 如果是web文件下有这个form.html文件也可以就是通过请求转发访问 下面两种都可以 1RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;form.html&quot;); 1RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;/form.html&quot;); base标签的作用即使文件加上了base标签，也可以使用绝对路径 错误演示 c.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;这是a下的b下的c.html页面&lt;a href=&quot;/servlet2/index.html&quot;&gt;跳回首页&lt;/a&gt;&lt;a href=&quot;../../index.html&quot;&gt;跳回首页&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 这两个a标签中的地址都是index.html的地址一个是相对路径一个是绝对路径 这里因为是浏览器向服务器发起请求所以这里的绝对路径 &#x2F; 斜杠代表的是http://ip:port/ 访问到工程名默认的是访问web文件下的名为index的html或者js的文件 index.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;这是web下的index.html&lt;a href=&quot;a/b/c.html&quot;&gt;a/b/c.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://localhost:8086/servlet2/ForwardC&quot;&gt; 请求转发&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 第二个a标签利用请求转发跳转，是无法在c.html回到首页的 正确版本 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--base标签设置页面相对路径工作时参照的地址 href 属性就是参数的地址值 --&gt;&lt;/head&gt;&lt;body&gt;这是a下的b下的c.html页面&lt;a href=&quot;/servlet2/index.html&quot;&gt;跳回首页&lt;/a&gt;&lt;a href=&quot;../../index.html&quot;&gt;跳回首页&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; http://localhost:8080/servlet2/a/b/c.html就是这个文件中的所有相对路径的地址都是参照这个路径的 HttpServletResponse作用 HttpServletResponse 类和 HttpServletRequest 类一样。每次请求进来，Tomcat 服务器都会创建一个 Response 对象传递给 Servlet 程序去使用。 HttpServletRequest 表示请求过来的信息，HttpServletResponse 表示所有响应的信息， 我们如果需要设置返回给客户端的信息，都可以通过 HttpServletResponse 两个输出流说明字节流 getOutputStream() 常用于下载，传递二进制数据 字符流 getWriter() 常用于回传字符串(常用) 两个流同时只能使用一个，使用了字节流，就不能再使用字符流，否则就会报错 如何往客户端回传数据要求：往客户端回传字符串数据以及中文乱码的解决方案（将服务器和浏览器统一编码） 1234567891011121314151617181920212223242526package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class ResponseIOServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //查看相应的字符集 默认ISO-8859-1 System.out.println(resp.getCharacterEncoding()); //设置服务器字符集为UTF-8 resp.setCharacterEncoding(&quot;UTF-8&quot;); //同时要自己去改变浏览器的字符集，改为UTF-8 resp.setHeader(&quot;Content-Type&quot;,&quot;text/html;charset=UTF-8&quot;); //要求：往客户端回传字符串数据 PrintWriter writer=resp.getWriter(); writer.write(&quot;我很帅&quot;); &#125;&#125; 第二种解决中文乱码的方案 123456789101112131415161718192021package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class ResponseIOServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //它会同时设置服务器和客户端都使用UTF-8字符集，还设置了响应头 //此方法一定要在获取流之前时使用才有效 resp.setContentType(&quot;text/html; charset=UTF-8&quot;); System.out.println(resp.getCharacterEncoding()); //要求：往客户端回传字符串数据 PrintWriter writer=resp.getWriter(); writer.write(&quot;我很帅&quot;); &#125;&#125; Servlet请求重定向请求重定向，是指客户端给服务器发请求，然后服务器告诉客户端说。我给你一些地址。你去新地址访问。叫请求 重定向（因为之前的地址可能已经被废弃） 重点：两个servlet之间不共享Request域中的数据 其实就是当用HttpServletResponse的setAttribute()方法是不能把把存储的数据给多个Servlet获取的，但ServletContext可以 response1重定向到response2的解析 response1 1234567891011121314151617181920package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class response1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;曾到此一游 Response1&quot;); req.setAttribute(&quot;key&quot;,&quot;value1&quot;); //设置响应状态码，表示重定向(已搬迁) resp.setStatus(302); //设置响应头，说明新的地址在哪里 resp.setHeader(&quot;Location&quot;,&quot;http://localhost:8086/servlet2/response2&quot;); &#125;&#125; response2 123456789101112131415package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class response2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(req.getAttribute(&quot;key&quot;)); resp.getWriter().write(&quot;response2 result&quot;); &#125;&#125; response1重定向到form.html的解析 错误案例：不能够重定向到WEB-INF下的form.html文件 因为重定向也就是第二次的地址是用来浏览器向服务器发起请求，WEB-INF中的文件受保护所以不行 1234567891011121314151617181920package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class response1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;曾到此一游 Response1&quot;); req.setAttribute(&quot;key&quot;,&quot;value1&quot;); //设置响应状态码，表示重定向(已搬迁) resp.setStatus(302); //设置响应头，说明新的地址在哪里 resp.setHeader(&quot;Location&quot;,&quot;http://localhost:8086/WEB-INF/form.html&quot;); &#125;&#125; 正确案例：访问web目录下的form.html 新地址使用绝对路径的方法，下面两个都是绝对路径 1234567891011121314151617181920package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class response1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;曾到此一游 Response1&quot;); req.setAttribute(&quot;key&quot;,&quot;value1&quot;); //设置响应状态码，表示重定向(已搬迁) resp.setStatus(302); //设置响应头，说明新的地址在哪里 resp.setHeader(&quot;Location&quot;,&quot;http://localhost:8086/servlet2/form.html&quot;); &#125;&#125; 1234567891011121314151617181920package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class response1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;曾到此一游 Response1&quot;); req.setAttribute(&quot;key&quot;,&quot;value1&quot;); //设置响应状态码，表示重定向(已搬迁) resp.setStatus(302); //设置响应头，说明新的地址在哪里 resp.setHeader(&quot;Location&quot;,&quot;/servlet2/form.html&quot;); &#125;&#125; 相对路径 1234567891011121314151617181920package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class response1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;曾到此一游 Response1&quot;); req.setAttribute(&quot;key&quot;,&quot;value1&quot;); //设置响应状态码，表示重定向(已搬迁) resp.setStatus(302); //设置响应头，说明新的地址在哪里 resp.setHeader(&quot;Location&quot;,&quot;form.html&quot;); &#125;&#125; 因为这里的重定向的地址是浏览器会向服务器发起的请求，所以绝对路径的 &#x2F;表示的是tomcat根目录下的内容 重定向也可以访问外部地址，只要把location换成一个网站的网址就可以 第二种请求重定向的方法第二种方法 123456789101112131415package com.atguigu.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class response1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.sendRedirect(&quot;/servlet2/response2&quot;); &#125;&#125; 书城项目的第二个阶段用户的注册和登录 javaEE项目的三层架构 分层的目的是为了解耦。解耦就是为了降低代码的耦合度。方便项目后期的维护和升级 下面的斜杠是或者的意思 web 层 com.atguigu.web&#x2F;servlet&#x2F;controller service 层 com.atguigu.service Service 接口包 ​ com.atguigu.service.impl Service 接口实现类 dao 持久层 com.atguigu.dao Dao 接口包 ​ com.atguigu.dao.impl Dao 接口实现类 实体 bean 对象 com.atguigu.pojo&#x2F;entity&#x2F;domain&#x2F;bean JavaBean 类 测试包 com.atguigu.test&#x2F;junit 工具类 com.atguigu.utils 创建数据库和User用户表一般创建一个表都需要有一个id这样自增的主键 1234567891011121314create database book;use book;create table t_user(id int PRIMARY KEY auto_increment,username varchar(20) not null unique,password varchar(20) not null,email varchar(200));insert into t_user(username,password,email) values(&#x27;admin&#x27;,&#x27;admin&#x27;,&#x27;admin@guigu.com&#x27;);select *from t_user; 编写数据库表对应的javaBean对象所谓的javaBean对象就是一个和数据库中储存数据一样类型的java类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.atguigu.pojo;public class User &#123; private Integer id; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &quot;, email=&#x27;&quot; + email + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public User(Integer id, String username, String password, String email) &#123; this.id = id; this.username = username; this.password = password; this.email = email; &#125; public User() &#123; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; private String username; private String password; private String email; &#125; 编写工具类JDBCUtils 导入这两个包才能用@test JdbcUtils类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.atguigu.utils;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.pool.DruidDataSourceFactory;import java.io.InputStream;import java.sql.Connection;import java.sql.SQLException;import java.util.Properties;public class JdbcUtils &#123; private static DruidDataSource dataSource;static &#123; try&#123; Properties properties=new Properties(); //奇怪的是这个地方不能用绝对路径 InputStream inputStream=JdbcUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); properties.load(inputStream); dataSource= (DruidDataSource) DruidDataSourceFactory.createDataSource(properties); System.out.println(dataSource.getConnection()); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125;&#125;//获取数据库连接池中的连接，如果返回null就是获取失败，有值就是获取成功public static Connection getConnection()&#123; Connection conn=null; try &#123; conn=dataSource.getConnection(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return conn;&#125;//关闭连接 public static void close(Connection conn)&#123; if(conn!=null)&#123; try&#123; conn.close(); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 测试类 123456789101112131415161718package com.atguigu.test;import com.atguigu.utils.JdbcUtils;import org.junit.Test;import java.sql.Connection;public class JdbcUtilsTest &#123; @Testpublic void testJdbcUtils()&#123; for (int i = 0; i &lt;100 ; i++) &#123; Connection conn=JdbcUtils.getConnection(); System.out.println(conn); JdbcUtils.close(conn); &#125; &#125;&#125; 因为数据库连接池配置文件中有最大连接数为规定数，所以只有每次都释放才能获取连接 BaseDao封装了增删改和查询方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.atguigu.dao.impl;import com.atguigu.utils.JdbcUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.apache.commons.dbutils.handlers.ScalarHandler;import java.sql.Connection;import java.sql.SQLException;import java.util.List;public class BaseDao &#123; //使用DbUtils操作数据库private QueryRunner queryRunner=new QueryRunner();/*update()方法用来执行：insert update delete语句如果返回-1说明执行失败， 否则返回其他表示影响的行数 */ public int update(String sql,Object...args)&#123; Connection conn= JdbcUtils.getConnection(); try &#123; return queryRunner.update(conn, sql, args); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; return -1; &#125; /* 查询返回一个javaBean的sql语句 type为返回对象类型，args是sql对应的参数值，sql是执行的sql语句 &lt;T&gt;返回的类型和泛型 */ public &lt;T&gt; T queryForOne(Class&lt;T&gt; type,String sql,Object...args) &#123; Connection con=JdbcUtils.getConnection(); try &#123; return queryRunner.query(con,sql,new BeanHandler&lt;T&gt;(type),args); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; finally&#123; JdbcUtils.close(con); &#125; return null; &#125; /* 查询返回多个javaBean的sql语句 */ public &lt;T&gt; List&lt;T&gt; queryForList(Class&lt;T&gt; type,String sql,Object...args)&#123; Connection con=JdbcUtils.getConnection(); try &#123; return queryRunner.query(con,sql,new BeanListHandler&lt;T&gt;(type),args); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; finally&#123; JdbcUtils.close(con); &#125; return null; &#125; /* 执行返回一个单元格的sql */ public Object queryForSingleValue(String sql,Object...args)&#123; Connection conn=JdbcUtils.getConnection(); try &#123; return queryRunner.query(conn, sql,new ScalarHandler(), args); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; finally&#123; JdbcUtils.close(conn); &#125; return null; &#125;&#125; 编写UserDao和测试其实这个Dao可以设计为一个泛型接口，用哪个类时再传递泛型参数，这样就是设计了一个不同数据库类的通用Dao 根据你所需要的方法来设计 UserDao 可以在空白处按ctrl和shift和t得到这个接口的测试 将Destination package换成你想要的位置，勾选好下面三个方法 123456789101112131415161718192021222324252627282930313233package com.atguigu.dao;import com.atguigu.pojo.User;public interface UserDao &#123; /* 根据用户名查询用户信息 username 用户名 如果返回null则说明没有这个用户，返之亦然 */ public User queryByUsername(String username); /** * 保存用户信息 * @param user * @return 返回-1表示操作失败，其他是sql语句影响的行数 */ public int saveUser(User user); /** * 根据用户名和密码查询用户信息 * @param username * @param password * @return 如果返回null则说明用户名或密码错误，返之亦然 */ public User queryUserByUsernameAndPassword(String username,String password);&#125; UserDaoImpl 12345678910111213141516171819202122232425package com.atguigu.dao.impl;import com.atguigu.dao.UserDao;import com.atguigu.pojo.User;public class UserDaoImpl extends BaseDao implements UserDao &#123; @Override public User queryByUsername(String username) &#123; String sql=&quot;select id,username,password,email from t_user where username=?&quot;; return queryForOne(User.class,sql,username); &#125; @Override public int saveUser(User user) &#123; String sql=&quot;insert into t_user(username,password,email) values(?,?,?)&quot;; return update(sql,user.getUsername(),user.getPassword(),user.getEmail()); &#125; @Override public User queryUserByUsernameAndPassword(String username, String password) &#123; String sql=&quot;select id,username,password,email from t_user where username=? and password=?&quot;; return queryForOne(User.class,sql,username,password); &#125;&#125; UserDaoTest 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.atguigu.test;import com.atguigu.dao.UserDao;import com.atguigu.dao.impl.UserDaoImpl;import com.atguigu.pojo.User;import org.junit.Test;import static org.junit.Assert.*;public class UserDaoTest &#123; UserDao userDao=new UserDaoImpl(); @Test public void queryByUsername() &#123; if(userDao.queryByUsername(&quot;admin123&quot;)==null) &#123; System.out.println(&quot;用户名可用&quot;); &#125; else &#123; System.out.println(&quot;用户名已存在&quot;); &#125; &#125; @Test public void saveUser() &#123; if(userDao.queryUserByUsernameAndPassword(&quot;admin&quot;,&quot;admin&quot;)==null)&#123; System.out.println(&quot;用户名或密码错误登陆错误&quot;); &#125; else &#123; System.out.println(&quot;登陆成功&quot;); &#125; &#125; @Test public void queryUserByUsernameAndPassword() &#123; System.out.println(userDao.saveUser(new User(null,&quot;admin&quot;,&quot;123456&quot;,&quot;wzg168@qq.com&quot;))); &#125;&#125; 编写UserService和测试可以在空白处按ctrl和shift和t得到这个接口的测试 将Destination package换成你想要的位置，勾选好下面三个方法 实现业务 UserService 123456789101112131415161718192021222324252627package com.atguigu.service;import com.atguigu.pojo.User;public interface UserService &#123; /** * 注册用户 * @param user */ public void registerUser(User user); /** * 登录 * @param user * @return 如果返回null，说明登录失败，返回有值，是登录成功 */ public User login(User user); /** * 检查用户名是否可用 * @param username * @return 返回true表示用户名已存在，返回false表示用户名可用 */ public boolean existsUsername(String username);&#125; UserServiceImpl 1234567891011121314151617181920212223242526272829package com.atguigu.service.impl;import com.atguigu.dao.UserDao;import com.atguigu.dao.impl.UserDaoImpl;import com.atguigu.pojo.User;import com.atguigu.service.UserService;public class UserServiceImpl implements UserService &#123; private UserDao userDao=new UserDaoImpl(); @Override public void registerUser(User user) &#123; userDao.saveUser(user); &#125; @Override public User login(User user) &#123; return userDao.queryUserByUsernameAndPassword(user.getUsername(),user.getPassword()); &#125; @Override public boolean existsUsername(String username) &#123; if(userDao.queryByUsername(username)==null)&#123; //等于null说明没查到，没查到表示可用 return false; &#125; return true; &#125;&#125; UserServiceTest 123456789101112131415161718192021222324252627282930313233package com.atguigu.test;import com.atguigu.pojo.User;import com.atguigu.service.UserService;import com.atguigu.service.impl.UserServiceImpl;import org.junit.Test;import static org.junit.Assert.*;public class UserServiceTest &#123; UserService userService=new UserServiceImpl(); @Test public void registerUser() &#123; userService.registerUser(new User(null,&quot;bbj168&quot;,&quot;666666&quot;,&quot;6668@qq.com&quot;)); &#125; @Test public void login() &#123; System.out.println(userService.login(new User(null,&quot;bbj168&quot;,&quot;666666&quot;,null))); &#125; @Test public void existsUsername() &#123; if(userService.existsUsername(&quot;bbj168&quot;))&#123; System.out.println(&quot;用户名已存在&quot;); &#125; else &#123; System.out.println(&quot;用户名可用&quot;); &#125; &#125;&#125; 实现用户注册的功能 javaweb阶段用base设定相对路径跳转 框架阶段用绝对路径 在title下面加上base标签，然后改变文件中所有的路径，因为现在的相对路径是以base这个路径为开头的 改变的文件既有register.html也有register_success.html 1&lt;base href=&quot;http://localhost:8087/book2/&quot;&gt; xml文件中配置servlet 把html文件中的表单，action设置为servlet的路径，method改为post 1&lt;form action=&quot;registServlet&quot; method=&quot;post&quot;&gt; 编写RegistServlet程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.atguigu.web;import com.atguigu.pojo.User;import com.atguigu.service.UserService;import com.atguigu.service.impl.UserServiceImpl;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class RegisterServlet extends HttpServlet &#123; //web层和service层交互 UserService userService=new UserServiceImpl(); @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.获取请求的参数 String username=req.getParameter(&quot;username&quot;); String password=req.getParameter(&quot;password&quot;); String email=req.getParameter(&quot;email&quot;); String code=req.getParameter(&quot;code&quot;); //2.检查 验证码是否正确,先把验证码写死，要求为abcde if(&quot;abcde&quot;.equalsIgnoreCase(code))&#123; //验证码正确 //检查用户名是否可用 if(userService.existsUsername(username))&#123; System.out.println(&quot;用户名&quot;+username+&quot;已存在&quot;); //跳回到注册页面 req.getRequestDispatcher(&quot;/pages/user/regist.html&quot;).forward(req,resp); &#125; else &#123; //可用 //调用Sercice保存到数据库 userService.registerUser(new User(null,username,password,email)); //注册成功后，跳转到注册成功页面 req.getRequestDispatcher(&quot;/pages/user/regist_success.html&quot;).forward(req,resp); &#125; &#125;else&#123; System.out.println(&quot;验证码&quot;+code+&quot;错误&quot;); //验证码不正确 //跳回注册页面，因为还是申请服务器中文件所以/还是工程目录下的 req.getRequestDispatcher(&quot;/pages/user/regist.html&quot;).forward(req,resp); &#125; &#125;&#125; IDEA中的Debug调试看pdf文件即可 用户登录功能的实现操作步骤和用户注册功能差不多 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.atguigu.web;import com.atguigu.pojo.User;import com.atguigu.service.UserService;import com.atguigu.service.impl.UserServiceImpl;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class RegisterServlet extends HttpServlet &#123; //web层和service层交互 UserService userService=new UserServiceImpl(); @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.获取请求的参数 //这个getParameter方法是通过那个属性的name得到的 String username=req.getParameter(&quot;username&quot;); String password=req.getParameter(&quot;password&quot;); String email=req.getParameter(&quot;email&quot;); String code=req.getParameter(&quot;code&quot;); //2.检查 验证码是否正确,先把验证码写死，要求为abcde if(&quot;abcde&quot;.equalsIgnoreCase(code))&#123; //验证码正确 //检查用户名是否可用 if(userService.existsUsername(username))&#123; System.out.println(&quot;用户名&quot;+username+&quot;已存在&quot;); //跳回到注册页面 req.getRequestDispatcher(&quot;/pages/user/regist.html&quot;).forward(req,resp); &#125; else &#123; //可用 //调用Sercice保存到数据库 userService.registerUser(new User(null,username,password,email)); //注册成功后，跳转到注册成功页面 req.getRequestDispatcher(&quot;/pages/user/regist_success.html&quot;).forward(req,resp); &#125; &#125;else&#123; System.out.println(&quot;验证码&quot;+code+&quot;错误&quot;); //验证码不正确 //跳回注册页面，因为还是申请服务器中文件所以/还是工程目录下的 req.getRequestDispatcher(&quot;/pages/user/regist.html&quot;).forward(req,resp); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"java","slug":"java","date":"2022-09-29T09:56:50.000Z","updated":"2022-09-30T00:44:43.955Z","comments":true,"path":"2022/09/29/java/","link":"","permalink":"http://example.com/2022/09/29/java/","excerpt":"","text":"变量在Java中，静态变量和实例变量可以统称为成员变量。首先，明白什么是静态变量，什么是实例变量，他们定义的形式。静态变量也叫做类变量，独立于方法之外的变量，有static修饰。实例变量同样独立也是独立于方法之外 的变量，但没有static修饰。 运算符&lt;&lt;：是逻辑左移，右边补0，符号位和其他位一样要移动。 数学意义：在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以2的1次方，左移n位就相当于乘以2的n次方。 计算：3 &lt;&lt; 2 3 &lt;&lt; 2，则是将数字3左移2位 1、首先把3转换为二进制数字0000 0000 0000 0000 0000 0000 0000 0011 2、然后把该数字高位（左侧）的两个零移出，其他的数字都朝左平移2位，最后在低位（右侧）的两个空位补零。 3、则得到的最终结果是0000 0000 0000 0000 0000 0000 0000 1100，则转换为十进制是12。 （右移运算符） 位运算符 凡位运算符都是把值先转换成二进制再进行后续的处理，5的二进制位是0000 0101，右移两位就是把101左移后为0000 0001，正数左边第一位补0，负数补1，等于除于2的n次方，结果为1 ，只保留了结果的整数部分 &amp;（按位与） 位运算符 &amp;按位与的运算规则是将两边的数转换为二进制位，然后运算最终值，运算规则即(两个为真才为真)1&amp;1&#x3D;1 , 1&amp;0&#x3D;0 , 0&amp;1&#x3D;0 , 0&amp;0&#x3D;0 3的二进制位是0000 0011 ， 5的二进制位是0000 0101 ， 那么就是011 &amp; 101，由按位与运算规则得知，001 &amp; 101等于0000 0001，最终值为1 7的二进制位是0000 0111，那就是111 &amp; 101等于101，也就是0000 0101，故值为5 |（按位或） 位运算符 |按位或和&amp;按位与计算方式都是转换二进制再计算，不同的是运算规则(一个为真即为真)1|0 &#x3D; 1 , 1|1 &#x3D; 1 , 0|0 &#x3D; 0 , 0|1 &#x3D; 1 6的二进制位0000 0110 , 2的二进制位0000 0010 , 110|010为110，最终值0000 0110，故6|2等于6 ^（异或运算符） 位运算符 ^异或运算符顾名思义，异就是不同，其运算规则为1^0 &#x3D; 1 , 1^1 &#x3D; 0 , 0^1 &#x3D; 1 , 0^0 &#x3D; 0 5的二进制位是0000 0101 ， 9的二进制位是0000 1001，也就是0101 ^ 1001,结果为1100 , 00001100的十进制位是12 ~（取反运算符） 位运算符 取反就是1为0,0为1,5的二进制位是0000 0101，取反后为1111 1010，值为-6 （无符号右移运算符） 正数无符号右移 无符号右移运算符和右移运算符的主要区别在于负数的计算，因为无符号右移是高位补0，移多少位补多少个0。 15的二进制位是0000 1111 ， 右移2位0000 0011，结果为3 负数无符号右移 -6的二进制是6的二进制取反再加1,6的二进制也就是0000 0000 0000 0000 0000 0000 0000 0110，取反后加1为1111 1111 1111 1111 1111 1111 1111 1010，右移三位0001 1111 1111 1111 1111 1111 1111 1111 二进制正值转负值 a.最高位改成1 b.除了最高位，其他位取反 c.结果+1 d.得到的结果就是对应的负值 java.lang包java.lang包是java语言的核心，它提供了java中的基础类。包括基本Object类、Class类、String类、基本类型的包装类、基本的数学类等等最基本的类。我们介绍一下Java 8中的java.lang包。主要类如下图： 类 由 域(变量) 方法 组成 常量叫做直接量 数据类型基本数据类型:整形:短整型，整形，长整型，字节型空数组引用数据类型:类，接口，数组 字符’ ‘字符串” “ 一个字节八比特，一个byte八位 byte 1字节 short2字节 int 4字节 long 8字节 float 4字节 double 8字节 char 2字节 boolean 1位 类方法与实例方法的区别定义：类方法：static修饰的方法实例方法：由类创建实例调用 对象变量:指类中不加static的成员变量 区别： 类方法中不能引用对象变量；实例方法可以引用对象变量，也可以引用类变量。 类方法不能直接调用实例方法；实例方法可以直接调用类方法 类方法中不能使用super、this关键字；实例方法可以使用。 类方法不能被覆盖。 5.实例方法不能通过类名调用，当类的字节码文件被加载到内存时，类的实例方法不会被分配入口地址，当该类创建对象后，类中的实例方法才分配入口地址，从而实例方法可以被类创建的任何对象调用执行。 6.类方法可以通过类名调用，类方法在该类被加载到内存时，就分配了相应的入口地址。从而类方法不仅可以被类创建的任何对象调用执行，也可以直接通过类名调用。类方法的入口地址直到程序退出时才被取消。 类名.方法名() 子类中出现和父类相同的方法，就是覆盖，子类的对象就无法访问父类的那个被覆盖的方法，覆盖方法和被覆盖的方法要么都是类方法，要么都是实例方法，不能一个是类方法，一个是实例方法 private方法不支持重写 如果父类方法是private，即使子类中定义一个与父类private方法相同的方法名，相同的参数列表依然不是重写，只是在子类里重新定义了一个新的方法 标识符标识符命名规则：1，只能由字母数字，_或$2.必须以字母，_或$开头3.大小写敏感，无长度限制4，不能是java的关键字和保留字 标识符规则标识符常量用大写字母，变量用小写字母开始，类以大写字母开始标识符不能与关键字同名标识符最好见名知义 super关键字在子类方法中调用父类中被覆盖的方法，则可以使用super（被覆盖的是实例方法），或者父类类名来调用父类中被覆盖的函数（被覆盖的是类方法） 继承和多态12345678910111213141516171819202122232425262728293031323334353637383940414243package Hello;public class Hello &#123; public String s; public int a; public Hello() &#123; &#125; public Hello(String s,int a) &#123; this.s=s; this.a=a; &#125; public void print() &#123; System.out.println(&quot;123&quot;); &#125; public void print2() &#123; System.out.println(&quot;1234&quot;); &#125; public static void main(String[] args) &#123; Hello a=new Hello(); Hello b=new Hello(&quot;as&quot;,1); System.out.print(b.s); System.out.print(a.s); Hello c=new Hello(); Hello d=new Hell(); c.print(); d.print(); d.print2(); ((Hell)d).print3(); &#125;&#125;class Hell extends Hello&#123; public void print() &#123; System.out.print(&quot;234&quot;); &#125; public void print3() &#123; System.out.println(&quot;12345&quot;); &#125; &#125; 静态初始化块，和初始化块 12345678910111213141516171819202122232425262728293031323334package Hello;public class Hello &#123; static int a; int b; static&#123; System.out.println(&quot;静态初始化块&quot;); a=6; // b=2;这个地方会报错 &#125; &#123; int b=6; if (b&gt;4) &#123; System.out.println(&quot;lss&quot;); &#125; System.out.println(a); &#125; &#123; System.out.println(&quot;第二个构造器&quot;); &#125; public Hello() &#123; System.out.println(&quot;构造器&quot;); &#125; public static void main(String[] args) &#123; Hello a=new Hello(); &#125;&#125; 数字转字符串 String b&#x3D;5+””; equals和&#x3D;&#x3D;的使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package Hello;class Person&#123; private String name; public Person(String name) &#123; this.name=name; &#125;&#125;public class Hello &#123;public static void main(String[] args) &#123; Person p=new Person (&quot;123&quot;); System.out.println(p.toString()); System.out.println(p); System.out.println(p+&quot;123&quot;); int it =65; float fl=65.0f; char ch=&#x27;A&#x27;; if(it==fl) &#123; System.out.print(&quot;相等&quot;); &#125; if(ch==it) &#123; System.out.println(&quot;相等&quot;); &#125; Hello a=new Hello(); Hello b=new Hello(); if(a==b) &#123; System.out.println(&quot;相等&quot;); &#125; else &#123; System.out.println(&quot;不相等&quot;); &#125; if(a.equals(b)) &#123; System.out.println(&quot;相等&quot;); &#125; else &#123; System.out.println(&quot;不相等&quot;); &#125; String H=&quot;123&quot;; String G=&quot;345&quot;; String I=&quot;123345&quot;; String T=H+G; String R=new String(&quot;123&quot;); if(H==R) &#123; System.out.println(&quot;相等1&quot;); &#125; if(T==I) &#123; System.out.println(&quot;相等2&quot;); &#125; if(H.equals(R)) &#123; System.out.println(&quot;相等1&quot;); &#125; if(T.equals(I)) &#123; System.out.println(&quot;相等2&quot;); &#125; &#125;&#125; 1O:12:&quot;Road_is_Long&quot;:2:&#123;s:6:&quot;string&quot;;O:13:&quot;Make_a_Change&quot;:1:&#123;s:6:&quot;effort&quot;;O:13:&quot;Try_Work_Hard&quot;:1:&#123;s:3:&quot;var&quot;;s:52:&quot;php://filter/convert.base64-encode/resource=flag.php&quot;;&#125;&#125;s:4:&quot;page&quot;;O:12:&quot;Road_is_Long&quot;:2:&#123;s:6:&quot;string&quot;;N;s:4:&quot;page&quot;;N;&#125;&#125; 1O:12:&quot;Road_is_Long&quot;:2:&#123;s:6:&quot;string&quot;;N;s:4:&quot;page&quot;;O:12:&quot;Road_is_Long&quot;:2:&#123;s:6:&quot;string&quot;;O:13:&quot;Make_a_Change&quot;:1:&#123;s:6:&quot;effort&quot;;O:13:&quot;Try_Work_Hard&quot;:1:&#123;s:3:&quot;var&quot;;s:52:&quot;php://filter/convert.base64-encode/resource=flag.php&quot;;&#125;&#125;s:4:&quot;page&quot;;s:3:&quot;aaa&quot;;&#125;&#125; final的使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package Hello;class Person&#123; private String name; public static int a=1; public int c=1; final static int d; static&#123; a=2; //b=2; d=1; &#125; public Person(String name) &#123; this.name=name; &#125; public void print() &#123; final int h=1; //public int y=1; int x=1; &#125; public static void print1(final int i) &#123; final int a=1; //i=1; &#125;&#125;public class Hello &#123; public final void test()&#123; &#125; public final void test(String name) &#123; &#125;public static void main(String[] args) &#123; Person b=new Person(&quot;1&quot;); System.out.println(b.a); System.out.println(Person.a); final int[] iArr= &#123;5,6,12,9&#125;; iArr[2]=10; //iArr=null; final Person p=new Person(&quot;1&quot;); p.a=123; String str2=&quot;java&quot;; String str3=&quot;com&quot;; final String str=&quot;java&quot;; final String str1=&quot;com&quot;; String s1=&quot;javacom&quot;; System.out.println(str+str1==s1); System.out.println(str2+str3==s1); &#125;&#125; 有关强制类型转换基本类型之间的转换只能在数值类型之间间进行，这里所说的数值类型包括整数型，字符型和浮点型，但数值类型和字符串类型和布尔类型是不能进行类型转换的 总结：父类引用可以指向子类对象，子类引用不能指向父类对象。把子类对象直接赋给父类引用叫做向上转型，向上转型不用强制转型，如Father f1&#x3D;new Son()，把指向子类对象的父类引用赋给子类引用叫做向下转型，要强制转型，如Son s1 &#x3D; (Son)f1。向上转型会丢失子类特有的方法，但是子类overriding父类的方法，子类方法有效。 将一种类型的数据赋给另外一种类型变量时，满足下列两种要求将执行自动类型转换：1.两种类型是兼容的；2.目的类型的范围比来源类型大。 数据值类型按照范围从小到大为：byte，short，char，int，long，float，double 例如int类型比所有byte合法类型大，因此不要求显式强制类型转换。对于数字类型，整型和浮点型都是彼此兼容的，但是数字类型和字符类型和布尔类型是不兼容的，字符类型和布尔类型也不是互相兼容的。 自动类型转换不能满足所有的转换需求，比如int型变量赋值给byte型变量，这种转换不会自动进行，因为byte型比int型范围小。为了完成两种不兼容类型转换，需要用到强制类型转换。 目标类型指定了要转换成为的类型。例如果将int型转为byte型，int型取值范围大于byte型，它的值将堆byte型范围进行取模。而把浮点型赋值给整数型，就会出现截断，截取掉小数部分。从其他数值类型转换为char类型时，必须进行强制转换。将char类型转换为其他数值类型时，除了byte、short必须强制转换之外，int、long、float、double都不用强制转换。 类型转换都是小范围向大范围转换的，大范围往小范围转化需要用到强制转换，转换后的值会有所损失。 String 与其他数据类型的转换String to int int i&#x3D;Integer.parseInt(str); int to String String s&#x3D;String.valueOf(i); String to Array char []a&#x3D;str.toCharArray(); char []a&#x3D;str.getChars(0,str.length,anArray,0); Array toString String str&#x3D;new String(anArray); char to String 123 char b=&#x27;2&#x27;;String a=String.valueOf(b); System.out.println(a); String to char charAt()和toCharArray() java的Big数字类java的BigDecimal类方法声明public BigDecimal add (BigDecinal value) 加法运算 public BigDecimal subtract (BigDecimal value)减法运算 public BigDecimal multiply(BigDecimal value)乘法运算 public BigDecimal divide (BigDecimal value)除法运算 精确的计算小数之间的加减乘除 1234567891011121314151617import java.math.BigDecimal;import java.util.Scanner;public class Main&#123; public static void main(String []args)&#123; Scanner in=new Scanner(System.in); while(in.hasNext())&#123; String a=in.next(); String b=in.next(); BigDecimal a1=new BigDecimal(a); BigDecimal a2=new BigDecimal(b); System.out.println(a2.add(a1));//求两个相加 System.out.println(a2.multiply(a1));//求两个的乘积 &#125; &#125;&#125; java的BigInteger类12345678910111213141516171819202122import java.math.BigInteger;import java.util.Arrays;import java.util.Scanner;public class Main&#123; public static void main(String []args)&#123; BigInteger a=new BigInteger(&quot;0&quot;); Scanner in=new Scanner(System.in); while(in.hasNext()) &#123; String key=in.nextLine(); if(key.equalsIgnoreCase(&quot;e&quot;)) &#123; break; &#125; a=a.add(new BigInteger(key));//求相加&#125; System.out.println(a);&#125;&#125; 一.BigInteger简介 BigInteger类所在的包 java中可以使用BigInteger操作大整数，也可以转换进制。如果在操作的时候一个整型数据已经超过了整数的最大类型长度long的话，则此数据就无法装入，所以，此时要使用BigInteger类进行操作。这些大数都会以字符串的形式传入。 二.BigInteger类常用方法 1.BigInteger(String value)：构造方法，将value字符串变成BigInteger类型数据。 2.BigInteger add(BigInteger value)：加法，求两个BigInteger类型数据的和。 3.BigInteger subtract(BigInteger value)：减法，求两个BigInteger类型数据的差。 4.BigInteger multiply(BigInteger value)：乘法，求两个BigInteger类型数据的积。 5.BigInteger divide(BigInteger divisor)：除法，求两个BigInteger类型数据的商。 6.BigInteger modInverse(BigInteger m)：求模，求BigInteger类型数据对m求模。 7.BigInteger remainder(BigInteger divisor)：求余数，求BigInteger类型数据除以divisor的余数。 8.BigInteger max(BigInteger value)：最大数，求两个BigInteger类型数据的最大值。 9.BigInteger min(BigInteger value)：最小数，求两个BigInteger类型数据的最小值。 10.BigInteger gcd(BigInteger value)：最大公约数，求两个BigInteger类型数据的最大公约数。 11.BigInteger abs()：绝对值，求BigInteger类型数据的绝对值。 12.BigInteger negate()：相反数，求BigInteger类型数据的相反数。 123456789101112131415161718192021222324252627282930 BigInteger a = new BigInteger(&quot;15&quot;);BigInteger b = new BigInteger(&quot;10&quot;);BigInteger c = new BigInteger(&quot;-10&quot;);BigInteger d = new BigInteger(&quot;2&quot;);BigInteger add_result = a.add(b);BigInteger subtract_result = a.subtract(b);BigInteger multiply_result = a.multiply(b);BigInteger divide_result = a.divide(b);BigInteger modinverse_result = a.modInverse(d);BigInteger remainder_result = a.remainder(b);BigInteger max_result = a.max(b);BigInteger min_result = a.min(b);BigInteger gcd_result = a.gcd(b);BigInteger abs_result = c.abs();BigInteger negate_result = a.negate();Log.d(&quot;TAG&quot;, &quot;15+10=&quot; + add_result);Log.d(&quot;TAG&quot;, &quot;15-10=&quot; + subtract_result);Log.d(&quot;TAG&quot;, &quot;15*10=&quot; + multiply_result);Log.d(&quot;TAG&quot;, &quot;15/10=&quot; + divide_result);Log.d(&quot;TAG&quot;, &quot;15对2求模=&quot; + modinverse_result);Log.d(&quot;TAG&quot;, &quot;15/10余数=&quot; + remainder_result);Log.d(&quot;TAG&quot;, &quot;15和10最大数=&quot; + max_result);Log.d(&quot;TAG&quot;, &quot;15和10最小数=&quot; + min_result);Log.d(&quot;TAG&quot;, &quot;15和10最大公约数=：&quot; + gcd_result);Log.d(&quot;TAG&quot;, &quot;-10的绝对值=&quot; + abs_result);Log.d(&quot;TAG&quot;, &quot;15的相反数=&quot; + negate_result); Java String类总序java中的字符串分为两类，字符串常量和字符串变量 字符串常量：包括直接字符串常量和String类的对象；字符串常量的值一旦创建不会再改动 字符串变量：指的是StringBuffer类的对象，创建之后允许对其进行修改 字符串文本 1234567String str1=&quot;java&quot;; 相当于 char cstr[]= &#123;&#x27;J&#x27;,&#x27;a&#x27;,&#x27;v&#x27;,&#x27;a&#x27;&#125;; String str=new String(cstr); System.out.println(str);把字符数组转变为字符串的一个方法 2.String str1&#x3D;new String(“hello”); 3.使用数组方式 char str[]&#x3D;{‘h’,’e’,’l’,’l’,’0’}; String str[]&#x3D;{“hello”,”word”,”!”} String类的构造方法 例子 n在String类提供的构造方法中，可以由字符数组、字节数组以及字符串缓冲区来构成字符串，如下面的代码所示。 char cDeomo[]&#x3D; {‘2’,’3’,’4’,’5’}; char cDeomo1[]&#x3D; {‘1’,’2’,’3’,’4’,’5’}; String strDemo1&#x3D;new String(cDeomo); String strDemo2&#x3D;new String(cDeomo1,1,4);&#x2F;&#x2F;从cDeomo1的下标1元素到下标为4的元素 System.out.println(strDemo1); System.out.println(strDemo2); 利用上面的两个构造方法生成的字符串实例的内容均为“2345”。 n下面例子说明如何利用字节数组生成字符串： byte cDemo[]&#x3D; {66,67,68};byte cDemo1[]&#x3D; {65,66,67,68};String strDemo1&#x3D;new String(cDemo);String strDemo2&#x3D;new String(cDemo1,1,3);&#x2F;&#x2F;从下标1到下标3 都包括刚开始第一个下标的那个字符System.out.println(strDemo1);System.out.println(strDemo2);&#x2F;&#x2F;会把数字转换为unicode编码的字符 利用上面的两个构造方法生成的字符串实例的内容均为”BCD” length方法1234String str=&quot;java&quot;;System.out.println(str.length());获取字符串长度 getChars方法public void getChars(int start,int end,char c[],int offset) ​ 该方法的作用是将当前字符串从start到end-1位置上的字符复制到字符数组c中，并从c的offset处开始存放 就是将字符串从下标为start到下标为end-1的字符从c字符数组的offset下标处开始存放 String str&#x3D;”java”;char dstch[]&#x3D;new char[20];int n&#x3D;str.length();str.getChars(0, n, dstch, 0);System.out.println(dstch); 都包括第一个下标开始的那个字符 compareTo方法String类是默认实现的comparable接口的compareTo方法 用于字符串比较 int compareTo(String str) 例如:字符串A和字符串B进行比较,如果A大于B,返回大于0的值;如果A等于B,返回0; 如果A小于B,返回小于0的值。 ​ A.compareTo(B); 即参与比较的两个字符串如果首字符相同，则比较下一个字符，直到有不同的为止，返回该不同的字符的ASCII码差值； 是A字符串字符的ascii编码减去B字符串字符的ascii编码 如果两个字符串不一样长，可以参与比较的字符又完全一样，则返回两个字符串的长度差值 String str&#x3D;”abcde”;System.out.println(str.compareTo(“boy”));System.out.println(str.compareTo(“aba”));System.out.println(str.compareTo(“abcdefghi”)); 运行结果 -12-4 使用例子 12345678public int compareTo(Student o1) &#123; if(o1.getScore()==this.getScore()) &#123; return this.id.compareTo(o1.id); &#125; else &#123; return o1.getScore()-this.getScore(); &#125;&#125; 先按成绩降序排序，当成绩相同的时候按照id来自然排序 concat方法n将调用该方法的字符串与指定字符串连接，返回新的字符串。 String str1&#x3D;”java”;String str2&#x3D;”world”;String str3;str3&#x3D;str1.concat(str2);System.out.println(str3);&#x2F;&#x2F;javaworld substring方法n用于提取调用方法的字符串中的子串。 String substring (int begin, int end)； 提取从begin到end-1处的字符。就是第二个参数是下标减一 String str1&#x3D;”java”,str2&#x3D;”world”,str3;str3&#x3D;str1.concat(str2);System.out.println(str3.substring(0,3)+” “+str3.substring(4,9)); 运行结果：jav world 当substring方法只有一个参数的时候 它是此字符串的一个子字符串。该子字符串从指定索引处的字符开始，直到此字符串末尾。 String str1&#x3D;”java”,str2&#x3D;”world”,str3;str3&#x3D;str1.concat(str2);System.out.println(str3.substring(2)); 运行结果：vaworld 包括这个第一个下标开始的那个字符 replace方法返回一个新字符串 n用于替换调用方法在字符串中的某个字符，返回替换后的新字符串。 String replace(char oldChar, char newChar)； String str1&#x3D;”java world”,str3;str3&#x3D;str1.replace(‘a’,’b’);System.out.println(str3); 运行结果： jbvb world trim方法返回一个新字符串 npublic String trim() 一个字符串s 通过调用方法trim()得到一个字符串对象,该字符串对象是s去掉前后空格后的字符串。 如下面的代码所示： String s&#x3D;”I mist theep “;String temp&#x3D;s.replace(‘t’, ‘s’);String a&#x3D;” i am a student “;String tema&#x3D;s.trim();System.out.println(temp);System.out.println(tema); indexOf方法indexOf, lastIndexOf: 这两个方法用于对字符串建立索引，返回字符串的位置； int indexOf(String str)；&#x2F;&#x2F;这个是返回第一个遇到的索引，两个都是返回匹配的字符串的第一个字符的索引值 int lastIndexOf(String str);&#x2F;&#x2F;这个是返回从最后开始遇到的索引 String str1&#x3D;”java world or”;String str2&#x3D;”or”;int v1&#x3D;str1.indexOf(str2);int v2&#x3D;str1.lastIndexOf(str2);System.out.println(v1+” “+v2); 运行结果：6 11 equals方法在String类中equals()定义如下： public boolean equals(String s) 该方法用来比较当前字符串对象的实体是否与参数指定的字符串s的实体是否相同。例如 String tom&#x3D;new String( “we are students”); String boy&#x3D;new String( “We are students”); String jerry&#x3D; new String(“we are students”); tom.equals(boy)的值是false，tom.equals(jerry)的值是true 而且字符串之间进行比较不能够用&#x3D;&#x3D;，因为&#x3D;&#x3D;是比较两个字符串的地址是否相同，而equals是比较两个字符串的内容是否是相等的 &#x3D;&#x3D;比较引用，equals 比较值 1、java中字符串的比较：&#x3D;&#x3D; 我们经常习惯性的写上if(str1&#x3D;&#x3D;str2)，这种写法在java中可能会带来问题 example1: 1String a=&quot;abc&quot;;String b=&quot;abc&quot; 那么a&#x3D;&#x3D;b将返回true。因为在java中字符串的值是不可改变的，相同的字符串在内存中只会存 一份，所以a和b指向的是同一个对象； example2： 1String a=new String(&quot;abc&quot;); String b=new String(&quot;abc&quot;); 那么a&#x3D;&#x3D;b将返回false，此时a和b指向不同的对象。 2、用equals方法比较的是字符串的内容是否相同， example： 123String a=new String(&quot;abc&quot;); String b=new String(&quot;abc&quot;); a.equals(b); 将返回true。 equalsIgnoreCase()方法n在String类中equalsIgnoreCase ()定义如下： public boolean equalsIgnoreCase(String s) 字符串对象调用比较当前字符串对象是否与参数指定的字符串s 相同,比较时忽略大小写。例如： String tom&#x3D;new String(“ABC”);String Jerry&#x3D;new String(“abc”);System.out.println(tom.equals(Jerry)); tom.equalsIgnoreCase(Jerry)的值是true。 split方法1public String[] split(String regex, int limit) 根据第一个参数的字符串将字符串分割为第二个参数的份数变成字符串数组 第一个参数一定是一个字符串用双引号 String [] c&#x3D;b[i].split(“：”);用冒号将字符串分割为字符串数组afd Integer.parseInt将字符串转换为数字 startsWith方法 prefix – 前缀。 toffset – 字符串中开始查找的位置。 12345public boolean startsWith(String prefix, int toffset)或public boolean startsWith(String prefix) toUpperCase()String cc &#x3D; “aBc123”.toUpperCase(); 结果就是：ABC123 Java中StringBuffer类构造方法StringBuffer中提供了三种构造方法 public StringBuffer() 构造一个不包含字符的字符串缓冲区，其初始的容量设为 16 个字符。 public StringBuffer(int) 构造一个不包含字符的字符串缓冲区，其初始容量由参数设定。 public StringBuffer(String) 构造一个字符串缓冲区，来表示和字符串参数相同的字符序列。 字符串缓冲区的初始容量为16加上字符串参数的长度。 capacity方法n用来计算StringBuffer的容量，返回容量大小的整型值。 StringBuffer sb&#x3D;new StringBuffer(100);int x&#x3D;sb.capacity();System.out.println(x); 运算结果：100 容量是一开始那个有的那个，而不是有内容的，可以是空的默认值 append方法n将指定的字符串的内容连接到StringBuffer对象中内容的后边，并返回连接后的的StringBuffer对象。 StringBuffer append(String str); StringBuffer sb1&#x3D;new StringBuffer(“Hello”);StringBuffer sb2&#x3D;new StringBuffer(“all”);String str&#x3D;”_good”;sb2&#x3D;sb1.append(str);System.out.println(sb2); 运行结果：Hello_good insert方法n将指定的字符ch插入到StringBuffer对象的offset处，并返回修改后的StringBuffer对象。 StringBuffer insert（int offset, char ch） StringBuffer sb1=new StringBuffer(&quot;Hello&quot;); char c=&#39;2&#39;; StringBuffer sb2=new StringBuffer(100); sb2=sb1.insert(1,c); System.out.println(sb2); insert的第一个参数是要插入的字符的下标 delete方法n将StringBuffer对象中的一部分内容删掉，并将删除后的StringBuffer对象返回。 StringBuffer delete(int start, int end); 从start 删除到 end-1； StringBuffer sb1&#x3D;new StringBuffer(“Hello”);StringBuffer sb2&#x3D;new StringBuffer(100);sb2&#x3D;sb1.delete(1, 3);System.out.println(sb2); 运行结果：Hlo reverse方法n将StringBuffer中的内容颠倒过来； StringBuffer reverse(); StringBuffer sb1&#x3D;new StringBuffer(“Hello”);sb1&#x3D;sb1.reverse();System.out.println(sb1); 结果为：olleH java中数组数组的声明需要提供数组元素的类型和数组的维数。 例如： int[] k; &#x2F;&#x2F;int型一维数组 ​ String s[]; 数组声明注意test 123456789101112131415161718package Main;import java.util.Scanner;class Main&#123; public static void main(String []args)&#123; int arr[]= &#123;1,3,2,4,5,6,7&#125;; int arr2[]= &#123;1,2,3,4&#125;; arr=arr2;//arr 也变成1,2,3,4 for(int i=0;i&lt;arr.length;i++) &#123; System.out.println(arr[i]); &#125; arr[0]=100; System.out.println(arr2[0]);//说明arr=arr2之后两个数组指向同一个内存地址 &#125;&#125; 创建数组对象使用关键字new； 例如：new int [5]; ​ new String [6][5]; &#x2F;&#x2F;创建String 型二维数组 创建后，需要将相应类型的数组引用指向该对象，才能对数组对象进行操作。 例如：int[] k; &#x2F;&#x2F;int型一维数组 ​ String[][] s; ​ k&#x3D;new int [5]; ​ s&#x3D;new String[6][5]; 枚举初始化例子：TestArray.java 循环初始化：TestArray.java 枚举初始化： 例如： int[] i&#x3D;{1,3,5,7,9}; ​ int[] i&#x3D;new int[]{1,3,5,7,9}; 数组排序整个数组排序 public static void sort (int[] a)； 对指定的数组区间进行排序 public static void sort (int[] a, int fromIndex, int toIndex)；这个第二个参数是最后一个下标减一 int a[]&#x3D; {1,2,3,5,4};Arrays.sort(a);for(int i:a){ System.out.println(i);} } 查找指定元素nJava中也提供binarySearch方法来帮助开发人员进行查找操作，该方法格式如下所示。 public static int binarySearch(int[ ] a,int key)； 方法的object[]参数是要查找的数组，key参数为要查找的key值。 方法的返回值有几种： 1.找到的情况下：如果key在数组中，则返回搜索值的索引。 2.找不到的情况下： [1] 搜索值不是数组元素，且在数组范围内，从1开始计数，得“ - 插入点索引值”； [2] 搜索值是数组元素，从0开始计数，得搜索值的索引值； [3] 搜索值不是数组元素，且大于数组内元素，索引值为 – (length + 1); [4] 搜索值不是数组元素，且小于数组内元素，索引值为 – 1。 这个binarySearch方法必须是按照从小到大的顺序排的元素才能够算是key在数组中，如果有小的数跟在最后面就是找不到的情况下的第一种情况 123456 int a[] = new int[] &#123;1, 3, 4, 6, 8, 9&#125;; int x1 = Arrays.binarySearch(a, 5); int x2 = Arrays.binarySearch(a, 4); int x3 = Arrays.binarySearch(a, 0); int x4 = Arrays.binarySearch(a, 10);x1=-4 x2=2 x3=-1 x4=-7结果 数组利用比较器排序注意点：这个数组必须是Integer这种对象类型的而不是int基本类型 同时自己设计的比较器需要实现Comparator接口，当下面例子这种形式的时候是从小到大排序 将第一个if返回值变为-1 第二个elseif返回值变为1就可以实现从大到小排序 1234567891011121314151617181920212223242526272829303132package Main;import java.util.Arrays;import java.util.Comparator;import java.util.Scanner;class compare implements Comparator&lt;Integer&gt;&#123; @Override public int compare(Integer o1, Integer o2) &#123; if(o1&gt;o2) &#123; return 1; &#125; else if(o1&lt;o2) &#123; return -1; &#125; else &#123; return 0; &#125; &#125;&#125;class Main&#123; public static void main(String []args) &#123; Integer []a= &#123;1,3,4,2,5&#125;;//这里必须使用Integer Comparator c=new compare(); Arrays.sort(a,c);for(int i:a) &#123; System.out.println(i);&#125; &#125;&#125; Java Character类中的方法Character类在java.lang包下所以不需要自己去导入 isLower(Upper)Case和to(Upper)Case方法作用：是转大小写或者判断是否是大写或者小写 char cstr[]&#x3D; {‘j’,’a’,’v’,’a’};System.out.println(Character.isUpperCase(cstr[0]));System.out.println(Character.isLowerCase(cstr[0]));cstr[1]&#x3D;Character.toUpperCase(cstr[1]);System.out.println(cstr[1]);cstr[1]&#x3D;Character.toLowerCase(cstr[1]);System.out.println(cstr[1]); java.lang包下的类是默认自动导入的，character类就是在java.lang包下，以及java.lang包下的自包还是不可以被默认导入，如果用到里面的类需要自己手动导入 转大小写的时候不会把原来的字符变为大写或小写，但可以重新赋值 isDigit方法确定指定字符是否为数字 Character a=&#39;2&#39;; System.out.println(Character.isDigit(a)); 输出的结果是true isLetter方法 确定指定字符是否为字母。 1234Character a=&#x27;a&#x27;; System.out.println(Character.isLetter(a)); 输出结果为true equals方法 Character a=&#39;a&#39;; Character b=&#39;b&#39;; System.out.println(a.equals(b)); 输出结果为faulse 两个基本类型字符（用char定义的，或者char数组中的）之间可以直接进行&#x3D;&#x3D;，!&#x3D;之间的比较，两个Character对象字符之间不能够用&#x3D;&#x3D; !&#x3D;得用equals 123456Character a=new Character(&#x27;a&#x27;);Character b=new Character(&#x27;a&#x27;);System.out.println(a==b);System.out.println(a.equals(b));结果：false true 123456789101112Character a=&#x27;a&#x27;;Character b=&#x27;a&#x27;;char c=&#x27;a&#x27;;char d=&#x27;a&#x27;;System.out.println(a==b);System.out.println(a.equals(b));System.out.println(c==d);//System.out.println(c.equals(d));结果：基本类型不能调用很多方法，可以用Character引用变量去指向基本类型truetruetrue 字符数组String str&#x3D;”java”;char dstch[]&#x3D;new char[20];int n&#x3D;str.length();str.getChars(0, n, dstch, 0);System.out.println(dstch); 结果：java java random类的使用random类不在java.lang包下，所以需要自己去导入 import java.util.Random; Random类的构造方法Random类包含两个构造方法，下面依次进行介绍：（1）public Random()该构造方法使用一个和当前系统时间对应的相对时间有关的数字作为种子数，然后使用这个种子数构造Random对象。（2）public Random(long seed)该构造方法可以通过制定一个种子数进行创建。示例代码：Random r &#x3D; new Random();Random r1 &#x3D; new Random(10);再次强调：种子数只是随机算法的起源数字，和生成的随机数字的区间无关。 Random有两种构造方法：1.Random()，用于创建一个伪随机数生成器，无参构造，每次生成的随机数是不同的。程序示例： 12345678Random r=new Random();//随机生成10个[0,100)之间的数for(int i=0;i&lt;10;i++)&#123;System.out.println(r.nextInt(100));&#125; 每次运行生成的随机数都是不同的 2.Random(long seed)，使用一个long型的seed种子创建伪随机数生成器 ，有参构造，每次生成的随机数相同。 12345678Random r=new Random(13); //创建对象时传入种子//随机生成10个[0,100)之间的数for(int i=0;i&lt;10;i++)&#123;System.out.println(r.nextInt(100));&#125; 每次运行生成的随机数都是相同的 nextBoolan方法该方法的作用是生成一个随机的boolean值，生成true和false的值几率相等，也就是都是50%的几率。 Random a=new Random(); System.out.println(a.nextBoolean()); nextDouble方法该方法的作用是生成一个随机的double值，数值介于[0,1.0)之间。 Random a=new Random(); System.out.println(a.nextDouble()); 也可以自己指定范围生成 1234567（2）生成[0,5.0)区间的小数double d2 = r.nextDouble() * 5;因为nextDouble方法生成的数字区间是[0,1.0)，将该区间扩大5倍即是要求的区间。同理，生成[0,d)区间的随机小数，d为任意正的小数，则只需要将nextDouble方法的返回值乘以d即可。（3）生成[1,2.5)区间的小数double d3 = r.nextDouble() * 1.5 + 1;生成[1,2.5)区间的随机小数，则只需要首先生成[0,1.5)区间的随机数字，然后将生成的随机数区间加1即可。同理，生成任意非从0开始的小数区间[d1,d2)范围的随机数字(其中d1不等于0)，则只需要首先生成[0,d2-d1)区间的随机数字，然后将生成的随机数字区间加上d1即可。 就是在原本的基础上乘以多少就可以变成原本的多少倍 nextInt方法该方法的作用是生成一个随机的int值，该值介于int的区间，也就是-231到231-1之间。 Random a=new Random(); System.out.println(a.nextInt()); 同时可以自己指定生成整数的范围 生成[0,10)区间的整数 Random a&#x3D;new Random(); System.out.println(a.nextInt(10)); 生成[0,10]区间的整数 Random a&#x3D;new Random(); System.out.println(a.nextInt(11)); 生成[-3,15)区间的整数 Random a&#x3D;new Random(); System.out.println(a.nextInt(18)-3); java中Math类不用导入包 静态常量Math 类中包含 E 和 PI 两个静态常量，正如它们名字所暗示的，它们的值分别等于 e（自然对数）和 π（圆周率）。 调用 Math 类的 E 和 PI 两个常量，并将结果输出。代码如下： 1System.out.println(&quot;E 常量的值：&quot; + Math.E);System.out.println(&quot;PI 常量的值：&quot; + Math.PI); 执行上述代码，输出结果如下： 12E 常量的值：2.718281828459045PI 常量的值：3.141592653589793 System.out.println(Math.E);System.out.println(Math.PI); 求最大值、最小值和绝对值在程序中常见的就是求最大值、最小值和绝对值问题，如果使用 Math 类提供的方法可以很容易实现。这些方法的说明如表 1 所示。 就是比较的时候两个数字的数字类型一定要相同，这些函数只能是在两个数之间进行比较 求 10 和 20 的较大值、15.6 和 15 的较小值、-12 的绝对值，代码如下： 12纯文本复制public class Test02 &#123; public static void main(String[] args) &#123; System.out.println(&quot;10 和 20 的较大值：&quot; + Math.max(10, 20)); System.out.println(&quot;15.6 和 15 的较小值：&quot; + Math.min(15.6, 15)); System.out.println(&quot;-12 的绝对值：&quot; + Math.abs(-12)); &#125;&#125; 该程序的运行结果如下： 12310和20的较大值：2015.6和15的较小值：15.0-12的绝对值：12 求整运算Math 类的求整方法有很多，详细说明如表 2 所示。 &#96;&#96;&#96;import java.util.Scanner;public class Test03 {public static void main(String[] args) { Scanner input &#x3D; new Scanner(System.in); System.outprintln(“请输入一个数字：”); double num &#x3D; input.nextDouble(); System.out.println(“大于或等于 “+ num +” 的最小整数：” + Math.ceil(num)); System.out.println(“小于或等于 “+ num +” 的最大整数：” + Math.floor(num)); System.out.println(“将 “+ num +” 加上 0.5 之后最接近的整数：” + Math.round(num)); System.out.println(“最接近 “+num+” 的整数：” + Math.rint(num)); }12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 Double a=1.0; System.out.println(Math.ceil(a)); System.out.println(Math.floor(a)); System.out.println(Math.rint(a)); System.out.println(Math.round(a));//当距离两个整数一样的时候取那个小的# Java Scanner 类2022-01-25 14:23 更新java.util.Scanner是Java5的新特征，我们可以通过 Scanner 类来获取用户的输入。下面是创建 Scanner 对象的基本语法： Scanner s &#x3D; new Scanner(System.in); 1234567接下来我们演示一个最简单的的数据输入，并通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据：### 使用 next 方法： import java.util.Scanner; public class ScannerDemo { public static void main(String[] args) { Scanner scan &#x3D; new Scanner(System.in); &#x2F;&#x2F; 从键盘接收数据 //next方式接收字符串 System.out.println(&quot;next方式接收：&quot;); // 判断是否还有输入 if(scan.hasNext())&#123; String str1 = scan.next(); System.out.println(&quot;输入的数据为：&quot;+str1); &#125; &#125; } 123执行以上程序输出结果为： $ javac ScannerDemo.java$ java ScannerDemonext方式接收：youj com输入的数据为：youj 12345可以看到 com 字符串并未输出，接下来我们看 nextLine。### 使用 nextLine 方法： import java.util.Scanner; public class ScannerDemo &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); // 从键盘接收数据 //nextLine方式接收字符串 System.out.println(&quot;nextLine方式接收：&quot;); // 判断是否还有输入 if(scan.hasNextLine())&#123; String str2 = scan.nextLine(); System.out.println(&quot;输入的数据为：&quot;+str2); &#125; &#125; &#125; 1 执行以上程序输出结果为：$ javac ScannerDemo.java $ java ScannerDemo nextLine方式接收： youj com 输入的数据为：youj com 可以看到 com 字符串输出。 12345678910111213141516171819### next()与nextLine()区别**next():**- 1、一定要读取到有效字符后才可以结束输入。- 2、对输入有效字符之前遇到的空白，next()方法会自动将其去掉。- 3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。- next()不能得到带有空格的字符串。**nextLine()：**- 1、以Enter为结束符,也就是说nextLine()方法返回的是输入回车之前的所有字符。- 2、可以获得空白。如果要输入int或float类型的数据，在Scanner类中也有支持，但是在输入之前最好先使用 hasNextXxx() 方法进行验证，再使用 nextXxx() 来读取： import java.util.Scanner; public class ScannerDemo { public static void main(String[] args) { Scanner scan &#x3D; new Scanner(System.in); &#x2F;&#x2F; 从键盘接收数据 int i &#x3D; 0 ; float f &#x3D; 0.0f ; System.out.print(“输入整数：”); if(scan.hasNextInt()){ &#x2F;&#x2F; 判断输入的是否是整数 i &#x3D; scan.nextInt() ; &#x2F;&#x2F; 接收整数 System.out.println(“整数数据：” + i) ; }else{ &#x2F;&#x2F; 输入错误的信息 System.out.println(“输入的不是整数！”) ; } System.out.print(“输入小数：”); if(scan.hasNextFloat()){ &#x2F;&#x2F; 判断输入的是否是小数 f &#x3D; scan.nextFloat() ; &#x2F;&#x2F; 接收小数 System.out.println(“小数数据：” + f) ; }else{ &#x2F;&#x2F; 输入错误的信息 System.out.println(“输入的不是小数！”) ; } }} 123执行以上程序输出结果为： $ javac ScannerDemo.java$ java ScannerDemo输入整数：12整数数据：12输入小数：1.2小数数据：1.2 12345678910111213一个字节八比特，一个byte八位## java SimpleDateFormat类**1、为什么要使用SimpleDateFormat？**在Java中，如果我们想获取当前时间，一般会使用Date类的无参构造函数，如下所示，我们获取到当前时间并输出： import java.util.Date; public class SimpleDateFormatDemo { public static void main(String[] args) { Date currentTime &#x3D; new` `Date(); System.out.println(currentTime); &#x2F;&#x2F; 输出：Mon Feb 18 10:24:30 CST 2019 }&#96;&#96;} 123456789101112131415161718192021此时我们会发现， 输出的格式并不是我们预期的格式，一般情况下，我们希望的格式都是类似于2019-02-18，2019-02-18 10:24:30，2019/02/18这样的，此时我们就需要用到java.text.SimpleDateFormat来自定义格式。**2.使用format()方法将日期转换为字符串**使用format()方法，我们可以将日期类型转换为自己自定义的字符串格式，如2019-02-18，2019/02/18，2019-02-18 10:24:30等，自定义格式如下表所示：| 格式 | 释义 | 举例 || ---- | -------------- | ------------ || yyyy | 年 | 2019 || MM | 月 | 02 || dd | 日 | 18 || HH | 小时(24小时制) | 13，下午一点 || mm | 分钟 | 53 || ss | 秒 | 42 || SSS | 毫秒 | 629 | package com.zwwhnly.springbootdemo; import java.text.SimpleDateFormat;import java.util.Date;` `public class SimpleDateFormatDemo &#123; public static void main(String[] args) &#123; Date currentTime = new Date(); System.out.println(currentTime); // Mon Feb 18 13:53:50 CST 2019` ` SimpleDateFormat simpleDateFormat1 &#x3D; new` `SimpleDateFormat(“yyyy-MM-dd HH:mm:ss.SSS”); SimpleDateFormat simpleDateFormat2 = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); SimpleDateFormat simpleDateFormat3 &#x3D; new` `SimpleDateFormat(“yyyy&#x2F;MM&#x2F;dd”);` ` System.out.println(simpleDateFormat1.format(currentTime)); // 输出2019-02-18 13:53:50.629 System.out.println(simpleDateFormat2.format(currentTime)); &#x2F;&#x2F; 输出2019-02-18 System.out.println(simpleDateFormat3.format(currentTime)); // 输出2019/02/18 &#125;} 1234567**3.使用parse()方法将字符串转换为日期**在实际开发过程中，我们经常需要将字符串转换为日期类型，以进行后续操作，此时可以使用parse()方法，但需要**注意：如果字符串与指定的格式不匹配，会报java.text.ParseException异常**。 package com.zwwhnly.springbootdemo; import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date; public class SimpleDateFormatDemo { public static void main(String[] args) { try` `&#123; SimpleDateFormat simpleDateFormat1 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;); String strDate1 = “2019-02-18 13:58”; String strDate2 = “2019-02-18”;` ` Date date1 &#x3D; simpleDateFormat1.parse(strDate1); System.out.println(date1); Date date2 &#x3D; simpleDateFormat1.parse(strDate2); System.out.println(date2); } catch` `(ParseException e) &#123; e.printStackTrace(); &#125; &#125;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455运行结果如下图所示：![img](https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291918082.png)由此我们可以看到，strDate1格式匹配能正常转换为Date类型，而strDate2由于格式不匹配，抛出java.text.ParseException，正是因为如此，以上的代码才必须包括在try,catch语句中，否则IDEA会提示错误，代码也编译不通过，如下图所示：![img](https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291918064.png)## 抽象类和接口package Shape;public abstract class Shape &#123; &#123; System.out.println(&quot;执行Shapes初始化块..&quot;); &#125; private String color; public abstract double calPerimeter(); public abstract String getType(); public Shape() &#123;&#125; public Shape(String color) &#123; System.out.println(&quot;执行Shape的构造器&quot;); this.color=color; &#125;​ public interface Output&#123; int MAX_CACHE_LINE=50; void out(); void getData(String msg); default void print(String...msgs) &#123; for (String msg :msgs) &#123; System.out.println(&quot;默认的test()方法&quot;); &#125; &#125; default void test() &#123; System.out.println(&quot;test方法&quot;); &#125; static String staticTest() &#123; return &quot;接口里的类方法&quot;; &#125; &#125;&#125;多入参方式 public static void main(String[] args) { System.out.println(“test1:”); test(“a”,”b”,”c”); System.out.println(“test2:”); test(new String[] {“a”, “b”, “c”}); } /** * 测试方法 * @param params 参数 * */ public static void test(String... params)&#123; //遍历参数内容 for(String temp : params)&#123; System.out.println(temp); &#125; System.out.println(); 123定义这种类型的入参必须放到最后一个才可以，也就是说int入参需要放到可变入参的前面，同时再test1处增加一个String进行测试，看一下代码。 public static void main(String[] args) { System.out.println(“test1:”); test(1,”a”,”b”,”c”,”d”); System.out.println(“test2:”); test(2,new String[] {“a”, “b”, “c”}); } 12345678910111213141516171819202122​ /** * 测试方法 * @param params 参数 * */​ public static void test(int intParam,String... params)&#123;​ System.out.println(&quot;int:&quot;+intParam);​ //遍历参数内容​ for(String temp : params)&#123;​ System.out.println(temp);​ &#125;​ System.out.println();​ &#125;# java的内部类## 非静态内部类 package Shape; public class Shape{ private String prop&#x3D;”外部类的实例变量”; private class InClass{ private String prop&#x3D;”内部类的实例变量”; public void info() { String prop&#x3D;”局部变量”; System.out.println(Shape.this.prop); System.out.println(this.prop); System.out.println(prop); } } public void test() { InClass a&#x3D;new InClass(); a.info(); } public static void main(String[] args) { new Shape().test(); } } 123## 静态内部类 package Shape; public class Shape{ private int a&#x3D;1; private static int b&#x3D;2; static class show{ 123456789101112131415161718 private static int age=1; public int c=3; public void accessOuterProp() &#123; //System.out.println(a); System.out.println(b); &#125; &#125; public static void main(String[] args) &#123; System.out.println(show.age); System.out.println(new show().c); &#125; &#125;## 在外部类以外使用非静态内部类 package Shape; class Out{ class In{ public In(String msg){ System.out.println(msg); } }}public class Shape{ public static void main(String[] args) { Out.In in&#x3D;new Out().new In(“测试信息”); &#125; } 123## 在外部类以外使用静态内部类 package Shape; class StaticOut{ static class StaticIn{ public StaticIn() { System.out.println(“静态类内部的构造器”); } }}public class Shape{ public static void main(String[] args) { StaticOut.StaticIn in&#x3D;new StaticOut.StaticIn(); &#125; } 1234567891011121314151617181920212223242526272829## 使用静态内部类注意事项```javapackage Shape;class StaticOut&#123; private int a=1; private static int h=2; static class StaticIn&#123; public StaticIn() &#123; System.out.println(&quot;静态类内部的构造器&quot;); //System.out.println(a); StaticOut b= new StaticOut(); System.out.println(b.a); System.out.println(h); &#125; &#125;&#125;public class Shape&#123; public static void main(String[] args) &#123; StaticOut.StaticIn in=new StaticOut.StaticIn(); &#125;&#125; 匿名内部类1234567891011121314151617181920212223242526272829303132package Shape;interface Product&#123; public double getPrice(); public String getName();&#125;public class Shape&#123; private static int age=1; public void test(Product P) &#123; System.out.println(&quot;购买了一个&quot;+P.getName()+&quot;,花掉了&quot;+P.getPrice()); &#125; public static void main(String[] args) &#123; Shape a=new Shape(); a.test(new Product() &#123; public double getPrice() &#123; System.out.println(age); return 567.8; &#125; public String getName() &#123; return &quot;Agp显卡&quot;; &#125; &#125;); &#125;&#125; 12345678910111213141516171819 可以替代上面的匿名内部类 class product1 implements Product&#123;public double getPrice()&#123;return 56.7;&#125;public String getName()&#123;return &quot;agp显卡&quot;;&#125;&#125;a.test(new product1()); lambda表达式1234567891011121314151617181920212223242526272829303132333435363738394041package Shape;interface Eatable&#123;void taste(); &#125;interface Flyable&#123; void fly(String weather);&#125;interface Addable&#123; int add(int a,int b);&#125;public class Shape&#123; public void eat(Eatable e) &#123; System.out.println(e); e.taste(); &#125; public void drive(Flyable f) &#123; System.out.println(&quot;我正在驾驶&quot;+f); &#125; public void test(Addable add) &#123; System.out.println(&quot;5域3的和位&quot;+add.add(5,3)); &#125; public static void main(String[] args) &#123; Shape lq=new Shape(); lq.eat(()-&gt;System.out.println(&quot;okok&quot;)); lq.drive(weather-&gt;&#123;System.out.println(&quot;今天的天气是&quot;+weather);&#125;); lq.test((a,b)-&gt;a+b); &#125;&#125; 123456789101112package hello;interface like&#123; void print();&#125;public class Hello&#123; public static void main(String []args) &#123; like l=()-&gt;&#123; System.out.println(&quot;1&quot;); &#125;; &#125;&#125; 引用类方法1234567891011121314package Shape;@FunctionalInterfaceinterface Converter&#123; Integer convert(String from);&#125;public class Shape&#123;public static void main(String[] args) &#123;Converter converter1=from-&gt;Integer.valueOf(from);Converter converter2=Integer::valueOf;&#125;&#125; 引用特定对象的实例方法1234567891011121314package Shape;@FunctionalInterfaceinterface Converter&#123; Integer convert(String from);&#125;public class Shape&#123; Converter converter2=from-&gt;&quot;fkit.org&quot;.indexOf(from); Converter converter1=&quot;fkit.org&quot;::indexOf; int value=converter1.convert(&quot;1&quot;); void print() &#123; System.out.println(value); &#125; } 引用某类对象的实例方法12345678910111213141516171819202122package Shape;@FunctionalInterfaceinterface Mytest&#123; String test(String a,int b ,int c);&#125;public class Shape&#123;Mytest mt =(a,b,c)-&gt;a.substring(b,c);Mytest mt1=String::substring;void print() &#123; String str=mt.test(&quot;java i love you&quot;,3,9); System.out.println(str);&#125;public static void main(String[] args)&#123; Shape a=new Shape(); a.print(); &#125;&#125; 引用构造器12345678910111213141516171819202122package Shape;@FunctionalInterfaceinterface YourTest&#123; JFrame win(String title);&#125;public class Shape&#123;YourTest yt=(String a)-&gt;new JFrame(a);YourTest yt1=JFrame::new;void print() &#123; JFrame jf=yt.win(&quot;我的窗口&quot;); System.out.println(jf);&#125;public static void main(String[] args)&#123; Shape a=new Shape(); a.print(); &#125;&#125; 12345678package Shape;public class JFrame &#123;public JFrame(String a)&#123; System.out.println(&quot;a&quot;); &#125;&#125; 枚举类1234567891011121314151617181920212223242526272829303132333435363738394041package Shape;enum SeasonEnum&#123; SPRING,SUMMER,FALL,WINTER;&#125;public class Shape&#123;public void judge(SeasonEnum s)&#123; switch (s) &#123; case SPRING: System.out.println(&quot;春天&quot;); break; case SUMMER: System.out.println(&quot;夏天&quot;); break; case FALL: System.out.println(&quot;秋天&quot;); break; case WINTER: System.out.println(&quot;冬天&quot;); break; &#125;&#125;public static void main(String[] args)&#123; for (SeasonEnum s:SeasonEnum.values()) &#123; System.out.println(s); &#125; new Shape().judge(SeasonEnum.SPRING); &#125;&#125; 更合理的枚举类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package Shape;enum Gender&#123; MALE,FEMALE; private String name; public void setName(String name) &#123; switch (this) &#123; case MALE: if(name.equals(&quot;男&quot;)) &#123; this.name=name; &#125; else &#123; System.out.println(&quot;参数错误&quot;); &#125; break; case FEMALE: if(name.equals(&quot;女&quot;)) &#123; this.name=name; &#125; else &#123; System.out.println(&quot;参数错误&quot;); &#125; break; &#125; &#125; public String getName() &#123; return this.name; &#125;&#125;public class Shape&#123;public static void main(String[] args)&#123; Gender g=Gender.valueOf(&quot;FEMALE&quot;); g.setName(&quot;女&quot;); System.out.println(g+&quot;代表&quot;+g.getName()); //g.setName(&quot;男&quot;); &#125;&#125; 用构造器做的枚举类，更合理12345678910111213141516171819202122232425package Shape;enum Gender&#123; MALE(&quot;男&quot;),FEMALE(&quot;女&quot;); private final String name; private Gender(String name) &#123; this.name=name; &#125; public String getName() &#123; return this.name; &#125;&#125;public class Shape&#123;public static void main(String[] args)&#123; Gender g=Gender.valueOf(&quot;FEMALE&quot;); System.out.println(g.getName()); &#125; &#125; 实现接口的枚举类，不同的枚举值重写的函数还不一样1234567891011121314151617181920212223242526272829303132333435package Shape;interface GenderDesc&#123; void info(); &#125;enum Gender implements GenderDesc&#123;MALE(&quot;男&quot;)&#123;public void info()&#123;System.out.println(&quot;这个枚举值代表男性&quot;); &#125;&#125;,FEMALE(&quot;女&quot;)&#123; public void info() &#123; System.out.println(&quot;这个枚举值代表女性&quot;); &#125;&#125;; private final String name;private Gender(String name) &#123; this.name=name;&#125;&#125;public class Shape&#123;public static void main(String[] args)&#123; Gender g=Gender.valueOf(&quot;FEMALE&quot;); g.info(); &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051这个是包含抽象方法的枚举类在对枚举值实例化的时候也是进行了一个方法的重写，类似于匿名内部类，创建了一个Gender子类的实例package Shape;enum Gender&#123;PLUS&#123;public double eval(double x, double y)&#123; return x+y;&#125;&#125;,MINUS&#123;public double eval(double x,double y) &#123;return x-y; &#125;&#125;,TIMES&#123;public double eval(double x,double y)&#123;return x*y; &#125;&#125;,DEVIDE&#123; public double eval(double x,double y) &#123; return x/y; &#125;&#125;;public abstract double eval(double x,double y);public static void main(String []args) &#123; System.out.println(Gender.PLUS.eval(5,4)); System.out.println(Gender.PLUS.eval(5,4)); System.out.println(Gender.PLUS.eval(5,4)); System.out.println(Gender.PLUS.eval(5,4));&#125; } java中的集合Collection这是一个接口，只能new 实现类 Collection常用方法 12345678910111213141516171819202122int size();boolean isEmpty();boolean contains(Object o);//调用o的equals方法和集合中元素比较来判断是否存在Iterator&lt;E&gt; iterator();Object[] toArray ();boolean add(E o);boolean remove(Object o);boolean containsAll (Collection&lt;?&gt; c);//检查集合c是否在集合里面出现boolean addAll (Collection&lt;? extends E&gt; c);boolean removeAll (Collection&lt;?&gt; c);//boolean retainAll (Collection&lt;?&gt; c);//保留两个集合交集void clear();boolean equals(Object o); 常用方法的使用 12345678910111213141516171819202122232425package Shape;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;public class Shape&#123;public static void main(String []args) &#123; Collection c =new ArrayList(); c.add(&quot;寻悟空&quot;); c.add(6); c.remove(6); System.out.println(c.contains(&quot;寻悟空&quot;)); c.add(&quot;java&quot;); Collection books=new HashSet(); books.add(&quot;轻量级javaee企业实战&quot;); books.add(&quot;疯狂java将以&quot;); books.add(&quot;寻悟空&quot;); c.removeAll(books);//移除c中和books相同的元素 c.clear();//清除所有元素 books.retainAll(c);//移除books中和c不相同的元素 System.out.println(books);&#125;&#125; 使用lambda表达式遍历集合 12345678910111213141516package Shape;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;public class Shape&#123;public static void main(String []args) &#123; Collection books=new HashSet(); books.add(&quot;轻量级javaee企业实战&quot;); books.add(&quot;疯狂java讲义&quot;); books.add(&quot;疯狂安定&quot;); books.forEach(obj-&gt;System.out.println(&quot;迭代元素集合&quot;+obj));&#125;&#125; Iterator 遍历集合元素 例一 12345678910111213141516171819202122232425262728293031323334package Shape;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;import java.util.Iterator;public class Shape&#123;public static void main(String []args) &#123; Collection books=new HashSet(); books.add(&quot;轻量级javaee企业实战&quot;); books.add(&quot;疯狂java讲义&quot;); books.add(&quot;疯狂安定&quot;); Iterator it =books.iterator(); while(it.hasNext()) &#123; String book=(String)it.next(); System.out.println(book); if(books.equals(&quot;疯狂java讲义&quot;)) &#123; it.remove();//从集合中删除上一次next()方法返回的元素 //books.remove();迭代过程中不能使用这个，只有Iterator来remove才行 &#125; book=&quot;测试字符串&quot;;//对book变量赋值，不会改变集合元素本身的 System.out.println(books); it.forEachRemaining(obj-&gt;System.out.println(&quot;可迭代的元素&quot;+obj)); &#125;&#125;&#125; 例二 12345678910111213141516public static void main(String []args) &#123;Collection c=new HashSet();c.add(new Student(1,&quot;Tom&quot;,60));c.add(new Student(2,&quot;Peter&quot;,70));c.add(new Student(3,&quot;Bob&quot;,80));Iterator i=c.iterator();while(i.hasNext()) &#123; Student s=(Student)i.next();//将得到的元素强制转换为（Student）类然后就可以正常使用了 //如果这里上面的Iterator规定泛型是&lt;Student&gt;就不需要转换了 //其实其他集合也是一样，因为java无法知道集合中是什么类 System.out.println(s.getName());&#125; &#125; jdk1.5用foreach循环遍历集合 1234567891011121314151617181920212223242526package Shape;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;public class Shape&#123;public static void main(String []args) &#123; Collection books=new HashSet(); books.add(&quot;轻量级javaee企业实战&quot;); books.add(&quot;疯狂java讲义&quot;); books.add(&quot;疯狂安定&quot;); for(Object obj:books) &#123; String book=(String)obj; System.out.println(&quot;book&quot;); if(book.equals(&quot;疯狂java讲义&quot;)) &#123; books.remove(book); &#125; &#125; System.out.println(books); &#125;&#125; Predicate操作集合 1234567891011121314151617181920package Shape;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;public class Shape&#123;public static void main(String []args) &#123; Collection books=new HashSet(); books.add(&quot;轻量级javaee企业实战&quot;); books.add(&quot;疯狂java讲义&quot;); books.add(&quot;疯狂安定&quot;); books.add(&quot;疯狂ios讲义&quot;); books.add(&quot;疯狂ajax讲义&quot;); books.add(&quot;疯狂andriod将以&quot;); books.removeIf(ele-&gt;((String)ele).length()&lt;10); System.out.println(books);&#125;&#125; 123456789101112131415161718192021222324252627282930package Shape;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;import java.util.function.Predicate;public class Shape&#123;public static void main(String []args) &#123; Collection books=new HashSet(); books.add(&quot;疯狂java&quot;); books.add(&quot;疯狂javajavajavajvaa&quot;); System.out.println(calAll(books,ele-&gt;((String)ele).contains(&quot;疯狂&quot;)));&#125;public static int calAll(Collection books,Predicate p)&#123; int total=0; for(Object obj:books) &#123; if(p.test(obj)) &#123; total++; &#125; &#125; return total;&#125;&#125; List集合是一个集合，需要new实现类 特点：实现该接口的类中的元素**有顺序，可以重复 List容器中的元素都有一个对应的整数型的序号，用以记录元素在容器中的位置，可以根据序号取元素。** 主要实现类：ArrayList，LinkedList 列表：按照一定次序（对象进入的顺序）排列的·对象集，对象之间有次序关系，对象可以重复 Object get(int index); Object set(int index, Object element); void add(int index,Object element); Object remove(int index); int indexOf (Object o); int lastIndexOf(Object o); 常用方法的使用 123456789101112131415161718192021222324package Hello;import java.util.ArrayList;import java.util.List;import java.util.Scanner;public class Hello&#123; public static void main(String[] args) &#123;List books=new ArrayList();books.add(new String(&quot;轻量级javaee企业应用实战&quot;));books.add(new String (&quot;疯狂java讲义&quot;));books.add(new String(&quot;疯狂狂andriod讲义&quot;));System.out.println(books);books.add(1,new String(&quot;java讲义&quot;));//将新字符串对象插入在第二个位置for(int i=0;i&lt;books.size();i++)&#123;System.out.println(books.get(i)); &#125;books.remove(2);//删除第三个元素System.out.println(books);System.out.println(books.indexOf(new String(&quot;java讲义&quot;)));//判断指定元素在List集合中的位置，输出1，表明位于第二位books.set(1,new String(&quot;疯狂java讲义&quot;));//将第二个元素替换成新的字符串对象System.out.println(books);System.out.println(books.subList(1,2));//将集合的第二个元素截取成子集合,就是第二个参数减一是结束下标 &#125; } addAll方法 1234567891011121314151617 public static void main(String []args) &#123;ArrayList&lt;String&gt; a=new ArrayList&lt;String&gt;();ArrayList&lt;String&gt; b=new ArrayList&lt;String&gt;();a.add(&quot;a&quot;);a.add(&quot;b&quot;);a.add(&quot;c&quot;);b.add(&quot;a&quot;);b.add(&quot;b&quot;);b.add(&quot;c&quot;);a.addAll(b);System.out.println(a); &#125;结果：[a, b, c, a, b, c] LIST集合是通过equals方法判断两个对象是否一样的 A类重写了equals方法 123456789101112131415161718192021222324package Hello;import java.util.ArrayList;import java.util.List;import java.util.Scanner;class A&#123; public boolean equals(Object obj) &#123; return true; &#125;&#125;public class Hello&#123; public static void main(String[] args) &#123;List books=new ArrayList();books.add(new String(&quot;轻量级javaee企业应用实战&quot;));books.add(new String (&quot;疯狂java讲义&quot;));books.add(new String(&quot;疯狂狂andriod讲义&quot;));books.remove(new A());//会删除第一个元素，因为它和任意元素都可以相等books.remove(new A());//再次删除第一个元素System.out.println(books); &#125;&#125; List两个新增方法sort和replacell()方法 sort需要一个Comparator对象来控制元素排序，程序可使用Lambda表达式作为参数 sort方法必须传入构造器 replaceAll()方法需要一个UnaryOperator来替换所有的集合元素，UnaryOperator是一个函数式接口，也可以使用Lambda作为参数 12345678910111213141516171819202122232425262728package Hello;import java.util.ArrayList;import java.util.List;import java.util.Scanner;class A&#123; public boolean equals(Object obj) &#123; return true; &#125;&#125;public class Hello&#123; public static void main(String[] args) &#123;List books=new ArrayList();books.add(new String(&quot;轻量级javaee企业应用实战&quot;));books.add(new String (&quot;疯狂java讲义&quot;));books.add(new String(&quot;疯狂狂andriod讲义&quot;)); //使用目标类型为Comparator的Lambda表达式对List集合排序books.sort((o1,o2)-&gt;((String)o1).length()-((String)o2).length());System.out.println(books); //使用目标类型为UnaryOperator的Lambda表达式来替换集合中的所有元素 //该Lambda表达式控制使用每个字符串的长度作为新的集合元素books.replaceAll(ele-&gt;((String)ele).length());System.out.println(books); &#125;&#125; 123456789101112131415161718192021222324252627class Compare implements Comparator&lt;Integer&gt;&#123; @Override public int compare(Integer o1, Integer o2) &#123; return o2-o1; &#125;&#125;public class Main&#123; public static void main(String []args) &#123;ArrayList&lt;Integer&gt; a=new ArrayList&lt;Integer&gt;();a.add(1);a.add(4);a.add(3);Compare b=new Compare();a.sort(b);System.out.println(a); &#125;&#125;结果：[4, 3, 1] Arrays.List方法 123456789101112131415161718192021222324package Hello;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.Scanner;class A&#123; public boolean equals(Object obj) &#123; return true; &#125;&#125;public class Hello&#123; public static void main(String[] args) &#123;List books=Arrays.asList(&quot;轻量级javaee企业应用实战&quot;,&quot;疯狂java讲义&quot;,&quot;疯狂狂andriod讲义&quot;);System.out.println(books.getClass());books.forEach(System.out::println);//books.add(&quot;疯狂java讲义&quot;);//books.add(&quot;疯狂java&quot;); &#125;&#125; 将集合转变为数组的方法 ** 123456789101112131415161718192021222324public** **static** **void** main(String[] args)&#123;​ *// 创建一个动态数组*​ ArrayList&lt;String&gt; sites = **new** ArrayList&lt;&gt;();​ ​ sites.add(&quot;Runoob&quot;);​ sites.add(&quot;Google&quot;);​ sites.add(&quot;Wiki&quot;);​ sites.add(&quot;Taobao&quot;);​ System.out.println(&quot;网站列表: &quot; + sites);​ *// 创建一个新的 String 类型的数组*​ *// 数组长度和 ArrayList 长度一样*​ String[] arr = **new** String[sites.size()];​ *// 将ArrayList对象转换成数组*​ sites.toArray(arr);​ *// 输出所有数组的元素*​ System.out.print(&quot;Array: &quot;);​ **for**(String item:arr) &#123;​ System.out.print(item+&quot;, &quot;);​ &#125; &#125; 子类ArrayListArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。 ArrayList 继承了 AbstractList ，并实现了 List 接口。 12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.Collections;class Main&#123;public static void main(String []args)&#123; ArrayList&lt;String&gt; sites=new ArrayList&lt;String&gt;(); sites.add(&quot;google&quot;);//向集合中添加 sites.add(&quot;runoob&quot;); sites.add(&quot;taobao&quot;); System.out.println(sites.get(1));//得到指定下标的元素 sites.set(2, &quot;Wiki&quot;);//在指定下标处插入 sites.remove(3);//移除下标为3的元素 System.out.println(sites.size()); for(int i=0;i&lt;sites.size();i++) &#123; System.out.println(sites.get(i)); &#125; for(String i:sites) &#123; System.out.println(i); &#125; ArrayList&lt;Integer&gt; myNumbers=new ArrayList&lt;Integer&gt;(); myNumbers.add(10); myNumbers.add(15); myNumbers.add(20); myNumbers.add(25); System.out.println(myNumbers.size());//得到数组中元素的数量 Collections.sort(sites);//排序 for(String i:sites) &#123; System.out.println(i); &#125;&#125;&#125; 一个ArrayList自己的排序方法 sort方法中的参数是一个比较器，下面这个例子是按照字母顺序进行排序 12345678910111213class Main&#123; public static void main(String []args) &#123; ArrayList&lt;String&gt; name=new ArrayList&lt;String&gt;(); name.add(&quot;a&quot;); name.add(&quot;c&quot;); name.add(&quot;b&quot;); name.sort(Comparator.naturalOrder()); System.out.println(name); &#125;&#125; ArrayList转数组 1234567891011121314151617181920public class Main &#123;public static void main(String []args) &#123; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.add(&quot;c&quot;); list.add(&quot;d&quot;); list.add(&quot;e&quot;); list.add(&quot;f&quot;); list.add(&quot;g&quot;); String[] array =new String[list.size()]; list.toArray(array); for(String x:list) &#123; System.out.println(x); &#125;&#125;&#125; VectorList接口的实现类。 特点：跟ArrayList一样，都是可变长的对象数组。 与ArrayList区别 ①Vector是线程安全的，是可以同步的，运行效率低； ②ArrayList不同步，适合于单线程环境中。 public Object elementAt(int index) public void addElement(Object obj) public void removeElementAt(int index) public void insertElementAt(E obj, int index) public boolean removeElement(Object obj) public void removeAllElements() Stack(栈)extends Vector 后进先出，就是一个底下有底的箱子，只能从上面拿所以是后进先出 常用方法 – public Object push(E item) – public Object pop() – public Object peek() – public boolean empty() – public int search(Object o) 1234567891011121314public static void main(String []args) &#123; Stack s=new Stack(); s.push(&quot;hello&quot;); s.push(new Date());//往箱子里面放东西 s.push(100); s.push(3.14); System.out.println(&quot;弹栈前size=&quot;+s.size()); System.out.println(s.pop());//弹出箱子中最顶上的元素 System.out.println(&quot;弹栈后size=&quot;+s.size()); System.out.println(s.peek());//获得箱子中最顶上的元素，但是不弹出 System.out.println(&quot;peek操作后&quot;+s.size()); while(!s.isEmpty()) &#123;//判断箱子中是否是空 System.out.println(s.pop()); &#125; 把Stack当作普通List用 失去了Stack所特有的性质 12345678910111213141516171819202122public static void main(String[] args) &#123;Stack&lt;String&gt; s = new Stack&lt;String&gt;();s.add(&quot;one&quot;);s.add(&quot;two&quot;);s.add(&quot;three&quot;);s.add(2, &quot;four&quot;);s.add(0,&quot;five&quot;);System.*out*.println(s);s.remove(&quot;two&quot;);System.*out*.println(s);&#125; Queue集合队列：一种先进先出（FIFO）的容器，从容器的一端放入对象，从另一端取出对象，并且放入和取出的顺序相同 常用方法 –offer()：（入队）如果可能，将指定的元素插入此队列。 –peek()，element()：在不移除的情况下返回队头。peek方法在队列为空时返回null，element方法在队列为空时抛出异常。 –poll()，remove()：移除并返回队头（出队）。poll方法在队列为空时返回null，remove方法在队头为空时抛出异常。 12345678910Queue queue=new LinkedList();queue.offer(&quot;hello&quot;);queue.offer(&quot;world&quot;);queue.offer(&quot;你好&quot;);System.out.println(queue.size());String str;System.out.println(queue.peek());//返回当前队头的元素while((str=(String)queue.poll())!=null) &#123;//移除并返回当前队头的元素 System.out.println(str);&#125; PriorityQueue实现类123456789101112131415161718192021222324package Hello;import java.util.PriorityQueue;class A&#123; public boolean equals(Object obj) &#123; return true; &#125;&#125;public class Hello&#123; public static void main(String[] args) &#123;PriorityQueue pq=new PriorityQueue();pq.offer(6);pq.offer(-3);pq.offer(20);pq.offer(18);System.out.println(pq);System.out.println(pq.poll()); &#125;&#125; Deque接口与ArrayDeque实现类1234567891011121314151617181920212223package Hello;import java.util.ArrayDeque;import java.util.PriorityQueue;class A&#123; public boolean equals(Object obj) &#123; return true; &#125;&#125;public class Hello&#123; public static void main(String[] args) &#123;ArrayDeque stack=new ArrayDeque();stack.push(&quot;疯狂java讲义&quot;);stack.push(&quot;轻量级java ee企业应用实战&quot;);System.out.println(stack.peek());System.out.println(stack.pop());System.out.println(stack); &#125;&#125; LinkedList实现类123456789101112131415161718192021222324252627282930313233package Hello;import java.util.ArrayDeque;import java.util.LinkedList;import java.util.PriorityQueue;class A&#123; public boolean equals(Object obj) &#123; return true; &#125;&#125;public class Hello&#123; public static void main(String[] args) &#123;LinkedList books=new LinkedList();books.offer(&quot;疯狂java讲义&quot;);books.push(&quot;轻量级java ee企业级应用实战&quot;);books.offerFirst(&quot;疯狂andriod讲义&quot;);for(int i=0;i&lt;books.size();i++)&#123;System.out.println(&quot;遍历中&quot;+books.get(i)); &#125;System.out.println(books.peekFirst());System.out.println(books.peekLast());System.out.println(books.pop());System.out.println(books);System.out.println(books.pollLast());System.out.println(books); &#125;&#125; Set对象唯一，不会重复，元素没有顺序 HashSet元素值可以使null HashSet判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode方法返回值也相等（重写两个方法的时候最好两者统一） 先判断hashCode是否相等，如果hashCode相等再去判断equals方法是否为true 只有用到Hashtable HashMap HashSet LinkedHashMap等时才要注意hashcode方法。 equals方法重写的方法1234567891011121314151617181920212223242526272829public boolean equals(Object obj) &#123;if (this == obj) return true;if (obj == null)//先看看参数是不是空 return false;if (getClass() != obj.getClass())//再看看参数是否是同一个类，getClass()是指获取这个类创建实例的类型，也就是获取当前类这个类型 return false;//getClass方法获得的不是引用变量的类型，而是真正的类型final Student other = (Student) obj;if (no != other.no) return false;return true;&#125;public String toString() &#123; return &quot;no is : &quot; + no;&#125; 重写equals方法 12345678910public boolean equals(Object obj) &#123; if(obj==null) &#123;//先判断是否为空 return false; &#125; if(obj instanceof Company) &#123;//判断能否向下转型 Company c=(Company)obj; return c.name.equals(name); &#125; return false; &#125; TreeSet实现了对Set的排序 自然排序 123456789public static void main(String []args) &#123;TreeSet ts=new TreeSet();ts.add(&quot;YaoMing&quot;);ts.add(&quot;Kobe&quot;);ts.add(&quot;McGrand&quot;);ts.add(&quot;Jordan&quot;);System.out.println(ts); &#125; 结果：[Jordan, Kobe, McGrand, YaoMing] 按照字典排序 定制排序 TreeSet(Comparator&lt;? super E&gt; comparator) 可以自己写一个构造器当作参数 LinkedSet就是按照插入的顺序排列元素 Mapjava中的Hash表Hash表介绍 哈希表：能够通过元素快速查获找到元素的存储位置，又称为散列表。 哈希表基本原理：通过哈希函数或散列函数将元素的关键字和元素的存储位置关联起来。由哈希函数计算出来的值称为哈希码(Hash Code)或散列索引。 哈希表的存储空间称为哈希表的容量(Capacity)。 hash表分为三类 java语言提供了java.util.Hashtable, java.util.HashMap, java.util.WeakHashMap三个类来提供哈希存储支持。这三者的元素都是主要由关键字和值两部分组成。 Hashtable元素的关键字和值都不允许null。HashMap和WeakHashMap的关键字和值都允许null。 Hashtable支持线程同步， HashMap和WeakHashMap不支持线程同步。 WeakHashMap会自动按一定规则检查各个元素是否常用，不常用的元素会被去除，从而被系统回收。（WeakHashMap是HashMap的子类） k-y相等判断方式判断两个value相等，两个对象通过equals方法比较返回true即可，判断两个key相等，那equals放回true hashcode值也相等 Map元素遍历Set keySet( )获取所有Key的集合 Collection values( ) 获取所有Value的集合 Set entrySet( ) 获取所有key-value对的集合 再用相应的Iterator或者for循环遍历 例一 12345678910HashMap&lt;String ,Integer&gt; a=new HashMap&lt;String,Integer&gt;();a.put(&quot;a&quot;,1);a.put(&quot;b&quot;,2);Set b=a.keySet();Iterator&lt;String&gt; i=b.iterator();while(i.hasNext()) &#123; String key=i.next(); Integer value=a.get(key); System.out.println(key+&quot;-&quot;+value+&quot; &quot;);&#125; 1234567891011 public static void main(String []args) &#123;HashMap &lt;String,Integer&gt;a=new HashMap&lt;String,Integer&gt;();a.put(&quot;a&quot;,1);a.put(&quot;b&quot;,2);a.put(&quot;c&quot;,3);Collection b=a.values();System.out.println(b);结果：[1, 2, 3]&#125; 例二 entrySet方法介绍 Map的entrySet()方法返回一个实现Map.Entry接口的对象集合。集合中每个对象都是底层Map中一个特定的键&#x2F;值对。通过这个集合的迭代器，获得每一个条目(唯一获取方式)的键或值并对值进行更改。Map.Entry中的常用方法如下所示： 123(1) Object getKey(): 返回条目的关键字 (2) Object getValue(): 返回条目的值 (3) Object setValue(Object value): 将相关映像中的值改为value，并且返回旧值 12345678910public static void main(String[]args) &#123; HashMap&lt;String ,Integer&gt; a=new HashMap&lt;String,Integer&gt;(); a.put(&quot;a&quot;,1); a.put(&quot;b&quot;,2); Set b=a.entrySet(); for(Object o:b) &#123; Map.Entry e=(Map.Entry)o; System.out.println(e.getKey()+&quot;-&quot;+e.getValue()+&quot; &quot;); &#125;&#125; 按照key或者value对map排序的方法Map会根据key的大小来自动排序 因为LinekedHashMap是按照顺序添加的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.*;class compare1 implements Comparator&lt;Map.Entry&gt;&#123; @Override public int compare(Map.Entry o1,Map.Entry o2) &#123; return (int)(o2.getValue())-(int)(o1.getValue());//注意这个地方的()缺一不可 &#125;&#125;class Main&#123; public static void main(String []args)&#123; Scanner in=new Scanner(System.in); String a=in.nextLine(); String b[]=a.split(&quot; &quot;); Hashtable&lt;String,Integer&gt; c=new Hashtable&lt;String,Integer&gt;(); int count =0; for(int i=0;i&lt;b.length;i++) &#123; if(c.containsKey(b[i])) &#123; c.put(b[i],c.get(b[i])+1); &#125; else &#123; c.put(b[i],1); &#125; &#125; List list=new LinkedList(c.entrySet()); compare1 q=new compare1(); Collections.sort(list,q); Map sortedMap=new LinkedHashMap();//这个地方必须使用LinkedHashMap for(Iterator it=list.iterator();it.hasNext();) &#123; Map.Entry entry=(Map.Entry)it.next();//这里的迭代器如果加泛型&lt;Iterator&gt;,就不用强制转换了 sortedMap.put(entry.getKey(), entry.getValue());&#125; Set h=sortedMap.keySet(); Iterator&lt;String&gt; r=h.iterator(); while(r.hasNext()) &#123; String i=r.next(); System.out.println(i+&quot;:&quot;+ sortedMap.get(i)); &#125; &#125;&#125; 用函数法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.*;import java.util.Map.Entry;class Compare implements Comparator&lt;Map.Entry&gt;&#123; @Override public int compare(Map.Entry o1,Map.Entry o2) &#123; return (int)(o2.getValue())-(int)(o1.getValue()); &#125;&#125;class Main&#123; public static Map getMap(Map unsortedMap) &#123; List a=new ArrayList(unsortedMap.entrySet()); Compare b=new Compare(); Collections.sort(a,b); Map sortedMap=new LinkedHashMap();//这里必须是LinkedHashMap for(Iterator it=a.iterator();it.hasNext();) &#123; Map.Entry entry=(Map.Entry)it.next(); sortedMap.put(entry.getKey(), entry.getValue()); &#125; return sortedMap; &#125; public static void main(String []args) &#123; Scanner in=new Scanner(System.in); String a=in.nextLine(); String b[]=a.split(&quot; &quot;); Hashtable&lt;String,Integer&gt; c=new Hashtable&lt;String,Integer&gt;(); int count =0; for(int i=0;i&lt;b.length;i++) &#123; if(c.containsKey(b[i])) &#123; c.put(b[i],c.get(b[i])+1); &#125; else &#123; c.put(b[i],1); &#125; &#125; Map n=getMap(c); Set i=n.keySet(); Iterator&lt;String&gt; e=i.iterator(); while(e.hasNext()) &#123; String t=e.next(); System.out.println(t+&quot;:&quot;+n.get(t)); &#125; &#125;&#125;就是java是向下兼容的，如果函数返回类型是Map其实是返回的只要是Map的子类的实例化对象都可以 如果函数的参数类型是Map类型，其实这个参数只要是Map子类的实例化对象都可以 ​ Hashtable集合不能保证顺序 Hashtable的构造方法 名称 描述 public Hashtable( ) 创建哈希表实例对象，容量为11，装填因子为0.75。 public Hashtable( int initialCapacity) 创建哈希表实例对象，容量为initialCapacity，装填因子为0.75。 public Hashtable( int initialCapacity, float loadFactor) 创建哈希表实例对象，容量为initialCapacity，装填因子为loadFactor。 Hashtable ht1&#x3D;new Hashtable&lt;String, Integer&gt; ( ); Hashtable ht2&#x3D;new Hashtable( );&#x2F;&#x2F;未指定关键字和键值类型，编译会警告 java.util.Hashtable的成员方法 名称 描述 public V put(K key, V value ) 添加关键字为****key, 值为value的元素 public V get(Object key) 获得由参数key指定的关键字所对应的元素值 public void Clear( ) 清空整个Hash表 public boolean containsKey(Object key) 判断表中是否存在关键字****key public boolean containsValue(Object value) 判断表中是否存在元素值****value public boolean contains(Object value) 判断表中是否存在元素值****value public boolean isEmpty( ) 判断Hash表是否为空 public V remove(Object key) 删除指定关键字key所对应的元素 public int size( ) 返回Hash表元素的个数 1234567891011121314151617例子 String []sa= &#123;&quot;Mary&quot;,&quot;Tom&quot;,&quot;John&quot;,&quot;James&quot;,&quot;Louis&quot;,&quot;Jim&quot;,&quot;Rose&quot;,&quot;Ann&quot;,&quot;Liza&quot;,&quot;Betty&quot;,&quot;Henry&quot;&#125;; Hashtable &lt;String ,Integer&gt; ht=new Hashtable&lt;String ,Integer&gt;(); for(int i=0;i&lt;sa.length;i++) &#123; ht.put(sa[i],new Integer(i) );//将这个key和value放入hash表中 &#125; String s=sa[5]; System.out.println(ht.get(s));//获得key为参数所对应的value值 System.out.println(ht.containsKey(sa[5])); System.out.println(ht.containsValue(1)); System.out.println(ht.contains(1)); System.out.println(ht.isEmpty()); System.out.println(ht.size()); ht.remove(sa[5]); System.out.println(ht.size()); 还有一个方法就是keySet() ，可以得到集合的key的一个集合** Set s &#x3D; ht.keySet();** Properties集合Properties是用来读取配置文件的（结尾为.properties的文件） Properties类表示一组持久的属性。 Properties可以保存到流中或从流中加载。 extends Hashtable&lt;k,v&gt; implements Map&lt;k,v&gt; Properties集合是一个唯一和IO相结合的集合 第一条的解释 可以使用Properties集合中的方法store，把集合中的临时数据，持久化写入到硬盘中存储 可以使用Properties集合中的load，把硬盘保存的文件（键值对），读取到集合中使用 属性列表中的每个键及其对应的值都是一个字符串。 解释： ​ Properties集合是一个双列集合，key和value默认都是字符串 Properties集合存储数据，遍历取出Properties集合中的数据 Properties结合是一个双列集合，key和value默认都是字符串 Properties集合有一些操作字符串的特有方法 ​ Object setProperty(String key,String value)其实就是调用Hashtable的方法put ​ String getProperty(String key) 通过key找到value值，相当于Map集合中的get方法 ​ Set stringPropertyNames() 返回此属性列表中的一组键，其中键及其对应的值为字符串，包括默认属性列表中的不同键，如果尚未从主属性列表中找到相同名称的键。相当于Map集合中的keySet方法 几个方法的基本使用 //创建Properties集合对象 Properties prop=new Properties(); prop.setProperty(&quot;a&quot;, &quot;1&quot;); prop.setProperty(&quot;b&quot;,&quot;2&quot;); prop.setProperty(&quot;c&quot;,&quot;3&quot;); //使用stringPropertyNames把Properties集合中的键取出，存储到一个Set集合中 Set&lt;String&gt; set=prop.stringPropertyNames(); for(String key:set) &#123; String value=prop.getProperty(key); System.out.println(key+&quot;-&quot;+value); Properties集合中的store方法 void store(OutputStream out,String comments) void store(Writer writer,String comments) 参数： ​ OutputStream out：字节输出流，不能写入中文 ​ Writer writer ：字符输出流，可以写中文 ​ String comments：注释，解释说明保存的文件是做什么用的 ​ 不能使用中文，会产生乱码，默认是Unicode编码，而系统默认编码是GBK 使用步骤： ​ 1.创建Properties集合对象，添加数据 ​ 2.创建字节输出流&#x2F;字符输出流对象，构造方法中绑定要输出的目的地 ​ 3.使用Properties集合中的方法store，把集合中的临时数据，持久化写入到硬盘中存储 ​ 4.释放资源 123456789101112131415161718192021222324public static void main(String []args) throws IOException &#123;show01();&#125;private static void show01() throws IOException &#123; //1.创建Properties集合对象，添加数据 Properties prop=new Properties(); prop.setProperty(&quot;a&quot;, &quot;1&quot;); prop.setProperty(&quot;b&quot;,&quot;2&quot;); prop.setProperty(&quot;c&quot;,&quot;3&quot;); //.创建字节输出流/字符输出流对象，构造方法中绑定要输出的目的地FileWriter fw=new FileWriter(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);// 3.使用Properties集合中的方法store，把集合中的临时数据，持久化写入到硬盘中存储prop.store(fw,&quot;sava data&quot;);//关闭资源fw.close();&#125;文件写入结果： #sava data#Fri Jul 01 10:34:48 CST 2022a=1b=2c=3上面的时间是自己加的 Properties集合的load方法 可以使用Properties集合中的方法load，把硬盘中保存的文件（键值对），读取到集合中使用 void load(InputStream inStream) void load(Reader reader) 参数： ​ InputStream inStream：不能读取含有中文的键值对 ​ Reader reader：字符输入流，能读取含有中文的键值对 使用步骤： ​ 1.创建Properties集合对象 ​ 2.使用Properites集合对象中的方法load读取到保存键值对的文件 ​ 3.遍历Properties集合 注意：1.存储键值对的文件中，键与值默认的连接符号可以使用-，空格（其他符号） ​ 2.存储键值对的文件中，可以使用井号进行注释，被注释的键值对不会再被读取 ​ 3.存键值对的文件中，键与值都默认是字符串，都不用再加引号 12345678public void test2() throws Exception &#123; Properties pros=new Properties(); FileInputStream fis=new FileInputStream(&quot;./jdbc.properties&quot;); pros.load(fis); String user=pros.getProperty(&quot;user&quot;); String password=pros.getProperty(&quot;password&quot;); System.out.println(&quot;user=&quot;+user+&quot;password=&quot;+password);&#125; HashMap集合不能保证顺序 12345678910111213141516171819202122232425262728293031323334package Hello;import java.util.HashMap;import java.util.Map;class A&#123; public boolean equals(Object obj) &#123; return true; &#125;&#125;public class Hello&#123; public static void main(String[] args) &#123;Map map=new HashMap();map.put(&quot;疯狂Java&quot;,109);map.put(&quot;疯狂python&quot;,10);map.put(&quot;疯狂ios&quot;,79);map.put(&quot;疯狂php&quot;,99);System.out.println(map.put(&quot;疯狂python&quot;,99));System.out.println(map);System.out.println(map.containsKey(&quot;疯狂python&quot;));System.out.println(map.containsValue(99));for(Object key:map.keySet())&#123;System.out.println(key+&quot;--&gt;&quot;+map.get(key));&#125;map.remove(&quot;疯狂python&quot;);System.out.println(map); &#125;&#125; LinkedHashMap实现类是一种按照map的添加顺序存储的实现类 12345678910111213141516171819202122package Hello;import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;class A&#123; public boolean equals(Object obj) &#123; return true; &#125;&#125;public class Hello&#123; public static void main(String[] args) &#123;LinkedHashMap scores=new LinkedHashMap();scores.put(&quot;语文&quot;,80);scores.put(&quot;英语&quot;,82);scores.put(&quot;数学&quot;,76);scores.forEach((key,value)-&gt;System.out.println(key+&quot;--&gt;&quot;+value)); &#125;&#125; 实用类Collections类提供了List容器操作的静态方法 void sort(List list);&#x2F;&#x2F;对List容器内元素排序，默认升序 void reverse(List list);&#x2F;&#x2F;对List容器内的对象进行逆序排列 void copy(List dest,List src); &#x2F;&#x2F;把src中List容器内容拷贝到dest List容器 int binarySearch(List list, Object key); &#x2F;&#x2F;对顺序的List容器，用折半查找方法查找指定对象，返回对应key元素的下标 void shuffle(List);&#x2F;&#x2F;对List容器内的对象进行随机排序 12345678910111213public static void main(String[]args) &#123; List list1=new LinkedList(); for(int i=0;i&lt;=9;i++) &#123; list1.add(&quot;a&quot;+i); &#125; System.out.println(list1); Collections.reverse(list1); System.out.println(list1); Collections.shuffle(list1); System.out.println(list1); Collections.sort(list1); System.out.println(Collections.binarySearch(list1,&quot;a2&quot;)); &#125; Collections.sort()方法public static void sort(List list, Comparator&lt;? super T&gt; c) List(接口)就是指List类型,那么也就是说只能对集合的具体类的Arraylist和LinkedList这两种类型进行排序,由于接口也能向上转型,光论排序的内容的话其它各种自建类型都行。 第一种方法 在日常开发中，很多时候都需要对一些数据进行排序的操作。然而那些数据一般都是放在一个集合中如：Map ，Set ，List 等集合中。他们都提共了一个排序方法 sort()，要对数据排序直接使用这个方法就行，但是要保证集合中的对象是 可比较的。 怎么让一个对象是 可比较的，那就需要该对象实现 Comparable 接口啦。然后重写里面的compareTo()方法 &#96;&#96;&#96;public interface Comparable123456789101112131415161718192021222324252627282930313233当实现Comparable类的时候也是不规定泛型就是Object，且下面的compareTo方法中的参数类型要和他一样```javapublic class Student implements Comparable&lt;Student&gt; &#123; private int id; private int age; private String name; public Student(int id, int age, String name) &#123; this.id = id; this.age = age; this.name = name; &#125; @Override public int compareTo(Student o) &#123; //降序 //return o.age - this.age; //升序 return this.age - o.age; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&quot; + id + &quot;, age=&quot; + age + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 调用compareTo方法后负数时，当前对象在前面，正数时当前对象在后面，0时位置不变 12345678public int compareTo(Student o1) &#123; if(o1.getScore()==this.getScore()) &#123; return this.id.compareTo(o1.id); &#125; else &#123; return o1.getScore()-this.getScore(); &#125;&#125; 先按照成绩降序排序，成绩相同按照学号升序排序 第二种方法 &#96;&#96;&#96;public interface Comparator1234567891011121314实现Comparator接口的时候，如果没有规定泛型默认是Object，同时T必须和下面compare方法中的参数类型一样自己搞一个构造器，重写compare方法当作Collections.sort(第二个参数)```javaclass compare implements Comparator&lt;Integer&gt;&#123; @Override public int compare(Integer o1, Integer o2) &#123; return o1-o2; &#125;&#125; 第三种直接倒叙的方法 Collection.sort的第二个参数 如果要降序呢?可以传入Collections.reverseOrder(), 返回一个倒叙的Comparator对象, Arrays类定义了多种数组操作的方法 12345678910Integer[]a= &#123;3,25,12,79,48&#125;; System.out.println(Arrays.toString(a));//输出数组 Arrays.sort(a);//对数组中元素进行排序 System.out.println(Arrays.toString(a));//输出数组以[3,25,12,79,48] int idx=Arrays.binarySearch(a,25);//返回25元素所对应的下标 System.out.println(idx); List list=Arrays.asList(3,4,5);//将其转换为List集合返回值是一个List//public static &lt;T&gt; List&lt;T&gt; asList(T... a) System.out.println(list); 其实Arrays.toString的本质是调用数组中所有对象的toString方法然后用逗号隔开然后用[ ]框起来 java异常机制的处理异常：指程序中出现的不期而至的各种状况，如文件找不到，网络连接失败，非法参数等等； java把异常当作对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类 在javaAPI中已经定一个许多异常类，这些异常分为两类，错误Error和异常Exception 这个图中只是举了例子 错误：一般指程序运行时遇到的硬件或操作系统的错误，如内存溢出、不能读取硬盘分区、 硬 件驱动错误等。这是致命的，将导致程序无法运行，同时也是程序本身不能处理 的。错误大都是jvm的问题 2.异常： 异常大都是语法问题； 运行异常和编译异常。 运行异常：顾名思义，是程序运行时才会出现的异常。运行异常是java.lang.RuntimeException类及其子类的统称。如NullPointerException（空指针异常）、IndexOutOfBoundsException（数组下标越界异常）等。运行异常一般是由程序逻辑错误导致的，可以通过捕获处理或向上抛出。运行异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现运行异常，也会被编译通过。编译异常：顾名思义，是程序编译时就会出现的异常。编译异常是java.lang.RuntimeException以外的异常。编译异常必须进行处理，如果不处理，程序就不能编译通过。 异常可以分为两类：1.运行时异常 RuntimeException 2.其他的异常都属于非运行时异常 异常处理机制例1 1234int a=1; int b=0; try &#123;//try监控区域 System.out.println(a/b); &#125; catch(ArithmeticException e)//这个地方的错误必须是和try中出现的错误类型相同，否则没什么用 &#123;//catch 捕获异常 System.out.println(&quot;程序出现异常，变量b不能为0&quot;); &#125; finally &#123;//处理善后工作，无论是否报错这个finally都是会执行的，无论怎样都会执行，报其他错也会执行 System.out.println(&quot;finally&quot;); //finally可以不要finally，假设IO时读取文件关闭资源关闭时可以用 &#125; 例2 123456public static void main(String args[])&#123; int a=1; int b=0; try &#123;//try监控区域 new Main().a();//这是一个栈溢出的异常 &#125; catch(Error e)//这个地方如果时Error和Throwable都可以，就是根据上面那个表格，cathch括号里错误类型的子类也可以被捕获 &#123;//catch 捕获异常 System.out.println(&quot;程序出现异常，变量b不能为0&quot;); &#125; finally &#123;//处理善后工作，无论是否报错这个finally都是会执行的，无论怎样都会执行，报其他错也会执行 System.out.println(&quot;finally&quot;); //finally可以不要finally，假设IO时读取文件关闭资源关闭时可以用 &#125; &#125; public void a() &#123; b(); &#125; public void b() &#123; a(); &#125; 例3 有多个catch的异常处理机制，只能执行一个catch，所以越往下catch括号里的错误类型越高层，从小到大去捕获 123try &#123;//try监控区域 new Main().a();//这是一个栈溢出的异常 &#125; catch(Error e)//这个地方的错误必须是和try中出现的错误类型相同，否则没什么用 &#123;//catch 捕获异常 System.out.println(&quot;程序出现异常，变量b不能为0&quot;); &#125; catch(Exception e) &#123; System.out.println(&quot;exception&quot;); &#125; catch(Throwable e) &#123; System.out.println(&quot;throwable&quot;); &#125; finally &#123;//处理善后工作，无论是否报错这个finally都是会执行的，无论怎样都会执行，报其他错也会执行 System.out.println(&quot;finally&quot;); //finally可以不要finally，假设IO时读取文件关闭资源关闭时可以用 &#125; 例四 throw和throws的用法，是用来主动抛出异常 public void test(int a,int b) throws ArithmeticException&#123;//有throws就是在调用这个方法的时候要对这个异常进行捕获，也就是下面使用这个trycatch /*if(b==0) &#123; throw new ArithmeticException();//主动的抛出异常，一般在方法中使用 &#125;*/ &#125; public static void main(String[] args) &#123; try &#123; new Hello().test(1,0); &#125; catch(ArithmeticException e)&#123; e.printStackTrace(); &#125; &#125; 不用throws的话就是要在throw那个地方去进行一个异常捕获 自定义异常exception类能被继承的常用方法： public void printStackTrace() public String toString() public String getMessage() 除内置的异常类可以描述大部分异常情况，除此之外，用户还可以自定义异常，用户自定义异常类，只需继承Exception类即可； 1.创建自定义异常类 2.在方法中通过throw关键字抛出异常对象 3.如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理；否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作 4.再出现异常方法的调用者捕获并处理异常 例子 自定义的异常类 12345678910111213141516package Main;class MyException extends Exception&#123;//传递数字大于10 private int detail; public MyException(int a) &#123; this.detail=a; &#125; @Override public String toString() &#123; return &quot;MyException&#123;&quot;+detail+&#x27;&#125;&#x27;; &#125;&#125; 测试 123456789101112131415161718192021class Test&#123;static void test(int a) throws MyException&#123; System.out.println(&quot;传递的参数为: &quot;+a); if(a&gt;10) &#123; throw new MyException(a)//抛出 &#125; System.out.println(&quot;ok&quot;);&#125;public static void main(String[] args)&#123;try &#123; test(11);&#125;catch(MyException e)&#123; System.out.println(&quot;MyException=&gt;&quot;+e);//这是调用e类中的toString方法&#125;&#125;&#125; 1234567891011121314### 自定义异常的常用格式public class MyException extends Exception&#123;public MyException()&#123;&#125;public MyException(String msg)&#123;super(msg);&#125;&#125; ATM 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package Main;import java.util.Scanner;class NoMoney extends Exception &#123; public NoMoney() &#123; &#125; public NoMoney(String msg) &#123; super(msg);//构造方法传报错信息 &#125; /* public String toString () &#123; return &quot;您的余额不足，您当前余额为&quot;+Main.money; &#125;*/&#125;class Main&#123; public static double money=0; public void deposit(double a) &#123; this.money+=a; System.out.println(&quot;您的当前余额为&quot;+this.money); &#125; public void query() &#123; System.out.println(&quot;您的当前余额为&quot;+this.money); &#125; public void withdraw(double a) throws NoMoney &#123; if(this.money&lt;a) &#123; throw new NoMoney(&quot;余额不足&quot;); &#125; &#125;public static void main(String []args) &#123; int index=0; while(true) &#123; if(index==0) &#123; System.out.println(&quot;您可以输入 查询余额,取款,存款,退出&quot;);&#125; index++; Scanner in=new Scanner(System.in); String str=in.nextLine(); String str1=&quot;查询余额&quot;; String str2=&quot;取款&quot;; String str3=&quot;存款&quot;; String str4=&quot;退出&quot;; Main discount =new Main(); if(str.equals(str1))&#123; discount.query(); &#125; else if(str.equals(str2))&#123; System.out.println(&quot;您要取出的金额是&quot;); double count =in.nextDouble(); try &#123; discount.withdraw(count); Main.money=Main.money-count; System.out.println(&quot;您当前的余额是&quot;+Main.money); &#125; catch(NoMoney e)&#123; //System.out.println(&quot;您当前的余额不足,您当前的余额是&quot;+Main.money); /*System.out.println(e.toString()); continue;*/ e.printStackTrace();//打印报错信息和堆栈信息 System.out.println(e.getMessage());//打印获得的报错信息 &#125; &#125; else if(str.equals(str3)) &#123; System.out.println(&quot;您要存入的金额是&quot;); double count=in.nextDouble(); discount.deposit(count); &#125; else if(str.equals(str4))&#123; break; &#125; else &#123; System.out.println(&quot;输入内容有问题&quot;); continue; &#125; &#125; &#125; &#125;# 异常语句的执行顺序分析12345678910111213141516public class Demo&#123; public int add(int a,int b)&#123; try&#123; return a+b; &#125;catch(Exception e)&#123; System.out.println(“catch 语句块”); &#125;finally&#123; System.out.println(“finally 语句块”); &#125; return 0; &#125; public static void main(String[] args)&#123; Demo demo = new Demo(); System.out.println(“和是：”+demo.add(9,34)); &#125;&#125; 执行结果： finally 语句块和是：43 调用add方法之后一直等到finally调用完才返回到主函数 java中的泛型泛型初体验 123456789101112131415161718192021//编译期间检查类型//减少了数据类型的转换ArrayList&lt;String&gt; strList=new ArrayList&lt;&gt;();strList.add(&quot;a&quot;);strList.add(&quot;b&quot;);strList.add(&quot;c&quot;);for(int i=0;i&lt;strList.size();i++)&#123; String s=strList.get(i); System.out.println(s);&#125;ArrayList&lt;Integer&gt; intList=new ArrayList&lt;&gt;();intList.add(100);intList.add(200);intList.add(300);for(int i=0;i&lt;intList.size();i++)&#123; int num=intList.get(i); System.out.println(num);&#125; 泛型类的创建12345678910111213141516171819202122232425/*泛型类的定义 * &lt;T&gt;泛型标识--类型形参 * T 创建对象的时候里指定具体的数据类型 */ public class Generic &lt;T&gt;&#123; //T，是由外部使用类的时候来指定 private T key; public Generic(T key) &#123; this.key=key; &#125; public T getKey() &#123; return key; &#125; public void setKey(T key) &#123; this.key=key; &#125; @Override public String toString() &#123; return &quot;Generic&#123;&quot;+&quot;key=&quot;+key+&#x27;&#125;&#x27;; &#125;&#125; 泛型类使用语法： 类名&lt;具体的数据类型&gt; 对象名&#x3D;new 类名&lt;具体的数据类型&gt;(); 或者 类名&lt;具体的数据类型&gt; 对象名&#x3D;new 类名&lt;&gt;(); 测试123456public static void main(String []args) &#123; //泛型类在创建对象的时候，来指定操作的具体的数据类型 Generic&lt;String&gt; strGeneric=new Generic&lt;&gt;(&quot;赵梓皓&quot;); String key1=strGeneric.getKey(); System.out.println(&quot;key1:&quot;+key1); Generic&lt;Integer&gt; intGeneric =new Generic&lt;&gt;(123); int key=intGeneric.getKey(); System.out.println(&quot;key:&quot;+key); //泛型类在创建对象的时候，没有指定类型，将按照Object类型来操作 Generic generic =new Generic(&quot;ABC&quot;); Object key3=generic.getKey(); System.out.println(&quot;key3:&quot;+key3); //泛型类不支持基本数据类型 // Generic &lt;int&gt; generic2=new Generic &lt;int&gt;(100); //同一泛型类，根据不同的数据类型创建的对象，本质上是同一类型，是Generic类型 System.out.println(intGeneric.getClass()); System.out.println(strGeneric.getClass()); System.out.println(intGeneric.getClass()==strGeneric.getClass()); &#125; 注意事项：泛型类，如果没有指定具体的数据类型，此时，操作类型是Object 2.泛型的类型参数只能是类类型，不能是基本数据类型 3.泛型类型在逻辑上可以看成是多个不同的类型，但实际上都是相同类型 泛型类的使用抽奖器泛型类 1234567891011121314151617import java.util.ArrayList;import java.util.Random;public class ProductGetter &lt;T&gt; &#123; Random random=new Random(); //奖品private T product;//奖品池ArrayList &lt;T&gt; list=new ArrayList&lt;T&gt;();public void addProduct(T t) &#123; list.add(t);&#125; //抽奖public T getProduct() &#123; return list.get(random.nextInt(list.size()));&#125;&#125; 抽奖器使用 1234567891011121314151617181920class Main&#123; public String b=&quot;100&quot;; public static void main(String []args) &#123; //创建抽奖器对象，指定数据类型 ProductGetter&lt;String&gt; stringProductGetter=new ProductGetter&lt;&gt;(); String[] strProducts= &#123;&quot;苹果手机&quot;,&quot;华为手机&quot;,&quot;扫地机器人&quot;,&quot;咖啡机&quot;&#125;; //给抽奖器中，填充奖品 for(int i=0;i&lt;strProducts.length;i++) &#123; stringProductGetter.addProduct(strProducts[i]); &#125; //抽奖 String product1=stringProductGetter.getProduct(); System.out.println(&quot;恭喜您，你抽中了&quot;+product1); &#125;&#125; 泛型类派生子类1.子类也是泛型类，子类和父类的泛型类型一致 class ChildGeneric extends Generic 2.子类不是泛型类，父类要明确泛型的数据类型 class ChildGeneric extends Generic 例一： 1234567891011父类public class Parent &lt;E&gt; &#123;private E value;public E getValue() &#123; return value;&#125;public void setValue(E value) &#123; this.value=value;&#125;&#125; 123456789子类 //子类中可以泛型扩展，但必须要有一个泛型和父类中的一样 //泛型类派生子类，子类也是泛型类的情况时，子类的泛型标识要和父类一致public class ChildFirst&lt;T&gt; extends Parent&lt;T&gt; &#123; @Override public T getValue() &#123; return super.getValue(); &#125;&#125; 1234567891011测试class Main&#123; public static void main(String []args) &#123; ChildFirst&lt;String&gt; childFirst=new ChildFirst&lt;String&gt;(); childFirst.setValue(&quot;abc&quot;); String value=childFirst.getValue(); System.out.println(value); &#125;&#125; 例二 &#96;&#96;&#96;java&#x2F;* 子类 当泛型类派生自类的时候，如果子类不是泛型类那么父类要明确数据类型*&#x2F;public class ChildFirst extends Parent { @Override public String getValue() { return super.getValue(); }}1 1234567891011 * 测试class Main&#123; public static void main(String []args) &#123; ChildFirst childfirst=new ChildFirst(); childfirst.setValue(&quot;abc&quot;); String value1=childfirst.getValue(); System.out.println(value1); &#125;&#125; 泛型接口 1.泛型接口的实现类不是泛型类，接口要明确数据类型 泛型接口 1234567* /* * 泛型接口 */ public interface Generator&lt;T&gt; &#123; T getKey(); &#125; 子类 1234567891011public class Apple implements Generator&lt;String&gt;&#123; /* * 实现泛型接口的类，不是泛型类，需要明确实现泛型接口的数据类型 */ @Override public String getKey() &#123; return &quot;hello generic&quot;; &#125;&#125; 测试 12345678class Main&#123; public static void main(String []args) &#123; Apple apple=new Apple(); String key=apple.getKey(); System.out.println(key); &#125;&#125; 2.实现类也是泛型类，实现类和接口的泛型类型要一致 /*子类 123456789101112131415161718192021* 泛型接口的实现类是一个泛型类，那么要保证实现接口的泛型类泛型标识包含泛型接口的泛型标识 */ //实现类的泛型标识必须和接口的一样 public class Apple&lt;T,E&gt; implements Generator&lt;T&gt;&#123; private T key; private E value; public Apple(T key,E value)&#123; this.key=key; this.value=value; &#125; @Override public T getKey() &#123; return key; &#125; public E getValue() &#123; return value; &#125; &#125; 123* ``` /*泛型类 泛型接口*&#x2F;public interface Generator {T getKey();} 12345678910111213141516 实现类```javaclass Main&#123; public static void main(String []args) &#123; Apple&lt;String,Integer&gt; apple=new Apple&lt;&gt;(&quot;abc&quot;,100); String a=apple.getKey(); int b=apple.getValue(); System.out.println(a+b); &#125;&#125; 泛型方法12345修饰符 &lt;T,E,...&gt; 返回值类型 方法名(形参列表) &#123;方法体&#125; 泛型类 &#96;&#96;&#96;javaimport java.util.ArrayList; import java.util.Random; 123456789101112131415161718192021222324public class ProductGetter &lt;T&gt; &#123; Random random=new Random(); //奖品private T product;//奖品池ArrayList &lt;T&gt; list=new ArrayList&lt;T&gt;();public void addProduct(T t) &#123; list.add(t);&#125; //抽奖public T getProduct() &#123;//这都不是泛型方法，是用泛型的成员方法 return list.get(random.nextInt(list.size()));&#125;/* * 定义泛型方法 * 这里定义的就是一个泛型方法，有了&lt;E&gt;泛型标识，方法里就可以用这个泛型标识，具体类型由调用方法的时候来指定 */ public &lt;E&gt; E getProduct(ArrayList&lt;E&gt; list) &#123;//这个泛型方法的类型是独立于泛型类的 return list.get(random.nextInt(list.size())); &#125; &#125; 测试 123456789101112class Main&#123; public static void main(String []args) &#123; ProductGetter&lt;Integer&gt; productGetter=new ProductGetter&lt;&gt;(); ArrayList&lt;String&gt; strList=new ArrayList&lt;&gt;(); strList.add(&quot;笔记本&quot;); strList.add(&quot;手机&quot;); //这是对泛型方法的调用，类型是通过调用方法的时候来制定的，这个地方就是指定E类型为String String product1=productGetter.getProduct(strList); System.out.println(product1); &#125;&#125; 注意问题： 1.如果一个普通的成员方法用了类的这个泛型类型，是不能用static来修饰的 2.如果是泛型方法可以支持静态 静态类型的泛型方法 12345678910/* * 静态类型的泛型方法，采用多个泛型类型 */ public static &lt;E,T,K&gt; void printtype(E e,T t,K k) &#123; System.out.println(t.getClass()); System.out.println(e.getClass()); System.out.println(k.getClass()); &#125; 测试 123public static void main(String []args) &#123; ProductGetter.printtype(100,&quot;java&quot;,true);&#125; 泛型方法与可变参数 例子 1234567//因为参数的数目是可以变化的，所以可以形成数组//泛型方法对可变参数的支持public static &lt;E&gt; void print(E...e) &#123; for(int i=0;i&lt;e.length;i++) &#123; System.out.println(e[i]); &#125;&#125; 测试 123public static void main(String []args) &#123; ProductGetter.print(1,2,3,4,5,6);&#125; 总结：泛型方法能使方法独立于类而产生变化 如果static方法要使用泛型能力，就必须使其成为泛型方法 类型通配符方法参数使用类的泛型标识符时不能重载，因为标识符从根本上都是Object类 注意：1.类型通配符一般是使用“?”代替具体的类型实参 2.所以，类型通配符是类型实参，而不是类型形参 通配符初体验 1234567891011121314151617181920class Main&#123; public static void main(String []args) &#123; Box&lt;Number&gt; box1=new Box&lt;&gt;(); box1.setFirst(100); showBox(box1); Box&lt;Integer&gt; box2=new Box&lt;&gt;(); box2.setFirst(200); showBox(box2); &#125; public static void showBox(Box&lt;?&gt;box)//这个地方是问号就可以是任意类型的，都可以用这个showBox方法，但如果是Number类型的，即使是它的子类Integer也不能用因为标识符类型本质上都是一样的Object类所以不能进行方法重载 &#123; Object first=box.getFirst(); System.out.println(first); &#125;&#125; 通配符设置上限语法 类&#x2F;接口&lt;? extends 实参类型&gt; 要求该泛型的类型，只能是实参类型，或者是实参类型的子类类型 1234567891011121314151617181920class Main&#123; public static void main(String []args) &#123; Box&lt;Number&gt; box1=new Box&lt;&gt;(); box1.setFirst(100); showBox(box1); Box&lt;Integer&gt; box2=new Box&lt;&gt;(); box2.setFirst(200); showBox(box2); &#125; public static void showBox(Box&lt;? extends Number&gt;box)//这里意思就是最大接收的类型就是Number，如果单独是一个?的话就是最大是Object &#123; Number first=box.getFirst(); System.out.println(first); &#125;&#125; 例子： Cat是miniCat的父类，Animal是Cat的父类 1234567891011121314151617181920212223242526public class miniCat extends Cat&#123; public static void main(String[] args) &#123; ArrayList&lt;Animal&gt; animals=new ArrayList&lt;&gt;(); ArrayList&lt;Cat&gt; cats=new ArrayList&lt;&gt;(); ArrayList&lt;miniCat&gt; miniCats=new ArrayList&lt;&gt;(); //showAnimal(animals);这个会报错因为下面的通配符上限是Cat，传递的集合类型只能是Cat或Cat的子类 showAnimal(cats); showAnimal(miniCats); &#125; public static void showAnimal(ArrayList&lt;? extends Cat&gt; list) &#123; //这种用通配符来表述存储对象类型的集合是不能向其中添加元素的 /*list.add(new Cat()); list.add(new miniCat()); list.add(new Animal());*/ for(int i=0;i&lt;list.size();i++) &#123; //ArrayList通配符上限为Cat所以下面用Cat引用变量接受没有任何问题 Cat cat = list.get(i);//这个地方得到集合的类型，引用变量必须是最大的那一种 System.out.println(cat); &#125; &#125;&#125; 类型通配符的下限类&#x2F;接口&lt;? super 实参类型&gt; 要求该泛型的类型，只能是实参类型，或实参类型的父类类型 通配符下限初体验 12345678910111213141516171819202122232425import java.util.ArrayList;public class miniCat extends Cat&#123; public static void main(String[] args) &#123; ArrayList&lt;Animal&gt; animals=new ArrayList&lt;&gt;(); ArrayList&lt;Cat&gt; cats=new ArrayList&lt;&gt;(); ArrayList&lt;miniCat&gt; miniCats=new ArrayList&lt;&gt;(); showAnimal(animals); showAnimal(cats); // showAnimal(miniCats);要求只能是Cat或者Cat的父类类型，所以这个地方报错 &#125; /* * 类型通配符的下限，要求集合只能是Cat或Cat的父类类型 */ public static void showAnimal(ArrayList&lt;? super Cat&gt; list) &#123; for(Object o:list) &#123;//当接受用下限通配符标识的集合元素的时候，用object，因为Object是所有类的父类 System.out.println(o); &#125; &#125;&#125; TreeSet是通过自己定义的比较器来排序的 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Main&#123; public static void main(String []args) &#123; TreeSet&lt;Cat&gt; treeSet=new TreeSet&lt;&gt;(new Comprator2());//因为是comprator2所以是按照年龄大小来排序的 //TreeSet&lt;Cat&gt; treeSet=new TreeSet&lt;&gt;(new Comprator1());不会报错 //TreeSet&lt;Cat&gt; treeSet=new TreeSet&lt;&gt;(new Comprator3());会报错 //因为TreeSet的这个地方泛型是Cat它的构造方法也用到了泛型，只有是继承Cat或Cat子类标识Comparator接口的比较器才能够好用 treeSet.add(new Cat(&quot;jerry&quot;,20)); treeSet.add(new Cat(&quot;amy&quot;,22)); treeSet.add(new Cat(&quot;frank&quot;,23)); treeSet.add(new Cat(&quot;jim&quot;,25)); for(Cat cat:treeSet) &#123; System.out.println(cat); &#125; &#125;&#125;class Comprator1 implements Comparator&lt;Animal&gt;&#123; @Override public int compare(Animal o1, Animal o2) &#123; // TODO Auto-generated method stub return o1.name.compareTo(o2.name); &#125;&#125;class Comprator2 implements Comparator&lt;Cat&gt;&#123; @Override public int compare(Cat o1, Cat o2) &#123; // TODO Auto-generated method stub return o1.age-o2.age; &#125;&#125;class Comprator3 implements Comparator&lt;miniCat&gt;&#123; @Override public int compare(miniCat o1, miniCat o2) &#123; // TODO Auto-generated method stub return o1.level-o2.level; &#125;&#125; 12345public Treeset(Comparator &lt;? super E&gt; comparator)&#123;&#125; 类型擦除123456public static void main(String []args) &#123; //泛型类在创建对象的时候，来指定操作的具体的数据类型 Generic&lt;String&gt; strGeneric=new Generic&lt;&gt;(&quot;赵梓皓&quot;); String key1=strGeneric.getKey(); System.out.println(&quot;key1:&quot;+key1); Generic&lt;Integer&gt; intGeneric =new Generic&lt;&gt;(123); int key=intGeneric.getKey(); System.out.println(&quot;key:&quot;+key); //泛型类在创建对象的时候，没有指定类型，将按照Object类型来操作 Generic generic =new Generic(&quot;ABC&quot;); Object key3=generic.getKey(); System.out.println(&quot;key3:&quot;+key3); //泛型类不支持基本数据类型 // Generic &lt;int&gt; generic2=new Generic &lt;int&gt;(100); //同一泛型类，根据不同的数据类型创建的对象，本质上是同一类型，是Generic类型 System.out.println(intGeneric.getClass()); System.out.println(strGeneric.getClass()); System.out.println(intGeneric.getClass()==strGeneric.getClass()); } 判断两个类型是否相同 最后是相同的 因为泛型只有在编译阶段存在，编译结束之后类型就擦除了，都是Object类 泛型数组的创建可以声明带泛型的数组引用，但是不能直接创建带泛型的的数组对象 1234567891011class Main&#123; public static void main(String []args) &#123; ArrayList&lt;String&gt;[] listArr=new ArrayList[5];//定义泛型数组的方式，操作的时候就是拿引用去操作 ArrayList&lt;String&gt; strList=new ArrayList&lt;&gt;(); strList.add(&quot;abc&quot;); listArr[0]=strList; String s=listArr[0].get(0); System.out.println(s); &#125;&#125; 可以通过java.lang.reflect.Array的newInstance(Class,int) 创建T[]数组 Fruit 1234567891011121314151617181920212223package Main;import java.lang.reflect.Array;public class Fruit&lt;T&gt; &#123; private T[] array; public T[] getArray() &#123; return array; &#125; public void setArray(T[] array) &#123; this.array = array; &#125; public Fruit(Class&lt;T&gt; clz,int length)&#123;array=(T[])Array.newInstance(clz, length); &#125; public void put(int index, T string) &#123; array[index]=string; &#125; &#125; 测试 12345678910111213class Main&#123; public static void main(String []args) &#123; Fruit&lt;String&gt; fruit=new Fruit&lt;&gt;(String.class ,3); fruit.put(0,&quot;苹果&quot;); fruit.put(1,&quot;西瓜&quot;); fruit.put(2,&quot;香蕉&quot;); System.out.println(Arrays.toString(fruit.getArray())); &#125;&#125; 一个利用比较器以及string的compareTo的一个题 java的File类java.io.File类 文件和目录路径的抽象表示形式 java把电脑中的文件和文件夹封装为了一个File类，我们可以使用File类对文件和文件夹进行操作 我们可以使用File类的方法 创建一个文件&#x2F;文件夹等等 File类是一个和系统无关的类，任何的操作系统都可以使用这个类中的方法 重点记住三个单词：file：文件 directory：文件夹&#x2F;目录 path：路径 File类的静态属性 123456String pathSeparator=File.pathSeparator;//路径分隔符，分割多个路径的，windows系统是分号，linux系统是冒号System.out.println(pathSeparator);String separator=File.separator;System.out.println(separator);//文件名称分隔符，windows系统是反斜杠\\ linux系统是正斜杠///操作路径&quot;C:&quot;+File.separator+&quot;develop&quot;+File.separator+&quot;a&quot;+File.separator+&quot;a.txt&quot;//将反斜杠或者正斜杠用File.separator代替，不写死 绝对路径与相对路径 构造方法 &#96;&#96;&#96;java&#x2F;*一 File(String pathname) 通过将给定路径名字字符串转换为抽象路径来创建一个新的File实例 参数： String pathname 字符串的路径名称 路径可以是文件结尾也可以是文件夹结尾 路径可以是相对路径，也可以是绝对路径 路径可以存在也可以不存在，创建File对象，只是把字符串封装为File对象，不考虑路径的真假情况 *&#x2F;File f1&#x3D;new File(“D:\\放乱七八糟\\File.txt”);System.out.println(f1);&#x2F;&#x2F;重写了object类里的toString方法输出路径 D:\\放乱七八糟\\File.txt 1234567891011121314/* * ``` * File(String parent,Stringchild) * 参数分为两部分，String parent父路径 * String child 子路径 * 好处： * 父路径和子路径可以单独书写，使用起来非常灵活，父路径和子路径都可以变化 */ File f1=new File(&quot;c:\\\\&quot;,&quot;a.txt&quot;); System.out.println(f1); File f2=new File(&quot;d:\\\\&quot;,&quot;a.txt&quot;); System.out.println(f2); ​ &#x2F;* * ``` * File(File parent,String child)根据parent抽象路径名和child路径字符串创建一个新File实例 * 参数：把路径分为了两部分 * File parent：父路径 * String child：子路径 * 好处： * 父路径和子路径可以单独书写，使用起来非常灵活，父路径和子路径都可以变化 * */ File parent=new File(&quot;c:\\\\&quot;); File file=new File(parent,&quot;hello.java&quot;); System.out.println(file); 123456789 ## 常用方法### 获取方法public String getAbsolutePath() :返回此File的绝对路径字符串，获取构造方法中的传递的路径，不管你写的是相对的还是绝对的都返回绝对路径字符串 File f1&#x3D;new File(“C:\\a.txt”);System.out.println(f1.getAbsolutePath());File f2&#x3D;new File(“a.txt”);System.out.println(f2.getAbsolutePath());结果:C:\\a.txtD:\\Java\\12345\\a.txt 1234567891011public String getPath()将此File转换为路径名字符串```javaFile f1=new File(&quot;C:\\\\a.txt&quot;);System.out.println(f1.getPath());File f2=new File(&quot;a.txt&quot;);System.out.println(f2.getPath());结果：C:\\a.txta.txt public String getName()返回由此File表示的文件或目录的名称 1234567File f1=new File(&quot;C:\\\\a.txt&quot;);System.out.println(f1.getName());File f2=new File(&quot;a.txt&quot;);System.out.println(f2.getName());结果：a.txta.txt public long length() 获取的式构造方法指定的文件的大小，以字节为单位 注意： 文件夹是没有大小概念的，不能获取文件夹的大小，如果构造方法中给出的路径不存在，那么length方法返回零 文件夹没有大小概念，返回值也是零 1234567File f1=new File(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);System.out.println(f1.length());File f2=new File(&quot;a.txt&quot;);System.out.println(f2.length());结果：100 判断功能的方法public boolean exists() ：此File表示的文件或目录是否实际存在 用于判断构造方法中的路径是否存在 存在：true 不存在：false 123File f1=new File(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);System.out.println(f1.exists());结果：true 123File f1=new File(&quot;D:\\\\放乱七八糟\\\\Fil.txt&quot;);System.out.println(f1.exists());结果：false 注意下面两个判断方法的路径必须是存在的如果不存在则都返回false public boolean isDirectory() 表示此File是否为目录 用于判断构造方法中给定的路径是否是以文件夹结尾 123File f1=new File(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);System.out.println(f1.isDirectory());结果:false publicboolean isFile() 用于判断构造方法中给定的路径是否是以文件结尾 123File f1=new File(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);System.out.println(f1.isFile());结果：true 123File f1=new File(&quot;D:\\\\放乱七八糟\\\\Fil.txt&quot;);System.out.println(f1.isFile());结果：false 因为路径不存在 创建删除功能的方法public boolean createNewFile() :当且仅当具有该名称的文件尚不存在时，创建一个新的空文件 创建文件的路径和名称在构造方法中给出（构造方法的参数） 返回值：布尔值 true：文件不存在，创建文件，返回true false：文件存在不会创建，返回false 注意;1.此方法之恩那个创建文件，不能创建文件夹所以创建文件的路径必须存在，否则会抛出异常 123456File f1=new File(&quot;D:\\\\放乱七八糟\\\\Fil.txt&quot;);try &#123; System.out.println(f1.createNewFile());&#125; catch (IOException e) &#123; e.printStackTrace();//createNewFile声明抛出了IOException，我们调用这个方法，就必须的处理这个异常，要么throws，要么trycatch如果调用方法的时候也throws就会交给jvm处理&#125; 如果路径不存在则会抛出IO异常 public boolean mkdir() :创键单级空文件夹 public boolean mkdirs() :创建单级空文件夹，也可以创建多级文件夹 创建文件夹的路径和名称在构造方法中给出（构造方法的参数） 返回值：布尔值 true：文件夹不存在，创建文件夹，返回true false：文件夹存在不会创建，返回false，构造方法中给出的路径不存在返回false 注意;1.此方法只能创建文件夹，不能创建文件 123456789File f1=new File(&quot;D:\\\\放乱七八糟\\\\aaa\\\\bb&quot;);System.out.println(f1.mkdir());//不能创建多级目录File f2=new File(&quot;D:\\\\放乱七八糟\\\\aaa\\\\bb&quot;);System.out.println(f1.mkdirs());File f3=new File(&quot;D:\\\\放乱七八糟\\\\ccc&quot;);System.out.println(f3.mkdir());结果：falsetruetrue public boolean delete() 删除构造方法路径中给出的文件和文件夹 返回值也是一个布尔值 true：文件&#x2F;文件夹删除成功，返回true false：文件夹中有内容，不会删除返回false，构造方法中的路径不存在返回false，文件不管里面有没有内容都会删除 注意： delete方法是直接在硬盘删除文件&#x2F;文件夹，不走回收站，删除要谨慎 1234567File f2=new File(&quot;D:\\\\放乱七八糟\\\\aaa\\\\bb&quot;);System.out.println(f2.delete());File f3=new File(&quot;D:\\\\放乱七八糟\\\\ccc&quot;);System.out.println(f3.delete());结果：truetrue删除路径的最后一个文件或者文件夹 1234File f2=new File(&quot;D:\\\\放乱七八糟\\\\aaa&quot;);System.out.println(f2.delete());结果false因为文件夹aaa中有内容 1234File f2=new File(&quot;D:\\\\放乱七八糟\\\\aaa\\\\新建文本文档.txt&quot;);System.out.println(f2.delete());结果：true就算txt文件中有内容也会被删除 目录的遍历功能public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录（隐藏的也能获取到） 遍历构造方法中给出的目录，会获取目录中所有文件&#x2F;文件夹的名称，把获取到的多个名称存储到一个字符串String类型的数组中 public File[] listFiles(): 返回一个File数组，表示该File目录中所有的子文件或目录 遍历一个构造方法中给出的目录，会获取目录中所有个文件&#x2F;文件夹，把文件或文件夹封装为File对象，多个File对象存储到File数组里 注意： list方法和listFiles方法遍历的是构造方法中给出的目录 如果构造方法中给出的目录的路径不存在，会抛出空指针异常 如果构造方法中给出的路径不是一个目录，也会抛出空指针异常 1234567891011File f2=new File(&quot;D:\\\\放乱七八糟&quot;);String str[]=f2.list();for(String filename:str) &#123; System.out.println(filename);&#125;结果：eclipse.zipEverything-1.4.1.1017.x64-Setup.exeFil.txtFile.txtjava8中文说明文档321456第五章.ppt 1234567891011File file=new File(&quot;D:\\\\放乱七八糟&quot;);File []files=file.listFiles();for(File f:files) &#123; System.out.println(f);&#125;结果：D:\\放乱七八糟\\eclipse.zipD:\\放乱七八糟\\Everything-1.4.1.1017.x64-Setup.exeD:\\放乱七八糟\\Fil.txtD:\\放乱七八糟\\File.txtD:\\放乱七八糟\\java8中文说明文档321456D:\\放乱七八糟\\第五章.ppt 递归递归的分类：1.直接递归和间接递归 直接递归：main(){ a() } a(){ a();自己调用自己 } 间接递归：b(){ c();} c(){ b();} 注意事项：1.递归一定要有条件限定，保证递归能够停下来，否则会发生栈内存溢出 2.在递归中虽然有限定条件，但是递归次数不能太多，否则也会发生栈内存溢出 3.构造方法，禁止递归，编译错误，构造方法是创建对象时侯用的，一直递归会导致内存中有无数多个对象，直接编译报错 递归地使用前提：当调用方法的时候，方法的主体不变，每次调用方法的参数不同，可以使用递归 为什么递归无限制会导致栈内存溢出 a方法会在栈内存中一直调用a方法，就会导致栈内存中由无数多个a方法 方法太多了，超出栈内存的大小，就会导致内存溢出的错误 注意： 当一个方法调用其他方法时，被调用的方法没有执行完毕，当前方法就会一直等待低矮哦用的方法执行完毕才会继续执行 1使用递归计算0到n之间的和 1234567891011121314class Main&#123; public static void main(String []args) &#123; int s=Sum(3); System.out.println(s);&#125; public static int Sum(int n) &#123; if(n==1) return 1; return n+Sum(n-1); &#125;&#125; 递归计算阶乘 12345 public static void main(String []args) &#123; int s=Sum(7); System.out.println(s);&#125; public static int Sum(int n) &#123; if(n==1) return 1; return n*Sum(n-1); &#125; 递归打印多级目录 1遍历c:\\\\abc文件夹，及abc文件夹的子文件夹以及子文件夹中所有文件 12345678910111213141516171819class Main&#123;public static void main(String []args)&#123; File file=new File(&quot;d:\\\\放乱七八糟&quot;); getAllFile(file);&#125;public static void getAllFile(File dir) &#123; System.out.println(dir);//打印被遍历的目录 File[]files=dir.listFiles(); for(File f:files) &#123; if(f.isDirectory()) &#123; getAllFile(f); &#125; else &#123; System.out.println(f); &#125; &#125;&#125;&#125; 综合案例找出目录下文件中只有以.java为结尾的 12345678910111213141516171819202122232425262728293031323334353637class Main&#123;public static void main(String []args)&#123; File file=new File(&quot;D:\\\\同步空间\\\\新建文件夹&quot;); getAllFile(file);&#125;public static void getAllFile(File dir) &#123; // System.out.println(dir); File[]files=dir.listFiles(); for(File f:files) &#123; if(f.isDirectory()) &#123; getAllFile(f); &#125; else &#123; /* * 只要.java结尾的文件 * 把File对象f转换为字符串对象 * String name=f.getName(); * String path=f.getPath(); * String s=f.toString(); * System.out.println(f); */ /* * 2.调用String类中的方法endswith判断字符串是否是以.java结尾 * */ String s=f.toString(); //把字符串转换为小写 //s=s.toLowerCase(); boolean b=s.endsWith(&quot;.java&quot;); if(b) &#123; System.out.println(f); &#125; &#125; &#125;&#125;&#125; 第二种方法 1234567if(f.getName().toLowerCase().endsWith(&quot;.java&quot;))&#123;System.out.println(f);&#125; 文件过滤器优化 1234567891011121314151617181920212223需求：遍历某个文件夹，及其子文件夹，只要.java结尾的文件我们可以使用过滤器来实现，在File类中有两个和ListFiles重载的方法，方法的参数传递就是过滤器File[] listFiles(FileFilter filter)java.io.FileFilter接口：用于抽象路径名（File对象）的过滤器作用：用来过滤文件（File对象）抽象方法：用来过滤文件的方法boolean accept(File pathname) 测定指定抽象路径名是否应该包含在某一个路径名列表中参数： File pathname 使用listFiles方法遍历目录，得到的每一个文件对象 File[] listFiles(FilenameFileter filter) java.io.FilenameFilter接口：实现此接口的类实例可以用于过滤文件名 作用：用于过滤文件名称 抽象方法：用来过滤文件 boolean accept(File dir,String name) 参数： File dir:构造方法中传递的被遍历的目录，也就是除了最后一个之外的 String name:使用ListFiles方法遍历目录，获取的每一个文件/文件夹的名称(也就是最后一个)注意：两个过滤器接口是没有实现类的，需要我们自己写实现类，重写过滤的方法accept，在方法中自己定义过滤的规则 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.Scanner;//创建过滤器FileFilter的实现类，重写过滤方法accept，定义过滤规则//如果accept返回false就不会把这个文件对象放到文件对象数组中//如果accept返回true就可以把这个文件对象放到文件对象数组中class FileFilterimpl implements FileFilter&#123; @Override public boolean accept(File pathname) &#123; //如果是文件夹就返回true，再下面检测出是文件夹会继续调用getAllFile方法 if(pathname.isDirectory()) &#123; return true; &#125;return pathname.getName().toLowerCase().endsWith(&quot;.md&quot;);//要到.md结尾的文件对象 &#125;&#125;class Main&#123;public static void main(String []args)&#123; File file=new File(&quot;D:\\\\同步空间\\\\新建文件夹&quot;); getAllFile(file);&#125;public static void getAllFile(File dir) &#123; // System.out.println(dir); File[]files=dir.listFiles(new FileFilterimpl());//传递过滤器对象 /* * listFiles()方法做了三件事 * 1.listFiles方法会对构造方法中传递的目录进行遍历，获取目录中的每一个文件/文件夹--&gt;封装为File对象 * 2.listFiles会调用参数传递过程中的过滤器的方法accept * 3.listFiles方法会把遍历得到的每一个File对象传递给accept方法的参数叫pathname */ for(File f:files) &#123; if(f.isDirectory()) &#123; getAllFile(f); &#125; else &#123; System.out.println(f); &#125; &#125; &#125; &#125; FileNameFilter过滤器的使用和Lambda优化程序 当接口只有一个抽象方法的时候叫函数式接口此时可以用Lambda表达式来代替这个接口的实例化对像，要实现那一个抽象方法 匿名内部类是当这个接口的实例化对象只用一次时可以用来代替，要实现接口的所有抽象方法 1234567class Main&#123;public static void main(String []args)&#123; File file=new File(&quot;D:\\\\同步空间\\\\新建文件夹&quot;); getAllFile(file);&#125;public static void getAllFile(File dir) &#123;; File[]files=dir.listFiles(new FilenameFilter() &#123; @Override public boolean accept(File dir, String name) &#123; return new File(dir,name).isDirectory()||name.toLowerCase().endsWith(&quot;.md&quot;); &#125; &#125;);//传递过滤器对象 for(File f:files) &#123; if(f.isDirectory()) &#123; getAllFile(f); &#125; else &#123; System.out.println(f); &#125; &#125; &#125; &#125; java的IOio概述 字符和Ascii码的转换问题字符强转为(int)是获得它的Ascii码值 char a=&#39;a&#39;; int b=(int)a; System.out.println(b); 结果：97 ascii码值强转为char就是获得字符 int a =97; char b=(char)a; System.out.println(b); 结果：a 将字符1转换为数字1 123char a=&#x27;1&#x27;;System.out.println(a-&#x27;0&#x27;);结果：1 字节流一切文件数据在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据 在Ascii码中一个英文字符占用一个字节，一个汉字字符占用两个字节的空间 在unicode编码中，一个英文字符占用两个字节一个汉字字符也占用两个字节 UTF-8中，一个英文字符占用一个字节，一个汉字字符占用三个字节空间 字节输出流（OutputStream和FileOutputStream介绍） &#96;&#96;&#96;java java.io.OutputStream 字节输出流 这个抽象类是表示字节输出流的所有类的超类 定义了一些子类共性的成员方法 public void close() :关于此输出流并释放与此流相关联的任何系统资源 public void flush():刷新此输出流并强制任何缓冲的输出字节被写出 public void write(byte[] b):将 b.length字节从指定的字节数组写入此输出流。 public void write(byte[] b, int off, int len):从指定的字节数组写入 len个字节，从偏移 off开始输出到此输出流。 pubic void write(int b):将指定的字节写入此输出流。 java.io.FileOutputStream extends OutputStream FileOutputStream:文件字节输出流 作用：把内存中的数据给写入到硬盘的文件中 构造方法： FileOutputStream(File file)创建文件输出流以写入由指定的 File对象表示的文件。 FileOutputStream(String name) 创建文件输出流以指定的名称写入文件。构造方法作用1.创建一个FileOutputStream对象2.会根据构造方法中传递的文件&#x2F;文件路径，创建一个空的文件3.会把FileOutputStream对象指向创建好的文件 *&#x2F; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223​ **pubic void write(int b)**​ 写入数据的原理（内存到硬盘）：​ java程序--&gt;jvm(虚拟机)--&gt;os（操作系统）--&gt;os调用写数据的方法--&gt;把数据写入文件夹中字节输出流的使用步骤（重点） 1.创建一个FileOutputStream对象，构造方法中传递写入数据的目的地 2.调用FileOutputStream对象中的方法write，把数据写入到文件中 3.释放资源（流使用会占用一定的内存，使用完毕后把内存清空，提供程序效率） public static void main(String[]args) throws IOException &#123; //创建一个FileOutputStream对象，构造方法中传递写入数据的目的地 FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;); //调用FileOutputStream对象中的方法write，把数据写入到文件中 fos.write(97);//这个只能写入一个字节的大小的内容，97是这个字节对应的ASCII码值 //释放资源（流使用会占用一定的内存，使用完毕后把内存清空，提供程序效率） fos.close(); &#125;![image-20220630102639535](https://zhao1129.oss-cn-qingdao.aliyuncs.com/img/202209291918085.png)原理就是：97回先转换为二进制数储存在硬盘（文件）中，当用任何文本编辑器（记事本，notepad）再打开文件的时候，都会查询编码表，把字节转换为字符表示，0-127查询ASCII表 其他值：查询系统默认码表（中文windows系统GBK）我的电脑记事本查询的是UTF-8 **一次写多个字节的方法****public void write(byte[] b):将 b.length字节从指定的字节数组写入此输出流。**一次写多个字节： ​ 如果写的第一个字节是正数（0-127），那么显示的时候会查询ASCII表​ 如果写入的第一个字节是负数，那第一个字节会和第二个字节，两个字节组成一个中文显示，查询系统默认码表（中文系统GBK） 第一个例子 public static void main(String[]args) throws IOException &#123; //创建一个FileOutputStream对象，构造方法中传递写入数据的目的地 FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;); //调用FileOutputStream对象中的方法write，把数据写入到文件中 //在文件中显示100，写入3个字节 byte []bytes= &#123;49,48,48&#125;; fos.write(bytes); //释放资源 fos.close(); &#125;第二个例子 public static void main(String[]args) throws IOException &#123; //创建一个FileOutputStream对象，构造方法中传递写入数据的目的地 FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;); //调用FileOutputStream对象中的方法write，把数据写入到文件中 //在文件中显示100，写入3个字节 byte []bytes= &#123;-65,-66,-67,68,69&#125;; fos.write(bytes); //释放资源 fos.close(); &#125; 文件写入结果： 烤紻E就是前两个加起来组成一个系统默认码，后两个是一个组成一个系统默认码，最后一个时Ascii码**public void write(byte[] b, int off, int len):从指定的字节数组写入 len个字节，从偏移 off开始输出到此输出流。**把字节数组的一部分写入到文件中 public static void main(String[]args) throws IOException &#123; //创建一个FileOutputStream对象，构造方法中传递写入数据的目的地 FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;); //调用FileOutputStream对象中的方法write，把数据写入到文件中 byte []bytes= &#123;-65,-66,-67,68,69&#125;; fos.write(bytes,1,3);//从字节数组的下标1开始写入三个字节 //释放资源 fos.close(); &#125;写入字符的方法，可以使用String类方法把字符串，转换为字节数组，byte []getBytes() 把字符串转换为字节数组 public static void main(String[]args) throws IOException &#123; //创建一个FileOutputStream对象，构造方法中传递写入数据的目的地 FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;); byte []bytes=&quot;你好&quot;.getBytes(); System.out.println(Arrays.toString(bytes));//结果[-60, -29, -70, -61] //中文在eclipse中默认编码是GBK编码所以是一个中文两个字节 // 如果写入的第一个字节是负数，那第一个字节会和第二个字节，两个字节组成一个中文显示，查询系统默认码表（中文系统GBK） fos.write(bytes); fos.close(); &#125; 文件写入结果： 你好**数据的追加写和换行写**上面的方法都是将文件中原有的东西覆盖掉下面是追加写,续写FileOutputStream(String name, boolean append)创建文件输出流以指定的名称写入文件。FileOutputStream(File file, boolean append)创建文件输出流以写入由指定的 File对象表示的文件。​ 参数：​ String name File file：写入数据的目的地​ boolean append ：追加写开关 true ：创建对象不会覆盖源文件，继续在文件的末尾追加写数据​ false：创建一个新文件，覆盖原文件，在新文件中重新写数据 //创建一个FileOutputStream对象，构造方法中传递写入数据的目的地 FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;,true);//追加写 fos.write(&quot;你好&quot;.getBytes()); fos.close(); 源文件内容：你好 程序执行之后：你好你好**换行**写换行符号：windows \\r\\n​ linux:/n​ mac:/r //创建一个FileOutputStream对象，构造方法中传递写入数据的目的地 FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;,true);//追加写 for(int i=1;i&lt;=10;i++) &#123; fos.write(&quot;你好&quot;.getBytes()); fos.write(&quot;\\r\\n&quot;.getBytes()); &#125; fos.close(); 文件添加结果： 你好 你好 你好 你好 你好 你好 你好 你好 你好​ ### 字节输入流（InputStream）FileInputStream和InputStream的介绍java.io.InputStream抽象类时表示字节输入流的所有类的超类，可以读取字节信息到内存中，它定义了字节输入流的基本共性功能方法定义了所有子类的共性的方法：​ int `read()` 从输入流读取数据的下一个字节。返回读取的那一个字节的内容​ int `read(byte[] b)` 从输入流读取一些字节数，并将它们存储到缓冲区 `b` 。返回读取的字节数，读取的内容储存在参数数组​ void `close()` 关闭此输入流并释放与流相关联的任何系统资源。java.io.FileInputStream extends InputStreamFileInputStream :文件字节输入流作用：把硬盘文件中的数据，读取到内存中使用构造方法：`FileInputStream(String name)` - - `FileInputStream(File file)` - 参数：读取文件的数据源 - ​ String name是文件的路径 - ​ File file就是一个文件对象 - 构造方法的作用： - ​ 1.会创建一个FileInputStream对象 - ​ 2.会把FileInputStream对象指定构造方法中要读取的文件 读取数据的原理（硬盘--&gt;内存）：​ java程序--&gt;jvm--&gt;os--&gt;os读取数据的方法--&gt;读取文件字节输入流的使用步骤：​ 1.创建FileInputStream对象，构造方法中绑定要读取的数据源​ 2.使用FileInputStream对象中的方法read，读取文件​ 3.释放资源```java//1.创建FileInputStream对象，构造方法中绑定要读取的数据源 FileInputStream fos=new FileInputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;); //2.使用FileInputStream对象中的方法read，读取文件 int len=fos.read();//读取文件中的一个字节并返回，读取到文件末尾返回-1 //读取读入的那一个字节 System.out.println(len); len=fos.read();//每次read文件中的文件指针会向后移动一位 System.out.println(len); len=fos.read(); System.out.println(len); len=fos.read(); System.out.println(len); len=fos.read(); System.out.println(len); len=fos.read(); System.out.println(len); fos.close(); &#x2F;* 发现以上读取文件是一个重复的过程，所以可以使用循环优化，不知道文件中有多少字节，使用while循环，while循环结束条件，读取到-1时结束*&#x2F; 1234567FileInputStream fos=new FileInputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;); int len=0; while((len=fos.read())!=-1) &#123; System.out.println((char)(len)); &#125; fos.close(); 字节输入流一次读取一个字节的原理 java程序–&gt;jvm–&gt;os–&gt;os读取数据的方法–&gt;读取文件 每次读取结束，文件下标就会向后移一个 字节输入流一次读取多个字节 方法的参数byte[]作用 ​ 起到缓冲的作用，存储每次读取到的多个字节 ​ 数组的长度一般定义为1024（1kb）或者是1024的整数倍 int的返回值是什么 ​ 每次读取到的有效字节个数 123456789101112131415161718192021222324252627282930313233 int `read(byte[] b)` 从输入流读取一些字节数，并将它们存储到缓冲区 `b` 。 返回值是读入了多少个字节 public static void main(String[]args) throws IOException &#123; FileInputStream fis=new FileInputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;); //读取文件，指定读取多少字节 byte []bytes=new byte[2]; int len=fis.read(bytes); System.out.println(len);//2 System.out.println(Arrays.toString(bytes));//65,66 /* * String类的构造方法 * String(byte[] bytes) 通过使用平台的默认字符集解码指定的字节数组来构造新的 String 。String(byte[] bytes, int offset, int length) 通过使用平台的默认字符集解码指定的字节子阵列来构造新的 String offset是开始的下标，length是长度。 */ System.out.println(new String(bytes));//AB len=fis.read(bytes); System.out.println(len);//2,返回的是读到的字节的个数，没读到返回-1 System.out.println(new String(bytes));//CD len=fis.read(bytes); System.out.println(len);//1 System.out.println(new String(bytes));//ED len=fis.read(bytes); System.out.println(len);//-1 System.out.println(new String(bytes));//ED fis.close(); &#125; 第三次读取时只读取到一个E，故len返回1，而且byte数组的第二个位置没有被重新覆盖掉所以剩下的东西还是D，所以第三次输出数组还是ED，第四次没有东西读，所以返回-1结束标记，数组里还是上次的东西DE 循环优化 1234567891011121314public static void main(String[]args) throws IOException &#123;FileInputStream fis=new FileInputStream(&quot;D:\\\\放乱七八糟\\\\a.txt&quot;);//读取文件，指定读取多少字节byte []bytes=new byte[1024];int len=0;while((len=fis.read(bytes))!=-1) &#123; //String(byte[] bytes, int offset, int length) //通过使用平台的默认字符集解码指定的字节子阵列来构造新的 String offset是开始的下标，length是长度。 System.out.println(new String(bytes,0,5));&#125;fis.close();&#125; 字节流练习复制文件 12345678910111213public static void main(String []args) throws IOException &#123; FileInputStream fis=new FileInputStream(&quot;C:\\\\Users\\\\#赵梓皓&amp;\\\\Pictures\\\\Default.jpg&quot;); FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.jpg&quot;); int len=0; 读取之后再写入 while((len=fis.read())!=-1) &#123; fos.write(len); &#125; fos.close();//先关写的 fis.close();//后关闭读的，如果写完了，肯定读取完毕了 &#125; 更高效率 123456789101112 FileInputStream fis=new FileInputStream(&quot;C:\\\\Users\\\\#赵梓皓&amp;\\\\Pictures\\\\Default.jpg&quot;); FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.jpg&quot;); int len=0; byte []bytes=new byte[1024]; while((len=fis.read(bytes))!=-1) &#123; fos.write(bytes,0,len); &#125; fos.close();//先关写的 fis.close();//后关闭读的，如果写完了，肯定读取完毕了&#125; public static void main(String []args) throws IOException &#123; long s=System.currentTimeMillis(); FileInputStream fis=new FileInputStream(&quot;C:\\\\Users\\\\#赵梓皓&amp;\\\\Pictures\\\\Default.jpg&quot;); FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.jpg&quot;); int len=0; byte []bytes=new byte[1024]; while((len=fis.read(bytes))!=-1) &#123; fos.write(bytes,0,len); &#125; fos.close();//先关写的 fis.close();//后关闭读的，如果写完了，肯定读取完毕了 long e=System.currentTimeMillis(); System.out.println(&quot;复制文件共耗时&quot;+(e-s)+&quot;毫秒&quot;); &#125; 字符流一个中文 ​ GBK:占用两个字节 ​ UTF-8：占用3个字节 所以在从硬盘文件中读入中文时没有很好的办法读入中文 使用字节流读取中文文件会产生乱码 字符输入流Reader和FileReader类Reader定义 的一些子类公用的方法,它是字符输入流最顶级的父类 int read() 读一个字符并返回 int read(char[] cbuf) 将字符读入数组 用来一次读取多个字符，返回读取的字符个数。 void close() 关闭流并释放与之相关联的任何系统资源。 java.io.FileReader extends InputStreamReader extends Reader ​ FileReader:文件字符输入流 ​ 作用：把硬盘文件中的数据以字符的方式读取到内存中 构造方法： ​ 1.FileReader(String fileName) 创建一个新的 FileReader ，给定要读取的文件的名称。 ​ 2.FileReader(File file) 创建一个新的 FileReader ，给出 File读取。 作用：创建一个FileReader对象 ​ 会把FileReader对象指向要读取的文件 ​ 参数：String fileName和File file是数据来源 #### 读取字符数据（以及编码问题） 一次读取一个字节 int read() 读一个字符并返回 每次只读取一个字符无论是中文还是英文还是数字 public static void main(String []args) throws IOException &#123; FileReader fis=new FileReader(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;); int len=0; while((len=fis.read())!=-1) &#123; System.out.println((char)len); &#125; fis.close(); &#125; 这里出现了一点小插曲，因为我的电脑记事本默认是UTF-8编码，但eclipse默认编码是GBK所以会出现错误 我把电脑记事本编码转换为ASNI也就是默认是windows中文默认的GBK编码然后就可以实现了 int read(char[] cbuf) 将字符读入数组 用来一次读取多个字符，返回读取的字符个数。 12345678910111213public static void main(String []args) throws IOException &#123; FileReader fis=new FileReader(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;); char[] cs=new char[1024];//存储读取到的多个字符 int len=0; while((len=fis.read(cs))!=-1) &#123; System.out.println(new String(cs)); System.out.println(new String(cs,0,len));//0是开始的索引，len是转换的个数 &#125; fis.close();&#125;读取文件的结果 123你好 123你好 字符输出流Writer类和FileWriter类的介绍 Writer是字符输出流最顶层的父类 定义了一些共性的方法 void write(String str) 写一个字符串 void write(String str, int off, int len) 写一个字符串的一部分。 void write(int c) 写一个字符 void flush() 刷新流 子类：FileWriter java.io.FileWriter extends OutputStreamWriter extends Writer FileWriter:文件字符输出流 作用：把内存中的字符数据写入到文件中 构造方法： ​ FileWriter(File file) 给一个File对象构造一个FileWriter对象。 ​ FileWriter(String fileName) 构造一个给定文件名的FileWriter对象。 ​ 参数：写入数据的目的地 ​ String fileName：文件的路径 ​ File file：是一个文件 ​ 构造方法的作用： ​ 1.会创建一个FileWriter的对象 ​ 2.会根据构造方法中传递的文件&#x2F;文件的路径，创建文件 ​ 3.会把FileWriter对象指向创建好的文件 写出单个字符到文件 字符输出流的使用步骤： ​ 1.创建FileWriter对象，构造方法中绑定要写入数据的目的地 ​ 2.使用FileWriter中的方法write，把数据写到内存缓冲区中（字符转换字节的过程） ​ 3.使用FileWriter中的方法flush，把内存缓冲区中的数据，刷新到文件中 ​ 4.释放资源（会先把内存缓冲区的数据刷新到文件中）所以其实不用flush 如果没有调用flush或者close方法那么文件中将不会写入内容，因为write方法是把数据写到内存缓冲区 123456789public static void main(String []args) throws IOException &#123; //1.创建FileWriter对象，构造方法中绑定要写入数据的目的地 FileWriter fw=new FileWriter(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;); // 2.使用FileWriter中的方法write，把数据写到内存缓冲区中（字符转换字节的过程） fw.write(97); //3 3.使用FileWriter中的方法flush，把内存缓冲区中的数据，刷新到文件中 fw.flush(); fw.close();&#125; flush方法和close方法的区别 flush：刷新缓冲区，流对象可以继续使用 close：先刷新缓冲区，然后通知系统释放资源，流对象不可以再被使用了 字符输出流写数据的其他方法 void write(char []cbuf)写入字符数组 123456 public static void main(String []args) throws IOException &#123;FileWriter fw=new FileWriter(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);char []cs= &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;&#125;;fw.write(cs);fw.close(); &#125; void write(char []cbuf,int off,int len) 123456 public static void main(String []args) throws IOException &#123;FileWriter fw=new FileWriter(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);char []cs= &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;&#125;;fw.write(cs,0,2);//从下标为零开始，读取两个字符fw.close(); &#125; void write(String str)写入字符串 123456 public static void main(String []args) throws IOException &#123;FileWriter fw=new FileWriter(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);String a=&quot;你好&quot;;fw.write(a);fw.close(); &#125; void write(String str,int off,int len) 123456 public static void main(String []args) throws IOException &#123;FileWriter fw=new FileWriter(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);String a=&quot;你好我是java程序员&quot;;fw.write(a,0,4);//从下标为零然后读取四个字符fw.close(); &#125; 字符输出流写数据的续写和换行 续写： ​ 下面是追加写,续写 FileWriter(String name, boolean append)创建文件输出流以指定的名称写入文件。 FileWriter(File file, boolean append)创建文件输出流以写入由指定的 File对象表示的文件。 ​ 参数： ​ String name File file：写入数据的目的地 ​ boolean append ：追加写开关 true ：创建对象不会覆盖源文件，继续在文件的末尾追加写数据 ​ false：创建一个新文件，覆盖原文件，在新文件中重新写数据 换行：换行符号 ​ windows：\\r\\n ​ Linux:&#x2F;n ​ mac:&#x2F;r 123456789101112131415161718FileWriter fw=new FileWriter(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;,true);for(int i=0;i&lt;10;i++) &#123; fw.write(&quot;HelloWorld&quot;+i+&quot;\\r\\n&quot;);&#125;fw.close(); &#125;文件内容： 你好我是HelloWorld0HelloWorld1HelloWorld2HelloWorld3HelloWorld4HelloWorld5HelloWorld6HelloWorld7HelloWorld8HelloWorld9 IO异常的处理fw.close要放在finally中因为程序无论是否报错都得有这个流的关闭 同时fw.close也有异常，所以在fianally里要嵌套一个trycatch 12345678910111213141516171819202122232425262728public static void main(String []args) &#123; //提高变量fw的作用域，让finally可以使用 //变量在定义的时候可以没有值，但是使用的时候必须有值 //如果下面new执行失败了，则fw没有值，fw.close()会报错，所以 FileWriter fw=null; try &#123; //可能会产出异常的代码 fw=new FileWriter(&quot;w:\\\\放乱七八糟\\\\File.txt&quot;,true);for(int i=0;i&lt;10;i++) &#123; fw.write(&quot;HelloWorld&quot;+i+&quot;\\r\\n&quot;);&#125; &#125; catch(IOException e) &#123; System.out.println(e); &#125; finally &#123; //一定会指定的代码 //创建对象失败了，fw的默认值就是null，null是不能调用方法的，会抛出NullPointerException，需要增加一个判断，不是null再把资源释放 if(fw!=null)&#123;try &#123; //fw.close方法声明抛出了IOException异常对象，所以我们就处理这个异常对象，要么throws要么trycatch fw.close();&#125; catch (IOException e) &#123; e.printStackTrace();&#125;&#125; &#125;&#125; JDK7新特性 在try的后面可以增加一个()，在括号中可以定义流对象 那么这个流对象的作用域就在try中有效，就不用自己关闭流了 try中代码执行完毕，会自动把流对象释放，不再写finally try(定义流对象;定义流对象…){ &#x2F;&#x2F;可能会产生异常的代码 } catch(异常类变量 变量名){ 异常处理的逻辑 } 123456789//try括号中的这个流只在try中有效，就不用自己关闭流了 try (FileWriter fw=new FileWriter(&quot;d:\\\\放乱七八糟\\\\File.txt&quot;,true);)&#123;for(int i=0;i&lt;10;i++) &#123; fw.write(&quot;HelloWorld&quot;+i+&quot;\\r\\n&quot;);&#125; &#125; catch(IOException e) &#123; System.out.println(e); &#125; 缓冲流缓冲流都是在基本的流对象基础之上创建来的，就像穿上铠甲的武士一样，相当于是对基本流对象的一种增强 概述： 缓冲流也叫做高效流，是对四个基本的FileXxx流的增强，所以也是四个流，按照数据类型分类： 字节缓冲流：BufferedInputStream，BufferedOutputStream 字符缓冲流：BufferedReader，BufferedWriter 缓冲流的基本原理是在创建流对象的时候，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写效率 就是返回文件内容的时候，不是一个一个返回，是把所有的都整到一个缓冲区里然后全部一起以一个数组的形式返回 字节缓冲输出流java.io.BufferedOutputStream extends OutputStream 继承的父类的共性方法 OutputStream有的方法它都有 构造方法 BufferedOutputStream(OutputStream out) 创建一个新的缓冲输出流，以将数据写入指定的底层输出流 BufferedOutputStream(OutputStream out, int size) 创建一个新的缓冲输出流，以便以指定的缓冲区大小将数据写入指定的底层输出流。 参数：OutputStream 就是一个字节输出流 我们可以传递FileOutputStream，缓冲流会给FileOutputStream增加一个缓冲区，提高FileOutputStream的的写入效率 int size：指定缓冲流内部缓冲区的大小，不指定就是默认的大小 使用步骤： ​ 1.创建FileOutputStream对象，构造方法中绑定要输出的目的地 ​ 2.创建BufferedOutputStream对象，构造方法中传递FileOutputStream对象，提高FileOutputStream对象效率 ​ 3.使用BufferedOutputStream对象中的方法write，把数据写入到内部缓冲区中 ​ 4.使用BufferedOutputStream对象中方法flush，吧内部缓冲区的数据刷新到文件中 ​ 5.释放资源（会先调用flush方法刷新数据，所以第四步可以省略） 12345678910111213141516class Main&#123;public static void main(String []args) throws IOException &#123; // 1.创建FileOutputStream对象，构造方法中绑定要输出的目的地 FileOutputStream fos= new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;); //2.创建BufferedOutputStream对象，构造方法中传递FileOutputStream对象，提高FileOutputStream对象效率 BufferedOutputStream bos=new BufferedOutputStream(fos); //3.使用BufferedOutputStream对象中的方法write，把数据写入到内部缓冲区中 bos.write(&quot;我把数据写入到内部缓冲区中&quot;.getBytes()); //4.使用BufferedOutputStream对象中方法flush，吧内部缓冲区的数据刷新到文件中 bos.flush(); //5.释放资源（会先调用flush方法刷新数据，所以第四步可以省略） bos.close();&#125;&#125; 字节缓冲输入流java.io.BufferedInputStream extends InputStream BufferedInputStream:字节缓冲输入流 所有InputStream有的方法他都有 构造方法 BufferedInputStream(InputStream in) 创建一个 BufferedInputStream并保存其参数，输入流 in ，供以后使用。 BufferedInputStream(InputStream in, int size) 创建 BufferedInputStream具有指定缓冲区大小，并保存其参数，输入流 in ，供以后使用 参数; ​ InputStream in:字节输入流 ​ 我们可以传递FileInputStream，缓冲区会给FileInputStream增加一个缓冲区，提高FileInputStream的读取效率 使用步骤： ​ 1.创建一个FileInputStream对象，构造方法中绑定要读取的数据源 ​ 2.创建BufferedInputStream对象，构造方法中传递FileInputStream对象，提高FileInputStream对象的读取效率 ​ 3.使用BufferedInputStream对象中的方法read()，读取文件 ​ 4.释放资源 123456789101112public static void main(String []args) throws IOException &#123; //1.创建一个FileInputStream对象，构造方法中绑定要读取的数据源 FileInputStream fis=new FileInputStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;); //2.创建BufferedInputStream对象，构造方法中传递FileInputStream对象，提高FileInputStream对象的读取效率 BufferedInputStream bis=new BufferedInputStream(fis); // 3.使用BufferedInputStream对象中的方法read()，读取文件 int len=0;//记录每次读取到的字节 while((len=bis.read())!=-1) &#123; System.out.println(len); &#125; bis.close();&#125; 12345678910111213public static void main(String []args) throws IOException &#123; //1.创建一个FileInputStream对象，构造方法中绑定要读取的数据源 FileInputStream fis=new FileInputStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;); //2.创建BufferedInputStream对象，构造方法中传递FileInputStream对象，提高FileInputStream对象的读取效率 BufferedInputStream bis=new BufferedInputStream(fis); // 3.使用BufferedInputStream对象中的方法read()，读取文件 int len=0;//记录每次读取的有效字节个数 byte[] bytes=new byte[1024]; while((len=bis.read(bytes))!=-1) &#123;//最后这个-1是不会返回给len的 System.out.println(new String(bytes,0,len)); &#125; bis.close();&#125; 用缓冲流来复制文件速度变得更快，可见效率变得更高 123456789101112131415161718public static void main(String []args) throws IOException &#123; long end =System.currentTimeMillis(); FileInputStream fis=new FileInputStream(&quot;C:\\\\Users\\\\#赵梓皓&amp;\\\\Pictures\\\\Default.jpg&quot;); BufferedInputStream bis=new BufferedInputStream(fis); FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.jpg&quot;); BufferedOutputStream bos=new BufferedOutputStream(fos); int len=0; while((len=bis.read())!=-1) &#123; bos.write(len); &#125; bos.close(); bis.close(); long end1=System.currentTimeMillis(); System.out.println(&quot;耗时&quot;+(end1-end)+&quot;毫秒&quot;);&#125;耗时42毫秒 123456789101112131415161718public static void main(String []args) throws IOException &#123; long end =System.currentTimeMillis(); FileInputStream fis=new FileInputStream(&quot;C:\\\\Users\\\\#赵梓皓&amp;\\\\Pictures\\\\Default.jpg&quot;); BufferedInputStream bis=new BufferedInputStream(fis); FileOutputStream fos=new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\a.jpg&quot;); BufferedOutputStream bos=new BufferedOutputStream(fos); int len=0; byte []bytes=new byte[1024]; while((len=bis.read(bytes))!=-1) &#123; bos.write(bytes,0,len); &#125; bos.close(); bis.close(); long end1=System.currentTimeMillis(); System.out.println(&quot;耗时&quot;+(end1-end)+&quot;毫秒&quot;);&#125;耗时4毫秒 字符缓冲输出流 &#96;&#96;&#96;public class BufferedWriterextends Writer123456789101112131415161718192021222324252627282930313233343536有继承自父类的共性成员方法，所有Writer的方法他都有构造方法- - `BufferedWriter(Writer out)` 创建使用默认大小的输出缓冲区的缓冲字符输出流- - `BufferedWriter(Writer out, int sz)` 创建一个新的缓冲字符输出流，使用给定大小的输出缓冲区参数：​ 第一个参数是一个字符输出流​ 我们可以传递FileWriter，缓冲流会给FileWriter增加一个缓冲区，提高FileWriter的写入效率​ 第二个参数 int sz：指定缓冲区的大小，不写是默认大小特有的成员方法- - `void newLine()` 写一行行分隔符。方法和上面的都一样，便不再注释```javapublic static void main(String []args) throws IOException &#123; FileWriter fw=new FileWriter(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);BufferedWriter bw=new BufferedWriter(fw);for(int i=0;i&lt;10;i++) &#123; bw.write(&quot;你好&quot;); bw.newLine();//用来进行换行&#125;bw.flush();bw.close();&#125; BufferedReader字符缓冲输入流 Java.io.BufferedReader extends Reader 继承自父类的共性成员方法 构造方法 BufferedReader(Reader in) 创建使用默认大小的输入缓冲区的缓冲字符输入流。 BufferedReader(Reader in, int sz) 创建使用指定大小的输入缓冲区的缓冲字符输入流 参数： 字符输入流 ​ 我们可以传递FileReader，缓冲流会给FileReader增加一个缓冲区，提高FileReader的读取效率 特有的成员方法 String readLine() 读一行文字。 ​ 行的终止符浩：通过下列字符之一即可认为某行已经终止：换行(‘\\n’),回车(‘\\r’),或回车后直接跟着换行(\\r\\n) ​ 返回值： ​ 包含该行内容的字符串，不包含任何终止符，如果已经达到里流末尾，返回null 1234567891011public static void main(String []args) throws IOException &#123;FileReader fr=new FileReader(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);BufferedReader br=new BufferedReader(fr);String line;while((line=br.readLine())!=null) &#123; System.out.println(line);&#125;br.close();&#125;结果:可以输出所有行 练习：文本排序（以及转义）12345678910111213141516171819202122232425262728class Main&#123;public static void main(String []args) throws IOException &#123; HashMap&lt;String,String&gt; hm=new HashMap&lt;String,String&gt;();FileReader fr=new FileReader(&quot;D:\\\\放乱七八糟\\\\File1.txt&quot;);FileWriter fw=new FileWriter(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);BufferedWriter bw=new BufferedWriter(fw);BufferedReader br=new BufferedReader(fr);String line;while((line=br.readLine())!=null) &#123; String []str=line.split(&quot;\\\\.&quot;);//split用的是正则表达式.有特殊含义，所以用\\转义，而java中\\\\才是\\ // \\t,\\n等有特殊含义所以java中字符串如果出现\\会有歧义，所以用\\\\来吧\\替换为一个普通字符，这个普通字符进了正则表达式中又可以把.转义，所以在java中使用正则表达式匹配“\\”时就需要写成&quot;\\\\\\\\&quot; //把切割好的序号和文本内容储存到HashMap集合中(key序号是有序的，会自动排序1，2，3，4) hm.put(str[0], str[1]);&#125;for(String b:hm.keySet()) &#123; String value=hm.get(b); line=b+&quot;.&quot;+value; bw.write(line); bw.newLine();&#125;bw.close();br.close();&#125;&#125; 文件原内容 12341.我是2.我才不是4.我真的不是3.你不是 文件变更以后 12341.我是2.我才不是3.你不是4.我真的不是 插曲：我读取内容的文件是utf-8形式的，写入的文件是以gbk打开，所以出现乱码我把utf-8改为gbk就好了 转换流字符编码： 计算机中储存的信息都是用二进制表示的，而我们在屏幕上看到的数字英文标点符号汉字等字符是二进制转换之后的结果 按照某种规则，将字符储存到计算机中，成为编码，反之，将存储在计算机中的二进制数按照某种规则解析出来称为解码，比如说按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号，反之，按照A规则存储，按照B规则解析，就会出现乱码 编码：字符–》字节 解码：字节–》字符 字符编码：就是一套自然语言的字符与二进制数之间的对应规则。 编码表：生活中文字和计算机中二进制的对应规则 字符集： Ascii码字符集–》Ascii码编码 GBK字符集–》GBK编码 Unicode字符集–》UTF8编码，UTF16编码，UTF32编码 转换流原理输入转换原理 用InputStreamReader FileReader底层还是FileInputStream将字节转换为字符时只能用IDE默认编码 而InputStreamReader可以指定字节转换为字符的编码形式 输出转换原理 用OutputStreamWriter FileWriter的底层实现还是FileOutputStream，只能将字符转换为IDE默认的编码的字节 如果用OutputStreamWriter 可以指定字符转字节的时候的编码格式 编码引出的问题FileReader读取文件 就是FileReader能读取编译器默认编码的文件，比如eclipse时GBK，IDEA是UTF-8 下面演示在eclipse用FileReader读取UTF-8 OutputStreamWriter OutputStreamWriter是字符的桥梁流以字节流：向其写入的字符编码成使用指定的字节charset 。 它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集。 java.io.BufferedWriter extends Writer Writer中的方法都可以使用 构造方法： OutputStreamWriter(OutputStream out) 创建一个使用默认字符编码的OutputStreamWriter OutputStreamWriter(OutputStream out, String charsetName) 创建一个使用命名字符集的OutputStreamWriter。 参数：OutputStream out：字节输出流，可以用来写转换之后的字节到文件中 ​ String charsetName：指定的编码表的名称，不区分大小写，可以使utf-8&#x2F;UTF-8&#x2F;GBK&#x2F; public static void main(String []args) throws IOException &#123; //创建OutputStreamWriter对象，构造方法中传递字节输出流的指定的编码表名称 OutputStreamWriter osw=new OutputStreamWriter(new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;),&quot;UTF-8&quot;); //使用OutputStreamWriter对象中的方法write，把字符转换为字节存储缓冲区中（编码） osw.write(&quot;你好&quot;); //使用OutputStreamWriter对象中的flush，把内存缓冲区中的字节刷新到文件中（使用字节流写字节） osw.flush(); //释放内存 osw.close(); &#125; 将你好写入了UTF-8编码显示的文件 InputStreamReaderjava.io.InputStreamReader extends Reader InputStreamReader是从字节流到字符流的桥：它读取字节，并使用指定的charset将其解码为字符 。 它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集。 它由继承字父类的共性的成员方法 ​ Reader有的方法它都有 构造方法： ​ InputStreamReader(InputStream in) 创建一个使用默认字符集的InputStreamReader ​ InputStreamReader(InputStream in, String charsetName) 创建一个使用命名字符集的InputStreamReader ​ 参数： ​ InputStream in：字节输入流，用来读取文件中保存的字节 ​ String charsetName：字符表名称 public static void main(String []args) throws IOException &#123; //创建InputStreamWriter对象，构造方法中传递字节输入流和指定的编码表名称 InputStreamReader osw=new InputStreamReader(new FileInputStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;),&quot;UTF-8&quot;); //使用InputStreamWriter对象中的方法read()，把字符转换为字节存储缓冲区中（编码） int len=0; while((len=osw.read())!=-1) &#123; System.out.println((char)len); &#125; //释放内存 osw.close(); &#125; 即是文件内容是UTF-8，也可以给他读入到内存中 结果：你 好 转换文件编码的练习 1234567891011public static void main(String []args) throws IOException &#123; InputStreamReader isr=new InputStreamReader(new FileInputStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;),&quot;UTF-8&quot;); OutputStreamWriter osw=new OutputStreamWriter(new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\File1.txt&quot;),&quot;GBK&quot;); int len=0; while((len=isr.read())!=-1) &#123; osw.write(len); &#125; osw.close(); isr.close();&#125;将UTF-8的文件转换为GBK编码的文件 序列化ObjectOutputStream extends OutputStream ObjectOutputStream：对象的序列化流 作用：把对象以流的形式写入到文件中保存 构造方法： ​ ObjectOutputStream(OutputStream out) 创建一个写入指定的OutputStream的ObjectOutputStream。 ​ 参数： ​ 床第一个字节输出流 特有的成员方法： ​ writeObject(Object obj) 将指定的对象写入ObjectOutputStream。 使用步骤; ​ 1.创建ObjectOutputStream对象，构造方法中传递字节输出流 ​ 2.使用ObjectOutputStream对象中的writeObject，把对象写入到文件中 ​ 3.释放资源 类只有实现了Serializable接口才能被序列化或者反序列化 1234567891011121314151617181920212223242526272829class Test implements Serializable&#123;private String name;public String getName() &#123; return name;&#125;public void setName(String name) &#123; this.name = name;&#125;public int getAge() &#123; return age;&#125;public void setAge(int age) &#123; this.age = age;&#125;private int age;public Test() &#123; &#125;public Test(String name,int age) &#123; this.name=name; this.age=age;&#125;&#125;文件内容以二进制字节来存储所以无法直接打开看 1234567 public static void main(String []args) throws IOException, ClassNotFoundException &#123;ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;));oos.writeObject(new Test(&quot;小美女&quot;,18));oos.close(); &#125; ObjectInputStream extends InputStream ObjectInputStream :对象的反序列化流 作用：把文件中保存的对象以流的形式读取出来使用过 构造方法: ​ ObjectInputStream(InputStream in) 创建从指定的InputStream读取的ObjectInputStream ​ 参数：传入一个字节输入流 特有的成员方法： ​ readObject() 从ObjectInputStream读取一个对象。 使用步骤： 1.创建ObjectInputStream对象，构造方法中传递字节输入流 2.使用ObjectInputStream对象中的方法readObject读取保存对象的文件 3.释放资源 4.使用读取出来的对象（打印） readObject方法声明抛出了ClassNotFoundException（Class文件找不到异常）当不存在对象的class文件时抛出此异常 反序列化的前提： ​ 1.类必须实现Serializable接口 ​ 2.必须存在类对应的class文件 1234567891011public static void main(String []args) throws IOException, ClassNotFoundException &#123; //1.创建ObjectInputStream对象，构造方法中传递字节输入流 ObjectInputStream ois=new ObjectInputStream(new FileInputStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;)); //2.使用ObjectInputStream对象中的方法readObject读取保存对象的文件 Object o=ois.readObject();//这里必须使用Object类型来接受 ois.close(); //4.使用读取出来的对象（打印） System.out.println(o); Test t=(Test)o; System.out.println(t.getName()+t.getAge());&#125; transient关键字 static关键字:静态关键字 1.静态优先于非静态加载到内存中（静态优先于对象进入到内存中） 被static修饰的成员变量不能被序列化的，序列化的都是对象 private static int age oos.writeObject(new Person(“小美女”,18)); Object o&#x3D;ois.readObject(); Person{name&#x3D;”小美女”,age&#x3D;0} 所以静态的不能够被序列化 transient关键字：瞬态关键字 ​ 被transient修饰的成员变量，不能被序列化 它的功能就是不让某个属性序列化，但是又没有静态的含义 InvalidClassException异常当分别一次序列化和反序列化之后是正常的，但现在你去改了那个序列化的类属性，然后没有对他序列化而是直接反序列化 就会报InvalidClassException 就是当你改动了类之后你txt文件中的类的id和你class文件中的id不同就导致不能够反序列化成功 所以就在类中加一个private static final long serialVersionUID&#x3D;1L; 这样无论怎么改id都不会变了 练习：序列化集合练习：序列化集合 ​ 当我们想在文件中保存多个对象的时候 ​ 可以把多个对象储存到一个集合中 ​ 对集合进行序列化和反序列化 分析： ​ 1.定义一个存储Person对象的集合和ArrayList集合 ​ 2.往ArrayList集合中存储Person对象 ​ 3.创建一个序列化流ObjectOutputStream ​ 4.使用ObjectOutputStream对象中的方法writeObject，对集合进行序列化 ​ 5.创建一个反序列化ObjectInputStream对象 ​ 6.使用ObjectInput中的方法readObject读取文件中保存的集合 ​ 7.把Object类型的集合转换为ArrayList类型 ​ 8，遍历这个ArrayList集合 ​ 9.释放资源 public static void main(String []args) throws IOException, ClassNotFoundException &#123; // 1.定义一个存储Person对象的集合和ArrayList集合 ArrayList&lt;Test&gt; list=new ArrayList&lt;Test&gt;(); // 2.往ArrayList集合中存储Person对象 list.add(new Test(&quot;张三&quot;,18)); list.add(new Test(&quot;例四&quot;,18)); list.add(new Test(&quot;赵武&quot;,18)); //3.创建一个序列化流ObjectOutputStream ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;)); //4.使用ObjectOutputStream对象中的方法writeObject，对集合进行序列化 oos.writeObject(list); // 5.创建一个反序列化ObjectInputStream对象 ObjectInputStream ois=new ObjectInputStream(new FileInputStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;)); // 6.使用ObjectInput中的方法readObject读取文件中保存的集合 Object o=ois.readObject(); //7.把Object类型的集合转换为ArrayList类型 ArrayList&lt;Test&gt; list2=(ArrayList&lt;Test&gt;)o; //8，遍历这个ArrayList集合 for(Test p:list2) &#123; System.out.println(p); &#125; // 9.释放资源 ois.close(); oos.close(); &#125; 打印流重定向标准输入输出java.io.PrintStream ​ PrintStream为另一个输出流添加了功能，即能够方便地打印各种数据值的表示。 PrintStream特带你： ​ 1.只负责数据的输出，不负责数据的读取 ​ 2.与其他输出流不同，PrintStream永远不会抛出IOException ​ 3.有特有的方法，print，println方法 ​ void print(任意类型的值) ​ void println(任意类型的值并换行) 构造方法： ​ PrintStream(File file) 输出的目的地是一个文件 ​ PrintStream(OutputStream out) 输出的目的地是一个字节输出流 ​ PrintStream(String fileName) 输出的目的地是一个文件路径 printStream extends OutputStream 继承自父类的成员方法 注意： ​ 如果使用继承自父类的write方法那么查看数据的时候会查询编码表 ​ 如果是用自己特有的方法print&#x2F;println方法写数据，写的数据原样输出 123456789101112131415161718192021222324```java用父类的方法会查询编码表 public static void main(String []args) throws IOException, ClassNotFoundException &#123;PrintStream ps=new PrintStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);ps.write(97);ps.close(); &#125;文件：文件的内容是a```用自己的方法是原样输出 public static void main(String []args) throws IOException, ClassNotFoundException &#123;PrintStream ps=new PrintStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);ps.println(&quot;a&quot;);ps.println(97);ps.println(100);ps.println(&quot;我是&quot;);ps.close(); &#125; 文件内容是：a 97 100 我是 可以改变输出语句的目的地（打印流的流向） 输出语句：默认在控制台输出 使用System.setOut放法改变输出语句的目的为参数传递的打印流的目的地 ​ static void setOut(printStream out) ​ 重新分配”标准”输出流 下面这个是将System.out的输出重定向到文件输出而不是在屏幕上输出 12345678 public static void main(String []args) throws IOException, ClassNotFoundException &#123; System.out.println(&quot;我在控制台输出&quot;);PrintStream ps=new PrintStream(&quot;D:\\\\放乱七八糟\\\\File.txt&quot;);System.setOut(ps);//把输出语句的目的地改变为打印流的目的地System.out.println(&quot;我在打印流的目的地中输出&quot;);&#125; 改变这个输出语句在流里输出 使用System的setIn()方法将系统标准输入重定向到该文件输入流，不会等待用户输入而是直接输出了文件的内容 java的多线程详解概念多线程案例：一起开黑打王者荣耀，你给我发消息的时候我也能给你发消息 多线程： 可以实现一个并发操作，在一个程序中可以定义多个线程并同时运行它们，每个线程可以执行不同的任务。 进程（Process）：在操作系统中运行的程序就是进程，比如你的qq播放器游戏IDE 进程则是执行程序的一次执行过程，它是一个动态的概念，是系统资源分配的单位 线程(Thread)：一个进程可以有多个线程，如视频中同时听声音，看图像，看弹幕等等 进程可以包含多个线程，一个进程至少有一个Main线程，不然没有存在的意义 多线程和多任务的区别：多任务是针对操作系统而言的，代表操作系统可以同时执行的程序个数；多线程是针对一个程序而言的，代表一个程序可以同时执行的线程的个数，每个线程完成不同的任务。 在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器(cpu)是与操作系统紧密相关的，先后顺序是不能人为干预的 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制（10000个人抢100张票必定有人抢不到） 继承Thread类 创建一个新的执行线程有两种方法。 一个是将一个类声明为Thread的子类。 这个子类应该重写run类的方法Thread 。 创建线程对象，调用start()方法启动线程 12345678910111213141516171819202122public class Hello extends Thread&#123; @Overridepublic void run() &#123; //run方法线程体 for(int i=0;i&lt;20;i++) &#123; System.out.println(&quot;我在看书&quot;); &#125;&#125; public static void main(String []args) &#123; //main线程主线程 //创建一个线程对象 Hello testThread=new Hello(); //调用start()方法开启线程 testThread.start(); for(int i=0;i&lt;20;i++) &#123; System.out.println(&quot;我在学习&quot;); &#125; &#125; &#125;用start方法是开了一条新线程，两条线程同时执行（线程不一定立即执行,cpu调度安排），如果是调用run方法则就是先执行run方法再回到主线程执行 注意：县城开启不一定立即执行，由cpu调度执行 网图下载 建立多个TestThread2对象，开辟多个线程，同时执行 实现Runnable接口定义MyRunnable类实现Runnable接口 实现run()方法，编写线程执行体 创建线程对象，调用start()方法启动线程 1234567891011121314151617@Override public void run() &#123; //run方法线程体 for(int i=0;i&lt;20;i++) &#123; System.out.println(&quot;我在看书&quot;); &#125; &#125; public static void main(String []args) &#123; //创建一个runnable接口的实现类对象 Hello testThread3=new Hello(); //创建线程对象，通过线程对象来开启我们的线程，代理 Thread thread=new Thread(testThread3); thread.start(); for(int i=0;i&lt;20;i++) &#123; System.out.println(&quot;我在学习&quot;); &#125; &#125; 小结 初始并发问题 &#x2F;&#x2F;多个线程同时操作同一个对象 &#x2F;&#x2F;买火车票的例子 &#x2F;&#x2F;返现问题：多个线程操作同一个资源的情况下，线程不安全，数据紊乱，就是小明老师黄牛党都拿到了第十张票， 12345678910111213141516171819202122232425262728public class Hello implements Runnable&#123; private int ticketNums=10; public void run() &#123; while(true) &#123; if(ticketNums&lt;=0) &#123; break; &#125; try &#123; Thread.sleep(200);//模拟延时,是当前线程进入休息状态 &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;--&gt;拿到了第&quot;+ticketNums--+&quot;票&quot;); &#125; &#125;public static void main(String []args) &#123; Hello ticket=new Hello(); //Thread后面的第二个参数是这个线程的名字 new Thread(ticket,&quot;小明&quot;).start(); new Thread(ticket,&quot;老师&quot;).start(); new Thread(ticket,&quot;黄牛党&quot;).start(); &#125;&#125; 龟兔赛跑相当于乌龟和兔子是两条线程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package hello;public class Hello implements Runnable&#123; private String winner;public void run() &#123; for(int i=0;i&lt;=100;i++) &#123; //模拟兔子休息 if(Thread.currentThread().getName().equals(&quot;兔子&quot;)&amp;&amp;i%10==0) &#123; try &#123; Thread.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //判断比赛是否结束 boolean flag=gameOver(i); //如果比赛结束了，就停止程序 if(flag) &#123; break; &#125; System.out.println(Thread.currentThread().getName()+&quot;--&gt;跑了&quot;+i+&quot;步&quot;); &#125;&#125;private boolean gameOver(int step) &#123; //判断是否存在胜利者 if(winner!=null) &#123; return true; &#125; else &#123; if(step&gt;=100) &#123; winner=Thread.currentThread().getName(); System.out.println(&quot;winner is&quot;+winner); return true; &#125; &#125; return false; &#125;public static void main(String []args) &#123; Hello race=new Hello(); new Thread(race,&quot;兔子&quot;).start(); new Thread(race,&quot;乌龟&quot;).start();&#125;&#125; 实现Callable接口好处：1.可以定义返回值 2.可以抛出异常 t1就是实现Callable接口的类的实例化对象 要重写call方法，可以自己设定它的返回值和哪个Collable接口的泛型类型一致 静态代理模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package hello;//静态代理模式：//真实对象和代理对象都要实现同一个接口//代理对象要代理真实角色//好处： //代理对象可以做很多真实对象做不了的事情 //真实对象专注做自己的事情public class Hello&#123; public static void main(String []args) &#123; WeddingCompany weddingCompany=new WeddingCompany(new You());//我来、把自己给婚庆公司 weddingCompany.HappyMarry();//婚庆公司代理我结婚，没有通过我直接去调用结婚的方法 &#125;&#125;interface Marry&#123; void HappyMarry();&#125;class You implements Marry&#123; @Override public void HappyMarry() &#123; System.out.println(&quot;我要结婚了&quot;); &#125;&#125;//婚庆公司代理我去结婚，还是我去结婚class WeddingCompany implements Marry&#123; //这个地方是一个真实的结婚的角色 private Marry target; public WeddingCompany(Marry target) &#123; this.target=target; &#125; @Override public void HappyMarry() &#123; before(); this.target.HappyMarry();//这就是真实对象 after(); &#125; private void after() &#123; System.out.println(&quot;结婚之后，收尾款&quot;); &#125; private void before() &#123; System.out.println(&quot;结婚之前，布置现场&quot;); &#125;&#125; 类比到多线程：new Thread(()-&gt;System.out.println(“我爱你”)).start(); Thread类代理Runnable接口那个真实对象 线程状态 new是创建状态 dead是死亡状态 停止线程不推荐使用jdk提供的stop() destroy()方法 推荐线程自己停下来 建议使用一个标志位进行终止变量 当flag&#x3D;false，则终止线程运行 &#x2F;&#x2F;测试stop&#x2F;&#x2F;1.建议线程正常停止—》利用次数，不建议死循环&#x2F;&#x2F;2.建议使用标志位–&gt;设置一个标志位&#x2F;&#x2F;3.不要使用stop或者destroy等果实或者JDK不建议使用的方法 12345678910111213141516171819202122232425262728293031public class Hello implements Runnable&#123; //1设置一个标识位 private boolean flag=true; @Override public void run() &#123; int i=0; while(flag) &#123; System.out.println(&quot;run thread&quot;+i++); &#125; &#125; //2.设置一个公开的方法停止线程 public void stop() &#123; this.flag=false; &#125; public static void main(String []args) &#123; Hello teststop=new Hello(); new Thread(teststop).start(); for(int i=0;i&lt;1000;i++) &#123; System.out.println(&quot;main&quot;+i); if(i==900) &#123; //调用stop方法切换标志位，让线程停止 teststop.stop(); System.out.println(&quot;线程该停止了&quot;); &#125; &#125; &#125;&#125; 线程休眠（sleep）sleep指定当前线程阻塞的毫秒数 sleep存在异常InterruptedException sleep时间达到后线程进入就绪状态 sleep可以模拟网络延迟，倒计时等 每一个对象都有一个锁，sleep不会释放锁 &#x2F;&#x2F;模拟网络延时，放大问题的发生性 12345678910111213141516171819202122232425262728public class Hello implements Runnable&#123; private int ticketNums=10; public void run() &#123; while(true) &#123; if(ticketNums&lt;=0) &#123; break; &#125; try &#123; Thread.sleep(200);//模拟延时,是当前线程进入休息状态 &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;--&gt;拿到了第&quot;+ticketNums--+&quot;票&quot;); &#125; &#125;public static void main(String []args) &#123; Hello ticket=new Hello(); //Thread后面的第二个参数是这个线程的名字 new Thread(ticket,&quot;小明&quot;).start(); new Thread(ticket,&quot;老师&quot;).start(); new Thread(ticket,&quot;黄牛党&quot;).start(); &#125;&#125; 模拟倒计时 12345678910111213141516171819202122public class Hello&#123; public static void tenDown() throws InterruptedException&#123; int num=10; while(true) &#123; Thread.sleep(1000); System.out.println(num--); if(num&lt;=0) &#123; break; &#125; &#125; &#125; public static void main(String []args) &#123; try &#123; tenDown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 获取当前系统时间 1234567891011121314151617public class Hello&#123; public static void main(String []args) &#123; Date startTime=new Date(System.currentTimeMillis()); //获取当前的时间Mon Jul 04 16:40:30 CST 2022 while(true) &#123; try &#123; Thread.sleep(1000); System.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(startTime));//16:40:30 startTime=new Date(System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;&#125; 礼让线程礼让线程(yield)：让当前正在执行的线程暂停，但不阻塞 将线程从运行状态转为就绪状态 让cpu重新调度，礼让不一定成功，看CPU心情 123456789101112131415161718192021222324public class Hello&#123; public static void main(String []args) &#123; Myyield e=new Myyield(); new Thread(e,&quot;a&quot;).start(); new Thread(e,&quot;b&quot;).start();&#125;&#125;class Myyield implements Runnable&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+&quot;线程开始执行&quot;); Thread.yield();//礼让 System.out.println(Thread.currentThread().getName()+&quot;线程停止执行&quot;); &#125;&#125;结果：a线程开始执行 b线程开始执行 a线程停止执行 b线程停止执行 线程强制执行（join）join合并线程，待此线程执行完成之后再执行其他线程，其他线程阻塞 可以想象成插队 123456789101112131415161718192021222324class Hello implements Runnable&#123; @Override public void run() &#123; for(int i=0;i&lt;1000;i++) &#123; System.out.println(&quot;线程vip来了&quot;); &#125; &#125; public static void main(String []args) throws InterruptedException &#123; //启动我们的线程 Hello testjoin=new Hello(); Thread a=new Thread(testjoin); a.start(); //主线程 for(int i=0;i&lt;500;i++) &#123; if(i==200) &#123; a.join();//强制让run方法线程执行完毕再执行主线程 &#125; System.out.println(&quot;main&quot;+i); &#125; &#125;&#125; 观测线程状态 NEW尚未启动的线程处于此状态。 RUNNABLE在Java虚拟机中执行的线程处于此状态。 BLOCKED被阻塞等待监视器锁定的线程处于此状态。 WAITING正在等待另一个线程执行特定动作的线程处于此状态。 TIMED_WAITING正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。 TERMINATED已退出的线程处于此状态 12345678910111213141516171819202122232425262728293031class Hello &#123; public static void main(String []args) throws InterruptedException &#123; Thread thread=new Thread(()-&gt;&#123; for(int i=0;i&lt;5;i++) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; System.out.println(&quot;abc&quot;); &#125;); //观察状态 Thread.State state=thread.getState(); System.out.println(state);//NEW //观察启动后 thread.start(); state=thread.getState(); while(state!=Thread.State.TERMINATED) &#123; Thread.sleep(100); state=thread.getState(); System.out.println(state); &#125; &#125;&#125;死亡之后的线程不能够被重新启动，一个线程不能够启动两次 线程的优先级123456789101112131415161718192021222324252627282930313233343536class Hello &#123; public static void main(String []args) throws InterruptedException &#123; System.out.println(Thread.currentThread().getPriority());//主线程默认优先级 MyPriority myPriority=new MyPriority(); Thread t1=new Thread(myPriority,&quot;1&quot;); Thread t2=new Thread(myPriority,&quot;2&quot;); Thread t3=new Thread(myPriority,&quot;3&quot;); Thread t4=new Thread(myPriority,&quot;4&quot;); Thread t5=new Thread(myPriority,&quot;5&quot;); Thread t6=new Thread(myPriority,&quot;6&quot;); //先设置优先级，再启动 t1.start(); t2.setPriority(1); t2.start(); t3.setPriority(4); t3.start(); t4.setPriority(Thread.MAX_PRIORITY); t4.start(); //设置优先级大于10小于0会报错 /*t5.setPriority(-1); t5.start(); t6.setPriority(11); t6.start();*/ &#125;&#125;class MyPriority implements Runnable&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+&quot;--&gt;&quot;+Thread.currentThread().getPriority()); &#125;&#125; 优先级低只是意味着获得调度的概率低，并不是优先级低就不会被调用了，这都是看cpu的调度 优先级低的执行，优先级高的在等待，这个就会造成性能倒置 守护线程线程分为用户线程（main）和守护线程（gc） 虚拟机必须确保用户线程执行完毕 虚拟机不用等待守护线程执行完毕 如，后台记录操作日志，监控内存，垃圾回收等待 1234567891011121314151617181920212223242526272829class Hello &#123; public static void main(String []args) throws InterruptedException &#123; God god =new God(); You you=new You(); Thread thread =new Thread(god); thread.setDaemon(true);//默认是false表示是用户线程,正常的线程都是用户线程 thread.start();//上帝守护线程启动，这个线程不停止程序也会在用户线程执行完毕时停止,这时守护线程也就停止了 new Thread(you).start();//你 用户线程启动&#125;&#125;class God implements Runnable&#123; public void run() &#123; while(true) &#123; System.out.println(&quot;上帝健康快乐地活着&quot;); &#125; &#125;&#125;class You implements Runnable&#123; public void run() &#123; for(int i=0;i&lt;36000;i++) &#123; System.out.println(&quot;我健康快乐的活着&quot;); &#125; System.out.println(&quot;goodbyeworld&quot;); &#125;&#125; 线程同步多个线程操作同一个资源 并发：同一个对象被多个线程同时操作 保证线程安全要有队列而且要有锁，线程同步需要队列加锁 锁就相当于排队上厕所的时候，你进去把门关上防止后面的人进来，等你解决完了下一个人才能够进来 关键词：synchronized 当一个线程获得对象的排它锁，独占资源，其他线程必须等待 存在问题：1.一个线程持有锁会导致其他所有需要此锁的线程挂起 ​ 2.在多线竞争下，加锁释放锁会导致比较多的上下文切换和调度延时，引起性能问题 ​ 3.如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题 不安全的买票 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.text.SimpleDateFormat;import java.util.Date;//不安全的买票//可能三个人都抢到同一个第十张票//出现负数，就是他们都认为有一张票，当他们买完之后有人拿到的就是负的public class Hello&#123; public static void main(String []args) &#123; buyticket station=new buyticket(); new Thread(station,&quot;小明&quot;).start(); new Thread(station,&quot;小红&quot;).start(); new Thread(station,&quot;小蓝&quot;).start(); &#125;&#125;class buyticket implements Runnable&#123; //票 private int ticketNum=10; boolean flag=true;//外部停止方式 public void run() &#123; //买票 while(flag) &#123; try &#123; buy(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; private void buy() throws InterruptedException &#123; //判断是否有票 if(ticketNum&lt;=0) &#123; flag=false; return; &#125; //模拟延时 Thread.sleep(100); //买票 System.out.println(Thread.currentThread().getName()+&quot;拿到&quot;+ticketNum--); &#125;&#125; 银行取钱不安全 最后钱会变成负数，总共100，你想取50你对象想去100，你俩看到的都是余额100块，所以会造成余额为负数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Hello&#123; public static void main(String []args) &#123; //账户 Account account=new Account(100,&quot;结婚基金&quot;); Drawing you=new Drawing(account,50,&quot;你&quot;); Drawing girl=new Drawing(account,100,&quot;她&quot;);//第三个参数传入的是这个线程的名字 you.start(); girl.start(); &#125;&#125;class Account&#123; int money;//金额 String name;//卡名 Account account;//账户 public Account(int money, String name) &#123; super(); this.money = money; this.name = name; &#125;&#125;//银行：模拟取款class Drawing extends Thread&#123; //取了多少钱 int drawingMoney; //现在手里有多少钱 int nowMoney; Account account ; public Drawing(Account account, int drawingMoney, String name) &#123; super(name);//这个线程的名字 this.account = account; this.drawingMoney = drawingMoney; &#125; public void run() &#123; //判断有没有钱 if(account.money-drawingMoney&lt;0) &#123; System.out.println(Thread.currentThread().getName()+&quot;钱不够取不到&quot;); return; &#125; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //卡内金额=金额-你取的钱 account.money=account.money-drawingMoney; //你手里的钱 nowMoney=nowMoney+drawingMoney; System.out.println(account.name+&quot;余额为:&quot;+account.money); //Thread.currentThread().getName()=this.getName() System.out.println(this.getName()+&quot;手里的钱:&quot;+nowMoney); &#125;&#125; ArrayList集合线程不安全 123456789101112131415161718192021222324252627import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.List;public class Hello&#123; public static void main(String []args) &#123; List&lt;String&gt; lise=new ArrayList&lt;String&gt;(); for(int i=0;i&lt;10000;i++) &#123; new Thread(()-&gt;&#123; lise.add(Thread.currentThread().getName()); &#125;).start(); &#125; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(lise.size()); &#125;&#125;结果：9992 可能会有两个元素同时占同一个坑位 线程同步的修改 使用synchronized修饰那个会出现线程问题的方法 这个买票的例子就是一个对象所以在buy方法前面加一个synchronized就可以 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.text.SimpleDateFormat;import java.util.Date;//不安全的买票//可能三个人都抢到同一个第十张票//出现负数，就是他们都认为有一张票，当他们买完之后有人拿到的就是负的public class Main&#123; public static void main(String []args) &#123; buyticket station=new buyticket(); new Thread(station,&quot;小明&quot;).start(); new Thread(station,&quot;小红&quot;).start(); new Thread(station,&quot;小蓝&quot;).start(); &#125;&#125;class buyticket implements Runnable&#123; //票 private int ticketNum=10; boolean flag=true;//外部停止方式 public void run() &#123; //买票 while(flag) &#123; try &#123; buy(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; //synchronized同步方法，锁的是this，会一个一个进来 private synchronized void buy() throws InterruptedException &#123; //判断是否有票 if(ticketNum&lt;=0) &#123; flag=false; return; &#125; //模拟延时 Thread.sleep(100); //买票 System.out.println(Thread.currentThread().getName()+&quot;拿到&quot;+ticketNum--); &#125;&#125; 下面这个取钱的如果按照上面那个一样在run方法前面加synchronized还是会出现负的余额，因为它是两个对象 这个就要用同步块 synchronized (Obj){} obj称之为同步监视器 同步监视器的执行过程 1.第一个线程访问，锁定同步监视器，执行器中的代码 2.第二个·线程访问，发现同步监视器被锁定，无法继续访问 3.第一个线程访问完毕，解锁同步监视器 4.第二个线程访问，发现同步监视器没有锁，然后锁定并访问 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Main&#123; public static void main(String []args) &#123; //账户 Account account=new Account(100,&quot;结婚基金&quot;); Drawing you=new Drawing(account,50,&quot;你&quot;); Drawing girl=new Drawing(account,100,&quot;她&quot;);//第三个参数传入的是这个线程的名字 you.start(); girl.start(); &#125;&#125;class Account&#123; int money;//金额 String name;//卡名 Account account;//账户 public Account(int money, String name) &#123; super(); this.money = money; this.name = name; &#125;&#125;//银行：模拟取款class Drawing extends Thread&#123; //取了多少钱 int drawingMoney; //现在手里有多少钱 int nowMoney; Account account ; public Drawing(Account account, int drawingMoney, String name) &#123; super(name);//这个线程的名字 this.account = account; this.drawingMoney = drawingMoney; &#125; public void run() &#123; //判断有没有钱 synchronized(account) &#123;//这里面是就是需要排队使用的资源，也就是account对象 if(account.money-drawingMoney&lt;0) &#123; System.out.println(Thread.currentThread().getName()+&quot;钱不够取不到&quot;); return; &#125; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //卡内金额=金额-你取的钱 account.money=account.money-drawingMoney; //你手里的钱 nowMoney=nowMoney+drawingMoney; System.out.println(account.name+&quot;余额为:&quot;+account.money); //Thread.currentThread().getName()=this.getName() System.out.println(this.getName()+&quot;手里的钱:&quot;+nowMoney); &#125; &#125;&#125; 下面这个和上面那个一样，锁住的是lise集合 123456789101112131415161718192021222324252627import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.List;public class Main&#123; public static void main(String []args) &#123; List&lt;String&gt; lise=new ArrayList&lt;String&gt;(); for(int i=0;i&lt;10000;i++) &#123; new Thread(()-&gt;&#123; synchronized(lise) &#123; lise.add(Thread.currentThread().getName()); &#125; &#125;).start(); &#125; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(lise.size()); &#125;&#125; 放在synchronized块里面的是可能会出现问题的代码 一个线程安全的集合1234567891011121314151617181920import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.List;import java.util.concurrent.CopyOnWriteArrayList;public class Main&#123; public static void main(String []args) &#123; CopyOnWriteArrayList&lt;String&gt; list=new CopyOnWriteArrayList&lt;String&gt;(); for(int i=0;i&lt;1000;i++) &#123; new Thread(()-&gt;&#123; list.add(Thread.currentThread().getName()); &#125;).start(); &#125; System.out.println(list.size()); &#125;&#125; 死锁多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形，某一个同步块同时拥有两个以上的锁时，就可能会发生死锁的问题 &#x2F;&#x2F;死锁：多个线程互相抱着对方需要的资源，然后形成僵持 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class Main&#123; public static void main(String []args) &#123; MakeUp g1=new MakeUp(0,&quot;灰姑娘&quot;); MakeUp g2=new MakeUp(1,&quot;白雪公主&quot;); g1.start(); g2.start(); &#125;&#125;//口红class Lipstick&#123; &#125;//镜子class Mirror&#123; &#125;class MakeUp extends Thread&#123; //需要的资源只有一份，用static保证只有一份 static Lipstick lipstick=new Lipstick(); static Mirror mirror=new Mirror(); public MakeUp(int choice,String girlname) &#123; this.choice=choice; this.girlname=girlname; &#125; int choice;//选择 String girlname;//使用化妆品的人 public void run() &#123; try &#123; makeup(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; //化妆，互相持有对方的锁，就是需要拿到对方的资源 private void makeup() throws InterruptedException &#123; if(choice==0) &#123; synchronized(lipstick) &#123; System.out.println(this.girlname+&quot;获得口红的锁&quot;); Thread.sleep(1000); synchronized(mirror) &#123;//一秒钟之后获得镜子 System.out.println(this.girlname+&quot;获得镜子的锁&quot;); &#125; &#125; &#125; else &#123; synchronized(mirror) &#123; System.out.println(this.girlname+&quot;获得镜子的锁&quot;); Thread.sleep(1000); synchronized(lipstick) &#123;//一秒钟之后获得镜子 System.out.println(this.girlname+&quot;获得口红的锁&quot;); &#125; &#125; &#125;​ &#125;&#125;结果： 白雪公主获得镜子的锁灰姑娘获得口红的锁 这样之后他们还想要对方的东西，所以程序就卡死了 解决方法 变成两个锁，不是一个锁在另一个锁里面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.List;import java.util.concurrent.CopyOnWriteArrayList;//死锁：多个线程互相抱着对方需要的资源，然后形成僵持public class Main&#123; public static void main(String []args) &#123; MakeUp g1=new MakeUp(0,&quot;灰姑娘&quot;); MakeUp g2=new MakeUp(1,&quot;白雪公主&quot;); g1.start(); g2.start(); &#125;&#125;//口红class Lipstick&#123; &#125;//镜子class Mirror&#123; &#125;class MakeUp extends Thread&#123; //需要的资源只有一份，用static保证只有一份 static Lipstick lipstick=new Lipstick(); static Mirror mirror=new Mirror(); public MakeUp(int choice,String girlname) &#123; this.choice=choice; this.girlname=girlname; &#125; int choice;//选择 String girlname;//使用化妆品的人 public void run() &#123; try &#123; makeup(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; //化妆，互相持有对方的锁，就是需要拿到对方的资源 private void makeup() throws InterruptedException &#123; if(choice==0) &#123; synchronized(lipstick) &#123; System.out.println(this.girlname+&quot;获得口红的锁&quot;); Thread.sleep(1000); &#125; synchronized(mirror) &#123;//一秒钟之后获得镜子 System.out.println(this.girlname+&quot;获得镜子的锁&quot;); &#125; &#125; else &#123; synchronized(mirror) &#123; System.out.println(this.girlname+&quot;获得镜子的锁&quot;); Thread.sleep(1000); &#125; synchronized(lipstick) &#123;//一秒钟之后获得镜子 System.out.println(this.girlname+&quot;获得口红的锁&quot;); &#125; &#125; &#125;&#125; 产生死锁的条件：1.互斥条件：一个资源每次只能被一个进程使用 2，请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放 3.不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺 4.循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关闭 破坏上面的一个条件就可以避免死锁的发生 Lock锁控制多个线程对共享资源进行访问的工具 ReentrantLock类实现了Lock 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.concurrent.locks.ReentrantLock;public class Main&#123; public static void main(String args[]) &#123; testlock testlock1=new testlock(); new Thread(testlock1,&quot;小蓝&quot;).start(); new Thread(testlock1,&quot;小红&quot;).start(); new Thread(testlock1,&quot;小明&quot;).start(); &#125;&#125;class testlock implements Runnable&#123;private int ticketnums=10;//定义lock锁private final ReentrantLock lock=new ReentrantLock(); @Override public void run() &#123; while(true) &#123; try &#123; lock.lock();//加锁 if(ticketnums&gt;0) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;拿到了第&quot;+ticketnums--+&quot;票&quot;); &#125; else &#123; break; &#125; &#125; finally&#123; //解锁 lock.unlock(); &#125; &#125; &#125; &#125; 加锁和解锁最好是在try和finally里面，而且try中是可能会出现问题的代码 线程协作线程通信：这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件 对于生产者，没有生产产品之前，要通知消费者等待，有了产品之后，马上通知消费者消费 对于消费者，在消费之后，要通知生产者结束消费，需要生产新的产品以供消费 在生产者消费者问题中，仅有synchronized是不够的 ​ synchronized可阻止并发更新同一个共享资源，实现了同步 ​ synchronized不能用来实现不同线程之间的消息传递 通过一个标志来判断什么时候应该等待，什么时候应该唤醒 notifyAll方法是唤醒线程只能唤醒wait等待的线程 wait方法是让该线程等待 管程法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import java.util.concurrent.locks.ReentrantLock;//测试：生产者消费者模型，利用缓冲区来解决：管程法public class Main&#123; public static void main(String []args) &#123; SynContainer container=new SynContainer(); new Productor(container).start(); new Consumer(container).start(); &#125; &#125;//生产者class Productor extends Thread&#123; SynContainer container; public Productor(SynContainer container) &#123; this.container=container; &#125; //生产 public void run() &#123; for(int i=0;i&lt;100;i++) &#123; System.out.println(&quot;生产了&quot;+i+&quot;只鸡&quot;); container.push(new Chicken(i)); &#125; &#125; &#125;//消费者class Consumer extends Thread&#123; SynContainer container; public Consumer(SynContainer container) &#123; this.container=container; &#125; //消费 public void run() &#123; for(int i=0;i&lt;100;i++) &#123; System.out.println(&quot;消费了--&gt;&quot;+container.pop().id+&quot;只鸡&quot;); &#125; &#125;&#125;//产品class Chicken&#123; public int id; public Chicken(int id) &#123; this.id=id; &#125;&#125;//缓冲区class SynContainer&#123; //需要一个容器大小 Chicken[] chickens=new Chicken[10]; //容器计数器 int count=0; //生产者放入产品 public synchronized void push(Chicken chicken) &#123; //如果容器满了就要等待消费者消费 if(count==chickens.length) &#123; //通知生产者消费，生产等待 try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; //如果没有满，我们就需要放入产品 chickens[count]=chicken; count++; //可以通知消费者消费了 this.notifyAll(); &#125; //消费者消费产品 public synchronized Chicken pop() &#123; //判断是否能消费 if(count==0) &#123; //等待生产者生产，消费者等待 try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; //如果可以消费 count--; Chicken chicken=chickens[count]; //吃完了，通知生产者生产 this.notifyAll(); return chicken; &#125; &#125; 信号灯法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.util.concurrent.locks.ReentrantLock;//测试：生产者消费者模型，信号灯法，标志位解决public class Main&#123; public static void main(String []args) &#123; TV tv=new TV(); new Player(tv).start(); new Watcher(tv).start(); &#125;&#125;//生产者-&gt;演员class Player extends Thread&#123; TV tv; public Player(TV tv) &#123; this.tv=tv; &#125; public void run() &#123; for(int i=0;i&lt;20;i++) &#123; if(i%2==0) &#123; this.tv.play(&quot;快乐大本营播放中&quot;); &#125; else &#123; this.tv.play(&quot;抖音:记录美好生活&quot;); &#125; &#125; &#125;&#125;//消费者-&gt;观众class Watcher extends Thread&#123; TV tv; public Watcher(TV tv) &#123; this.tv=tv; &#125; public void run() &#123; for(int i=0;i&lt;20;i++) &#123; this.tv.watch(); &#125; &#125;&#125;//产品-&gt;节目class TV&#123; //演员表演，观众等待 t //观众观看，演员等待 f String voice;//表演的节目 boolean flag=true; //表演 public synchronized void play(String voice) &#123; if(!flag) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; System.out.println(&quot;演员表演了&quot;+voice); //通知观众观看 this.notifyAll();//通知唤醒 this.voice=voice; this.flag=!this.flag; &#125; //观看 public synchronized void watch() &#123; if(flag) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; System.out.println(&quot;观看了&quot;+voice); //通知演员要表演了 this.notifyAll(); this.flag=!this.flag; &#125;&#125; 线程池java反射1.Reflection是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性和方法 2.加载完类之后，在堆内存中的方法区就产生了一个Class类型的对象，这个对象就包含了完整的类的结构信息，我们可以通过这个对象看到类的结构，这个对象就像一个面镜子，透过这个镜子看到类的结构，所以我们形象的称之为，反射 动态语言和静态语言的区别就是动态语言在运行时代码可以根据某些条件改变自身结构 java之所以成为准动态语言是因为有反射机制 正常方式：引入需要的包类名称 —》通过new实例化对象–》取得实例化对象 反射方式：实例化对象–》getClass()方法–》得到完整的包类名称 反射的功能反射的功能 反射相关的API java.lang.Class:代表一个类 java.lang.reflect.Method:代表类的方法 java.lang.reflect.Field:代表类的成员变量 java.lang.reflect.Constructor:代表类的构造器 一个反射的演示Person类 123456789101112131415161718192021222324252627282930313233343536373839404142public class Person &#123; private String name; public int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125;private Person(String name)&#123; this.name=name;&#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; public void show()&#123; System.out.println(&quot;你好，我是一个人&quot;); &#125; private String showNation(String nation)&#123; System.out.println(&quot;我的国籍是&quot;+nation); return nation; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; ReflectionTest 12345678910111213141516171819202122232425262728293031323334353637383940414243import org.junit.Test;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class ReflectionTest &#123; //反射之前，对于Person操作 @Test public void test1()&#123; //创建Person类的对象 Person p1=new Person(&quot;Tom&quot;,12); //通过对象，调用其内部属性方法 p1.age=10; System.out.println(p1.toString()); p1.show(); &#125; //在Person类外部不能通过person对象调用内部私有结构 //比如name。showNation()以及私有的构造器 //反射之后，对于Person的操作，做的是和上面一样的事 @Test public void test2() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException &#123; //获取一个Class类的实例对象 Class clazz=Person.class; //1.通过反射，创建Person类的对象 //获取构造器 Constructor cons=clazz.getConstructor(String.class,int.class); //创建实例 Object obj=cons.newInstance(&quot;Tom&quot;,12); Person p=(Person)obj; System.out.println(p.toString()); //2.通过反射，调用对象的指定属性方法 Field age=clazz.getDeclaredField(&quot;age&quot;); age.set(p,10); System.out.println(p.toString()); //调用空参的show方法 Method show=clazz.getDeclaredMethod(&quot;show&quot;); show.invoke(p); &#125;&#125; 疑问：通过直接new的方式或反射的方式都可以调用公共的结构，开发中到底用哪个 建议：用直接new的方式 疑问：什么时候用反射的方式 反射的特性是动态性，比如在编译的时候你无法确定到底是要实例化哪个类就是要用这种反射的方式 关于Class类理解1.类的加载过程 程序经过javac.exe命令以后，会生成一个或多个字节码文件（.class结尾） 接着我们使用java.exe命令对某个字节码文件进行解释运行，相当于将某个字节码文件加载到内存中，此过程就称为类的加载，加载到内存中的类，我们就称为运行时类，此运行时类，就作为Class的一个实例 2.换句话说，Class的实例就对应的一个运行时类 3.加载到内存中的运行时类，会缓存一定的时间，在此时间之内，我们可以通过不同的方式来获取此运行时类 123456789101112131415161718192021222324//获取大的class实例的方式 @Test public void test3() throws ClassNotFoundException &#123; //方式一 //加上泛型之后就避免了你后面进行强转 Class&lt;Person&gt; clazz1=Person.class; System.out.println(clazz1); //方式二:通过运行时类的对象 Person p1=new Person(); Class clazz2=p1.getClass(); System.out.println(clazz2); //方式三：调用Class的静态方法，forName(String classPath) //这个路径就是看以src为基准，这种文件直接在src下就直接用文件名，如果底下还有包，就要加上包名 Class clazz3=Class.forName(&quot;Person&quot;); System.out.println(clazz3); System.out.println(clazz1==clazz2); System.out.println(clazz2==clazz3); //方式四 ClassLoader classLoader = ReflectionTest.class.getClassLoader(); Class clazz4=classLoader.loadClass(&quot;Person&quot;); System.out.println(clazz1==clazz4); &#125; 其他可以有Class实例的类型 哪些类型可以有Class对象？ （1）class： 外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类 （2）interface：接口 （3）[]：数组 （4）enum：枚举 （5）annotation：注解@interface （6）primitive type：基本数据类型 （7）void 理解类的加载过程 在类的加载过程中就已经执行了静态代码块，构建对象才调用实例代码块和构造方法，且实例代码块比构造方法早 子类加载时，先加载子类的父类，也就是父类的静态代码块先执行再是子类的静态代码块 子类实例化时，先是父类的实例代码块和构造器再是子类的实例代码块和构造器 ClassLoader类加载器作用： 将class文件字节码内容加载到内存中，并将这些静态数据转换成方 法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为 方法区中类数据的访问入口。 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器 中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。 读取文件的时候，把这个Transparent native-to-ascii conversion勾上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import org.junit.Test;import java.io.FileInputStream;import java.io.InputStream;import java.util.Properties;public class ClassLoaderTest &#123; @Test public void test1()&#123; // 1.获取一个系统类加载器 ClassLoader classLoader = ClassLoaderTest.class.getClassLoader(); System.out.println(classLoader); //调用系统类加载器的getParent()：获取扩展类加载器 ClassLoader classLoader1 = classLoader.getParent(); System.out.println(classLoader1); //调用扩展类加载器的getParent()：无法获取引导类加载器 //引导类加载器主要负责加载java的核心类库，无法加载自定义类的。 ClassLoader classLoader2 = classLoader1.getParent(); System.out.println(classLoader2); ClassLoader classLoader3 = String.class.getClassLoader(); System.out.println(classLoader3); &#125; /* Properties 用来读取配置文件 */ @Test public void test2() throws Exception &#123; Properties pros=new Properties(); //读取配置文件的方式一 //此时的文件默认在当前的module下 FileInputStream fis=new FileInputStream(&quot;./jdbc.properties&quot;); //FileInputStream fis=new FileInputStream(&quot;src\\\\jdbc1.properties&quot;); System.out.println(fis); //pros.load(fis); //读取配置文件的方式二，使用ClassLoader ClassLoader classLoader = ClassLoaderTest.class.getClassLoader(); //这个方法直接是映射到src下的文件 //在java中路径字符串中/和\\\\都是一样的 InputStream resource = classLoader.getResourceAsStream(&quot;jdbc1.properties&quot;); pros.load(resource); String user=pros.getProperty(&quot;user&quot;); String password=pros.getProperty(&quot;password&quot;); System.out.println(&quot;user=&quot;+user+&quot;password=&quot;+password); &#125;&#125; java项目中的路径问题123456File file=new File(&quot;/&quot;);System.out.println(file.getAbsolutePath());//D:\\File file1=new File(&quot;.&quot;);System.out.println(file1.getAbsolutePath());D:\\IDEAjava工程\\javaSE\\javareflect\\. &#x2F;代表的是盘符 .代表的是工程目录下的 使用FileInputStream fis&#x3D;new FileInputStream(“jdbc.properties”); 所以这个jdbc.properties也可以是.&#x2F;jdbc.properties 默认就是项目路径下，而不是src路径下，也可以用 全部的整个路径比如D:\\IDEAjava工程\\javaSE\\javareflect\\jdbc.properties InputStream resource &#x3D; classLoader.getResourceAsStream(“jdbc1.properties”);方法就是映射到scr目录下 一般就不用相对路径了，用不明白 1而且idea中路径字符串中\\\\和/是同样的效果 创建运行时类的对象和体会动态加载到内存中的类我们就把它叫做运行时类 test1时创建运行时类的对象 test2是体会反射的动态性，就是在编译时不能确定创建哪个类对象，运行时才确定创建对象的类型 并且方法有参数别用@test 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import org.junit.Test;import java.util.Random;/** * 通过反射创建对应的运行时类的对象 */public class NewInstanceTest &#123; @Test public void test1() throws IllegalAccessException, InstantiationException &#123; //用了泛型之后后面就不用强转了 Class&lt;Person&gt; clazz=Person.class; //newInstance();调用子方法创建对应的运行时类的对象 //其实内部还是调用了Person的空参构造器， //所以这个方法要求1.类必须有空参构造器 // 2.这个空参构造器的权限不是私有。通常为public //在javabean中要求提供一个public的空参构造其，原因： //1.便于通过反射，创建运行时类的对象 //2.便于子类继承此运行时类时，默认调用super(),保证父类有空参构造器 Person obj = clazz.newInstance(); System.out.println(obj); &#125; @Test public void test2() &#123;int num=new Random().nextInt(3);//0.1.2String path=&quot;&quot;;switch(num) &#123; case 0: path = &quot;java.util.Date&quot;; break; case 1: path = &quot;java.lang.Object&quot;; break; case 2: path = &quot;Person&quot;; break;&#125; try &#123; Object obj = getInstance(path); System.out.println(obj); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125;&#125; /** * 创建一个指定类的对象 * @param classPath 指定类的全类名 * @return * @throwsException */ public Object getInstance(String classPath) throws Exception&#123; Class clazz=Class.forName(classPath); return clazz.newInstance(); &#125;&#125; 提供结构丰富的Person类1234567891011121314151617181920212223242526272829303132333435363738package com.atguigu.java;public class Person extends Creature&lt;String&gt; implements Comparable&lt;String&gt;,MyInterface&#123; private String name; int age; public int id; protected int score; public Person()&#123; &#125; private Person(String name)&#123; this.name=name; &#125; public Person(String name,int age)&#123; this.name=name; this.age=age; &#125; private String show(String nation)&#123; System.out.println(&quot;我的国际时&quot;+nation); return nation; &#125; public String display(String interests)&#123; return interests; &#125; @Override public int compareTo(String o) &#123; return 0; &#125; @Override public void info() &#123; System.out.println(&quot;我是一个人&quot;); &#125;&#125; 获取运行时类的属性结构及其内部结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.atguigu.java1;import com.atguigu.java.Person;import com.sun.deploy.util.SystemUtils;import org.junit.Test;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import java.util.Locale;/*获取运行时类的属性结构 */public class FieldTest &#123;@Test public void test1()&#123; Class clazz= Person.class; //获取属性结构 //getFields():获取当前运行时类及其父类中声明为public访问权限的属性 Field[] fields = clazz.getFields(); for (Field f : fields) &#123; System.out.println(f); &#125;System.out.println(&quot;******************&quot;); //getDeclaredFields():获取当前运行时类当中的所有属性 Field[] declaredFields = clazz.getDeclaredFields(); for (Field f : declaredFields) &#123; System.out.println(f); &#125;&#125;//每一个属性的具体的部分也是可以拿到的//权限，修饰符，数据类型，变量名，变量值 @Test public void test2()&#123; Class clazz=Person.class; Field[] declaredFields = clazz.getDeclaredFields(); for (Field f : declaredFields) &#123; //1.权限修饰符 //这个地方获取的是一个表示访问类型的数字 int modifier =f.getModifiers(); //这个地方是将访问类型的数字转换成访问类型的文字,空白是默认类型 System.out.println(Modifier.toString(modifier)); //2.数据类型 Class type=f.getType();//type获得的是一个类型 System.out.println(type.getName());//这样是获得type的全名 //3.变量名 String name = f.getName(); System.out.println(name); &#125;&#125;&#125; 获取运行时类的方法结构和内部结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.atguigu.java1;import com.atguigu.java.Person;import org.junit.Test;import java.lang.reflect.Method;import java.lang.reflect.Modifier;/*获取运行时类的方法结构 */public class MethodTest &#123; @Test public void test1() &#123; Class clazz = Person.class; //getMethods:获取当前运行时类及其所有父类中声明为public权限的方法 Method[] methods = clazz.getMethods(); for (Method m : methods) &#123; System.out.println(m); &#125; System.out.println(&quot;****************************&quot;); //获取当前运行时类中声明的所有方法，不包含父类中声明的 Method[] declaredMethods = clazz.getDeclaredMethods(); for (Method m : declaredMethods) &#123; System.out.println(m); &#125; &#125; @Test /* @注解 权限修饰符，返回值类型，方法名（参数类型 形参名1，...）throws Exception()&#123; &#125; */ public void test2() &#123; Class clazz = Person.class; Method[] methods = clazz.getDeclaredMethods(); for (Method m : methods) &#123; //获取权限修饰符 System.out.println(Modifier.toString(m.getModifiers())); //获取方法的返回值类型 System.out.println(m.getReturnType().getName()); //获取方法名 System.out.println(m.getName()); System.out.println(&quot;(&quot;); //获取形参列表 Class[] parameterTypes = m.getParameterTypes(); if (!(parameterTypes != null &amp;&amp; parameterTypes.length == 0)) &#123; for (int i = 0; i &lt; parameterTypes.length; i++) &#123; if (i == parameterTypes.length - 1) &#123; System.out.println(parameterTypes[i].getName() + &quot; args_&quot; + i); break; &#125; System.out.println(parameterTypes[i].getName() + &quot; args_&quot; + i + &quot;,&quot;); &#125; System.out.println(&quot;)&quot;); &#125; //获取抛出的异常 Class[] exceptionTypes = m.getExceptionTypes(); if (exceptionTypes.length &gt; 0) &#123; System.out.print(&quot;throws&quot;); for (int i = 0; i &lt; exceptionTypes.length; i++) &#123; if (i == exceptionTypes.length - 1) &#123; System.out.println(exceptionTypes[i].getName()); break; &#125; System.out.println(exceptionTypes[i].getName() + &quot;,&quot;); &#125; &#125; &#125; &#125;&#125; 获取运行时类的构造器结构1234567891011121314151617181920212223242526package com.atguigu.java1;import com.atguigu.java.Person;import org.junit.Test;import java.lang.reflect.Constructor;import java.lang.reflect.Method;public class OtherTest &#123;@Test public void test1()&#123; Class clazz= Person.class; //getConstructors获取当前运行时类中声明为public的构造器 Constructor[] constructors = clazz.getConstructors(); for (Constructor constructor : constructors) &#123; System.out.println(constructor); &#125; System.out.println(&quot;***********************&quot;); //getDeclaredMethods获取当前运行时类中声明的所有的构造器 Constructor[] declaredMethods = clazz.getDeclaredConstructors(); for (Constructor declaredMethod : declaredMethods) &#123; System.out.println(declaredMethod); &#125;&#125;&#125; 获取运行时类的父类和泛型ParameterizedType是Type的子接口 Type是Class的父接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 /* 获取运行时类的父类 */ @Test public void test2()&#123; Class clazz = Person.class; Class superclass = clazz.getSuperclass(); System.out.println(superclass); &#125; /* 获取运行时类的带泛型的父类 */ @Test public void test3()&#123; Class clazz = Person.class; Type genericSuperclass = clazz.getGenericSuperclass(); System.out.println(genericSuperclass); &#125; /* 获取运行时类的带泛型的父类的泛型 代码：逻辑性代码 vs 功能性代码 */ @Test public void test4()&#123; Class clazz = Person.class; Type genericSuperclass = clazz.getGenericSuperclass(); //ParameterizedType是Type的子接口 //Type是Class的父接口，就像是List和ArrayList的关系 ParameterizedType paramType = (ParameterizedType) genericSuperclass; //获取泛型类型 Type[] actualTypeArguments = paramType.getActualTypeArguments();// System.out.println(actualTypeArguments[0].getTypeName()); //将Type类型强转为class，然后再用getName，只有Type才有getTypename方法 System.out.println(((Class)actualTypeArguments[0]).getName()); &#125; /* 获取运行时类实现的接口 */ @Test public void test5()&#123; Class clazz = Person.class; Class[] interfaces = clazz.getInterfaces(); for(Class c : interfaces)&#123; System.out.println(c); &#125; System.out.println(); //获取运行时类的父类实现的接口 Class[] interfaces1 = clazz.getSuperclass().getInterfaces(); for(Class c : interfaces1)&#123; System.out.println(c); &#125; &#125; 获取运行时类实现的接口，所在的包，注解123456789101112131415161718192021222324252627282930313233343536373839404142434445/*获取运行时类实现的接口 */@Testpublic void test5()&#123; Class clazz = Person.class; Class[] interfaces = clazz.getInterfaces(); for(Class c : interfaces)&#123; System.out.println(c); &#125; System.out.println(); //获取运行时类的父类实现的接口 Class[] interfaces1 = clazz.getSuperclass().getInterfaces(); for(Class c : interfaces1)&#123; System.out.println(c); &#125;&#125;/* 获取运行时类所在的包 */@Testpublic void test6()&#123; Class clazz = Person.class; Package pack = clazz.getPackage(); System.out.println(pack);&#125;/* 获取运行时类声明的注解 */@Testpublic void test7()&#123; Class clazz = Person.class; Annotation[] annotations = clazz.getAnnotations(); for(Annotation annos : annotations)&#123; System.out.println(annos); &#125;&#125; 调用运行时类的指定结构指定结构主要指的是属性和方法构造器","categories":[],"tags":[]}],"categories":[],"tags":[]}